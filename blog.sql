/*
 Navicat Premium Data Transfer

 Source Server         : MySQL
 Source Server Type    : MySQL
 Source Server Version : 80016
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80016
 File Encoding         : 65001

 Date: 10/10/2019 20:48:45
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog_article
-- ----------------------------
DROP TABLE IF EXISTS `blog_article`;
CREATE TABLE `blog_article`  (
  `article_id` int(15) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `markdown_content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `article_content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `user_id` int(10) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0),
  `visit_count` int(10) NULL DEFAULT 0,
  `comment_count` int(10) NULL DEFAULT 0 COMMENT '评论数量',
  `key_word` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `is_delete` int(5) NULL DEFAULT 0,
  `is_top` int(255) NULL DEFAULT 0 COMMENT '是否置顶0不置顶，1置顶',
  PRIMARY KEY (`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 29 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_article
-- ----------------------------
INSERT INTO `blog_article` VALUES (28, 'ActiveMQ 入门', '#Java消息中间件-ActiveMQ\n\n[TOC]\n\n本笔记主要根据慕课网视屏教程整理出：https://www.imooc.com/learn/856\n\n练习源码：https://github.com/caojx-git/learn\n\n使用其他消息中间件：https://github.com/jovezhao/nest\n\n## 一、简介\n\n### 1.1 案例\n\n老王有两个女儿，每天晚上睡觉前都要给女儿们讲故事，女儿才睡得照，在沒有使中间件之前，老王需要分别给两个女儿讲故事，这样老王又要工作，又要讲故事很晚，老王也很累。\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625102311_jms_1.png)\n\n老王后来使用了中间件（假设微信是中间件），老王只要将故事推送到微信中，然后让两个女儿订阅微信中的故事，两个女儿就可以在想听故事的时候听到老王的故事，这样老王也省了很多精力。\n![](https://ailuoli.cn/image/get_image?fileName=20190625102342_jms_2.png)\n\n### 1.2 消息中间件带来的好处\n\n- 系统的解耦\n\n- 异步\n\n- 横向扩展\n\n- 安全可靠\n\n  消息中间件会将我们的消息保存，直到我们的消息被消费为止。如果其他系统没有消费，或消费系统出现异常的时候，消费系统可以在下一次恢复正常后继续消费这条消息。\n\n- 顺序保存\n\n### 1.3 消息中间件概述\n\n#### 1. 什么是中间件？\n\n非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来价值的软件系统统称为中间件。\n\n#### 2. 什么是消息中间件？\n\n关注于**数据的发送和接受**，利用高效可靠的**异步**消息传递机制集成**分布式系统**。\n\n如下是消息中间件示意图：\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625102414_jms_3.png)\n\n应用程序A通过应用程序接口向消息中间件发送消息，应用程序B通过应用程序接口向消息中间件接收消息。\n\n\n\n#### 3.什么是 JMS？\n\nJava消息服务（Java Message Service）即JMS，是一个Java平台中关于面向消息中间件的**API**，用于在两个应用程序之间，或分布式系统中发送消息，进行**异步**通信。\n\n#### 4. 什么是AMQP？\n\nAMQP（advanced message queuing protocol）是一个提供统一消息服务的**应用层**标准协议，基于此协议的客户端与消息中间件可传递消息，**并不受客户端/中间件不同产品，不同开发语言条件限制**。\n\n#### 5. JMS与AMQP对比\n\n|          | JMS规范                                                      | AMQP协议                                                     |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 定义     | Java API                                                     | Wire-protocol                                                |\n| 跨语言   | 否                                                           | 是                                                           |\n| 消息类型 | 提供两种消息类型p2p、pub/sub                                 | 提供了5中消息类型<br />direct、fanout、topic、headers、system |\n| 消息类型 | TextMessage、MapMessage、ByteMessage、StreamMessage、ObjectMessage、Message | byte[]                                                       |\n| 综合评价 | JMS定义了Java API层面的标准；在Java体系中国年，多个client均可以通过JMS进行交互，不需要应用修改代码，但是对于跨平台的支持较差。 | AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 |\n\n### 1.4 常见的消息中间件对比\n\n#### 1. ActiveMQ\n\nActiveMQ是Apache出品，最流行，能力强劲的开源消息总线。ActiveMQ是一个完全支持JMS1.1和J2EE1.4规范的JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间件任然扮演着特殊的地位。\n\n**ActiveMQ的特性**：\n\n- 多种语言和协议编写客户端\n- 支持语言：Java、C、C++、C#、Ruby、Perl、Python、PHP\n- 支持应用协议：OpenWire、Stomp REST、WS、Notification、XMPP、AMQP\n- 完全支持JMS1.1和J2EE1.4规范（持久化、XA消息、事务）\n- 虚拟主题、组合目的、镜像队列\n\n\n\n#### 2. RabbitMQ\n\nRabbitMQ是一个开源的AMQP实现，服务端用Erlang语言编写。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性表现不俗。\n\n**RabbitMQ的特性**：\n\n- 支持多种客户端，如：Java、Python、Ruby、.NET、JMS、C、PHP、ActionScript等\n- AMQP的完整实现（vhost、Exchange、Binding、Routing Key等）\n- 事务支持/发布确认\n- 消息持久化\n\n#### 3. Kafka\n\nKafka是一个高吞吐量的分布式发布订阅消息系统，是一个分布式的、分区的、可靠的分布式日志存储服务。它通过一种独一无二的设计提供了一个消息系统的功能。\n\n**Kafka的特性**\n\n- 通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。\n- 高吞吐量：即使是非常比普通的硬件Kafka也可以支持每秒数百万的消息。\n- Partion、Consumer Group\n\n#### 4. ActiveMQ、RabbitMQ和Kafka消息中间件对比\n\n|          | ActiveMQ                                                     | RabbitMQ                                                     | KafKa                                                        |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 跨语言   | 支持(Java优先)                                               | 语言无关                                                     | 支持（Java优先）                                             |\n| 支持协议 | OpenWire,Stomp,XMPP,AMQP                                     | AMQP                                                         |                                                              |\n| 优点     | 遵循JMS规范安装部署方便                                      | 继承Erlang天生的并发性最初用于金融行业，稳定性，安全性有保障 | 依赖zk，可动态扩展节点，高性能，高吞吐量，无限扩容，消息可指定追溯 |\n| 缺点     | 根据其他用户反馈，会莫名丢失消息。目前重心在下代产品apolle上，目前社区不活跃，对5.x维护较少 | Erlang语言难度较大，不支持动态扩展                           | 严格的顺序机制，不支持消息优先级，不支持标准的消息协议，不利于平台的迁移 |\n| 综合评价 | 适合中小企业消息应用场景，不适合上千个队列的应用场景         | 适合对性能稳定性要求高的企业级应用                           | 一般应用在大数据日志处理或者对实时性（少量延迟），可靠性（少量丢失数据）要求稍低的场景使用 |\n\n### 1.5 JMS规范\n\n#### 1. Java消息服务定义\n\nJava消息服务（Java Message Service）即JMS，是一个Java平台中关于面向消息中间件的**API**，用于在两个应用程序之间，或分布式系统中发送消息，进行**异步**通信。\n\n#### 2. JMS相关概念\n\n**提供者**：实现JMS规范的消息中间件服务器\n\n**客户端**：发送或接受消息的应用程序\n\n**生产者/发布者**：创建并发送消息的客户端\n\n**消费者/订阅者**：接受并处理消息的客户端\n\n**消息**：应用程序之间传递的数据内容\n\n**消息模式**：在客户端之间传递消息的方式，JMS定义了主题和队列两种模式\n\n#### 3. 队列模式\n\n- 客户端包括生产者和消费者\n- 队列中的消息只能被一个消费者所消费\n- 消费者可以随时消费队列中的消息\n\n下图是队列模式示意图：\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625102548_jms_4.png)\n\n应用1和应用2分别发送了消息M1/M3/M5 和M2/M4/M6共6条消息，然后消息队列中有了这6条消息，然后创建了2个消费者应用3建立了2个连接和应用4建立了一个连接，由结果可见，应用消费者中的每个连接平摊了队列中的每个消息。\n\n#### 4. 主题模式\n\n- 客户端包括发布者可订阅者\n- 主题中的消息被所有订阅者消费\n- 消费者不能消费订阅之前就发送到主题中的消息\n\n下图是主题模式示意图：\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625102615_jms_5.png)\n\n创建两个订阅者应用3和应用4与JMS主题先建立连接，然后再创建两个发布者应用1和应用2与JMS主题建立连接分别发送了M1/M3/M5和M2/M4/M6，这时JMS主题中有了6条消息，由于应用3和应用4在之前就订阅了该主题的消息，所以应用3和应用4都能收到所有的消息。主要是订阅者需要提前去订阅主题。\n\n#### 5.JMS编码接口\n\n- ConnectionFactory 用于创建连接到消息中间件的连接工厂，这个工厂一般由消息提供商提供。\n- Connection 代表了应用程序和消息服务器之间的通信链路\n- Destination 指消息发布和接受的地点，包括队列或主题\n- Session 表示一个单线程的上下文会话，用于发送和接收消息\n- MessageConsumer 由会话创建，用于接受发送到目标的消息\n- MessageProducer 由会话创建，用于发送消息到目标\n- Message 是在消费者和生产者之间传送的对象，消息头，一组消息属性，一个消息体\n\n\n\n#### 6. JMS编码接口之间的关系\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625102637_jms_6.png)\n\n首先连接工厂创建一个连接Connection，有了这个连接之后就可以创建会话Session，这里我们的连接也可以创建多个会话Session，而每个会话是在一个线程上下文的。由会话Session我们可以创建生产者和消费者，并且会话也可以用来创建一个新的消息。然后我们可以使用我们的生产者将我们的消息发送到指定的目的地，然后我们的消费者可以到指定的目的地去接收我们的消息。\n\n\n\n## 二、安装ActiveMQ\n\n### 2.1 Windows平台安装ActiveMQ\n\n1. 下载安装包 http://www.apache.org/dyn/closer.cgi?filename=/activemq/5.15.3/apache-activemq-5.15.3-bin.zip&action=download\n\n2. 直接启动\n\n   解压安装包后进入bin/win64目录，运行activemq.bat即运行activeMQ\n\n3. 使用服务启动\n\n   解压安装包后进入bin/win64目录，运行installService.bat,运行之后，会将ActiveMQ以服务的方式安装到我们电脑，这样我们就可以以服务的方式启动了。\n\n### 2.2 Linux平台安装ActiveMQ\n\nhttp://www.apache.org/dyn/closer.cgi?filename=/activemq/5.15.3/apache-activemq-5.15.3-bin.tar.gz&action=download\n\n```shell\n#解压安装包\n#tar -zxvf apache-activemq-5.15.3.tar.gz\n#cd apache-activemq-5.15.3/bin\n#ls \nactivemq      activemq-diag activemq.jar  env           linux-x86-32  linux-x86-64  macosx        wrapper.jar\n#启动activeMQ\n#./activemq start #启动后activeMQ默认端口是8161\n\n#需要停止activemq\n#./activemq stop\n```\n\n访问：http://127.0.0.1:8161 后点击Manage ActiveMQ broker 会要求输入ActiveMQ管理密码，默认是admin/admin\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625102714_activeMQ_1.png)\n\n  \n\n\n\n## 三、JMS接口规范连接ActiveMQ\n\n**使用JMS接口规范连接ActiveMQ**\n\n- 创建生产者/消费者\n- 创建发布者/订阅者\n\n这里我们将演示p2p和发布订阅两种模式\n\n注意：本节内容可以参考**1.5 JMS规范**\n\n### 3.1 pom.xml\n\n引入activemq依赖\n\n```xml\n<!-- 引入activemq依赖-->\n<dependency>\n  <groupId>org.apache.activemq</groupId>\n  <artifactId>activemq-all</artifactId>\n  <version>5.15.3</version>\n</dependency>\n```\n\n### 3.1 队列模式的消息演示 \n\n队列模式的特点：\n\n- 客户端包括生产者和消费者\n- 队列中的消息只能被一个消费者所消费\n- 消费者可以随时消费队列中的消息\n\n**1.AppProducer.java**\n\n使用队列模式创建一个生产者，发送100个消息到消息队列中，所以**之前要先启动activemq**。\n\n```java\npackage caojx.learn.jms.queue;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:41\n * jms队列模式-消息生产者\n */\npublic class AppProducer {\n\n\n    public static final String url=\"tcp://127.0.0.1:61616\"; //连接activemq的地址，61616是连接activemq默认的端口\n\n    public static final String queueName=\"queue-test\"; //队列名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 队列\n        Destination destination = session.createQueue(queueName);\n\n        //6.创建一个生产者,并指定目标\n        MessageProducer producer = session.createProducer(destination);\n\n        for (int i = 1; i <= 100; i++) {\n            //7.创建消息\n            TextMessage textMessage = session.createTextMessage(\"test\"+i);\n            //8.发送消息\n            producer.send(textMessage);\n            System.out.println(\"发送消息\"+textMessage.getText());\n        }\n        //9.关闭连接\n        connection.close();\n    }\n}\n```\n\n2. **执行生产者的main方法发送消息**\n\n   控制台：\n\n   ```text\n   发送消息test1\n   发送消息test2\n   ...\n   发送消息test97\n   发送消息test98\n   发送消息test99\n   发送消息test100\n   ```\n\n   activemq管理界面：\n\n   Name:队列名称 quque-test\n\n   Number Of Pending Messages：挂起消息的数目\n\n   Number Of Consumers：消费者数目\n\n   Messages Enqueued：消息队列中的数目，待消费的数量\n\n   Messages Dequeued：消息出对的数目，已消费的数量\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625103147_activemq_queue_1.png)\n\n3. **AppConsumer.java**\n\n消费者，用于接收生产者发送到消息队列这中的消息\n\n```java\npackage caojx.learn.jms.queue;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:56\n * jms队列模式-消息消费者\n */\npublic class AppConsumer {\n\n    public static final String url=\"tcp://127.0.0.1:61616\"; //连接activemq的地址，61616是连接activemq默认的端口\n\n    public static final String queueName=\"queue-test\"; //队列名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 队列\n        Destination destination = session.createQueue(queueName);\n\n        //6.创建一个消费者,并指定目标\n        MessageConsumer consumer = session.createConsumer(destination);\n\n       //7.创建一个监听器,接收消息\n        consumer.setMessageListener(new MessageListener() {\n            public void onMessage(Message message) {\n                TextMessage textMessage = (TextMessage) message;\n                try {\n                    System.out.println(\"接收消息：\"+textMessage.getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        //注意，由于消息接收是异步的，所以不能关闭connection\n        //connection.close();\n    }\n}\n```\n\n4. **执行消费者的main方法接收消息**\n\n控制台：\n\n```text\n接收消息：test1\n....\n接收消息：test99\n接收消息：test100\n```\n\nactivemq管理界面：\n\nName:队列名称 quque-test\n\nNumber Of Pending Messages：挂起消息的数目\n\nNumber Of Consumers：消费者数目\n\nMessages Enqueued：消息队列中的数目，待消费的数量\n\nMessages Dequeued：消息出对的数目，已消费的数量\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625103000_activemq_queue_2.png)\n\n**注意：如果先启动多个消费者，再启动生产者发送消息，队列模式的消费者会平均分摊消息队列中的消息**\n\n### 3.2 主题模式的消息演示\n\n主题模式的特点：\n\n- 客户端包括发布者可订阅者\n- 主题中的消息被所有订阅者消费\n- 消费者不能消费订阅之前就发送到主题中的消息\n\n**1.AppProducer.java**\n\n使用主题模式创建一个发布者，发送100个消息到主题中，所以**之前要先启动activemq**。\n\n```java\npackage caojx.learn.jms.topic;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:41\n * jms主题模式-消息发布者\n */\npublic class AppProducer {\n\n\n    public static final String url=\"tcp://127.0.0.1:61616\"; //连接activemq的地址，61616是连接activemq默认的端口\n\n    public static final String topicName=\"topic-test\"; //主题名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 主题\n        Destination destination = session.createTopic(topicName);\n\n        //6.创建一个发布者,并指定目标\n        MessageProducer producer = session.createProducer(destination);\n\n        for (int i = 1; i <= 100; i++) {\n            //7.创建消息\n            TextMessage textMessage = session.createTextMessage(\"test\"+i);\n            //8.发送消息\n            producer.send(textMessage);\n            System.out.println(\"发送消息\"+textMessage.getText());\n        }\n        //9.关闭连接\n        connection.close();\n    }\n}\n```\n\n2. **AppConsumer.java**\n\n订阅者，用于接收发布者发送的对应主题消息\n\n```java\npackage caojx.learn.jms.topic;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:56\n * jms主题模式-消息订阅者\n */\npublic class AppConsumer {\n\n    public static final String url=\"tcp://127.0.0.1:61616\"; //连接activemq的地址，61616是连接activemq默认的端口\n\n    public static final String topicName=\"topic-test\"; //主题名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标\n        Destination destination = session.createTopic(topicName);\n\n        //6.创建一个订阅者,并指定目标 主题\n        MessageConsumer consumer = session.createConsumer(destination);\n\n       //7.创建一个监听器,接收消息\n        consumer.setMessageListener(new MessageListener() {\n            public void onMessage(Message message) {\n                TextMessage textMessage = (TextMessage) message;\n                try {\n                    System.out.println(\"接收消息：\"+textMessage.getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        //注意，由于消息接收是异步的，所以不能关闭connection\n        //connection.close();\n    }\n}\n```\n\n3. **测试**\n\n   主题模式需要先让订阅者订阅主题，然后发布者往主题中发送消息，订阅者才可以订阅到到消息。所以这里先启动订阅者（启动3个）,然后启动1个发布者发布消息。\n\n   ​\n\n   启动3个发布者后，topic-test显示有3个订阅者\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625103311_activemq_topic_1.png)\n\n   启动发布者发布消息\n\n   发布者控制台\n\n   ```text\n   发送消息test1\n   发送消息test2\n   ...\n   发送消息test100\n   ```\n\n   3个消费者控制台都是，即都接收到一样的消息\n\n   ```text\n   接收消息：test1\n   接收消息：test2\n   接收消息：test3\n   ....\n   接收消息：test100\n   ```\n![](https://ailuoli.cn/image/get_image?fileName=20190625110303_activemq_topic_2.png)\n\n   ​\n\n## 四、Spring集成JMS\n\n本节了解spring继承jms连接activemq。\n\n### 4.1 spring继承jms连接activemq\n\nspring继承jms连接activema，提供了\n\n- ConnectionFactory 用于管理连接的连接工厂\n\n  ConnectionFactory是spring为我们提供的连接池，之所有需要连接池是由于JmsTemplate每次发送消息都会重新创建连接，会话和productor 。在spring中分别提供了SingleConnectionFactory和CachingConnectionFactory。\n\n- JmsTemplate 用于接收和发送消息的模板类\n\n  JmsTemplate是spring提供的，只需向spring容器内注册这个类就可以使用JmsTemplate方便的操作jms。\n\n  JmsTemplate类是线程安全的，可以在整个应用范围使用。\n\n- MessageListerner 消息监听器\n\n  实现一个onMessage方法，该方法只接收一个Message参数。\n\n\n\n\n### 4.2 编码实现\n\n编码实现可以边参考，可以更好理解jms\n\n[理解JMS规范中消息的传输模式和消息持久化](http://blog.csdn.net/wilsonke/article/details/42804245)\n\n[理解JMS规范中的持久订阅和非持久订阅](http://blog.csdn.net/aitangyong/article/details/26013387)\n\n1.**项目目录**\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625110219_activemq_spring_1.png)\n\n2. **pom.xml**\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>caojx.learn</groupId>\n    <artifactId>activemq-java</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>jar</packaging>\n\n    <name>activemq-java</name>\n    <url>http://maven.apache.org</url>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <spring.version>4.3.14.RELEASE</spring.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>3.8.1</version>\n            <scope>test</scope>\n        </dependency>\n\n        <!--集成spring-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jms</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>${spring.version}</version>\n            <scope>test</scope>\n        </dependency>\n\n        <!--集成spring的时候，可以不需要activemq-all依赖-->\n        <dependency>\n            <groupId>org.apache.activemq</groupId>\n            <artifactId>activemq-core</artifactId>\n            <version>5.7.0</version>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.springframework</groupId>\n                    <artifactId>spring-context</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n\n    </dependencies>\n</project>\n```\n\n3. **ProducerService.java**\n\n```java\npackage caojx.learn.jms.spring.queue;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:25\n * 接收消息业务接口\n */\npublic interface ProducerService {\n\n    void sendMessage(String message);\n}\n```\n\n4. **ProducerServiceImpl.java**\n\n```java\npackage caojx.learn.jms.spring.queue;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jms.core.JmsTemplate;\nimport org.springframework.jms.core.MessageCreator;\n\nimport javax.annotation.Resource;\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:33\n * 接收消息业务实现类\n */\npublic class ProducerServiceImpl implements ProducerService {\n\n    @Autowired\n    JmsTemplate jmsTemplate;\n\n    public void sendMessage(final String message) {\n        //使用消息模板发送消息\n        jmsTemplate.send(new MessageCreator() {\n            //创建一个消息\n            public Message createMessage(Session session) throws JMSException {\n                TextMessage textMessage = session.createTextMessage(message);\n                return textMessage;\n            }\n        });\n        System.out.println(\"发送消息：\"+message);\n    }\n}\n```\n\n5. **spring-jms-common.xml**\n\njms与spring集成公共配置，如果要使用持久模式必须指定clientId（接收者Id）,这样即使是在主题模式下订阅者也能接收到之前发布者该给对应订阅者的消息，即相当于消费者有个vip卡，消息提供者会给消费者预留消息。极力推荐两篇文章会对jms理解更深刻\n\n[理解JMS规范中消息的传输模式和消息持久化](http://blog.csdn.net/wilsonke/article/details/42804245)\n\n[理解JMS规范中的持久订阅和非持久订阅](http://blog.csdn.net/aitangyong/article/details/26013387)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n    <!--ActiveMQ为我们提供的ConnectionFactory-->\n    <bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\">\n        <!-- 配置activemq的连接配置 -->\n        <property name=\"brokerURL\" value=\"tcp://127.0.0.1:61616\"></property>\n        <property name=\"userName\" value=\"admin\"></property>\n        <property name=\"password\" value=\"admin\"></property>\n    </bean>\n\n    <!--spring jms为我们提供连接池，代理activemq的连接工厂-->\n\n    <!--\n    持久订阅时，客户端向JMS 服务器注册一个自己身份的ID，当这个客户端处于离线时，JMS Provider 会为这个ID 保存所有发送到主题的消息，\n    当客户再次连接到JMS Provider时，会根据自己的ID得到所有当自己处于离线时发送到主题的消息。\n    -->\n    <bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.CachingConnectionFactory\">\n        <!--代理的连接工厂-->\n        <property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"></property>\n        <!-- 持久订阅模式时接收者ID必须指定,如果使用非持久订阅模式时不用配置 -->\n        <!--<property name=\"clientId\" value=\"client_119\"/>-->\n        <!-- Session缓存数量 -->\n        <property name=\"sessionCacheSize\" value=\"10\" />\n    </bean>\n\n    <!--一个队列目的地，点对点队列模式-->\n    <bean id=\"queueDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\">\n        <!-- 设置消息队列的名字 -->\n        <constructor-arg index=\"0\" value=\"queue\"/>\n    </bean>\n\n    <!--一个主题目的地，发布订阅模式-->\n    <bean id=\"topicDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\">\n        <!-- 设置消息主题的名字 -->\n        <constructor-arg index=\"0\" value=\"topic\"/>\n    </bean>\n</beans\n```\n\n6. **spring-jms-producer.xml**\n\n提供者配置文件，会映入公共配置，jmsTemplate用于配置消息模板，编写的时候可以自行选择主题模式或队列模式\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--导入公共配置-->\n    <import resource=\"spring-jms-common.xml\"></import>\n\n    <!--消息模板,用于发送消息-->\n    <bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\">\n        <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\n        <!--发送消息的目的地,一个队列-->\n        <!--<property name=\"defaultDestination\" ref=\"queueDestination\"/>-->\n        <!--发送消息的目的地,一个主题-->\n        <property name=\"defaultDestination\" ref=\"topicDestination\"/>\n    </bean>\n\n    <!--bean配置-->\n    <bean class=\"caojx.learn.jms.spring.queue.ProducerServiceImpl\"></bean>\n</beans>\n```\n\n7. **spring-jms-consumer.xml**\n\n消费者配置文件，使用消息监听器监听消息\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!--导入公共配置-->\n    <import resource=\"spring-jms-common.xml\"></import>\n\n    <!--配置消息监听器-->\n    <bean id=\"consumerMessageListener\" class=\"caojx.learn.jms.spring.queue.ConsumerMessageListener\"></bean>\n\n    <!--配置消息监听容器-->\n    <bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\">\n        <!--连接工厂-->\n        <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\n        <!--队列模式-->\n        <!--<property name=\"destination\" ref=\"queueDestination\"/>-->\n        <!--主题模式-->\n        <property name=\"destination\" ref=\"topicDestination\"/>\n        <!--消息监听器-->\n        <property name=\"messageListener\" ref=\"consumerMessageListener\"/>\n\n        <!-- 持久订阅模式时接收者ID必须指定,如果使用非持久订阅模式时不用配置 -->\n <!--       <property name=\"clientId\" value=\"client_119\"/>\n        <property name=\"durableSubscriptionName\" value=\"client_119\"/>-->\n    </bean>\n</beans>\n```\n\n8. **ConsumerMessageListener.java**\n\n消费者消息监听器，接收消息\n\n```java\npackage caojx.learn.jms.spring.queue;\n\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.MessageListener;\nimport javax.jms.TextMessage;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:49\n */\npublic class ConsumerMessageListener implements MessageListener {\n\n    public void onMessage(Message message) {\n        TextMessage textMessage = (TextMessage) message;\n        try {\n            System.out.println(\"接收消息：\"+textMessage.getText());\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n9.**AppProducer.java**\n\n消息发送者\n\n```java\npackage caojx.learn.jms.spring.queue;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:43\n * 消息提供者\n */\npublic class AppProducer {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-jms-producer.xml\");\n        ProducerService service = context.getBean(ProducerService.class);\n        for (int i = 0; i < 100; i++) {\n            service.sendMessage(\"test\"+i);\n        }\n        //关闭资源\n        context.close();\n    }\n}\n```\n\n10.**AppConsumer.java**\n\n消息消费者\n\n```java\npackage caojx.learn.jms.spring.queue;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:57\n * 消息消费者\n */\npublic class AppConsumer {\n    public static void main(String[] args) throws Exception{\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-jms-consumer.xml\");\n    }\n}\n```\n\n\n\n注意:如果使用持久订阅，由于设置了clientId,如果先启动**AppConsumer.java**消费者，由于消费者会等待接受消息，对应的clientId连接没有关闭，再启动**AppProducer.java**发布消息的时候会报错。如果不使用持久订阅，即不设置clientid，则不会出现如下错误。\n\n下边的报错也不算是错误，如果**AppProducer.java**先发布消息context.close();关闭了clientId,然后**AppConsumer.java**接收消息就不会有这个问题了。就好比发了个消息就下线了，然后接收者上线就可以接收到消息。\n\n```java\nException in thread \"main\" org.springframework.jms.InvalidClientIDException: Broker: localhost - Client: client_119 already connected from tcp://127.0.0.1:57479; nested exception is javax.jms.InvalidClientIDException: Broker: localhost - Client: client_119 already connected from tcp://127.0.0.1:57479\n	at org.springframework.jms.support.JmsUtils.convertJmsAccessException(JmsUtils.java:282)\n	at org.springframework.jms.support.JmsAccessor.convertJmsAccessException(JmsAccessor.java:169)\n	at org.springframework.jms.core.JmsTemplate.execute(JmsTemplate.java:487)\n	at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:559)\n	at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:550)\n	at caojx.learn.jms.spring.queue.ProducerServiceImpl.sendMessage(ProducerServiceImpl.java:22)\n	at caojx.learn.jms.spring.queue.AppProducer.main(AppProducer.java:15)\nCaused by: javax.jms.InvalidClientIDException: Broker: localhost - Client: client_119 already connected from tcp://127.0.0.1:57479\n	at org.apache.activemq.broker.region.RegionBroker.addConnection(RegionBroker.java:247)\n	at org.apache.activemq.broker.jmx.ManagedRegionBroker.addConnection(ManagedRegionBroker.java:227)\n	at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:99)\n	at org.apache.activemq.advisory.AdvisoryBroker.addConnection(AdvisoryBroker.java:119)\n	at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:99)\n	at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:99)\n	at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:99)\n	at org.apache.activemq.broker.TransportConnection.processAddConnection(TransportConnection.java:843)\n	at org.apache.activemq.broker.jmx.ManagedTransportConnection.processAddConnection(ManagedTransportConnection.java:77)\n	at org.apache.activemq.command.ConnectionInfo.visit(ConnectionInfo.java:139)\n	at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:330)\n	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:194)\n	at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n	at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:125)\n	at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:301)\n	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n	at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)\n	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)\n	at java.lang.Thread.run(Thread.java:748)\n```\n\n\n\n## 五、activeMQ集群\n\n本节主要了解：\n\n- ActiveMQ集群配置\n- 消息中间件在企业系统中的使用\n\n### 5.1 activeMQ集群理论\n\n#### 1. 为什么要对消息中间件集群？\n\n- 实现**高可用**，以排除单点故障引起的服务中断\n- 实现**负载均衡**，以提升效率为更多客户提供服务\n\n#### 2. 集群方式\n\n- 客户端集群：让多个消费者消费同一个队列\n- Broker clusters：多个Broker之间同步消息\n- Master Slave：高可用\n\n#### 3. 集群客户端配置\n\n- ActiveMQ失效转移（failover）\n\n  允许当其中一台消息服务器宕机时，客户端在传输层上重新连接到其他消息服务器\n\n  语法：failover:(消息服务器uri1,…,消息服务器uriN)?transportOptions\n\n  transportOptions重要参数说明：\n\n  randomize 默认为true，表示在URI列表中选择URI连接时是否采用随机策略\n\n  initialReconnectDelay 默认为10，单位毫秒，表示第一次尝试重连之间等待时间\n\n  maxReconnectDelay 默认30000，单位毫秒，表示最长重连的时间间隔\n\n#### 4. Broker Cluster集群配置\n\n**原理**\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625110134_activemq_broker+cluster_1.png) \n\n节点A将消息同步给节点B，节点B将消息同步给节点A，通过这样的消息同步之后，节点A和节点B之间都有相同的消息。它的实现方式采用的是一种网络连接器的方式实现的\n\n**NetworkConnector(网络连接器)**\n\n网络连接器主要用于配置ActiveMQ服务器与服务器之间的网络通讯方式，用于服务器透传消息\n\n网络连接器分为静态连接和动态连接\n\n**静态连接器：**\n\n在配置连接器的时候去指定具体的ip地址，参考一下配置\n\n```xml\n<networkConnectors>\n	<networkConnector uri=\"static:(tpc://127.0.0.1:61617,tpc://127.0.0.1:61618)\"/>\n</networkConnectors>\n```\n\n**动态连接器：**\n\n如果我们服务器比较多的时候，或者服务器可能需要动态扩展的时候，静态配置显然比较麻烦，这时我们需要使用动态连接，动态连接主要使用组播的方式实现的，参考一下配置\n\n```xml\n<transportConnectors>\n	<transportConnector uri=\"tcp://localhost:0\" discoveryUri=\"multicast://default\"/>\n</transportConnectors>\n```\n\n#### 5. Master/Slave 集群配置\n\n这种集群方式主要有一下3种实现方案\n\n- Share nothing storage master/slave (已经过时，5.8+后移除)，这里不了解\n- Share storage master/slave 共享储存\n- Replicated LevelDB Store 基于复制的LevelDB Store,主要使用zookeeper实现\n\n\n\n**共享存储集群的原理：**\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625110100_activemq_master_slave_1.png)\n\n假如我们有节点A和节点B两台服务器，还有一个共享的储存地址持久化（可以是jdbc的数据库，也可以是基于SAN的文件系统）。\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625110032_activemq_master_slave_2.png)\n\n然后我们将节点A和节点B都配置到同一个持久化地址后，先启动节点A，这时节点A获取到资源排它锁成为Master，节点B因为他获取不到锁资源成为Slave，成为Master的节点A获取到了对外服务开放的能力，可以通过外部的客户端提交信息到节点A，但是不能够发送信息到节点B。\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625110003_activemq_master_slave_3.png) \n\n如果节点A挂点了，节点B会立即获取到持久化资源的排它锁，节点B成为新的Master，可以接收外部客户端发送的消息，客户端使用失效转移之后将请求发送到节点B，这样就完成了整个请求的不间断性，达到了高可用效果。\n\n\n\n**基于复制的LevelDB Store的原理：**\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625105932_activemq_leveldb_1.png)\n\n因为LevelDB是基于zookeeper的，所以服务器至少需要3台，这里假设我们有3台服务器节点A/B/C，每个节点都有自己的持久化方式，因为她们都配置同样的zookeeper节点，通过zookeeper来选举一台服务器节点作为Master。比如选举了节点A作为Master，这时节点A成为Master之后，节点A具有了对外服务的能力，而节点B和节点C是不具有对外服务的能力的。节点A获取到外部发送过的消息之后，先进行本地储存（Store），然后通过zookeeper将消息同步给节点B和节点C，节点B和节点C分别在自己的服务器上储存。当然如果节点A出现故障，zookepper会立即选举一台新的Master出来。\n\n\n\n#### 6. 两种集群方式的对比\n\n|                | 高可用 | 负载均衡 | 特点                                                         |\n| -------------- | ------ | -------- | ------------------------------------------------------------ |\n| Master/Slave   | 是     | 否       | Slave服务器不具备对外服务的能力                              |\n| Broker Cluster | 否     | 是       | 自己的消息没有在一个地方储存，当某台服务器挂掉的时候，消息可能会同步丢失 |\n\n上边的两种集群方案要么是不支持负载均衡，要么不能高可用，是否有一种方案可以即可以负载均衡又可以做到高可用呢？\n\n\n\n### 5.2 activeMQ集群实践\n\n由于是演示配置，所以都在同一台机器上完成\n\n#### 1. 三台服务器的完美集群方案\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625105842_activemq_jq_1.png)\n\n假如我们有3台服务器，我们可以组一个如上图的架构即达到高可用，又可以负载均衡。\n\n节点A和节点B和节点C组成一个 Broker Cluster集群方案，然后节点B和节点C组成一个Master/Slave方案共享持久化内容。\n\n\n\n#### 2. 实现配置\n\n**配置说明：**\n\n|        | 服务端口 | 管理端口 | 存储               | 网络连接器     | 用途           |\n| ------ | -------- | -------- | ------------------ | -------------- | -------------- |\n| Node-A | 61616    | 8161     | -                  | Node-B、Node-C | 消费者         |\n| Node-B | 61617    | 8162     | /share_file/kahadb | Node-A         | 生产者、消费者 |\n| Node-C | 61618    | 8163     | /share_file/kahadb | Node-A         | 生产者、消费者 |\n\n上边因为Node-A配置的是Broker集群，所以Node-A不需要配置存储，Node-B和Node-C配置的是Master/Slave集群，所以需要配置存储。\n\nNode-A只能做消费者（Broker Cluster集群），如果作为生产者的话，因为网络连接是双向连接，Node-A的消息能够被Node-B和Node-C消费掉，如果单Node-A上边有消息，但是还么有被消费的时候，如果Node-A节点挂掉，Node-B和Node-C就收不到消息。\n\n\n\n**配置准备：**\n\n```shell\n#1.创建active_cluster目录，复制activemq安装包到里边，并解压3分作为节点A/B/C\n$mkdir activemq_cluster\n$cp apache-activemq-5.15.3-bin.tar.gz activemq_cluster\n$tar -zxvf apache-activemq-5.15.3-bin.tar.gz\n$cp apache-activemq-5.15.3 apache-activemq-nodeA\n$cp apache-activemq-5.15.3 apache-activemq-nodeB\n$cp apache-activemq-5.15.3 apache-activemq-nodeC\n\n#2.创建一个共享文件夹用于nodeB和nodeC的共享储存文件夹\n$ mkdir kahadb\n```\n\n**节点A配置:**\n\n修改apache-activemq-nodeA/conf/activemq.xml，注释掉不需要使用的协议，服务端口为61618，新增网络连接配置，由于这里是已知的3台服务器，所以这里使用静态配置网络连接，连接到B和C两台服务器。\n\n```xml\n        <transportConnectors>\n            <!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB -->\n            <transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <!--\n\n            	注释不需要的协议\n\n            <transportConnector name=\"amqp\" uri=\"amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"stomp\" uri=\"stomp://0.0.0.0:61613?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"mqtt\" uri=\"mqtt://0.0.0.0:1883?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"ws\" uri=\"ws://0.0.0.0:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n\n       		-->\n        </transportConnectors>\n\n        <!-- 新增网络连接配置项，名字自定义，uri使用静态配置，连接到B和C两台服务器 -->\n        <networkConnectors>\n        	<networkConnector name=\"local_network\" uri=\"static:(tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)\"/>\n        </networkConnectors>\n```\n\n查看后端管理端口是否需要修改apache-activemq-nodeA/conf/jetty.xml,由于已经是8161，不需要修改\n\n```xml\n    <bean id=\"jettyPort\" class=\"org.apache.activemq.web.WebConsolePort\" init-method=\"start\">\n             <!-- the default port number for the web console -->\n        <property name=\"host\" value=\"0.0.0.0\"/>\n        <property name=\"port\" value=\"8161\"/>\n    </bean>\n```\n\n**节点B配置：**\n\n修改apache-activemq-nodeB/conf/activemq.xml，注释掉不需要使用的协议，配置服务端口为61617，新增网络连接配置，使用静态配置网络连接，连接到A服务器。并配置B与C的持久化共享文件目录\n\n```xml\n   <!--配置B与C的共享文件夹 -->\n	<persistenceAdapter>\n            <!--<kahaDB directory=\"${activemq.data}/kahadb\"/> -->\n            <kahaDB directory=\"/Users/caojx/Downloads/activemq_cluster/kahadb\"/>\n    </persistenceAdapter>\n	\n	<transportConnectors>\n            <!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB -->\n            <transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61617?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <!-- 注释不需要的协议 \n            <transportConnector name=\"amqp\" uri=\"amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"stomp\" uri=\"stomp://0.0.0.0:61613?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"mqtt\" uri=\"mqtt://0.0.0.0:1883?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"ws\" uri=\"ws://0.0.0.0:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            -->\n        </transportConnectors>\n\n        <!-- 新增网络连接配置项，名字自定义，uri使用静态配置，连接到A服务器 -->\n        <networkConnectors>\n            <networkConnector name=\"network_a\" uri=\"static:(tcp://127.0.0.1:61616)\"/>\n        </networkConnectors>\n```\n\n修改apache-activemq-nodeB/conf/jetty.xml中的管理端口8162\n\n```xml\n    <bean id=\"jettyPort\" class=\"org.apache.activemq.web.WebConsolePort\" init-method=\"start\">\n             <!-- the default port number for the web console -->\n        <property name=\"host\" value=\"0.0.0.0\"/>\n        <property name=\"port\" value=\"8162\"/>\n    </bean>\n```\n\n\n\n**配置C节点：**\n\n修改apache-activemq-nodeC/conf/activemq.xml，注释掉不需要使用的协议，配置服务端口为61618，新增网络连接配置，使用静态配置网络连接，连接到A服务器。并配置B与C的持久化共享文件目录\n\n```xml\n   <!--配置B与C的共享文件夹 -->\n	<persistenceAdapter>\n            <!--<kahaDB directory=\"${activemq.data}/kahadb\"/> -->\n            <kahaDB directory=\"/Users/caojx/Downloads/activemq_cluster/kahadb\"/>\n    </persistenceAdapter>\n	\n	<transportConnectors>\n            <!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB -->\n            <transportConnector name=\"openwire\" uri=\"tcp://0.0.0.0:61618?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <!-- 注释不需要的协议 \n            <transportConnector name=\"amqp\" uri=\"amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"stomp\" uri=\"stomp://0.0.0.0:61613?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"mqtt\" uri=\"mqtt://0.0.0.0:1883?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            <transportConnector name=\"ws\" uri=\"ws://0.0.0.0:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600\"/>\n            -->\n        </transportConnectors>\n\n        <!-- 新增网络连接配置项，名字自定义，uri使用静态配置，连接到A服务器 -->\n        <networkConnectors>\n            <networkConnector name=\"network_a\" uri=\"static:(tcp://127.0.0.1:61616)\"/>\n        </networkConnectors>\n```\n\n修改apache-activemq-nodeC/conf/jetty.xml中的管理端口8163\n\n```xml\n    <bean id=\"jettyPort\" class=\"org.apache.activemq.web.WebConsolePort\" init-method=\"start\">\n             <!-- the default port number for the web console -->\n        <property name=\"host\" value=\"0.0.0.0\"/>\n        <property name=\"port\" value=\"8163\"/>\n    </bean>\n```\n\n**启动3台ActiveMQ:**\n\n```shell\n$./apache-activemq-nodeA/bin/activemq start\n$./apache-activemq-nodeB/bin/activemq start\n$./apache-activemq-nodeC/bin/activemq start\n```\n\n启动之后，可以在浏览器中访问节点Ahttp://127.0.0.1:8161 和节点Bhttp://127.0.0.1:8162 而节点C由于在B的后边启动所以作为节点B的Slave暂时不能访问，当B节点挂调后C节点会获得资源成为新的Master，就可以方位节点Chttp://127.0.0.1:8163。\n\n\n\n#### 3. 编码\n\n生产者\n\n```java\npackage caojx.learn.jms.queue;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:41\n * jms队列模式-消息生产者\n */\npublic class AppProducer {\n\n    //配置多个节点，failover失效转移，当61617节点失效之后，会将请求转向61618节点，randomize表示从节点列表中随机选择一台\n    public static final String url=\"failover:(tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)?randomize=true\";\n    public static final String queueName=\"queue-test\"; //队列名称\n\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 队列\n        Destination destination = session.createQueue(queueName);\n\n        //6.创建一个生产者,并指定目标\n        MessageProducer producer = session.createProducer(destination);\n\n        for (int i = 1; i <= 100; i++) {\n            //7.创建消息\n            TextMessage textMessage = session.createTextMessage(\"test\"+i);\n            //8.发送消息\n            producer.send(textMessage);\n            System.out.println(\"发送消息\"+textMessage.getText());\n        }\n        //9.关闭连接\n        connection.close();\n    }\n}\n\n```\n\n\n\n消费者\n\n```java\npackage caojx.learn.jms.queue;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:56\n * jms队列模式-消息消费者\n */\npublic class AppConsumer {\n\n    //配置多个节点，failover失效转移，当61616节点失效之后，会将请求转向61617节点或，61618节点 randomize表示从节点列表中随机选择一台\n    public static final String url=\"failover:(tcp://127.0.0.1:61616,tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)?randomize=true\";\n\n    public static final String queueName=\"queue-test\"; //队列名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 队列\n        Destination destination = session.createQueue(queueName);\n\n        //6.创建一个消费者,并指定目标\n        MessageConsumer consumer = session.createConsumer(destination);\n\n       //7.创建一个监听器,接收消息\n        consumer.setMessageListener(new MessageListener() {\n            public void onMessage(Message message) {\n                TextMessage textMessage = (TextMessage) message;\n                try {\n                    System.out.println(\"接收消息：\"+textMessage.getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        //注意，由于消息接收是异步的，所以不能关闭connection\n        //connection.close();\n    }\n}\n```\n\n#### 4. 测试\n\n测试的时候我们可以停止任何一台节点nodeA/nodeB/nodeC服务器，然后测试结果是停止任何一台服务器服务依然正常，即使停掉2台剩下一台服务也依然正常。\n\n\n\n## 六、企业级系统中的最佳实践\n\n本节主要了解企业级系统中的现状，分析存在的问题，然后提出解决方案\n\n**实际业务场景分析：**\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625105755_activemq_qy_1.png)\n\n如上图所示某个企业总存在3个子系统登录系统，积分系统和日志系统，其中每个子系统都进行了集群，用户登录操作后要保证将登录事件通知到积分系统和业务系统，并且积分系统和日志系统不能重复收到这个消息，登录成功后要将登录事件发送到积分系统和日志系统。\n\n**实际业务场景特点：**\n\n- 子业务系统都有集群的可能性\n- 同一个消息会广播给关注改消息的所有子系统\n- 同一类消息在集群中被负载消费\n- 业务的发生和消费的发布最终一致性\n\n**需要解决的问题：**\n\n- 不同业务系统分别处理同一个消息，同一业务系统负载处理同类消息\n- 解决消息发送时的一致性问题\n- 解决消息处理时的幂等性问题\n- 基于消息机制简历事件总线\n\n**集群系统处理消息方案**\n\n使用JMS级联的解决方案1：\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625105734_activemq_qy_2.png)\n\nJMS存在两种消息模式，发布/订阅和消息队列模式，我们需要将两种模式结合起来应用。如上图发布者将消息发送到JMS主题，然后两个中转器接收主题中的消息，然后再将消息发送到JMS队列中，最后集群系统负载消费。\n\n这个方案主要存在几个问题，主要是中转器的使用增加了开发的复杂性，因为每增加一个业务系统集群都需要增加一个中转器，并且需要保证中转器的高可用，如果中转器出现故障消息将在主题中堆积，如下是解决这类问题的犯案。\n\n使用ActiveMQ的虚拟主题解决方案2:\n\n- 发布者：将消息发布到一个主题中，主题明为VirtualTopic开头，如VirtualTopic.Test\n- 消费者：从队列中获取消息，在队列名中表明自己的身份，如Comsumer.A.VirtualTopic.Test\n\n**解决消息发送时的一致性为题：**\n\n使用JMS中的XA系列的接口保证强一致性：\n\n- 引入分布式事务\n- 要求业务操作必须支持XA协议\n\n使用消息的本地事务解决方案1：\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625105714_activemq_qy_3.png)\n\n\n\n使用内存日志的解决方案2：\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625105655_activemq_qy_4.png)\n\n\n\n**解决消息处理时的幂等性问题：**\n\n使用本地消息表的本地事务解决方案1：\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625105631_activemq_qy_5.png)\n\n1消费者从消息中间件获取消息，2消费者查询日志消息是否已经处理过，3如果没有处理消费者开始使用本地事务处理业务，和更新消息状态，4最后向消息中间件确认消息。\n\n使用内存日志的解决方案2：\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625105612_activemq_qy_6.png)\n\n1消费者从消息中间件获取消息，2消费者去查询本地内存日志是否已经处理过，3如果说当前消息没有被处理，那么进行业务处理，4业务处理成功之后更新本地内存日志。5最后再确认消息。\n\n**基于消息机制简历事件总线:**\n\n使用了最终一致性后系统变得很复杂，不管是发送方还是接收方都需要做更多的事情，为了简化开发我们需要将一些代码进行复用，将有规律性的代码放到一起。\n\n我们之前的消息发送接收就像是一个事件，发送者就是事件的发起者，消费者就是时间的影响者，这样的架构方式也称为事件驱动。\n\n什么是事件驱动架构？\n\n事件驱动架构（Event Driven Architecture, EDA）定义了一个设计和实现一个应用系统的方法学，在这个系统里事件可传输于松散耦合的组件服务之间。\n\n特点：有事我找你，没事别烦我，就是不要是不是来问我有关于你关注的消息，有消息的时候我会通知你\n\n案例：\n\nhttps://github.com/jovezhao/nest\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625103420_activemq_qy_7.png)\n\n首先我们假如我们有3个业务系统，使用事件总线来简化业务事件之间的发布接收，业务系统B/C通过事件总线提供的方法进行事件注册，业务发起系统通过事件总线提供的方法进行发起事件。这样事件总线就实现了事件的发送和接收以及内存日志的处理。但是事件总线还不具备消息中间件的功能，所以事件总线还需要定义一个抽象的消息提供者，然后我们可以根据不同的消息中间件提供消息提供者，比如ActiveMQ/RabbitMQ/Kafka消息提供者。\n\n该事件总线编码可以参考：https://github.com/jovezhao/nest\n\n## 七、使用其他消息中间件\n\n这里只是对消息进行简单的原理，源码见：https://github.com/jovezhao/nest\n\n之前的消息中间件中我们使用的都是ActiveMQ,ActiveMQ最大的优点就是JMS，jms使得Java消息中间件的开发变得简单，但是ActiveMQ各方面都表现的比较中庸，存在很多自己的缺点，比如吞吐量没有kafka强，稳定性没有RabbitMQ强。在企业开发中往往也不只是基于ActiveMQ的开发，还有其他许多优秀的消息中间件。下边简单介绍一下其他消息中间件的使用方法。\n\n**企业开发需要解决的问题：**\n\n在前面的企业开发过程中我们了解了企业开发中需要解决的问题：\n\n- 不同业务系统分别处理同一个消息，同一业务系统负载处理同类消息\n- 解决消息发送时的一致性问题\n- 解决消息处理时的幂等性问题\n- 基于消息机制简历事件总线\n\n我们使用其他消息中间件时只需要解决\n\n- 解决个业务系统集群处理同一条消息\n- 实现自己的消息提供者\n\n常用的消息中间件\n\n- ActiveMQ\n- RabbitMQ\n- Kafka\n\n### 7.1 集成RabbitMQ\n\n**RabbitMQ:使用交换器绑定到队列**\n\n![](https://ailuoli.cn/image/get_image?fileName=20190625103345_rabbitmq_1.png)\n\n在RabbitMQ中消费者首先需要将队列与交换器绑定，生产者不是直接将消息发送到队列而是发送到交换器。\n\n**RabbitMQ消息提供者源码解析**\n\n- 创建ConnectionFactory\n- 创建Connection\n- 创建Channel通道\n- 基于通道创建一个交换器Exchange\n- 定义Queue队列并将队列绑定到交换器\n\n### 7.2 集成Kafka\n\n**Kafka使用group.id分组消费者**\n\n- 配置消息者参数group.id相同时对消息进行负载处理\n- 配置服务器partitions参数，控制同一个group.id下的consumer数量小于partitions\n- kafka只保证同一个partition下的消息是有序的\n\n**Kafka消息提供者源码分析：**\n\n- 创建生产者\n- 创建消费者\n\n## 参考与推荐文章\n\n[理解JMS规范中消息的传输模式和消息持久化](http://blog.csdn.net/wilsonke/article/details/42804245)\n\n[理解JMS规范中的持久订阅和非持久订阅](http://blog.csdn.net/aitangyong/article/details/26013387)\n\n[Spring整合JMS(消息中间件)](http://blog.csdn.net/suifeng3051/article/details/51718675)\n\n[ActiveMQ订阅模式持久化实现](http://blog.csdn.net/fulai0_0/article/details/52127320)\n\nhttps://www.cnblogs.com/wangjian1990/p/6689703.html', '<h1 id=\"h1-java-activemq\"><a name=\"Java消息中间件-ActiveMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Java消息中间件-ActiveMQ</h1><div class=\"markdown-toc editormd-markdown-toc\">[TOC]</div><p>本笔记主要根据慕课网视屏教程整理出：<a href=\"https://www.imooc.com/learn/856\">https://www.imooc.com/learn/856</a></p>\n<p>练习源码：<a href=\"https://github.com/caojx-git/learn\">https://github.com/caojx-git/learn</a></p>\n<p>使用其他消息中间件：<a href=\"https://github.com/jovezhao/nest\">https://github.com/jovezhao/nest</a></p>\n<h2 id=\"h2--\"><a name=\"一、简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、简介</h2><h3 id=\"h3-1-1-\"><a name=\"1.1 案例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 案例</h3><p>老王有两个女儿，每天晚上睡觉前都要给女儿们讲故事，女儿才睡得照，在沒有使中间件之前，老王需要分别给两个女儿讲故事，这样老王又要工作，又要讲故事很晚，老王也很累。</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625102311_jms_1.png\" alt=\"\"></p>\n<p>老王后来使用了中间件（假设微信是中间件），老王只要将故事推送到微信中，然后让两个女儿订阅微信中的故事，两个女儿就可以在想听故事的时候听到老王的故事，这样老王也省了很多精力。<br><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625102342_jms_2.png\" alt=\"\"></p>\n<h3 id=\"h3-1-2-\"><a name=\"1.2 消息中间件带来的好处\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 消息中间件带来的好处</h3><ul>\n<li><p>系统的解耦</p>\n</li><li><p>异步</p>\n</li><li><p>横向扩展</p>\n</li><li><p>安全可靠</p>\n<p>消息中间件会将我们的消息保存，直到我们的消息被消费为止。如果其他系统没有消费，或消费系统出现异常的时候，消费系统可以在下一次恢复正常后继续消费这条消息。</p>\n</li><li><p>顺序保存</p>\n</li></ul>\n<h3 id=\"h3-1-3-\"><a name=\"1.3 消息中间件概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 消息中间件概述</h3><h4 id=\"h4-1-\"><a name=\"1. 什么是中间件？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是中间件？</h4><p>非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来价值的软件系统统称为中间件。</p>\n<h4 id=\"h4-2-\"><a name=\"2. 什么是消息中间件？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 什么是消息中间件？</h4><p>关注于<strong>数据的发送和接受</strong>，利用高效可靠的<strong>异步</strong>消息传递机制集成<strong>分布式系统</strong>。</p>\n<p>如下是消息中间件示意图：</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625102414_jms_3.png\" alt=\"\"></p>\n<p>应用程序A通过应用程序接口向消息中间件发送消息，应用程序B通过应用程序接口向消息中间件接收消息。</p>\n<h4 id=\"h4-3-jms-\"><a name=\"3.什么是 JMS？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.什么是 JMS？</h4><p>Java消息服务（Java Message Service）即JMS，是一个Java平台中关于面向消息中间件的<strong>API</strong>，用于在两个应用程序之间，或分布式系统中发送消息，进行<strong>异步</strong>通信。</p>\n<h4 id=\"h4-4-amqp-\"><a name=\"4. 什么是AMQP？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 什么是AMQP？</h4><p>AMQP（advanced message queuing protocol）是一个提供统一消息服务的<strong>应用层</strong>标准协议，基于此协议的客户端与消息中间件可传递消息，<strong>并不受客户端/中间件不同产品，不同开发语言条件限制</strong>。</p>\n<h4 id=\"h4-5-jms-amqp-\"><a name=\"5. JMS与AMQP对比\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. JMS与AMQP对比</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>JMS规范</th>\n<th>AMQP协议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>定义</td>\n<td>Java API</td>\n<td>Wire-protocol</td>\n</tr>\n<tr>\n<td>跨语言</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>消息类型</td>\n<td>提供两种消息类型p2p、pub/sub</td>\n<td>提供了5中消息类型&lt;br /&gt;direct、fanout、topic、headers、system</td>\n</tr>\n<tr>\n<td>消息类型</td>\n<td>TextMessage、MapMessage、ByteMessage、StreamMessage、ObjectMessage、Message</td>\n<td>byte[]</td>\n</tr>\n<tr>\n<td>综合评价</td>\n<td>JMS定义了Java API层面的标准；在Java体系中国年，多个client均可以通过JMS进行交互，不需要应用修改代码，但是对于跨平台的支持较差。</td>\n<td>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3-1-4-\"><a name=\"1.4 常见的消息中间件对比\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.4 常见的消息中间件对比</h3><h4 id=\"h4-1-activemq\"><a name=\"1. ActiveMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. ActiveMQ</h4><p>ActiveMQ是Apache出品，最流行，能力强劲的开源消息总线。ActiveMQ是一个完全支持JMS1.1和J2EE1.4规范的JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间件任然扮演着特殊的地位。</p>\n<p><strong>ActiveMQ的特性</strong>：</p>\n<ul>\n<li>多种语言和协议编写客户端</li><li>支持语言：Java、C、C++、C#、Ruby、Perl、Python、PHP</li><li>支持应用协议：OpenWire、Stomp REST、WS、Notification、XMPP、AMQP</li><li>完全支持JMS1.1和J2EE1.4规范（持久化、XA消息、事务）</li><li>虚拟主题、组合目的、镜像队列</li></ul>\n<h4 id=\"h4-2-rabbitmq\"><a name=\"2. RabbitMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. RabbitMQ</h4><p>RabbitMQ是一个开源的AMQP实现，服务端用Erlang语言编写。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性表现不俗。</p>\n<p><strong>RabbitMQ的特性</strong>：</p>\n<ul>\n<li>支持多种客户端，如：Java、Python、Ruby、.NET、JMS、C、PHP、ActionScript等</li><li>AMQP的完整实现（vhost、Exchange、Binding、Routing Key等）</li><li>事务支持/发布确认</li><li>消息持久化</li></ul>\n<h4 id=\"h4-3-kafka\"><a name=\"3. Kafka\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Kafka</h4><p>Kafka是一个高吞吐量的分布式发布订阅消息系统，是一个分布式的、分区的、可靠的分布式日志存储服务。它通过一种独一无二的设计提供了一个消息系统的功能。</p>\n<p><strong>Kafka的特性</strong></p>\n<ul>\n<li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li><li>高吞吐量：即使是非常比普通的硬件Kafka也可以支持每秒数百万的消息。</li><li>Partion、Consumer Group</li></ul>\n<h4 id=\"h4-4-activemq-rabbitmq-kafka-\"><a name=\"4. ActiveMQ、RabbitMQ和Kafka消息中间件对比\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. ActiveMQ、RabbitMQ和Kafka消息中间件对比</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>ActiveMQ</th>\n<th>RabbitMQ</th>\n<th>KafKa</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>跨语言</td>\n<td>支持(Java优先)</td>\n<td>语言无关</td>\n<td>支持（Java优先）</td>\n</tr>\n<tr>\n<td>支持协议</td>\n<td>OpenWire,Stomp,XMPP,AMQP</td>\n<td>AMQP</td>\n<td></td>\n</tr>\n<tr>\n<td>优点</td>\n<td>遵循JMS规范安装部署方便</td>\n<td>继承Erlang天生的并发性最初用于金融行业，稳定性，安全性有保障</td>\n<td>依赖zk，可动态扩展节点，高性能，高吞吐量，无限扩容，消息可指定追溯</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>根据其他用户反馈，会莫名丢失消息。目前重心在下代产品apolle上，目前社区不活跃，对5.x维护较少</td>\n<td>Erlang语言难度较大，不支持动态扩展</td>\n<td>严格的顺序机制，不支持消息优先级，不支持标准的消息协议，不利于平台的迁移</td>\n</tr>\n<tr>\n<td>综合评价</td>\n<td>适合中小企业消息应用场景，不适合上千个队列的应用场景</td>\n<td>适合对性能稳定性要求高的企业级应用</td>\n<td>一般应用在大数据日志处理或者对实时性（少量延迟），可靠性（少量丢失数据）要求稍低的场景使用</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"h3-1-5-jms-\"><a name=\"1.5 JMS规范\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.5 JMS规范</h3><h4 id=\"h4-1-java-\"><a name=\"1. Java消息服务定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Java消息服务定义</h4><p>Java消息服务（Java Message Service）即JMS，是一个Java平台中关于面向消息中间件的<strong>API</strong>，用于在两个应用程序之间，或分布式系统中发送消息，进行<strong>异步</strong>通信。</p>\n<h4 id=\"h4-2-jms-\"><a name=\"2. JMS相关概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. JMS相关概念</h4><p><strong>提供者</strong>：实现JMS规范的消息中间件服务器</p>\n<p><strong>客户端</strong>：发送或接受消息的应用程序</p>\n<p><strong>生产者/发布者</strong>：创建并发送消息的客户端</p>\n<p><strong>消费者/订阅者</strong>：接受并处理消息的客户端</p>\n<p><strong>消息</strong>：应用程序之间传递的数据内容</p>\n<p><strong>消息模式</strong>：在客户端之间传递消息的方式，JMS定义了主题和队列两种模式</p>\n<h4 id=\"h4-3-\"><a name=\"3. 队列模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 队列模式</h4><ul>\n<li>客户端包括生产者和消费者</li><li>队列中的消息只能被一个消费者所消费</li><li>消费者可以随时消费队列中的消息</li></ul>\n<p>下图是队列模式示意图：</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625102548_jms_4.png\" alt=\"\"></p>\n<p>应用1和应用2分别发送了消息M1/M3/M5 和M2/M4/M6共6条消息，然后消息队列中有了这6条消息，然后创建了2个消费者应用3建立了2个连接和应用4建立了一个连接，由结果可见，应用消费者中的每个连接平摊了队列中的每个消息。</p>\n<h4 id=\"h4-4-\"><a name=\"4. 主题模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 主题模式</h4><ul>\n<li>客户端包括发布者可订阅者</li><li>主题中的消息被所有订阅者消费</li><li>消费者不能消费订阅之前就发送到主题中的消息</li></ul>\n<p>下图是主题模式示意图：</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625102615_jms_5.png\" alt=\"\"></p>\n<p>创建两个订阅者应用3和应用4与JMS主题先建立连接，然后再创建两个发布者应用1和应用2与JMS主题建立连接分别发送了M1/M3/M5和M2/M4/M6，这时JMS主题中有了6条消息，由于应用3和应用4在之前就订阅了该主题的消息，所以应用3和应用4都能收到所有的消息。主要是订阅者需要提前去订阅主题。</p>\n<h4 id=\"h4-5-jms-\"><a name=\"5.JMS编码接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.JMS编码接口</h4><ul>\n<li>ConnectionFactory 用于创建连接到消息中间件的连接工厂，这个工厂一般由消息提供商提供。</li><li>Connection 代表了应用程序和消息服务器之间的通信链路</li><li>Destination 指消息发布和接受的地点，包括队列或主题</li><li>Session 表示一个单线程的上下文会话，用于发送和接收消息</li><li>MessageConsumer 由会话创建，用于接受发送到目标的消息</li><li>MessageProducer 由会话创建，用于发送消息到目标</li><li>Message 是在消费者和生产者之间传送的对象，消息头，一组消息属性，一个消息体</li></ul>\n<h4 id=\"h4-6-jms-\"><a name=\"6. JMS编码接口之间的关系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. JMS编码接口之间的关系</h4><p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625102637_jms_6.png\" alt=\"\"></p>\n<p>首先连接工厂创建一个连接Connection，有了这个连接之后就可以创建会话Session，这里我们的连接也可以创建多个会话Session，而每个会话是在一个线程上下文的。由会话Session我们可以创建生产者和消费者，并且会话也可以用来创建一个新的消息。然后我们可以使用我们的生产者将我们的消息发送到指定的目的地，然后我们的消费者可以到指定的目的地去接收我们的消息。</p>\n<h2 id=\"h2--activemq\"><a name=\"二、安装ActiveMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、安装ActiveMQ</h2><h3 id=\"h3-2-1-windows-activemq\"><a name=\"2.1 Windows平台安装ActiveMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 Windows平台安装ActiveMQ</h3><ol>\n<li><p>下载安装包 <a href=\"http://www.apache.org/dyn/closer.cgi?filename=/activemq/5.15.3/apache-activemq-5.15.3-bin.zip&amp;action=download\">http://www.apache.org/dyn/closer.cgi?filename=/activemq/5.15.3/apache-activemq-5.15.3-bin.zip&amp;action=download</a></p>\n</li><li><p>直接启动</p>\n<p>解压安装包后进入bin/win64目录，运行activemq.bat即运行activeMQ</p>\n</li><li><p>使用服务启动</p>\n<p>解压安装包后进入bin/win64目录，运行installService.bat,运行之后，会将ActiveMQ以服务的方式安装到我们电脑，这样我们就可以以服务的方式启动了。</p>\n</li></ol>\n<h3 id=\"h3-2-2-linux-activemq\"><a name=\"2.2 Linux平台安装ActiveMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 Linux平台安装ActiveMQ</h3><p><a href=\"http://www.apache.org/dyn/closer.cgi?filename=/activemq/5.15.3/apache-activemq-5.15.3-bin.tar.gz&amp;action=download\">http://www.apache.org/dyn/closer.cgi?filename=/activemq/5.15.3/apache-activemq-5.15.3-bin.tar.gz&amp;action=download</a></p>\n<pre><code class=\"lang-shell\">#解压安装包\n#tar -zxvf apache-activemq-5.15.3.tar.gz\n#cd apache-activemq-5.15.3/bin\n#ls \nactivemq      activemq-diag activemq.jar  env           linux-x86-32  linux-x86-64  macosx        wrapper.jar\n#启动activeMQ\n#./activemq start #启动后activeMQ默认端口是8161\n\n#需要停止activemq\n#./activemq stop\n</code></pre>\n<p>访问：<a href=\"http://127.0.0.1:8161\">http://127.0.0.1:8161</a> 后点击Manage ActiveMQ broker 会要求输入ActiveMQ管理密码，默认是admin/admin</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625102714_activeMQ_1.png\" alt=\"\"></p>\n<h2 id=\"h2--jms-activemq\"><a name=\"三、JMS接口规范连接ActiveMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、JMS接口规范连接ActiveMQ</h2><p><strong>使用JMS接口规范连接ActiveMQ</strong></p>\n<ul>\n<li>创建生产者/消费者</li><li>创建发布者/订阅者</li></ul>\n<p>这里我们将演示p2p和发布订阅两种模式</p>\n<p>注意：本节内容可以参考<strong>1.5 JMS规范</strong></p>\n<h3 id=\"h3-3-1-pom-xml\"><a name=\"3.1 pom.xml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 pom.xml</h3><p>引入activemq依赖</p>\n<pre><code class=\"lang-xml\">&lt;!-- 引入activemq依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;\n  &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;\n  &lt;version&gt;5.15.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"h3-3-1-\"><a name=\"3.1 队列模式的消息演示\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 队列模式的消息演示</h3><p>队列模式的特点：</p>\n<ul>\n<li>客户端包括生产者和消费者</li><li>队列中的消息只能被一个消费者所消费</li><li>消费者可以随时消费队列中的消息</li></ul>\n<p><strong>1.AppProducer.java</strong></p>\n<p>使用队列模式创建一个生产者，发送100个消息到消息队列中，所以<strong>之前要先启动activemq</strong>。</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.queue;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:41\n * jms队列模式-消息生产者\n */\npublic class AppProducer {\n\n\n    public static final String url=&quot;tcp://127.0.0.1:61616&quot;; //连接activemq的地址，61616是连接activemq默认的端口\n\n    public static final String queueName=&quot;queue-test&quot;; //队列名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 队列\n        Destination destination = session.createQueue(queueName);\n\n        //6.创建一个生产者,并指定目标\n        MessageProducer producer = session.createProducer(destination);\n\n        for (int i = 1; i &lt;= 100; i++) {\n            //7.创建消息\n            TextMessage textMessage = session.createTextMessage(&quot;test&quot;+i);\n            //8.发送消息\n            producer.send(textMessage);\n            System.out.println(&quot;发送消息&quot;+textMessage.getText());\n        }\n        //9.关闭连接\n        connection.close();\n    }\n}\n</code></pre>\n<ol>\n<li><p><strong>执行生产者的main方法发送消息</strong></p>\n<p>控制台：</p>\n<pre><code class=\"lang-text\">发送消息test1\n发送消息test2\n...\n发送消息test97\n发送消息test98\n发送消息test99\n发送消息test100\n</code></pre>\n<p>activemq管理界面：</p>\n<p>Name:队列名称 quque-test</p>\n<p>Number Of Pending Messages：挂起消息的数目</p>\n<p>Number Of Consumers：消费者数目</p>\n<p>Messages Enqueued：消息队列中的数目，待消费的数量</p>\n<p>Messages Dequeued：消息出对的数目，已消费的数量</p>\n</li></ol>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625103147_activemq_queue_1.png\" alt=\"\"></p>\n<ol>\n<li><strong>AppConsumer.java</strong></li></ol>\n<p>消费者，用于接收生产者发送到消息队列这中的消息</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.queue;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:56\n * jms队列模式-消息消费者\n */\npublic class AppConsumer {\n\n    public static final String url=&quot;tcp://127.0.0.1:61616&quot;; //连接activemq的地址，61616是连接activemq默认的端口\n\n    public static final String queueName=&quot;queue-test&quot;; //队列名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 队列\n        Destination destination = session.createQueue(queueName);\n\n        //6.创建一个消费者,并指定目标\n        MessageConsumer consumer = session.createConsumer(destination);\n\n       //7.创建一个监听器,接收消息\n        consumer.setMessageListener(new MessageListener() {\n            public void onMessage(Message message) {\n                TextMessage textMessage = (TextMessage) message;\n                try {\n                    System.out.println(&quot;接收消息：&quot;+textMessage.getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        //注意，由于消息接收是异步的，所以不能关闭connection\n        //connection.close();\n    }\n}\n</code></pre>\n<ol>\n<li><strong>执行消费者的main方法接收消息</strong></li></ol>\n<p>控制台：</p>\n<pre><code class=\"lang-text\">接收消息：test1\n....\n接收消息：test99\n接收消息：test100\n</code></pre>\n<p>activemq管理界面：</p>\n<p>Name:队列名称 quque-test</p>\n<p>Number Of Pending Messages：挂起消息的数目</p>\n<p>Number Of Consumers：消费者数目</p>\n<p>Messages Enqueued：消息队列中的数目，待消费的数量</p>\n<p>Messages Dequeued：消息出对的数目，已消费的数量</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625103000_activemq_queue_2.png\" alt=\"\"></p>\n<p><strong>注意：如果先启动多个消费者，再启动生产者发送消息，队列模式的消费者会平均分摊消息队列中的消息</strong></p>\n<h3 id=\"h3-3-2-\"><a name=\"3.2 主题模式的消息演示\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 主题模式的消息演示</h3><p>主题模式的特点：</p>\n<ul>\n<li>客户端包括发布者可订阅者</li><li>主题中的消息被所有订阅者消费</li><li>消费者不能消费订阅之前就发送到主题中的消息</li></ul>\n<p><strong>1.AppProducer.java</strong></p>\n<p>使用主题模式创建一个发布者，发送100个消息到主题中，所以<strong>之前要先启动activemq</strong>。</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.topic;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:41\n * jms主题模式-消息发布者\n */\npublic class AppProducer {\n\n\n    public static final String url=&quot;tcp://127.0.0.1:61616&quot;; //连接activemq的地址，61616是连接activemq默认的端口\n\n    public static final String topicName=&quot;topic-test&quot;; //主题名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 主题\n        Destination destination = session.createTopic(topicName);\n\n        //6.创建一个发布者,并指定目标\n        MessageProducer producer = session.createProducer(destination);\n\n        for (int i = 1; i &lt;= 100; i++) {\n            //7.创建消息\n            TextMessage textMessage = session.createTextMessage(&quot;test&quot;+i);\n            //8.发送消息\n            producer.send(textMessage);\n            System.out.println(&quot;发送消息&quot;+textMessage.getText());\n        }\n        //9.关闭连接\n        connection.close();\n    }\n}\n</code></pre>\n<ol>\n<li><strong>AppConsumer.java</strong></li></ol>\n<p>订阅者，用于接收发布者发送的对应主题消息</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.topic;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:56\n * jms主题模式-消息订阅者\n */\npublic class AppConsumer {\n\n    public static final String url=&quot;tcp://127.0.0.1:61616&quot;; //连接activemq的地址，61616是连接activemq默认的端口\n\n    public static final String topicName=&quot;topic-test&quot;; //主题名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标\n        Destination destination = session.createTopic(topicName);\n\n        //6.创建一个订阅者,并指定目标 主题\n        MessageConsumer consumer = session.createConsumer(destination);\n\n       //7.创建一个监听器,接收消息\n        consumer.setMessageListener(new MessageListener() {\n            public void onMessage(Message message) {\n                TextMessage textMessage = (TextMessage) message;\n                try {\n                    System.out.println(&quot;接收消息：&quot;+textMessage.getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        //注意，由于消息接收是异步的，所以不能关闭connection\n        //connection.close();\n    }\n}\n</code></pre>\n<ol>\n<li><p><strong>测试</strong></p>\n<p>主题模式需要先让订阅者订阅主题，然后发布者往主题中发送消息，订阅者才可以订阅到到消息。所以这里先启动订阅者（启动3个）,然后启动1个发布者发布消息。</p>\n<p>​</p>\n<p>启动3个发布者后，topic-test显示有3个订阅者</p>\n</li></ol>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625103311_activemq_topic_1.png\" alt=\"\"></p>\n<p>   启动发布者发布消息</p>\n<p>   发布者控制台</p>\n<pre><code class=\"lang-text\">   发送消息test1\n   发送消息test2\n   ...\n   发送消息test100\n</code></pre>\n<p>   3个消费者控制台都是，即都接收到一样的消息</p>\n<pre><code class=\"lang-text\">   接收消息：test1\n   接收消息：test2\n   接收消息：test3\n   ....\n   接收消息：test100\n</code></pre>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625110303_activemq_topic_2.png\" alt=\"\"></p>\n<p>   ​</p>\n<h2 id=\"h2--spring-jms\"><a name=\"四、Spring集成JMS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、Spring集成JMS</h2><p>本节了解spring继承jms连接activemq。</p>\n<h3 id=\"h3-4-1-spring-jms-activemq\"><a name=\"4.1 spring继承jms连接activemq\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 spring继承jms连接activemq</h3><p>spring继承jms连接activema，提供了</p>\n<ul>\n<li><p>ConnectionFactory 用于管理连接的连接工厂</p>\n<p>ConnectionFactory是spring为我们提供的连接池，之所有需要连接池是由于JmsTemplate每次发送消息都会重新创建连接，会话和productor 。在spring中分别提供了SingleConnectionFactory和CachingConnectionFactory。</p>\n</li><li><p>JmsTemplate 用于接收和发送消息的模板类</p>\n<p>JmsTemplate是spring提供的，只需向spring容器内注册这个类就可以使用JmsTemplate方便的操作jms。</p>\n<p>JmsTemplate类是线程安全的，可以在整个应用范围使用。</p>\n</li><li><p>MessageListerner 消息监听器</p>\n<p>实现一个onMessage方法，该方法只接收一个Message参数。</p>\n</li></ul>\n<h3 id=\"h3-4-2-\"><a name=\"4.2 编码实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 编码实现</h3><p>编码实现可以边参考，可以更好理解jms</p>\n<p><a href=\"http://blog.csdn.net/wilsonke/article/details/42804245\">理解JMS规范中消息的传输模式和消息持久化</a></p>\n<p><a href=\"http://blog.csdn.net/aitangyong/article/details/26013387\">理解JMS规范中的持久订阅和非持久订阅</a></p>\n<p>1.<strong>项目目录</strong></p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625110219_activemq_spring_1.png\" alt=\"\"></p>\n<ol>\n<li><strong>pom.xml</strong></li></ol>\n<pre><code class=\"lang-xml\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;caojx.learn&lt;/groupId&gt;\n    &lt;artifactId&gt;activemq-java&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;activemq-java&lt;/name&gt;\n    &lt;url&gt;http://maven.apache.org&lt;/url&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;spring.version&gt;4.3.14.RELEASE&lt;/spring.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;3.8.1&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--集成spring--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--集成spring的时候，可以不需要activemq-all依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;\n            &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;\n            &lt;version&gt;5.7.0&lt;/version&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n                    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n                &lt;/exclusion&gt;\n            &lt;/exclusions&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<ol>\n<li><strong>ProducerService.java</strong></li></ol>\n<pre><code class=\"lang-java\">package caojx.learn.jms.spring.queue;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:25\n * 接收消息业务接口\n */\npublic interface ProducerService {\n\n    void sendMessage(String message);\n}\n</code></pre>\n<ol>\n<li><strong>ProducerServiceImpl.java</strong></li></ol>\n<pre><code class=\"lang-java\">package caojx.learn.jms.spring.queue;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jms.core.JmsTemplate;\nimport org.springframework.jms.core.MessageCreator;\n\nimport javax.annotation.Resource;\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:33\n * 接收消息业务实现类\n */\npublic class ProducerServiceImpl implements ProducerService {\n\n    @Autowired\n    JmsTemplate jmsTemplate;\n\n    public void sendMessage(final String message) {\n        //使用消息模板发送消息\n        jmsTemplate.send(new MessageCreator() {\n            //创建一个消息\n            public Message createMessage(Session session) throws JMSException {\n                TextMessage textMessage = session.createTextMessage(message);\n                return textMessage;\n            }\n        });\n        System.out.println(&quot;发送消息：&quot;+message);\n    }\n}\n</code></pre>\n<ol>\n<li><strong>spring-jms-common.xml</strong></li></ol>\n<p>jms与spring集成公共配置，如果要使用持久模式必须指定clientId（接收者Id）,这样即使是在主题模式下订阅者也能接收到之前发布者该给对应订阅者的消息，即相当于消费者有个vip卡，消息提供者会给消费者预留消息。极力推荐两篇文章会对jms理解更深刻</p>\n<p><a href=\"http://blog.csdn.net/wilsonke/article/details/42804245\">理解JMS规范中消息的传输模式和消息持久化</a></p>\n<p><a href=\"http://blog.csdn.net/aitangyong/article/details/26013387\">理解JMS规范中的持久订阅和非持久订阅</a></p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;context:annotation-config/&gt;\n\n    &lt;!--ActiveMQ为我们提供的ConnectionFactory--&gt;\n    &lt;bean id=&quot;targetConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;\n        &lt;!-- 配置activemq的连接配置 --&gt;\n        &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://127.0.0.1:61616&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;userName&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;password&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!--spring jms为我们提供连接池，代理activemq的连接工厂--&gt;\n\n    &lt;!--\n    持久订阅时，客户端向JMS 服务器注册一个自己身份的ID，当这个客户端处于离线时，JMS Provider 会为这个ID 保存所有发送到主题的消息，\n    当客户再次连接到JMS Provider时，会根据自己的ID得到所有当自己处于离线时发送到主题的消息。\n    --&gt;\n    &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;\n        &lt;!--代理的连接工厂--&gt;\n        &lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;targetConnectionFactory&quot;&gt;&lt;/property&gt;\n        &lt;!-- 持久订阅模式时接收者ID必须指定,如果使用非持久订阅模式时不用配置 --&gt;\n        &lt;!--&lt;property name=&quot;clientId&quot; value=&quot;client_119&quot;/&gt;--&gt;\n        &lt;!-- Session缓存数量 --&gt;\n        &lt;property name=&quot;sessionCacheSize&quot; value=&quot;10&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!--一个队列目的地，点对点队列模式--&gt;\n    &lt;bean id=&quot;queueDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;\n        &lt;!-- 设置消息队列的名字 --&gt;\n        &lt;constructor-arg index=&quot;0&quot; value=&quot;queue&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--一个主题目的地，发布订阅模式--&gt;\n    &lt;bean id=&quot;topicDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;&gt;\n        &lt;!-- 设置消息主题的名字 --&gt;\n        &lt;constructor-arg index=&quot;0&quot; value=&quot;topic&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans\n</code></pre>\n<ol>\n<li><strong>spring-jms-producer.xml</strong></li></ol>\n<p>提供者配置文件，会映入公共配置，jmsTemplate用于配置消息模板，编写的时候可以自行选择主题模式或队列模式</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;!--导入公共配置--&gt;\n    &lt;import resource=&quot;spring-jms-common.xml&quot;&gt;&lt;/import&gt;\n\n    &lt;!--消息模板,用于发送消息--&gt;\n    &lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;\n        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;\n        &lt;!--发送消息的目的地,一个队列--&gt;\n        &lt;!--&lt;property name=&quot;defaultDestination&quot; ref=&quot;queueDestination&quot;/&gt;--&gt;\n        &lt;!--发送消息的目的地,一个主题--&gt;\n        &lt;property name=&quot;defaultDestination&quot; ref=&quot;topicDestination&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!--bean配置--&gt;\n    &lt;bean class=&quot;caojx.learn.jms.spring.queue.ProducerServiceImpl&quot;&gt;&lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<ol>\n<li><strong>spring-jms-consumer.xml</strong></li></ol>\n<p>消费者配置文件，使用消息监听器监听消息</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;!--导入公共配置--&gt;\n    &lt;import resource=&quot;spring-jms-common.xml&quot;&gt;&lt;/import&gt;\n\n    &lt;!--配置消息监听器--&gt;\n    &lt;bean id=&quot;consumerMessageListener&quot; class=&quot;caojx.learn.jms.spring.queue.ConsumerMessageListener&quot;&gt;&lt;/bean&gt;\n\n    &lt;!--配置消息监听容器--&gt;\n    &lt;bean id=&quot;jmsContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;\n        &lt;!--连接工厂--&gt;\n        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;\n        &lt;!--队列模式--&gt;\n        &lt;!--&lt;property name=&quot;destination&quot; ref=&quot;queueDestination&quot;/&gt;--&gt;\n        &lt;!--主题模式--&gt;\n        &lt;property name=&quot;destination&quot; ref=&quot;topicDestination&quot;/&gt;\n        &lt;!--消息监听器--&gt;\n        &lt;property name=&quot;messageListener&quot; ref=&quot;consumerMessageListener&quot;/&gt;\n\n        &lt;!-- 持久订阅模式时接收者ID必须指定,如果使用非持久订阅模式时不用配置 --&gt;\n &lt;!--       &lt;property name=&quot;clientId&quot; value=&quot;client_119&quot;/&gt;\n        &lt;property name=&quot;durableSubscriptionName&quot; value=&quot;client_119&quot;/&gt;--&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<ol>\n<li><strong>ConsumerMessageListener.java</strong></li></ol>\n<p>消费者消息监听器，接收消息</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.spring.queue;\n\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.MessageListener;\nimport javax.jms.TextMessage;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:49\n */\npublic class ConsumerMessageListener implements MessageListener {\n\n    public void onMessage(Message message) {\n        TextMessage textMessage = (TextMessage) message;\n        try {\n            System.out.println(&quot;接收消息：&quot;+textMessage.getText());\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p>9.<strong>AppProducer.java</strong></p>\n<p>消息发送者</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.spring.queue;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:43\n * 消息提供者\n */\npublic class AppProducer {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-jms-producer.xml&quot;);\n        ProducerService service = context.getBean(ProducerService.class);\n        for (int i = 0; i &lt; 100; i++) {\n            service.sendMessage(&quot;test&quot;+i);\n        }\n        //关闭资源\n        context.close();\n    }\n}\n</code></pre>\n<p>10.<strong>AppConsumer.java</strong></p>\n<p>消息消费者</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.spring.queue;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午9:57\n * 消息消费者\n */\npublic class AppConsumer {\n    public static void main(String[] args) throws Exception{\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-jms-consumer.xml&quot;);\n    }\n}\n</code></pre>\n<p>注意:如果使用持久订阅，由于设置了clientId,如果先启动<strong>AppConsumer.java</strong>消费者，由于消费者会等待接受消息，对应的clientId连接没有关闭，再启动<strong>AppProducer.java</strong>发布消息的时候会报错。如果不使用持久订阅，即不设置clientid，则不会出现如下错误。</p>\n<p>下边的报错也不算是错误，如果<strong>AppProducer.java</strong>先发布消息context.close();关闭了clientId,然后<strong>AppConsumer.java</strong>接收消息就不会有这个问题了。就好比发了个消息就下线了，然后接收者上线就可以接收到消息。</p>\n<pre><code class=\"lang-java\">Exception in thread &quot;main&quot; org.springframework.jms.InvalidClientIDException: Broker: localhost - Client: client_119 already connected from tcp://127.0.0.1:57479; nested exception is javax.jms.InvalidClientIDException: Broker: localhost - Client: client_119 already connected from tcp://127.0.0.1:57479\n    at org.springframework.jms.support.JmsUtils.convertJmsAccessException(JmsUtils.java:282)\n    at org.springframework.jms.support.JmsAccessor.convertJmsAccessException(JmsAccessor.java:169)\n    at org.springframework.jms.core.JmsTemplate.execute(JmsTemplate.java:487)\n    at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:559)\n    at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:550)\n    at caojx.learn.jms.spring.queue.ProducerServiceImpl.sendMessage(ProducerServiceImpl.java:22)\n    at caojx.learn.jms.spring.queue.AppProducer.main(AppProducer.java:15)\nCaused by: javax.jms.InvalidClientIDException: Broker: localhost - Client: client_119 already connected from tcp://127.0.0.1:57479\n    at org.apache.activemq.broker.region.RegionBroker.addConnection(RegionBroker.java:247)\n    at org.apache.activemq.broker.jmx.ManagedRegionBroker.addConnection(ManagedRegionBroker.java:227)\n    at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:99)\n    at org.apache.activemq.advisory.AdvisoryBroker.addConnection(AdvisoryBroker.java:119)\n    at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:99)\n    at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:99)\n    at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:99)\n    at org.apache.activemq.broker.TransportConnection.processAddConnection(TransportConnection.java:843)\n    at org.apache.activemq.broker.jmx.ManagedTransportConnection.processAddConnection(ManagedTransportConnection.java:77)\n    at org.apache.activemq.command.ConnectionInfo.visit(ConnectionInfo.java:139)\n    at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:330)\n    at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:194)\n    at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)\n    at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:125)\n    at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:301)\n    at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)\n    at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)\n    at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)\n    at java.lang.Thread.run(Thread.java:748)\n</code></pre>\n<h2 id=\"h2--activemq-\"><a name=\"五、activeMQ集群\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、activeMQ集群</h2><p>本节主要了解：</p>\n<ul>\n<li>ActiveMQ集群配置</li><li>消息中间件在企业系统中的使用</li></ul>\n<h3 id=\"h3-5-1-activemq-\"><a name=\"5.1 activeMQ集群理论\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 activeMQ集群理论</h3><h4 id=\"h4-1-\"><a name=\"1. 为什么要对消息中间件集群？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 为什么要对消息中间件集群？</h4><ul>\n<li>实现<strong>高可用</strong>，以排除单点故障引起的服务中断</li><li>实现<strong>负载均衡</strong>，以提升效率为更多客户提供服务</li></ul>\n<h4 id=\"h4-2-\"><a name=\"2. 集群方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 集群方式</h4><ul>\n<li>客户端集群：让多个消费者消费同一个队列</li><li>Broker clusters：多个Broker之间同步消息</li><li>Master Slave：高可用</li></ul>\n<h4 id=\"h4-3-\"><a name=\"3. 集群客户端配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 集群客户端配置</h4><ul>\n<li><p>ActiveMQ失效转移（failover）</p>\n<p>允许当其中一台消息服务器宕机时，客户端在传输层上重新连接到其他消息服务器</p>\n<p>语法：failover:(消息服务器uri1,…,消息服务器uriN)?transportOptions</p>\n<p>transportOptions重要参数说明：</p>\n<p>randomize 默认为true，表示在URI列表中选择URI连接时是否采用随机策略</p>\n<p>initialReconnectDelay 默认为10，单位毫秒，表示第一次尝试重连之间等待时间</p>\n<p>maxReconnectDelay 默认30000，单位毫秒，表示最长重连的时间间隔</p>\n</li></ul>\n<h4 id=\"h4-4-broker-cluster-\"><a name=\"4. Broker Cluster集群配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. Broker Cluster集群配置</h4><p><strong>原理</strong></p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625110134_activemq_broker+cluster_1.png\" alt=\"\"> </p>\n<p>节点A将消息同步给节点B，节点B将消息同步给节点A，通过这样的消息同步之后，节点A和节点B之间都有相同的消息。它的实现方式采用的是一种网络连接器的方式实现的</p>\n<p><strong>NetworkConnector(网络连接器)</strong></p>\n<p>网络连接器主要用于配置ActiveMQ服务器与服务器之间的网络通讯方式，用于服务器透传消息</p>\n<p>网络连接器分为静态连接和动态连接</p>\n<p><strong>静态连接器：</strong></p>\n<p>在配置连接器的时候去指定具体的ip地址，参考一下配置</p>\n<pre><code class=\"lang-xml\">&lt;networkConnectors&gt;\n    &lt;networkConnector uri=&quot;static:(tpc://127.0.0.1:61617,tpc://127.0.0.1:61618)&quot;/&gt;\n&lt;/networkConnectors&gt;\n</code></pre>\n<p><strong>动态连接器：</strong></p>\n<p>如果我们服务器比较多的时候，或者服务器可能需要动态扩展的时候，静态配置显然比较麻烦，这时我们需要使用动态连接，动态连接主要使用组播的方式实现的，参考一下配置</p>\n<pre><code class=\"lang-xml\">&lt;transportConnectors&gt;\n    &lt;transportConnector uri=&quot;tcp://localhost:0&quot; discoveryUri=&quot;multicast://default&quot;/&gt;\n&lt;/transportConnectors&gt;\n</code></pre>\n<h4 id=\"h4-5-master-slave-\"><a name=\"5. Master/Slave 集群配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. Master/Slave 集群配置</h4><p>这种集群方式主要有一下3种实现方案</p>\n<ul>\n<li>Share nothing storage master/slave (已经过时，5.8+后移除)，这里不了解</li><li>Share storage master/slave 共享储存</li><li>Replicated LevelDB Store 基于复制的LevelDB Store,主要使用zookeeper实现</li></ul>\n<p><strong>共享存储集群的原理：</strong></p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625110100_activemq_master_slave_1.png\" alt=\"\"></p>\n<p>假如我们有节点A和节点B两台服务器，还有一个共享的储存地址持久化（可以是jdbc的数据库，也可以是基于SAN的文件系统）。</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625110032_activemq_master_slave_2.png\" alt=\"\"></p>\n<p>然后我们将节点A和节点B都配置到同一个持久化地址后，先启动节点A，这时节点A获取到资源排它锁成为Master，节点B因为他获取不到锁资源成为Slave，成为Master的节点A获取到了对外服务开放的能力，可以通过外部的客户端提交信息到节点A，但是不能够发送信息到节点B。</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625110003_activemq_master_slave_3.png\" alt=\"\"> </p>\n<p>如果节点A挂点了，节点B会立即获取到持久化资源的排它锁，节点B成为新的Master，可以接收外部客户端发送的消息，客户端使用失效转移之后将请求发送到节点B，这样就完成了整个请求的不间断性，达到了高可用效果。</p>\n<p><strong>基于复制的LevelDB Store的原理：</strong></p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625105932_activemq_leveldb_1.png\" alt=\"\"></p>\n<p>因为LevelDB是基于zookeeper的，所以服务器至少需要3台，这里假设我们有3台服务器节点A/B/C，每个节点都有自己的持久化方式，因为她们都配置同样的zookeeper节点，通过zookeeper来选举一台服务器节点作为Master。比如选举了节点A作为Master，这时节点A成为Master之后，节点A具有了对外服务的能力，而节点B和节点C是不具有对外服务的能力的。节点A获取到外部发送过的消息之后，先进行本地储存（Store），然后通过zookeeper将消息同步给节点B和节点C，节点B和节点C分别在自己的服务器上储存。当然如果节点A出现故障，zookepper会立即选举一台新的Master出来。</p>\n<h4 id=\"h4-6-\"><a name=\"6. 两种集群方式的对比\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 两种集群方式的对比</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>高可用</th>\n<th>负载均衡</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Master/Slave</td>\n<td>是</td>\n<td>否</td>\n<td>Slave服务器不具备对外服务的能力</td>\n</tr>\n<tr>\n<td>Broker Cluster</td>\n<td>否</td>\n<td>是</td>\n<td>自己的消息没有在一个地方储存，当某台服务器挂掉的时候，消息可能会同步丢失</td>\n</tr>\n</tbody>\n</table>\n<p>上边的两种集群方案要么是不支持负载均衡，要么不能高可用，是否有一种方案可以即可以负载均衡又可以做到高可用呢？</p>\n<h3 id=\"h3-5-2-activemq-\"><a name=\"5.2 activeMQ集群实践\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 activeMQ集群实践</h3><p>由于是演示配置，所以都在同一台机器上完成</p>\n<h4 id=\"h4-1-\"><a name=\"1. 三台服务器的完美集群方案\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 三台服务器的完美集群方案</h4><p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625105842_activemq_jq_1.png\" alt=\"\"></p>\n<p>假如我们有3台服务器，我们可以组一个如上图的架构即达到高可用，又可以负载均衡。</p>\n<p>节点A和节点B和节点C组成一个 Broker Cluster集群方案，然后节点B和节点C组成一个Master/Slave方案共享持久化内容。</p>\n<h4 id=\"h4-2-\"><a name=\"2. 实现配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 实现配置</h4><p><strong>配置说明：</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>服务端口</th>\n<th>管理端口</th>\n<th>存储</th>\n<th>网络连接器</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Node-A</td>\n<td>61616</td>\n<td>8161</td>\n<td>-</td>\n<td>Node-B、Node-C</td>\n<td>消费者</td>\n</tr>\n<tr>\n<td>Node-B</td>\n<td>61617</td>\n<td>8162</td>\n<td>/share_file/kahadb</td>\n<td>Node-A</td>\n<td>生产者、消费者</td>\n</tr>\n<tr>\n<td>Node-C</td>\n<td>61618</td>\n<td>8163</td>\n<td>/share_file/kahadb</td>\n<td>Node-A</td>\n<td>生产者、消费者</td>\n</tr>\n</tbody>\n</table>\n<p>上边因为Node-A配置的是Broker集群，所以Node-A不需要配置存储，Node-B和Node-C配置的是Master/Slave集群，所以需要配置存储。</p>\n<p>Node-A只能做消费者（Broker Cluster集群），如果作为生产者的话，因为网络连接是双向连接，Node-A的消息能够被Node-B和Node-C消费掉，如果单Node-A上边有消息，但是还么有被消费的时候，如果Node-A节点挂掉，Node-B和Node-C就收不到消息。</p>\n<p><strong>配置准备：</strong></p>\n<pre><code class=\"lang-shell\">#1.创建active_cluster目录，复制activemq安装包到里边，并解压3分作为节点A/B/C\n$mkdir activemq_cluster\n$cp apache-activemq-5.15.3-bin.tar.gz activemq_cluster\n$tar -zxvf apache-activemq-5.15.3-bin.tar.gz\n$cp apache-activemq-5.15.3 apache-activemq-nodeA\n$cp apache-activemq-5.15.3 apache-activemq-nodeB\n$cp apache-activemq-5.15.3 apache-activemq-nodeC\n\n#2.创建一个共享文件夹用于nodeB和nodeC的共享储存文件夹\n$ mkdir kahadb\n</code></pre>\n<p><strong>节点A配置:</strong></p>\n<p>修改apache-activemq-nodeA/conf/activemq.xml，注释掉不需要使用的协议，服务端口为61618，新增网络连接配置，由于这里是已知的3台服务器，所以这里使用静态配置网络连接，连接到B和C两台服务器。</p>\n<pre><code class=\"lang-xml\">        &lt;transportConnectors&gt;\n            &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;\n            &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;!--\n\n                注释不需要的协议\n\n            &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n\n               --&gt;\n        &lt;/transportConnectors&gt;\n\n        &lt;!-- 新增网络连接配置项，名字自定义，uri使用静态配置，连接到B和C两台服务器 --&gt;\n        &lt;networkConnectors&gt;\n            &lt;networkConnector name=&quot;local_network&quot; uri=&quot;static:(tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)&quot;/&gt;\n        &lt;/networkConnectors&gt;\n</code></pre>\n<p>查看后端管理端口是否需要修改apache-activemq-nodeA/conf/jetty.xml,由于已经是8161，不需要修改</p>\n<pre><code class=\"lang-xml\">    &lt;bean id=&quot;jettyPort&quot; class=&quot;org.apache.activemq.web.WebConsolePort&quot; init-method=&quot;start&quot;&gt;\n             &lt;!-- the default port number for the web console --&gt;\n        &lt;property name=&quot;host&quot; value=&quot;0.0.0.0&quot;/&gt;\n        &lt;property name=&quot;port&quot; value=&quot;8161&quot;/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p><strong>节点B配置：</strong></p>\n<p>修改apache-activemq-nodeB/conf/activemq.xml，注释掉不需要使用的协议，配置服务端口为61617，新增网络连接配置，使用静态配置网络连接，连接到A服务器。并配置B与C的持久化共享文件目录</p>\n<pre><code class=\"lang-xml\">   &lt;!--配置B与C的共享文件夹 --&gt;\n    &lt;persistenceAdapter&gt;\n            &lt;!--&lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt; --&gt;\n            &lt;kahaDB directory=&quot;/Users/caojx/Downloads/activemq_cluster/kahadb&quot;/&gt;\n    &lt;/persistenceAdapter&gt;\n\n    &lt;transportConnectors&gt;\n            &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;\n            &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;!-- 注释不需要的协议 \n            &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            --&gt;\n        &lt;/transportConnectors&gt;\n\n        &lt;!-- 新增网络连接配置项，名字自定义，uri使用静态配置，连接到A服务器 --&gt;\n        &lt;networkConnectors&gt;\n            &lt;networkConnector name=&quot;network_a&quot; uri=&quot;static:(tcp://127.0.0.1:61616)&quot;/&gt;\n        &lt;/networkConnectors&gt;\n</code></pre>\n<p>修改apache-activemq-nodeB/conf/jetty.xml中的管理端口8162</p>\n<pre><code class=\"lang-xml\">    &lt;bean id=&quot;jettyPort&quot; class=&quot;org.apache.activemq.web.WebConsolePort&quot; init-method=&quot;start&quot;&gt;\n             &lt;!-- the default port number for the web console --&gt;\n        &lt;property name=&quot;host&quot; value=&quot;0.0.0.0&quot;/&gt;\n        &lt;property name=&quot;port&quot; value=&quot;8162&quot;/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p><strong>配置C节点：</strong></p>\n<p>修改apache-activemq-nodeC/conf/activemq.xml，注释掉不需要使用的协议，配置服务端口为61618，新增网络连接配置，使用静态配置网络连接，连接到A服务器。并配置B与C的持久化共享文件目录</p>\n<pre><code class=\"lang-xml\">   &lt;!--配置B与C的共享文件夹 --&gt;\n    &lt;persistenceAdapter&gt;\n            &lt;!--&lt;kahaDB directory=&quot;${activemq.data}/kahadb&quot;/&gt; --&gt;\n            &lt;kahaDB directory=&quot;/Users/caojx/Downloads/activemq_cluster/kahadb&quot;/&gt;\n    &lt;/persistenceAdapter&gt;\n\n    &lt;transportConnectors&gt;\n            &lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;\n            &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61618?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;!-- 注释不需要的协议 \n            &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5672?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;\n            --&gt;\n        &lt;/transportConnectors&gt;\n\n        &lt;!-- 新增网络连接配置项，名字自定义，uri使用静态配置，连接到A服务器 --&gt;\n        &lt;networkConnectors&gt;\n            &lt;networkConnector name=&quot;network_a&quot; uri=&quot;static:(tcp://127.0.0.1:61616)&quot;/&gt;\n        &lt;/networkConnectors&gt;\n</code></pre>\n<p>修改apache-activemq-nodeC/conf/jetty.xml中的管理端口8163</p>\n<pre><code class=\"lang-xml\">    &lt;bean id=&quot;jettyPort&quot; class=&quot;org.apache.activemq.web.WebConsolePort&quot; init-method=&quot;start&quot;&gt;\n             &lt;!-- the default port number for the web console --&gt;\n        &lt;property name=&quot;host&quot; value=&quot;0.0.0.0&quot;/&gt;\n        &lt;property name=&quot;port&quot; value=&quot;8163&quot;/&gt;\n    &lt;/bean&gt;\n</code></pre>\n<p><strong>启动3台ActiveMQ:</strong></p>\n<pre><code class=\"lang-shell\">$./apache-activemq-nodeA/bin/activemq start\n$./apache-activemq-nodeB/bin/activemq start\n$./apache-activemq-nodeC/bin/activemq start\n</code></pre>\n<p>启动之后，可以在浏览器中访问节点A<a href=\"http://127.0.0.1:8161\">http://127.0.0.1:8161</a> 和节点B<a href=\"http://127.0.0.1:8162\">http://127.0.0.1:8162</a> 而节点C由于在B的后边启动所以作为节点B的Slave暂时不能访问，当B节点挂调后C节点会获得资源成为新的Master，就可以方位节点C<a href=\"http://127.0.0.1:8163。\">http://127.0.0.1:8163。</a></p>\n<h4 id=\"h4-3-\"><a name=\"3. 编码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 编码</h4><p>生产者</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.queue;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:41\n * jms队列模式-消息生产者\n */\npublic class AppProducer {\n\n    //配置多个节点，failover失效转移，当61617节点失效之后，会将请求转向61618节点，randomize表示从节点列表中随机选择一台\n    public static final String url=&quot;failover:(tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)?randomize=true&quot;;\n    public static final String queueName=&quot;queue-test&quot;; //队列名称\n\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 队列\n        Destination destination = session.createQueue(queueName);\n\n        //6.创建一个生产者,并指定目标\n        MessageProducer producer = session.createProducer(destination);\n\n        for (int i = 1; i &lt;= 100; i++) {\n            //7.创建消息\n            TextMessage textMessage = session.createTextMessage(&quot;test&quot;+i);\n            //8.发送消息\n            producer.send(textMessage);\n            System.out.println(&quot;发送消息&quot;+textMessage.getText());\n        }\n        //9.关闭连接\n        connection.close();\n    }\n}\n</code></pre>\n<p>消费者</p>\n<pre><code class=\"lang-java\">package caojx.learn.jms.queue;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author caojx\n * Created on 2018/3/13 下午下午12:56\n * jms队列模式-消息消费者\n */\npublic class AppConsumer {\n\n    //配置多个节点，failover失效转移，当61616节点失效之后，会将请求转向61617节点或，61618节点 randomize表示从节点列表中随机选择一台\n    public static final String url=&quot;failover:(tcp://127.0.0.1:61616,tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)?randomize=true&quot;;\n\n    public static final String queueName=&quot;queue-test&quot;; //队列名称\n\n    public static void main(String[] args) throws JMSException {\n\n        //1.创建ConnectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n\n        //2.创建Connection\n        Connection connection = connectionFactory.createConnection();\n\n        //3.启动连接\n        connection.start();\n\n        //4.创建会话，第一个参数表示是否在事务中处理，由于是演示代码所以不使用事务false，第二个参数是连接应答模式，Session.AUTO_ACKNOWLEDGE表示自动应答\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        //5.创建一个目标 队列\n        Destination destination = session.createQueue(queueName);\n\n        //6.创建一个消费者,并指定目标\n        MessageConsumer consumer = session.createConsumer(destination);\n\n       //7.创建一个监听器,接收消息\n        consumer.setMessageListener(new MessageListener() {\n            public void onMessage(Message message) {\n                TextMessage textMessage = (TextMessage) message;\n                try {\n                    System.out.println(&quot;接收消息：&quot;+textMessage.getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        //注意，由于消息接收是异步的，所以不能关闭connection\n        //connection.close();\n    }\n}\n</code></pre>\n<h4 id=\"h4-4-\"><a name=\"4. 测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 测试</h4><p>测试的时候我们可以停止任何一台节点nodeA/nodeB/nodeC服务器，然后测试结果是停止任何一台服务器服务依然正常，即使停掉2台剩下一台服务也依然正常。</p>\n<h2 id=\"h2--\"><a name=\"六、企业级系统中的最佳实践\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、企业级系统中的最佳实践</h2><p>本节主要了解企业级系统中的现状，分析存在的问题，然后提出解决方案</p>\n<p><strong>实际业务场景分析：</strong></p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625105755_activemq_qy_1.png\" alt=\"\"></p>\n<p>如上图所示某个企业总存在3个子系统登录系统，积分系统和日志系统，其中每个子系统都进行了集群，用户登录操作后要保证将登录事件通知到积分系统和业务系统，并且积分系统和日志系统不能重复收到这个消息，登录成功后要将登录事件发送到积分系统和日志系统。</p>\n<p><strong>实际业务场景特点：</strong></p>\n<ul>\n<li>子业务系统都有集群的可能性</li><li>同一个消息会广播给关注改消息的所有子系统</li><li>同一类消息在集群中被负载消费</li><li>业务的发生和消费的发布最终一致性</li></ul>\n<p><strong>需要解决的问题：</strong></p>\n<ul>\n<li>不同业务系统分别处理同一个消息，同一业务系统负载处理同类消息</li><li>解决消息发送时的一致性问题</li><li>解决消息处理时的幂等性问题</li><li>基于消息机制简历事件总线</li></ul>\n<p><strong>集群系统处理消息方案</strong></p>\n<p>使用JMS级联的解决方案1：</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625105734_activemq_qy_2.png\" alt=\"\"></p>\n<p>JMS存在两种消息模式，发布/订阅和消息队列模式，我们需要将两种模式结合起来应用。如上图发布者将消息发送到JMS主题，然后两个中转器接收主题中的消息，然后再将消息发送到JMS队列中，最后集群系统负载消费。</p>\n<p>这个方案主要存在几个问题，主要是中转器的使用增加了开发的复杂性，因为每增加一个业务系统集群都需要增加一个中转器，并且需要保证中转器的高可用，如果中转器出现故障消息将在主题中堆积，如下是解决这类问题的犯案。</p>\n<p>使用ActiveMQ的虚拟主题解决方案2:</p>\n<ul>\n<li>发布者：将消息发布到一个主题中，主题明为VirtualTopic开头，如VirtualTopic.Test</li><li>消费者：从队列中获取消息，在队列名中表明自己的身份，如Comsumer.A.VirtualTopic.Test</li></ul>\n<p><strong>解决消息发送时的一致性为题：</strong></p>\n<p>使用JMS中的XA系列的接口保证强一致性：</p>\n<ul>\n<li>引入分布式事务</li><li>要求业务操作必须支持XA协议</li></ul>\n<p>使用消息的本地事务解决方案1：</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625105714_activemq_qy_3.png\" alt=\"\"></p>\n<p>使用内存日志的解决方案2：</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625105655_activemq_qy_4.png\" alt=\"\"></p>\n<p><strong>解决消息处理时的幂等性问题：</strong></p>\n<p>使用本地消息表的本地事务解决方案1：</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625105631_activemq_qy_5.png\" alt=\"\"></p>\n<p>1消费者从消息中间件获取消息，2消费者查询日志消息是否已经处理过，3如果没有处理消费者开始使用本地事务处理业务，和更新消息状态，4最后向消息中间件确认消息。</p>\n<p>使用内存日志的解决方案2：</p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625105612_activemq_qy_6.png\" alt=\"\"></p>\n<p>1消费者从消息中间件获取消息，2消费者去查询本地内存日志是否已经处理过，3如果说当前消息没有被处理，那么进行业务处理，4业务处理成功之后更新本地内存日志。5最后再确认消息。</p>\n<p><strong>基于消息机制简历事件总线:</strong></p>\n<p>使用了最终一致性后系统变得很复杂，不管是发送方还是接收方都需要做更多的事情，为了简化开发我们需要将一些代码进行复用，将有规律性的代码放到一起。</p>\n<p>我们之前的消息发送接收就像是一个事件，发送者就是事件的发起者，消费者就是时间的影响者，这样的架构方式也称为事件驱动。</p>\n<p>什么是事件驱动架构？</p>\n<p>事件驱动架构（Event Driven Architecture, EDA）定义了一个设计和实现一个应用系统的方法学，在这个系统里事件可传输于松散耦合的组件服务之间。</p>\n<p>特点：有事我找你，没事别烦我，就是不要是不是来问我有关于你关注的消息，有消息的时候我会通知你</p>\n<p>案例：</p>\n<p><a href=\"https://github.com/jovezhao/nest\">https://github.com/jovezhao/nest</a></p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625103420_activemq_qy_7.png\" alt=\"\"></p>\n<p>首先我们假如我们有3个业务系统，使用事件总线来简化业务事件之间的发布接收，业务系统B/C通过事件总线提供的方法进行事件注册，业务发起系统通过事件总线提供的方法进行发起事件。这样事件总线就实现了事件的发送和接收以及内存日志的处理。但是事件总线还不具备消息中间件的功能，所以事件总线还需要定义一个抽象的消息提供者，然后我们可以根据不同的消息中间件提供消息提供者，比如ActiveMQ/RabbitMQ/Kafka消息提供者。</p>\n<p>该事件总线编码可以参考：<a href=\"https://github.com/jovezhao/nest\">https://github.com/jovezhao/nest</a></p>\n<h2 id=\"h2--\"><a name=\"七、使用其他消息中间件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、使用其他消息中间件</h2><p>这里只是对消息进行简单的原理，源码见：<a href=\"https://github.com/jovezhao/nest\">https://github.com/jovezhao/nest</a></p>\n<p>之前的消息中间件中我们使用的都是ActiveMQ,ActiveMQ最大的优点就是JMS，jms使得Java消息中间件的开发变得简单，但是ActiveMQ各方面都表现的比较中庸，存在很多自己的缺点，比如吞吐量没有kafka强，稳定性没有RabbitMQ强。在企业开发中往往也不只是基于ActiveMQ的开发，还有其他许多优秀的消息中间件。下边简单介绍一下其他消息中间件的使用方法。</p>\n<p><strong>企业开发需要解决的问题：</strong></p>\n<p>在前面的企业开发过程中我们了解了企业开发中需要解决的问题：</p>\n<ul>\n<li>不同业务系统分别处理同一个消息，同一业务系统负载处理同类消息</li><li>解决消息发送时的一致性问题</li><li>解决消息处理时的幂等性问题</li><li>基于消息机制简历事件总线</li></ul>\n<p>我们使用其他消息中间件时只需要解决</p>\n<ul>\n<li>解决个业务系统集群处理同一条消息</li><li>实现自己的消息提供者</li></ul>\n<p>常用的消息中间件</p>\n<ul>\n<li>ActiveMQ</li><li>RabbitMQ</li><li>Kafka</li></ul>\n<h3 id=\"h3-7-1-rabbitmq\"><a name=\"7.1 集成RabbitMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.1 集成RabbitMQ</h3><p><strong>RabbitMQ:使用交换器绑定到队列</strong></p>\n<p><img src=\"https://ailuoli.cn/image/get_image?fileName=20190625103345_rabbitmq_1.png\" alt=\"\"></p>\n<p>在RabbitMQ中消费者首先需要将队列与交换器绑定，生产者不是直接将消息发送到队列而是发送到交换器。</p>\n<p><strong>RabbitMQ消息提供者源码解析</strong></p>\n<ul>\n<li>创建ConnectionFactory</li><li>创建Connection</li><li>创建Channel通道</li><li>基于通道创建一个交换器Exchange</li><li>定义Queue队列并将队列绑定到交换器</li></ul>\n<h3 id=\"h3-7-2-kafka\"><a name=\"7.2 集成Kafka\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.2 集成Kafka</h3><p><strong>Kafka使用group.id分组消费者</strong></p>\n<ul>\n<li>配置消息者参数group.id相同时对消息进行负载处理</li><li>配置服务器partitions参数，控制同一个group.id下的consumer数量小于partitions</li><li>kafka只保证同一个partition下的消息是有序的</li></ul>\n<p><strong>Kafka消息提供者源码分析：</strong></p>\n<ul>\n<li>创建生产者</li><li>创建消费者</li></ul>\n<h2 id=\"h2-u53C2u8003u4E0Eu63A8u8350u6587u7AE0\"><a name=\"参考与推荐文章\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参考与推荐文章</h2><p><a href=\"http://blog.csdn.net/wilsonke/article/details/42804245\">理解JMS规范中消息的传输模式和消息持久化</a></p>\n<p><a href=\"http://blog.csdn.net/aitangyong/article/details/26013387\">理解JMS规范中的持久订阅和非持久订阅</a></p>\n<p><a href=\"http://blog.csdn.net/suifeng3051/article/details/51718675\">Spring整合JMS(消息中间件)</a></p>\n<p><a href=\"http://blog.csdn.net/fulai0_0/article/details/52127320\">ActiveMQ订阅模式持久化实现</a></p>\n<p><a href=\"https://www.cnblogs.com/wangjian1990/p/6689703.html\">https://www.cnblogs.com/wangjian1990/p/6689703.html</a></p>\n', 1, '2019-06-25 11:09:50', 3, 0, 'ActiveMQ', 0, 0);
INSERT INTO `blog_article` VALUES (29, 'Spring Cloud Ribbon 负载均衡策略解析', '[TOC]\n\n\n#负载均衡策略\n\n\n##`AabStractLoadBalancerRule`\n负载均衡策略的抽象类，在该抽象类中定义了负载均衡器`ILoadBalancer`对象，该对象能够在具体实现选择服务策略时，获取到一些负载均衡器中维护的信息来作为分配依据，并以此设计一些算法来实现针对特定场景的高效策略。\n```java\npublic abstract class AbstractLoadBalancerRule implements IRule,IClientConfigAware{\n\n    private ILoadBalancer lb;\n\n    @Override\n    public void setLoadBalancer(ILoadBalancer lb){\n        this.lb = lb;\n    }\n\n    @Override\n    public ILoadBalancer getLoadBalancer(){\n        return lb;\n    }\n}\n```\n\n\n##`RandomRule`\n该策略实现了从服务实例清单中随机选择一个服务实例的功能。它的具体实现如下,可以看到`IRule`接口的`choose(Object key)`函数实现，委托给了该类中的`choose(ILoadBalancer lb,Object key)`，该方法增加了一个负载均衡器对象的参数。从具体的实现上看，它会使用传入的负载均衡器来获得可用实例列表`upList`和所有实例列表`allList`，并通过`rand.nextInt(ServerCount)`函数来获取一个随机数，并将该随机数作为upList的索引值来返回具体实例。同时，具体的选择逻辑在一个`while(server==null)`循环之内，而根据选择逻辑的实现，正常情况下每次选择都应该选出一个服务实例，如果出现死循环获取不到服务实例时，则很可能存在并发的Bug。\n```java\n\n@Override\npublic Server choose(Object key){\n    return choose(getLoadBalancer(),key);\n}\n\n\npublic Server choose(ILoadBalancer lb,Object key){\n    ...\n\n    Server server = null;\n\n    while(server == null){\n\n        if(Thread.interrupted()){\n            return null;\n        }\n\n        List<Server> upList = lb.getReachableServers();\n\n        List<Server> allList = lb.getAllServers();\n\n        int serverCount = allList.size();\n\n        if(serverCount == 0){\n            return null;\n        }\n\n        int index = rand.nextInt(serverCount);\n        server = upList.get(index);\n        if(server == null){\n            Thread.yield();\n            continue;\n        }\n        if(server.isAlive()){\n            return (server);\n        }\n        server == null;\n        Thread.yield();\n    }\n\n    return server;\n\n}\n\n```\n\n\n##`RoundRobinRule`\n该策略实现了按照线性轮询的方式以此选择每一个服务实例的功能。它的具体实现如下，其详细结构与`RandomRule`非常类似。除了循环条件不同外，就是从可用列表中获取所谓的逻辑不同。从循环条件中，我们可以看到增加了一个count计数变量，该变量会在每次循环之后累加，也就是说，如果一直选择不到server超过10次，那么就会结束尝试，并打印一个警告信息`No available alive servers after 10 tries from load balancer:...。`而线性轮询的实现则时通过`AtomicInteger nextServerCyclicCounter`对象实现，每次进行实例选择时通过调用`incrementAndGetModulo`函数实现递增。\n```java\npublic Server choose(ILoadBalancer lb,Object key){\n\n    ...\n    Server server = null;\n\n    int count = 0;\n    while(server == null && count ++ <10){\n        List<Server> reachableServers = lb.getReachableServers();\n        List<Server> allServers = lb.getAllServers();\n        int upCount = reachableServers.size();\n        int serverCount = allServers.size();\n        if((upCount == 0)|| (serverCount == 0)){\n\n            log.warn(\"No up servers available from load balancer: \"+lb);\n            return null;\n        }\n\n        int nextServerIndex = incrementAndGetModulo(serverCount);\n        server = allServers.get(nextServerIndex);\n        if(server == null){\n            Thread.yield();\n            continue;\n        }\n        if(server.isAlive() && (server.isReadyToServe())){\n            return (server);\n        }\n        server = null;\n\n    }\n\n    if(count >= 10){\n        log.warn(\"No available alive servers after 10 tries from load balancer: \"+lb);\n    }\n\n    return server;\n\n}\n```\n\n##`RetryRule`\n该策略实现了一个具备重试机制的实例选择功能。从下面的实现中我们可以看到，在其内部还定义了一个`IRule`对象，默认使用了`RoundRobinRule`实例。而在`choose`方法中则实现了对内部定义的策略进行反复尝试的策略，若期间能够选择到具体的服务实例就返回，若选择不到就根据设置的尝试结束时间为阈值(`maxRetryMillis`参数定义的值+`choose`方法开始执行的时间戳)，当超过阈值后就返回null。\n```java\n\npublic class RetryRule extends AbstractLoadBalancerRule{\n\n    IRule subRule = new RoundRobinRule();\n\n    Long maxRetryMillis = 500;\n    ...\n\n    public server choose(ILoadBalancer lb ,Object key){\n\n        Long requestTime = System.currentTimeMillis();\n\n        Long deadline = requestTime = maxRetryMillis;\n\n        Server answer = null;\n\n        answer = subRule.choose(key);\n\n        if(((answer == null) || (!answer.isAlive())) && (System.currentTimeMillis() < deadline)){\n\n            InterruptTask task = new InterruptTask(deadline - System.currentTimeMillis());\n            while(!Thread.interrupted()){\n                answer = subRule.choose(key);\n                if(((answer == null) || (!answer.isAlive())) && (System.currentTimeMillis() < deadline)){\n                    Thread.yield();\n                }else{\n                    break;\n                }\n            }\n\n            task.cancel();\n        } \n        \n        if((answer == null || (!answer.isAlive()))){\n            return null;\n        }else{\n            return answer;\n        }\n    }\n    ...\n}\n\n```\n\n##`WeightResponseTimeRule`\n该策略是对`RoundRobinRule`的扩展，增加了根据实例的运行情况来计算权重，并根据权重来挑选实例，以达到更优的分配效果，他的实现主要有三个核心内容。\n###定时任务\n`WeightedResponseTimeRule`策略在初始化的时候会通过`serverWeightTimer.schedule(new DynamicServerWeightTask(),0,serverWeightTaskTimerInterval)`启动一个定时任务，用来为每个服务实例计算权重，任务默认是30秒执行一次。\n```java\nclass DynamicServerWeightTask extends TimerTaks{\n    \n    public void run(){\n\n        ServerWeight serverWeight = new ServerWeight();\n\n        try{\n            serverWeight.maintainWeights();\n        }catch(Throwable t){\n            logger.error(\"Throwable caught while running DynamicServerWeightTask for\"+name,t);\n        }\n\n    }\n}\n```\n###权重计算\n在源码中我们可以轻松找到用于存储权重的对象`List<Double> accumulatedWeights = new ArrayList<>()`,在`List`中每个权重值所处的位置对应了负载均衡器维护的服务实例清单中所有实例在清单中的位置。\n维护实例权重的计算过程通过maintainWeights函数实现，具体如下面的代码所示：\n```java\npublic void maintainWeights(){\n\n    ILoadBalancer lb = getLoadBalancer();\n\n    ...\n\n    try{\n        logger.infor(\"Weight adjusting job started\");\n        AbstractLoadBalancer nlb = (AbstractLoadBalancer) lb;\n        LoadBalancerStarts stats = nlb.getLoadBalancerStats();\n        ...\n        //计算所有实例的平均响应时间的总和\n        double totalReponseTime = 0;\n        for(Server server : nlb.getAllServers()){\n\n            //如果服务实例的状态快照不在缓存中，那么这里会进行自动加载\n            ServerStats ss = stats.getSingleServerStat(server);\n            totalResponseTime += ss.getResponseTimeAvg();\n        }\n        //逐个计算每个实例的权重：weightSoFar + totalResponseTime - 实例的平均响应时间\n        Double weightSoFar = 0.0;\n        List<Double> finalWeights = new ArrayList<>();\n        for(Server server : nlb.getAllServers()){\n\n            ServerStats ss = stats.getSinleServerStat(server);\n            double weight = totalResponseTime - ss.getResponseTimeAvg();\n            weightSoFa += weight;\n            finalWeights.add(weightSoFar);\n        }\n        setWeights(finalWeights);\n    }catch(Throwable t){\n        logger.error(\"Exception while dynamically calcuting server weight\",t);\n    }finnaly{\n        serverWeightAssignmentInProgress.set(false);\n    }\n}\n```\n该函数的实现主要分为两个步骤：\n- 根据`LoadBalancerStats` 中记录的每个实例的统计信息，累计所有实例的平均响应时间，得到总平均响应时间`totalResponseTime`，该值会用于后续的计算。\n- 为负载均衡器中维护的实例清单逐个计算权重（从第一个开始），计算规则为`weightSoFar`+`totalResponseTime`-实例的平均响应时间，其中`weightSoFar`初始化为零，并且每计算好一个权重需要累加到weightSoFar上供下一次计算使用。\n\n举个例子来理解这个计算过程，假设有4个实例A,B,C,D,它们的平均响应时间为10，40，80，100，所以总响应时间是10+40+80+100=230，每个实例的权重为总响应时间与实例自身的平均响应时间的差的累计所得，所以实例A，B，C，D的权重分别如下所示。\n- 实例  A: 230 - 10 = 220\n- 实例  B: 220 + (230-40) = 410\n- 实例  C: 410 + (230-80) = 560\n- 实例  D: 560 + (230-100) = 690\n\n需要注意的是，这里的权重值只是表示各个实例权重区间的上限，并非某个实例的优先级，所以不是数值越大被选中的概率就越大。那么什么是权重区间呢？以上面例子的计算结果为例，它实际上是为这4个实例构建了4个不同的区间，每个实例的区间下限是上一个实例的区间上限，而每个实例的区间上限则是我们上面计算并存储与List`accumulatedWeights`中的权重值，其中第一个实例的下限默认为零。所以，根据上面的示例的权重计算结果，我们可以得到每个实例的权重区间。\n- 实例 A：[0，220]\n- 实例 B：(220，410]\n- 实例 C: (410，560]\n- 实例 D: (560，690)\n\n实际上每个区间的宽度就是：总平均响应时间 - 实例的平均响应时间，所以实例的平均响应时间越短，权重区间的宽度越大，而权重区间的宽度越大被选中的概率就越高。\n###实例选择\n`WeightedResponseTimeRule`选择实例的实现与之前介绍的算法结构类似，下面是它的主体算法。\n\n```java\npublic Server choose(ILoadBalancer lb,Object key){\n    ...\n    List<Double> allList = lb.getAllServers();\n    int serverCount = allList.size();\n    if(serverCount == 0){\n        return null;\n    }\n    int serverIndex = 0;\n    //获取最后一个实例的权重\n    double maxTotalWeight = currentWeights.size() == 0 ? 0 : currentWeights.get(currentWeights.size() - 1);\n    if(maxTotalWeight < 0.001d){\n        //如果最后一个实例的权重小于0.001，则采用父类实现的线性轮询的策略\n        server = super.choose(getLoadBalancer(),key);\n        if(server == null){\n            return server;\n        }\n    }else{\n        //如果最后一个实例的权重值大于等于0.001，就产生一个[0,maxTotalWeight)的随机数\n        double randomWeight = random.nextDouble() * maxTotalWeight;\n        int n = 0;\n        for(Double d : currentWeights){\n            //便利维护的权重清单，若权重大于等于随机得到的值，就选择这个实例\n            if(d >= randomWeight){\n                serverIndex = n;\n                break;\n            }else{\n                n ++;\n            }\n        }\n        server = allList.get(serverIndex);\n    }\n    ...\n    return server;\n}\n\n```\n从源码中可以看出来，选择实例的核心过程就两步：\n\n- 生成一个[0,最大权重值)区间内的随机数。\n- 遍历权重列表，比较权重值与随机数的大小，如果权重值大于等于随机数，就拿当前权重列表的索引值去服务实例列表中获取具体实例。\n\n##`ClientConfigEnableRoundRobinRule`\n该策略较为特殊，一般不会直接使用它。因为它本身并没有什么特殊的处理逻辑，正如下面的源码所示，在它的内部定义了一个`RoundRobinRule`策略，而`choose`函数的实现也正是使用了RoundRobinRule的线性轮询机制，所以它实现的功能实际上与`RoundRobinRule`相同，那么定义它有什么特殊的用处呢？\n虽然我们不会直接使用策略，但是通过继承该策略，默认的choose就实现了线性轮询机制，在子类中做一些高级策略时通常有可能会存在一些无法试试的情况，那么就可以用父类的实现作为备选。在后面将介绍的高级策略均时基于ClientConfigEnabledRoundRobinRule的扩展。\n```java\npublic class ClientConfigEnabledRoundRobinRule extends AbstractLoadBalancerRule{\n\n    RoundRobinRule roundRobinRule = new RoundRobinRule();\n    ...\n\n    public Server choose(Object key){\n        if(roundRobinRule != null){\n            return roundRobinRule.choose(key);\n        }else{\n            throw new IllegalArgmentException(\"\")\n        }\n    }\n\n}\n```\n##`BestAvailableRule`\n该策略继承自`ClientConfigEnabledRoundRobinRule`,在实现中它注入了负载均衡器的统计对象 `LoadBalancerStats`，保存的实例统计信息来选择满足要求的实例。从如下源码中我们可以看到，它通过遍历负载均衡器中维护所有服务实例，会过滤掉故障的实例，并找出并发请求数最小的一个，所以该策略的特性是可选出最空闲的实例。\n```java\npublic Server choose(Object key){\n\n    if(loadBalancerStats == null){\n        return super.choose(key);\n    }\n    List<Server> serverList = getLoadBalancer().getAllServers();\n    int minimalConcurrentConnections = Integer.MAX_VALUE;\n    long currentTime = System.currentTimeMillis();\n    Server chosen = null;\n    for (Server server : serverList){\n\n        ServerStats serverStats = loadBalancerStats.getSingleServerStat(server);\n        if(!serverStats.isCiruitBreadkerTripped(currentTime)){\n            int concurrentConnections = serverStats.getActiveRequestCount(currentTime);\n            if(concurrentConnections < minimalConcurrentConnections){\n                minimalConcurrentConnections = concurrentConnections;\n                chosen = server;\n            }\n        }\n    }\n    if(chosen == null){\n        return super.choose(key);\n    }else{\n        return chosen;\n    }\n\n}\n```\n同时，由于该算法的核心依据是统计对象`loadBalancerStats`,当其为空的时候，该策略是无法执行的。所以从源码中我们可以看到，当`loadBalancerStats`为空的时候，它会采用父类的线性轮询策略，正如我们在介绍`ClientConfigEnabledRoundRobinRule`时那样，它的子类在无法满足实现高级策略的时候，可以使用线性轮询策略的特性。\n\n##`PredicateBasedRule`\n这是一个抽象策略，它也继承了`ClientConfigEnabledRoundRobinRule`，从其命名中可以猜出这是一个基于`Predicate`实现的策略，`Predicate`是`Google Guava Collection` 工具对集合进行过滤的条件接口。\n如下面的源码所示，它定义了一个抽象函数`getPredicate`来获取`AbstractServerPredicate`对象的实现，而在`choose`函数中，通过`AbstractServerPredicate`的`chooseRoundRobinAfterFiltering`函数来选出具体的服务实例。从该函数的命名我们也大致能猜出它的基础逻辑：先通过子类中实现的Predicate逻辑来过滤一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个。\n```java\npublic abstract class PredicateBassRule extends ClientConfigEnabledRoundRobinRule{\n\n    public abstract AbstractServerPredicate getPredicate();\n\n    @Override\n    public Server choose(Object key){\n\n        ILoadBalancer lb = getLoadBalancer();\n        Optional<Server> server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(),key);\n        if(server.isPresent){\n            return server.get();\n        }else{\n            return null;\n        }\n    }\n}\n```\n通过下面的`AbstractSererPredicate`的源码片段，可以证实我们上面所做的猜测。在上面`choose`函数中调用`chooseRoundRobinAfterFiltering`方法先通过内部定义的`getEligibleServers` 函数来获取备选的实例清单（实现了过滤），如果返回的清单为空，则用`Optional.absent()`来表示不存在，反之则以线性轮询的方式从备选清单中获取一个实例。\n```java\npublic abstract class AbstractServerPredicate implements Predicate<PredicaateKey>{\n\n    ...\n\n    public Optional<Server> choosenRoundRobinAfterFiltering (List<Server> servers,Object loadBalancerKey){\n        List<Server> eligible = getEligibleServer(servers,loadBalancerKey);\n        if(eligible.size() == 0){\n            return Optional.absent();\n        }\n        return Optional.of(eligible.get(nextIndex.getAndIncrement() % eligible.size()));\n    }\n\n\n    public List<Server> getEligibleServers(List<Server> servers,Object loadBalancerKey){\n\n        if(loadBalancerKey == null){\n            return ImmutableList.copyOf(Iterables.filter(servers,this.getServerOnlyPredicaate()));\n        }else{\n            List<Server> results = Lists.newArrayList();\n            for(Server server: servers){\n                if(this.apply(new PredicateKey(loadBalancerKey,server))){\n                    results.add(server);\n                }\n            }\n            return results;\n        }\n\n    }\n\n}\n\n```\n##`AvaliabilityFilteringRule`\n该策略继承自上面介绍的抽象策略`PredicateBasedRule`，所以它也继承了“先过滤清单，再轮询选择”的基本处理逻辑，其中过滤条件使用了`AvailabilityPredicate`:\n```java\npublic class AvailabilityPredicate extends AbstractServerPredicate{\n\n    ...\n    public boolean apply(@Nullable PredicateKey input){\n\n        LoadBalancerStats stats = getLBStats();\n        if(stats = null){\n            return true;\n        }\n        return !shouldSkipServer(stats.getSingleServerStat(input.getServer()));\n    }\n\n    private boolean shouldSkipServer(ServerStats stats){\n\n        if((CIRCUIT_BREAKER_FILTERING.get() && stats.isCircuitBreakerTripped()) || stats.getActiveRequestsCount() >= activeConnectionsLimit.get()){\n            return true;\n        }\n        return false;\n    }\n\n}\n```\n从上述源码中，可以知道它的主要过滤逻辑位于`shouldSkipServer`方法中，它主要判断服务实例的两项内容：\n- 是否故障，即断路器是否生效已断开。\n- 实例的并发请求数量大于阈值，默认值为$2^{32}-1$,该配置可通过`<clientName>.<nameSpace>.ActiveConnectionLimit`来修改。\n\n这两项内容中只要有一个满足apply就返回false（代表该节点可能存在故障或负载过高），都不满足就返回true。\n在该策略中，除了实现了上面的过滤方法之外，对于choose的策略也做了一些改进优化，所以父类的实现对于它来说只是一个备用选项，其具体实现如下所示：\n```java\npublic Server choose(Object key){\n\n    int count = 0;\n    Server server = roundRobinRule.choose(key);\n    while(count++ <= 10){\n        if(predicate.apply(new PredicateKey(server))){\n            return server;\n        }\n        server = roundRobinRule.choose(key);\n    }\n    return super.choose(key);\n}\n```\n可以看到，它并没有像在父类中那样，先遍历所有的节点进行过滤，然后在过滤后的集合中选择实例。而是先以线性的方式选择一个实例，接着用过滤条件来判断该实例是否满足要求，若满足就直接使用该实例，若不满足要求就再选择下一个实例，并检查是否满足要求，如此循环进行，当这个过程重复10次还是没有找到符合要求的实例，就采用父类的实现方案。\n简单的说，该策略通过线性抽样的方式直接尝试寻找可用且较空闲的实例来使用，优化了父类每次都要遍历所有实例的开销。\n\n##`ZoneAvoidanceRule`\n该策略在介绍负载均衡器`ZoneAwareLoadBalancer` 时已经提到过，他也是`PredicateBasedRule`的具体实现类。在之前的介绍主要针对`ZoneAvoidanceRule`中用于选择Zone区域策略的一些静态函数，比如`createSnapshot、getAvailableZones`。在这里将仔细看看`ZoneAvoidanceRule`的源码片段中可以看到，它使用了`CompositePredicate`来进行服务实例清单的过滤。这是一个组合过滤条件，在其构造函数中，它以`ZoneAvoidancePredicate`为主过滤条件，`AvailbilityPredicate`为次过滤条件初始化了组合过滤条件的实例。\n```java\npublic class ZoneAvoidanceRule extends PredicateBasedRule{\n\n    ...\n    private CompositePredicate compositePredicate;\n\n    public ZoneAvoidanceRule(){\n\n        super();\n        ZoneAvoidancePredicate zonePredicate = new ZoneAvoidancePredicate(this);\n        AvailabilityPredicate availabilityPredicate = new AvailabilityPredicate(this);\n        compositePredicate = createCompositePredicate(zonePredicate,availabilityPredicate);\n    }\n    ...\n\n}\n```\n`ZoneAvoidanceRule` 在实现的时候并没有像`AvailabilityFilteringRule`那样重写`choose`函数来优化，所以它完全遵循了父类的过滤主逻辑：“先过滤清单，再轮询选择”。其中过滤清单的条件就是我们上面提到的以`ZoneAvoidancePredicate`为主过滤条件、`AvailabilityPredicate`为次过滤条件的组合过滤条件`CompositePredicate`。从`CompositePredicate`的源码片段中，我们可以看到它定义了一个主过滤条件`AbstractServerPredicate delegate`以及一组次过滤条件列表List `fallbacks`,所以它的次过滤列表是可以拥有多个的，并且由于它采用了List存储所以次过滤条件是按顺序执行的。\n```java\npublic class CompositePredicate extends AbstractServerPredicate{\n\n    private AbstractServerPredicate delegate;\n    private List<AbstractServerPredicate> fallbacks = Lists.newArrayList();\n\n\n    private int minimalFilteredServers = 1;\n    private float minimalFilteredPercentage = 0;\n\n    public List<Server> getEligibleServers(List<Server> servers,Object loadBalancerKey){\n\n        List<Server> result = super.getEligibleServers(servers,loadBalancerKey);\n        Iterator<AbstractServerPredicate> i = fallbacks.iterator();\n        while(!(result.size() >= minimalFilteredServers && result.size() > (int)(servers.size() * minimalFilteredPeecentage)) && i.hasNext()){\n            AbstractServerPredicate predicate = i.next();\n            result = predicate.getEligibleServers(servers,loadBalancerKey);\n        }\n\n        return result;\n    }\n}\n```\n在获取过滤结果的实现函数`getEligibleServers`中，它的处理逻辑如下所示。\n- 使用主过滤条件对所有实例过滤并返回过滤后的实例清单。\n- 依次使用次过滤条件列表中的过滤条件对主过滤条件的结果进行过滤。\n- 每次过滤之后（包括主过滤条件和次过滤条件），都需要判断下面两个条件，只要有一个符合就不再进行过滤，将当前结果返回供线性轮询算法选择：\n    - 过滤后的实例总数 >= 最小过滤实例数（`minimalFilteredServers`,默认为1）。\n    - 过滤后的实例比例 >= 最小过滤百分比（`minimalFilteredPercentage`，默认为0）。', '<div class=\"markdown-toc editormd-markdown-toc\">[TOC]</div><h1 id=\"h1-u8D1Fu8F7Du5747u8861u7B56u7565\"><a name=\"负载均衡策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>负载均衡策略</h1><h2 id=\"h2--code-aabstractloadbalancerrule-code-\"><a name=\"<code>AabStractLoadBalancerRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>AabStractLoadBalancerRule</code></h2><p>负载均衡策略的抽象类，在该抽象类中定义了负载均衡器<code>ILoadBalancer</code>对象，该对象能够在具体实现选择服务策略时，获取到一些负载均衡器中维护的信息来作为分配依据，并以此设计一些算法来实现针对特定场景的高效策略。</p>\n<pre><code class=\"lang-java\">public abstract class AbstractLoadBalancerRule implements IRule,IClientConfigAware{\n\n    private ILoadBalancer lb;\n\n    @Override\n    public void setLoadBalancer(ILoadBalancer lb){\n        this.lb = lb;\n    }\n\n    @Override\n    public ILoadBalancer getLoadBalancer(){\n        return lb;\n    }\n}\n</code></pre>\n<h2 id=\"h2--code-randomrule-code-\"><a name=\"<code>RandomRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>RandomRule</code></h2><p>该策略实现了从服务实例清单中随机选择一个服务实例的功能。它的具体实现如下,可以看到<code>IRule</code>接口的<code>choose(Object key)</code>函数实现，委托给了该类中的<code>choose(ILoadBalancer lb,Object key)</code>，该方法增加了一个负载均衡器对象的参数。从具体的实现上看，它会使用传入的负载均衡器来获得可用实例列表<code>upList</code>和所有实例列表<code>allList</code>，并通过<code>rand.nextInt(ServerCount)</code>函数来获取一个随机数，并将该随机数作为upList的索引值来返回具体实例。同时，具体的选择逻辑在一个<code>while(server==null)</code>循环之内，而根据选择逻辑的实现，正常情况下每次选择都应该选出一个服务实例，如果出现死循环获取不到服务实例时，则很可能存在并发的Bug。</p>\n<pre><code class=\"lang-java\">\n@Override\npublic Server choose(Object key){\n    return choose(getLoadBalancer(),key);\n}\n\n\npublic Server choose(ILoadBalancer lb,Object key){\n    ...\n\n    Server server = null;\n\n    while(server == null){\n\n        if(Thread.interrupted()){\n            return null;\n        }\n\n        List&lt;Server&gt; upList = lb.getReachableServers();\n\n        List&lt;Server&gt; allList = lb.getAllServers();\n\n        int serverCount = allList.size();\n\n        if(serverCount == 0){\n            return null;\n        }\n\n        int index = rand.nextInt(serverCount);\n        server = upList.get(index);\n        if(server == null){\n            Thread.yield();\n            continue;\n        }\n        if(server.isAlive()){\n            return (server);\n        }\n        server == null;\n        Thread.yield();\n    }\n\n    return server;\n\n}\n</code></pre>\n<h2 id=\"h2--code-roundrobinrule-code-\"><a name=\"<code>RoundRobinRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>RoundRobinRule</code></h2><p>该策略实现了按照线性轮询的方式以此选择每一个服务实例的功能。它的具体实现如下，其详细结构与<code>RandomRule</code>非常类似。除了循环条件不同外，就是从可用列表中获取所谓的逻辑不同。从循环条件中，我们可以看到增加了一个count计数变量，该变量会在每次循环之后累加，也就是说，如果一直选择不到server超过10次，那么就会结束尝试，并打印一个警告信息<code>No available alive servers after 10 tries from load balancer:...。</code>而线性轮询的实现则时通过<code>AtomicInteger nextServerCyclicCounter</code>对象实现，每次进行实例选择时通过调用<code>incrementAndGetModulo</code>函数实现递增。</p>\n<pre><code class=\"lang-java\">public Server choose(ILoadBalancer lb,Object key){\n\n    ...\n    Server server = null;\n\n    int count = 0;\n    while(server == null &amp;&amp; count ++ &lt;10){\n        List&lt;Server&gt; reachableServers = lb.getReachableServers();\n        List&lt;Server&gt; allServers = lb.getAllServers();\n        int upCount = reachableServers.size();\n        int serverCount = allServers.size();\n        if((upCount == 0)|| (serverCount == 0)){\n\n            log.warn(&quot;No up servers available from load balancer: &quot;+lb);\n            return null;\n        }\n\n        int nextServerIndex = incrementAndGetModulo(serverCount);\n        server = allServers.get(nextServerIndex);\n        if(server == null){\n            Thread.yield();\n            continue;\n        }\n        if(server.isAlive() &amp;&amp; (server.isReadyToServe())){\n            return (server);\n        }\n        server = null;\n\n    }\n\n    if(count &gt;= 10){\n        log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;+lb);\n    }\n\n    return server;\n\n}\n</code></pre>\n<h2 id=\"h2--code-retryrule-code-\"><a name=\"<code>RetryRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>RetryRule</code></h2><p>该策略实现了一个具备重试机制的实例选择功能。从下面的实现中我们可以看到，在其内部还定义了一个<code>IRule</code>对象，默认使用了<code>RoundRobinRule</code>实例。而在<code>choose</code>方法中则实现了对内部定义的策略进行反复尝试的策略，若期间能够选择到具体的服务实例就返回，若选择不到就根据设置的尝试结束时间为阈值(<code>maxRetryMillis</code>参数定义的值+<code>choose</code>方法开始执行的时间戳)，当超过阈值后就返回null。</p>\n<pre><code class=\"lang-java\">\npublic class RetryRule extends AbstractLoadBalancerRule{\n\n    IRule subRule = new RoundRobinRule();\n\n    Long maxRetryMillis = 500;\n    ...\n\n    public server choose(ILoadBalancer lb ,Object key){\n\n        Long requestTime = System.currentTimeMillis();\n\n        Long deadline = requestTime = maxRetryMillis;\n\n        Server answer = null;\n\n        answer = subRule.choose(key);\n\n        if(((answer == null) || (!answer.isAlive())) &amp;&amp; (System.currentTimeMillis() &lt; deadline)){\n\n            InterruptTask task = new InterruptTask(deadline - System.currentTimeMillis());\n            while(!Thread.interrupted()){\n                answer = subRule.choose(key);\n                if(((answer == null) || (!answer.isAlive())) &amp;&amp; (System.currentTimeMillis() &lt; deadline)){\n                    Thread.yield();\n                }else{\n                    break;\n                }\n            }\n\n            task.cancel();\n        } \n\n        if((answer == null || (!answer.isAlive()))){\n            return null;\n        }else{\n            return answer;\n        }\n    }\n    ...\n}\n</code></pre>\n<h2 id=\"h2--code-weightresponsetimerule-code-\"><a name=\"<code>WeightResponseTimeRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>WeightResponseTimeRule</code></h2><p>该策略是对<code>RoundRobinRule</code>的扩展，增加了根据实例的运行情况来计算权重，并根据权重来挑选实例，以达到更优的分配效果，他的实现主要有三个核心内容。</p>\n<h3 id=\"h3-u5B9Au65F6u4EFBu52A1\"><a name=\"定时任务\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>定时任务</h3><p><code>WeightedResponseTimeRule</code>策略在初始化的时候会通过<code>serverWeightTimer.schedule(new DynamicServerWeightTask(),0,serverWeightTaskTimerInterval)</code>启动一个定时任务，用来为每个服务实例计算权重，任务默认是30秒执行一次。</p>\n<pre><code class=\"lang-java\">class DynamicServerWeightTask extends TimerTaks{\n\n    public void run(){\n\n        ServerWeight serverWeight = new ServerWeight();\n\n        try{\n            serverWeight.maintainWeights();\n        }catch(Throwable t){\n            logger.error(&quot;Throwable caught while running DynamicServerWeightTask for&quot;+name,t);\n        }\n\n    }\n}\n</code></pre>\n<h3 id=\"h3-u6743u91CDu8BA1u7B97\"><a name=\"权重计算\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>权重计算</h3><p>在源码中我们可以轻松找到用于存储权重的对象<code>List&lt;Double&gt; accumulatedWeights = new ArrayList&lt;&gt;()</code>,在<code>List</code>中每个权重值所处的位置对应了负载均衡器维护的服务实例清单中所有实例在清单中的位置。<br>维护实例权重的计算过程通过maintainWeights函数实现，具体如下面的代码所示：</p>\n<pre><code class=\"lang-java\">public void maintainWeights(){\n\n    ILoadBalancer lb = getLoadBalancer();\n\n    ...\n\n    try{\n        logger.infor(&quot;Weight adjusting job started&quot;);\n        AbstractLoadBalancer nlb = (AbstractLoadBalancer) lb;\n        LoadBalancerStarts stats = nlb.getLoadBalancerStats();\n        ...\n        //计算所有实例的平均响应时间的总和\n        double totalReponseTime = 0;\n        for(Server server : nlb.getAllServers()){\n\n            //如果服务实例的状态快照不在缓存中，那么这里会进行自动加载\n            ServerStats ss = stats.getSingleServerStat(server);\n            totalResponseTime += ss.getResponseTimeAvg();\n        }\n        //逐个计算每个实例的权重：weightSoFar + totalResponseTime - 实例的平均响应时间\n        Double weightSoFar = 0.0;\n        List&lt;Double&gt; finalWeights = new ArrayList&lt;&gt;();\n        for(Server server : nlb.getAllServers()){\n\n            ServerStats ss = stats.getSinleServerStat(server);\n            double weight = totalResponseTime - ss.getResponseTimeAvg();\n            weightSoFa += weight;\n            finalWeights.add(weightSoFar);\n        }\n        setWeights(finalWeights);\n    }catch(Throwable t){\n        logger.error(&quot;Exception while dynamically calcuting server weight&quot;,t);\n    }finnaly{\n        serverWeightAssignmentInProgress.set(false);\n    }\n}\n</code></pre>\n<p>该函数的实现主要分为两个步骤：</p>\n<ul>\n<li>根据<code>LoadBalancerStats</code> 中记录的每个实例的统计信息，累计所有实例的平均响应时间，得到总平均响应时间<code>totalResponseTime</code>，该值会用于后续的计算。</li><li>为负载均衡器中维护的实例清单逐个计算权重（从第一个开始），计算规则为<code>weightSoFar</code>+<code>totalResponseTime</code>-实例的平均响应时间，其中<code>weightSoFar</code>初始化为零，并且每计算好一个权重需要累加到weightSoFar上供下一次计算使用。</li></ul>\n<p>举个例子来理解这个计算过程，假设有4个实例A,B,C,D,它们的平均响应时间为10，40，80，100，所以总响应时间是10+40+80+100=230，每个实例的权重为总响应时间与实例自身的平均响应时间的差的累计所得，所以实例A，B，C，D的权重分别如下所示。</p>\n<ul>\n<li>实例  A: 230 - 10 = 220</li><li>实例  B: 220 + (230-40) = 410</li><li>实例  C: 410 + (230-80) = 560</li><li>实例  D: 560 + (230-100) = 690</li></ul>\n<p>需要注意的是，这里的权重值只是表示各个实例权重区间的上限，并非某个实例的优先级，所以不是数值越大被选中的概率就越大。那么什么是权重区间呢？以上面例子的计算结果为例，它实际上是为这4个实例构建了4个不同的区间，每个实例的区间下限是上一个实例的区间上限，而每个实例的区间上限则是我们上面计算并存储与List<code>accumulatedWeights</code>中的权重值，其中第一个实例的下限默认为零。所以，根据上面的示例的权重计算结果，我们可以得到每个实例的权重区间。</p>\n<ul>\n<li>实例 A：[0，220]</li><li>实例 B：(220，410]</li><li>实例 C: (410，560]</li><li>实例 D: (560，690)</li></ul>\n<p>实际上每个区间的宽度就是：总平均响应时间 - 实例的平均响应时间，所以实例的平均响应时间越短，权重区间的宽度越大，而权重区间的宽度越大被选中的概率就越高。</p>\n<h3 id=\"h3-u5B9Eu4F8Bu9009u62E9\"><a name=\"实例选择\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实例选择</h3><p><code>WeightedResponseTimeRule</code>选择实例的实现与之前介绍的算法结构类似，下面是它的主体算法。</p>\n<pre><code class=\"lang-java\">public Server choose(ILoadBalancer lb,Object key){\n    ...\n    List&lt;Double&gt; allList = lb.getAllServers();\n    int serverCount = allList.size();\n    if(serverCount == 0){\n        return null;\n    }\n    int serverIndex = 0;\n    //获取最后一个实例的权重\n    double maxTotalWeight = currentWeights.size() == 0 ? 0 : currentWeights.get(currentWeights.size() - 1);\n    if(maxTotalWeight &lt; 0.001d){\n        //如果最后一个实例的权重小于0.001，则采用父类实现的线性轮询的策略\n        server = super.choose(getLoadBalancer(),key);\n        if(server == null){\n            return server;\n        }\n    }else{\n        //如果最后一个实例的权重值大于等于0.001，就产生一个[0,maxTotalWeight)的随机数\n        double randomWeight = random.nextDouble() * maxTotalWeight;\n        int n = 0;\n        for(Double d : currentWeights){\n            //便利维护的权重清单，若权重大于等于随机得到的值，就选择这个实例\n            if(d &gt;= randomWeight){\n                serverIndex = n;\n                break;\n            }else{\n                n ++;\n            }\n        }\n        server = allList.get(serverIndex);\n    }\n    ...\n    return server;\n}\n</code></pre>\n<p>从源码中可以看出来，选择实例的核心过程就两步：</p>\n<ul>\n<li>生成一个[0,最大权重值)区间内的随机数。</li><li>遍历权重列表，比较权重值与随机数的大小，如果权重值大于等于随机数，就拿当前权重列表的索引值去服务实例列表中获取具体实例。</li></ul>\n<h2 id=\"h2--code-clientconfigenableroundrobinrule-code-\"><a name=\"<code>ClientConfigEnableRoundRobinRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>ClientConfigEnableRoundRobinRule</code></h2><p>该策略较为特殊，一般不会直接使用它。因为它本身并没有什么特殊的处理逻辑，正如下面的源码所示，在它的内部定义了一个<code>RoundRobinRule</code>策略，而<code>choose</code>函数的实现也正是使用了RoundRobinRule的线性轮询机制，所以它实现的功能实际上与<code>RoundRobinRule</code>相同，那么定义它有什么特殊的用处呢？<br>虽然我们不会直接使用策略，但是通过继承该策略，默认的choose就实现了线性轮询机制，在子类中做一些高级策略时通常有可能会存在一些无法试试的情况，那么就可以用父类的实现作为备选。在后面将介绍的高级策略均时基于ClientConfigEnabledRoundRobinRule的扩展。</p>\n<pre><code class=\"lang-java\">public class ClientConfigEnabledRoundRobinRule extends AbstractLoadBalancerRule{\n\n    RoundRobinRule roundRobinRule = new RoundRobinRule();\n    ...\n\n    public Server choose(Object key){\n        if(roundRobinRule != null){\n            return roundRobinRule.choose(key);\n        }else{\n            throw new IllegalArgmentException(&quot;&quot;)\n        }\n    }\n\n}\n</code></pre>\n<h2 id=\"h2--code-bestavailablerule-code-\"><a name=\"<code>BestAvailableRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>BestAvailableRule</code></h2><p>该策略继承自<code>ClientConfigEnabledRoundRobinRule</code>,在实现中它注入了负载均衡器的统计对象 <code>LoadBalancerStats</code>，保存的实例统计信息来选择满足要求的实例。从如下源码中我们可以看到，它通过遍历负载均衡器中维护所有服务实例，会过滤掉故障的实例，并找出并发请求数最小的一个，所以该策略的特性是可选出最空闲的实例。</p>\n<pre><code class=\"lang-java\">public Server choose(Object key){\n\n    if(loadBalancerStats == null){\n        return super.choose(key);\n    }\n    List&lt;Server&gt; serverList = getLoadBalancer().getAllServers();\n    int minimalConcurrentConnections = Integer.MAX_VALUE;\n    long currentTime = System.currentTimeMillis();\n    Server chosen = null;\n    for (Server server : serverList){\n\n        ServerStats serverStats = loadBalancerStats.getSingleServerStat(server);\n        if(!serverStats.isCiruitBreadkerTripped(currentTime)){\n            int concurrentConnections = serverStats.getActiveRequestCount(currentTime);\n            if(concurrentConnections &lt; minimalConcurrentConnections){\n                minimalConcurrentConnections = concurrentConnections;\n                chosen = server;\n            }\n        }\n    }\n    if(chosen == null){\n        return super.choose(key);\n    }else{\n        return chosen;\n    }\n\n}\n</code></pre>\n<p>同时，由于该算法的核心依据是统计对象<code>loadBalancerStats</code>,当其为空的时候，该策略是无法执行的。所以从源码中我们可以看到，当<code>loadBalancerStats</code>为空的时候，它会采用父类的线性轮询策略，正如我们在介绍<code>ClientConfigEnabledRoundRobinRule</code>时那样，它的子类在无法满足实现高级策略的时候，可以使用线性轮询策略的特性。</p>\n<h2 id=\"h2--code-predicatebasedrule-code-\"><a name=\"<code>PredicateBasedRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>PredicateBasedRule</code></h2><p>这是一个抽象策略，它也继承了<code>ClientConfigEnabledRoundRobinRule</code>，从其命名中可以猜出这是一个基于<code>Predicate</code>实现的策略，<code>Predicate</code>是<code>Google Guava Collection</code> 工具对集合进行过滤的条件接口。<br>如下面的源码所示，它定义了一个抽象函数<code>getPredicate</code>来获取<code>AbstractServerPredicate</code>对象的实现，而在<code>choose</code>函数中，通过<code>AbstractServerPredicate</code>的<code>chooseRoundRobinAfterFiltering</code>函数来选出具体的服务实例。从该函数的命名我们也大致能猜出它的基础逻辑：先通过子类中实现的Predicate逻辑来过滤一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个。</p>\n<pre><code class=\"lang-java\">public abstract class PredicateBassRule extends ClientConfigEnabledRoundRobinRule{\n\n    public abstract AbstractServerPredicate getPredicate();\n\n    @Override\n    public Server choose(Object key){\n\n        ILoadBalancer lb = getLoadBalancer();\n        Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(),key);\n        if(server.isPresent){\n            return server.get();\n        }else{\n            return null;\n        }\n    }\n}\n</code></pre>\n<p>通过下面的<code>AbstractSererPredicate</code>的源码片段，可以证实我们上面所做的猜测。在上面<code>choose</code>函数中调用<code>chooseRoundRobinAfterFiltering</code>方法先通过内部定义的<code>getEligibleServers</code> 函数来获取备选的实例清单（实现了过滤），如果返回的清单为空，则用<code>Optional.absent()</code>来表示不存在，反之则以线性轮询的方式从备选清单中获取一个实例。</p>\n<pre><code class=\"lang-java\">public abstract class AbstractServerPredicate implements Predicate&lt;PredicaateKey&gt;{\n\n    ...\n\n    public Optional&lt;Server&gt; choosenRoundRobinAfterFiltering (List&lt;Server&gt; servers,Object loadBalancerKey){\n        List&lt;Server&gt; eligible = getEligibleServer(servers,loadBalancerKey);\n        if(eligible.size() == 0){\n            return Optional.absent();\n        }\n        return Optional.of(eligible.get(nextIndex.getAndIncrement() % eligible.size()));\n    }\n\n\n    public List&lt;Server&gt; getEligibleServers(List&lt;Server&gt; servers,Object loadBalancerKey){\n\n        if(loadBalancerKey == null){\n            return ImmutableList.copyOf(Iterables.filter(servers,this.getServerOnlyPredicaate()));\n        }else{\n            List&lt;Server&gt; results = Lists.newArrayList();\n            for(Server server: servers){\n                if(this.apply(new PredicateKey(loadBalancerKey,server))){\n                    results.add(server);\n                }\n            }\n            return results;\n        }\n\n    }\n\n}\n</code></pre>\n<h2 id=\"h2--code-avaliabilityfilteringrule-code-\"><a name=\"<code>AvaliabilityFilteringRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>AvaliabilityFilteringRule</code></h2><p>该策略继承自上面介绍的抽象策略<code>PredicateBasedRule</code>，所以它也继承了“先过滤清单，再轮询选择”的基本处理逻辑，其中过滤条件使用了<code>AvailabilityPredicate</code>:</p>\n<pre><code class=\"lang-java\">public class AvailabilityPredicate extends AbstractServerPredicate{\n\n    ...\n    public boolean apply(@Nullable PredicateKey input){\n\n        LoadBalancerStats stats = getLBStats();\n        if(stats = null){\n            return true;\n        }\n        return !shouldSkipServer(stats.getSingleServerStat(input.getServer()));\n    }\n\n    private boolean shouldSkipServer(ServerStats stats){\n\n        if((CIRCUIT_BREAKER_FILTERING.get() &amp;&amp; stats.isCircuitBreakerTripped()) || stats.getActiveRequestsCount() &gt;= activeConnectionsLimit.get()){\n            return true;\n        }\n        return false;\n    }\n\n}\n</code></pre>\n<p>从上述源码中，可以知道它的主要过滤逻辑位于<code>shouldSkipServer</code>方法中，它主要判断服务实例的两项内容：</p>\n<ul>\n<li>是否故障，即断路器是否生效已断开。</li><li>实例的并发请求数量大于阈值，默认值为$2^{32}-1$,该配置可通过<code>&lt;clientName&gt;.&lt;nameSpace&gt;.ActiveConnectionLimit</code>来修改。</li></ul>\n<p>这两项内容中只要有一个满足apply就返回false（代表该节点可能存在故障或负载过高），都不满足就返回true。<br>在该策略中，除了实现了上面的过滤方法之外，对于choose的策略也做了一些改进优化，所以父类的实现对于它来说只是一个备用选项，其具体实现如下所示：</p>\n<pre><code class=\"lang-java\">public Server choose(Object key){\n\n    int count = 0;\n    Server server = roundRobinRule.choose(key);\n    while(count++ &lt;= 10){\n        if(predicate.apply(new PredicateKey(server))){\n            return server;\n        }\n        server = roundRobinRule.choose(key);\n    }\n    return super.choose(key);\n}\n</code></pre>\n<p>可以看到，它并没有像在父类中那样，先遍历所有的节点进行过滤，然后在过滤后的集合中选择实例。而是先以线性的方式选择一个实例，接着用过滤条件来判断该实例是否满足要求，若满足就直接使用该实例，若不满足要求就再选择下一个实例，并检查是否满足要求，如此循环进行，当这个过程重复10次还是没有找到符合要求的实例，就采用父类的实现方案。<br>简单的说，该策略通过线性抽样的方式直接尝试寻找可用且较空闲的实例来使用，优化了父类每次都要遍历所有实例的开销。</p>\n<h2 id=\"h2--code-zoneavoidancerule-code-\"><a name=\"<code>ZoneAvoidanceRule</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code>ZoneAvoidanceRule</code></h2><p>该策略在介绍负载均衡器<code>ZoneAwareLoadBalancer</code> 时已经提到过，他也是<code>PredicateBasedRule</code>的具体实现类。在之前的介绍主要针对<code>ZoneAvoidanceRule</code>中用于选择Zone区域策略的一些静态函数，比如<code>createSnapshot、getAvailableZones</code>。在这里将仔细看看<code>ZoneAvoidanceRule</code>的源码片段中可以看到，它使用了<code>CompositePredicate</code>来进行服务实例清单的过滤。这是一个组合过滤条件，在其构造函数中，它以<code>ZoneAvoidancePredicate</code>为主过滤条件，<code>AvailbilityPredicate</code>为次过滤条件初始化了组合过滤条件的实例。</p>\n<pre><code class=\"lang-java\">public class ZoneAvoidanceRule extends PredicateBasedRule{\n\n    ...\n    private CompositePredicate compositePredicate;\n\n    public ZoneAvoidanceRule(){\n\n        super();\n        ZoneAvoidancePredicate zonePredicate = new ZoneAvoidancePredicate(this);\n        AvailabilityPredicate availabilityPredicate = new AvailabilityPredicate(this);\n        compositePredicate = createCompositePredicate(zonePredicate,availabilityPredicate);\n    }\n    ...\n\n}\n</code></pre>\n<p><code>ZoneAvoidanceRule</code> 在实现的时候并没有像<code>AvailabilityFilteringRule</code>那样重写<code>choose</code>函数来优化，所以它完全遵循了父类的过滤主逻辑：“先过滤清单，再轮询选择”。其中过滤清单的条件就是我们上面提到的以<code>ZoneAvoidancePredicate</code>为主过滤条件、<code>AvailabilityPredicate</code>为次过滤条件的组合过滤条件<code>CompositePredicate</code>。从<code>CompositePredicate</code>的源码片段中，我们可以看到它定义了一个主过滤条件<code>AbstractServerPredicate delegate</code>以及一组次过滤条件列表List <code>fallbacks</code>,所以它的次过滤列表是可以拥有多个的，并且由于它采用了List存储所以次过滤条件是按顺序执行的。</p>\n<pre><code class=\"lang-java\">public class CompositePredicate extends AbstractServerPredicate{\n\n    private AbstractServerPredicate delegate;\n    private List&lt;AbstractServerPredicate&gt; fallbacks = Lists.newArrayList();\n\n\n    private int minimalFilteredServers = 1;\n    private float minimalFilteredPercentage = 0;\n\n    public List&lt;Server&gt; getEligibleServers(List&lt;Server&gt; servers,Object loadBalancerKey){\n\n        List&lt;Server&gt; result = super.getEligibleServers(servers,loadBalancerKey);\n        Iterator&lt;AbstractServerPredicate&gt; i = fallbacks.iterator();\n        while(!(result.size() &gt;= minimalFilteredServers &amp;&amp; result.size() &gt; (int)(servers.size() * minimalFilteredPeecentage)) &amp;&amp; i.hasNext()){\n            AbstractServerPredicate predicate = i.next();\n            result = predicate.getEligibleServers(servers,loadBalancerKey);\n        }\n\n        return result;\n    }\n}\n</code></pre>\n<p>在获取过滤结果的实现函数<code>getEligibleServers</code>中，它的处理逻辑如下所示。</p>\n<ul>\n<li>使用主过滤条件对所有实例过滤并返回过滤后的实例清单。</li><li>依次使用次过滤条件列表中的过滤条件对主过滤条件的结果进行过滤。</li><li>每次过滤之后（包括主过滤条件和次过滤条件），都需要判断下面两个条件，只要有一个符合就不再进行过滤，将当前结果返回供线性轮询算法选择：<ul>\n<li>过滤后的实例总数 &gt;= 最小过滤实例数（<code>minimalFilteredServers</code>,默认为1）。</li><li>过滤后的实例比例 &gt;= 最小过滤百分比（<code>minimalFilteredPercentage</code>，默认为0）。</li></ul>\n</li></ul>\n', 22, '2019-07-04 15:12:34', 4, 0, 'ribbon', 0, 0);

-- ----------------------------
-- Table structure for blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `blog_comment`;
CREATE TABLE `blog_comment`  (
  `comment_id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `comment_content` longtext CHARACTER SET utf8 COLLATE utf8_bin NULL COMMENT '评论信息',
  `user_id` int(10) NULL DEFAULT NULL COMMENT '用户id',
  `article_id` int(10) NULL DEFAULT NULL COMMENT '文章id',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '评论创建时间',
  `is_delete` int(5) NULL DEFAULT 0,
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 68 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for blog_course
-- ----------------------------
DROP TABLE IF EXISTS `blog_course`;
CREATE TABLE `blog_course`  (
  `course_id` int(10) NOT NULL AUTO_INCREMENT,
  `course_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `lan_id` int(50) NOT NULL,
  `course_value` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `is_delete` int(5) NULL DEFAULT 0 COMMENT '逻辑删除',
  PRIMARY KEY (`course_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 271 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_course
-- ----------------------------
INSERT INTO `blog_course` VALUES (1, 'C++ 整形数据类型', 1, '##整形数据类型\r\n```c++\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	/*整形;\r\n	显示数据类型的最大最小值;*/\r\n	short n_short = SHRT_MIN;         //定义short类型的最大最小值;\r\n	short n_short1 = SHRT_MAX;\r\n	unsigned short n_short2 = USHRT_MAX;  //定义无符号short类型的最大值; 无符号类型大小是从0开始的;\r\n\r\n	cout << n_short << endl;\r\n	cout << n_short1 << endl;\r\n	cout << n_short2 << endl;\r\n	cout << endl;\r\n\r\n	int n_int = INT_MAX;              //定义int类型的最大最小值;\r\n	int n_int1 = INT_MIN;\r\n	unsigned int n_int2 = UINT_MAX;\r\n	cout << n_int << endl;\r\n	cout << n_int1 << endl;\r\n	cout << n_int2 << endl;\r\n	cout << endl;\r\n\r\n	long n_long = LONG_MIN;              //定义长整形的最大最小值;\r\n	long n_long1 = LONG_MAX;\r\n	unsigned long n_long2 = ULONG_MAX;\r\n	cout << n_long << endl;\r\n	cout << n_long1 << endl;\r\n	cout << n_long2 << endl;\r\n	cout << endl;\r\n\r\n	long long n_ll = LLONG_MIN;               //定义长长整形的最大最小值;\r\n	long long n_ll1 = LLONG_MAX;\r\n	unsigned  long long n_ll2 = ULLONG_MAX;\r\n	cout << n_ll << endl;\r\n	cout << n_ll1 << endl;\r\n	cout << n_ll2 << endl;\r\n	cout << endl;\r\n\r\n	cout << sizeof(short) << endl;     //输出每个这种类型元素的大小;\r\n	cout << sizeof(int) << endl; \r\n	cout << sizeof(long) << endl;\r\n	cout << sizeof(long long) << endl;\r\n	cout << sizeof(double) << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (2, 'C++ 浮点数据类型', 1, '##浮点数据类型\r\n```\r\n#include<iostream>\r\n#include<float.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	float a = 123.2559542;      //浮点型定义变量一定要是小数;   有效数位是6\r\n	double b = 13.2345757575;     //有效数位是6；\r\n	long double c = 52.4124755555;  //有效数位是6；\r\n	cout << a << FLT_MIN << endl;   //显示其所能表达的范围;  转换到定义可以看到;   利用这个宏，上面要打一个头文件;\r\n	cout << b << FLT_MIN << endl;\r\n	cout << c << FLT_MIN <<endl;\r\n	cout << sizeof(float) << endl;     //4\r\n	cout << sizeof(double) << endl;     //8\r\n	cout << sizeof(long double) << endl;   //8\r\n\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (3, 'C++ char数据类型', 1, '##char数据类型\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	char ch = \'M\';       //char 定义字母时候需要加单引号 ‘’  M在ASCII中的十进制位数是77； 这里定义个ch为M;\r\n	cout << ch << endl;\r\n	cout << sizeof(char) << endl;     //char类型的大小是1；\r\n	int a = \'M\';          //相同的代码存储在int类型中;    输出的就是其十进制的形式77；\r\n	cout << a << endl;\r\n	ch = ch + 1;\r\n	cout << ch << endl;         //ch+1那么ASCLL所对应的第77位+1，就是第78位，就是N了；\r\n	cout.put(ch);     //成员函数cout.put() ,是一个输出字符的函数，不能输出整形；属于类的继承;\r\n	\r\n	\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (4, 'C++ 类型转换', 1, '##类型转换\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	char ch;\r\n	int i;\r\n	float f;\r\n	f = i = ch = \'c\';\r\n	cout<< ch <<\" \"<< i <<\" \"<< f << endl;   //c,99,99\r\n	//c字符对应的ascll码对应的十进制数是99；\r\n	ch = ch + 1;              \r\n	i = f + 2 * ch;    \r\n	f = 2.0 * ch + i;\r\n	cout<< ch <<\" \"<< i <<\" \"<< f <<endl;   //d,299,499;\r\n\r\n	ch=1107;\r\n	cout<< ch <<endl;      //演示降级转换，ch值是1107%256，既83；\r\n	ch=50.26;\r\n	cout<< ch <<endl;       //这里默认截断小数，只取整数50，50对应ascll码是数字2，所以这里输出2\r\n	 \r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//类型转换  从上到下类型大小依次减少；\r\n//	long double\r\n//	long\r\n//	float\r\n//	unsigned long\r\n//	long long\r\n//	unsigned long \r\n//	long\r\n//	unsigned int \r\n//	int\r\n//由低类型向高类型转换时不会影响什么，但是由低类型向高类型转换时会产生截断的情况\r\n//比如23.15，-23.15，转换成\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (5, 'C++ 强制类型转换', 1, '##强制类型转换\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int m=1.6+1.7;     //这里是先进行表达式里面的加算1.6+1.7=3.3，然后对3.3进行转换，结果为3；\r\n	cout<<m<<endl;\r\n	m=int(1.6)+(int)1.7;  //这里是直接对每个值进行转换，然后对其做加算，1+1=2；这就是强制类型转换，（类型名）+数据；\r\n	cout<<m<<endl;\r\n\r\n	//但是这两种转换一般情况都不要使用；尽量避免进行低位向高位的转换；\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (6, 'C++ 引用的声明', 1, '##引用的声明\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a = 12;\r\n	int &c = a;                   //声明一个变量a的引用c,c是变量a的一个别名；\r\n								  //这个的含义是：空间内存着这个变量a,然后再声明这个c也是这个a空间的名字；\r\n	c = 13;\r\n	cout << a << endl;\r\n	cout << &a << endl;\r\n	cout << &c << endl;     //a的地址和c的地址是一样的；\r\n							//数组的引用；\r\n	int d[3] = { 10,25,53 };\r\n	int(&f)[3] = d;   //数组的引用：定义一个int[3]类型的引用f与a相等；\r\n	cout << f[0] << \" \" << f[1] << \" \" << f[2] << endl;\r\n	//指针的引用；\r\n	int *p = &a;\r\n	int *(&p1) = p;\r\n	cout << p << endl;\r\n	cout << p1 << endl;\r\n	*p1 = 20;\r\n	cout << a << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (7, 'C++ 指针数组', 1, '##指针数组\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a[5] = { 10,5,6,20,30 };\r\n	int b[3] = { 1,50,21 };\r\n	int c[4] = { 25,40,51,600 };\r\n	int d[6] = { 27,56,84,54,86,21 };\r\n	int* m[4] = { a,b,c,d };\r\n	//cout << m[0] << endl;           //这里定义的是指针数组是一个数组，用来存储指针类型数据的数组\r\n	//cout << &a[0] << endl;          //所以定义的类型就一定是指针类型，a，b，c，d代表的是数组的第一位的地址；\r\n	////也可以用这个对其进行读写；\r\n	//m[0] = m[0] + 1;\r\n	//cout << m[0] << endl;      //int 类型的数据，地址加1就是向前移动4个字节；\r\n	//cout << &a[1] << endl;\r\n	//\r\n	a[0] = *m[0] + 1;\r\n	cout << a[0] << endl;\r\n	//也可以这样；\r\n	cout << m[1][2] << endl;      //这里就是其下标的运算：输出的是数组b的第三个元素;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//指针数组定义的是数组;\r\n	//可以是二维，几维的都可以，int*p[][][][][];\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (8, 'C++ 数组指针', 1, '##数组指针\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	int a[2][3] = { {1,20,50},{21,32,61} };\r\n	//定义他的数组指针\r\n	int(*p)[2][3] = &a;     //想定义一个数组类型的指针，理论上应该是 int [2][3]（*p）  像这样就是定义一个[2][3]类型的数组类型的指针;但是语法上只能这么写；\r\n	                       //这里定义的就是整个二维数组的地址；\r\n	cout << p << endl;\r\n	cout << *p<< endl;\r\n	//p = p + 1;           //地址加一就是向前加了24个字节；\r\n	cout << p << endl;\r\n	int(*p1)[3] = &a[0];   //定义大数组中小数组的地址，那么也是数组类型的地址，每个数组中有 3个元素，那么就是[3]型的指针，其地址位置就是a[0]或者是a[1];\r\n	cout << p1 << endl;\r\n	//p1 = p1 + 1;        //地址加一就是向前加了12个字节；\r\n	cout << p1 << endl;\r\n	int i, j;\r\n	for (i = 0; i < 2; i++)\r\n	{\r\n		for (j = 0; j < 3; j++)\r\n		{\r\n			cout << (*p)[i][j] << endl;    //利用数组的指针来遍历二维数组的地址;\r\n		}\r\n	}\r\n\r\n\r\n//数组指针定义的是指针：\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (9, 'C++ 数组之间的赋值', 1, '##数组之间的赋值\r\n```\r\n#include<iostream>\r\n#include<memory.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a[5] = { 10,9,8,7,6 };\r\n	int b[5];\r\n	//int b[3]；\r\n	/*int i;\r\n	for (i = 0; i < 5; i++)\r\n	{\r\n		b[i] = a[i];\r\n	}\r\n	cout << b[0] << endl;*/\r\n	memcpy(&b[0], &a[2], sizeof(int)*3);//其本质是地址的赋值;  将数组a的第三个元素到最后一元素拷贝到数组b，从数组b的第一个元素开始\r\n	cout << b[0] << endl;\r\n	cout << b[3] << endl; //元素为空\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (10, 'C++ char数组赋值与比较', 1, '##char数组赋值与比较\r\n```\r\n#include<iostream>\r\n#include<memory.h>\r\n#include<string.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	char a[5] = { \'A\',\'C\',\'V\',\'M\',\'W\' };\r\n	cout << sizeof(a) << endl;  //5\r\n    char b[7] =  \"ABCDFL\" ;     //注意这里是7，不是6;     使用这种字符串数组，系统会自动加一个\\0；\r\n	cout << b << endl;        //这种字符串的数组可以直接输出b;\r\n	cout << sizeof(b) << endl;\r\n	cout << b[0] << endl;\r\n	cout << b[1] << endl;\r\n	cout << b[2] << endl;\r\n	cout << b[3] << endl;\r\n	cout << b[4] << endl;\r\n	cout << b[5] << endl;\r\n	cout << b[6] << endl;     //第7位是\\0;\r\n	cout << endl;\r\n	char c[7];\r\n	//memcpy(c , b , sizeof ( char ) * 7 );\r\n	//memcpy_s(c,sizeof(c), b, sizeof(char) * 7);   //字符串之间的赋值和数组之间的赋值是一样的;\r\n    strcpy_s( c, sizeof(c), b);      //c++的更新的函数，因为strcpy在这里会产生警告，所以弃用strcpy，用这个新的函数来对两个字符串之间的赋值;\r\n	cout << c << endl;          //这三种方法都可以对字符串之间进行赋值;\r\n	char d[7] = \"FVBca\";\r\n	int res =strcmp( b, d); //对字符串的ASCLL进行比较;\r\n	cout << res << endl;    //==0,字符串相等;\r\n	                        //>0字符串b>d; \r\n	                        //<0 字符串b<d;\r\n	\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (11, 'C++ char拼接与长度', 1, '##char拼接与长度\r\n```\r\n#include<iostream>\r\n#include<string.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	char a[10] = \"myk\";\r\n	char b[3] = \"AB\";\r\n	strcat_s(a, sizeof(a), b);   //将b的字符串接到字符串a的后面;\r\n	cout << a << endl;\r\n	cout << b << endl;\r\n	//一个计数器，从字符串的开始位置开始，直到碰到\\0结束，然后返回计数器的值，不包括\\0;\r\n	cout << strlen(a) << endl;  //5  由于将b的字符串接到了a后面，所以最后就是5了;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (12, 'C++ char指针', 1, '##char指针\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	char a[10] = \"myk\";\r\n	char *ch = a;    \r\n	cout <<ch[0] << endl;     //取出字符串第一个字母元素；\r\n	cout << ch << endl;      \r\n	cout << &a << endl;         //取出字符串的地址；\r\n	cout <<&a+1<< endl;       //地址加一，那么地址量向前移动10；\r\n	\r\n\r\n	int b[3] = { 1,5,9 };\r\n	int *p = b;\r\n	cout << p[0] << endl;\r\n	cout << b << endl;\r\n	cout << b + 1 << endl;\r\n	cout << p << endl;\r\n	cout << p + 1 << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//#include<iostream>\r\n//using namespace std;\r\n//int main()\r\n//{\r\n//\r\n//	char name[20];\r\n//	cin >> name;\r\n//	cout << name << \" \" << (int *)name << endl;     //int *取地址的意思；\r\n//	cout << &name << endl;\r\n//\r\n//	system(\"pause\");\r\n//	return 0;\r\n//}\r\n```', 0);
INSERT INTO `blog_course` VALUES (13, 'C++ string类', 1, '##string类\r\n```\r\n#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	char a[20];            \r\n	string str;                                     //其主要区别是可以将string对象声明为简单变量，而不是数组；\r\n	   //其优势在于它可以自动调整str的大小;   这里创建一个大小为0的string对象\r\n	cin >> a; \r\n	cout << a << endl;\r\n	cin >> str;                          //这里就可以自动调整为string对象的长度;\r\n	cout << str << endl;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//string与char字符数组很多地方都一样;\r\n//1.可以使用C-风格字符串来初始化string对象;\r\n//2.可以使用cin来输入字符存储到string对象中;\r\n//3.可以使用cout来显示对象;\r\n//4.可以使用数组表示法来访问存储在string对象中的字符;\r\n```', 0);
INSERT INTO `blog_course` VALUES (14, 'C++ string类赋值拼接', 1, '##string类的赋值\r\n```\r\n#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	char a[20] =\"m\";\r\n	char b[20] = \"MYK\";\r\n	string str;\r\n	string str1 = \"myk\";\r\n	string str2;\r\n	cout << str1.size() << endl;            //取str类型字符串的长度；\r\n	cout << strlen(a) << endl;                  //取char型字符串的长度;\r\n\r\n	strcpy_s ( a, sizeof(a), b);       //字符串数组赋值时不可以直接  a=b，必须要用到赋值函数;\r\n	cout << a << endl;\r\n\r\n	str = str1;                    //而string对象可以直接进行赋值，就像简单常量一样;\r\n	cout << str << endl;\r\n\r\n\r\n	strcat_s(a, sizeof(a), b);         //拼接也需要用到函数;\r\n	cout << a << endl;\r\n	\r\n\r\n	str2 = str + str1;\r\n	cout << str2 << endl;          //string 对像类可以直接进行加法拼接;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (15, 'C++ cin.get()', 1, '##cin.get\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	char a[20];\r\n	char b[20];\r\n	cin.get(a, 20).get();                    //正常使用get()无法连续输入两行，因为get（）会将换行符保留，那么下一个输入行首先遇到的就是换行符\r\n	                                         //输入就会停止，那么我们在后面在添加一个.get（）将两个成员函数拼接起来，这样就可以了； \r\n                                             // get(arr,arrsize)这个只能用于char型字符串，而getline（cin，str）是用于string类型字符串；\r\n	cin.get(b, 20).get();                    \r\n	//cin.getline(a, 20).getline(b, 20);     //同样之前的getline()也可以连续的将输入的内容分别放到a和b中；\r\n	//cin.getline(a, 20)只能读取输入的19个字符，因为最后一位要存储；\r\n	cout << \"I\'m \" << a << endl;\r\n	cout << \"I\'m \" << b << endl;\r\n	system(\"pause\");\r\n	return 0;\r\n\r\n}\r\n//getline()  这种方法丢弃换行符;\r\n//get()  将换行符保留在序列中;\r\n//两者都是直接看到换行符后就停止读取;\r\n```', 0);
INSERT INTO `blog_course` VALUES (16, 'C++ getline()', 1, '##geline()\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	char a[20];\r\n	char b[20];\r\n	cin.getline(a,20);             //类似于cin,cin是输入一个词，这里是输入一行字符,这里就是输入一行字符\r\n	cin.getline(b, 20);            \r\n	cout << a << endl;\r\n	cout << b << endl;\r\n\r\n//这里就是先定义两组字符串数组，为其申请空间，其大小为20;然后在输入两组字符串 分别装入字符串a和b中，再输出a和b的值;\r\n	//int a;\r\n	//int b;\r\n	//cin >> a;\r\n	//cin >> b;\r\n	//cout << a << endl;\r\n	//cout << b << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (17, 'C++ 其他形式的字符串', 1, '##其他形式的字符串\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	wchar_t a[20] = L\"MYK\";  //L是wchar_t是前缀;\r\n	wcin >> a;\r\n	wcout << a << endl;\r\n	wcout << sizeof(wchar_t) << endl;\r\n	//wchar_t时C/C++的字符类型，主要用在国际化程序实现中；\r\n	//其中包含了256种以外的多种字符，其数据类型大小为2字节；\r\n	//其输出模式iostream提供了 wcin和wcout；\r\n	//char16_t;   //无符号类型，长16位    使用前缀为  u\r\n	//char32_t;   //无符号类型，长32位    使用前缀为  U\r\n	//这两种前缀在vs中不能加 ，vs中只能加L；\r\n	//正常用cout来输出带\\n字符串时是这样的;\r\n	cout << \"myk\\ is \\\\n\\ MYK.\" << endl;    //在要输出的字符串中添加\\；\r\n	//而C++11新增了原始字符串（raw），其前缀R；\r\n	cout << R\"(myk is \\n MYK)\" << endl;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (18, 'C++ 结构体简介', 1, '##结构体简介\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nstruct xinxi                               //关键字加新类型的名字，括号内放入结构的成员，里面可以存放各种类型；\r\n{\r\n	char name[20];  \r\n	float shengao;\r\n	double tizhong;\r\n};\r\nint main()\r\n{\r\n	//在主函数内可以使用这个新的自己创建的类型；\r\n	xinxi myk = {\"马永康\",173.55f,52.3 };              //定义个xinxi类型的变量并进行初始化  myk  dcj是类型名，其定义的方法和数组的格式一样；\r\n	xinxi dcj = { \"董承吉\",175.12f,53.2 };\r\n\r\n	xinxi xyh;\r\n	xyh = myk;           //也可以直接用= 对变量进行赋值;\r\n	cout << xyh.name << endl;\r\n\r\n	cout << myk.name << endl;        //用类型名加.的方式调用struct中的类型数据；\r\n	cout << myk.shengao << endl;\r\n	cout << myk.tizhong << endl;\r\n	\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (19, 'C++ 共用体', 1, '##共用体\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nunion xinxi\r\n{\r\n	int a;\r\n	float a;\r\n	double a;                        //共用体内只能存储一个值，但是这个值可以是不同的类型，成员名指出了使用的模式；\r\n};\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (20, 'C++ 枚举', 1, '##枚举\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nenum myk {red,orange,yellow=10,grean,blue,black}; //myk 这个新的类型被称为枚举；就像struct的变量被称为结构一样；\r\n//这里也可以对枚举量进行赋值；\r\n//enum myk{red,orange=20,yellow,grean,blue,black};这里面red的值就是默认为0，而orange后面的量的枚举量为前一个加1，也就是说yellow的枚举量为21；\r\nint main()\r\n{\r\n	myk a;\r\n	a = blue;         //这里由枚举定义的变量只能使用枚举内的数据;\r\n	//myk b = 2000;      像这种就是不被允许的;\r\n	\r\n	int color = blue;           //转换类型为int\r\n	color = 3 + red;\r\n	cout << color << endl;\r\n	myk m;\r\n	m = myk(2);             //强制类型转换\r\n	cout << m << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (21, 'C++ new和delete', 1, '##new和delete\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a = 10;\r\n	int *p = new int(10);            //申请一个int类型的内存空间：\r\n	            \r\n	cout << p << endl;\r\n	\r\n	double *p1 = new double;\r\n	*p1 = 10.1521556;\r\n	cout << p1 << endl;\r\n	cout << sizeof(p) << endl;\r\n	cout << sizeof(*p) << endl;\r\n	cout << sizeof(p1) << endl;        //而double类型指针的大小为4；\r\n	cout << sizeof(*p1) << endl;      //double的数据类型大小是8；\r\n	delete p;\r\n	/*cout << *p << endl;*/     //已经释放了内存  那么指针的地址将不再指向a的空间了，*p也就不再是a的值了；\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (22, 'C++ 使用new创建结构体', 1, '##使用new创建结构体\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nstruct myk\r\n{\r\n	char name[20];\r\n	float shengao;\r\n	double tizhong;\r\n};\r\nint main()\r\n{\r\n	myk *p = new myk;          //创建动态结构；\r\n	cin.get(p->name, 20);       //指针调用法，用指针来调用结构体内的类型；\r\n	cin >> (*p).shengao;         //*p就是结构体本身，利用*p.来调用结构体内的类型；\r\n	cin >> p->tizhong;\r\n	cout << p -> name << endl;\r\n	cout << p -> shengao << endl;\r\n	cout << p -> tizhong << endl;\r\n	//因为是先运行才进型内存的分配，所以是动态结构；\r\n	delete p;       //切记最后要释放内存；\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (23, 'C++ 模板类vevtor和array', 1, '##模板类vector和array\r\n```\r\n#include<iostream>\r\n#include<vector>\r\n#include<array>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	double a[4] = { 1.3,5.62,5.5,63.5 };//普通数组的定义初始化\r\n	a[-2] = 20.5;                 //注意这里a[-2]将会转换成*（a-2）=20.2，\r\n	                             //其含义是找到a指的地方，向前移动2个double元素，并将20.2存到这个地址；其实这个数组的值是越界的，这种做法是不安全的；\r\n	cout << a[-2] << \" \" << &a[-2] << endl;\r\n	cout << endl;\r\n	int i = 0;\r\n	for (i = 0; i < 4; i++)\r\n	{\r\n		cout << a[i] << endl;\r\n	}\r\n	cout << endl;\r\n	//////////////////////////////////////////////////////////\r\n	vector<double>a1(4);    //vector模板类的定义和初始化,类似于new的动态数组\r\n	vector<double>a4(4);\r\n	a1[0] = 1.3;\r\n	a1[1] = 5.62;\r\n	a1[2] = 5.5;\r\n	a1[3] = 63.5;\r\n	a4 = a1;             //直接对数组进行赋值；\r\n	for (i = 0; i < 4; i++)\r\n	{\r\n		cout << a4[i] << endl;\r\n	}\r\n	cout << endl;\r\n	////////////////////////////////////////////////////\r\n	double*p = new double[4];    //这两种方法创建数组都是动态的存储；\r\n								 //int m;\r\n								 //cin>>m;\r\n								 //double*p=new double[m]\r\n	p[0] = 1.3;\r\n	p[1] = 5.62;\r\n	p[2] = 5.5;\r\n	p[3] = 63.5;\r\n	for (i = 0; i < 4; i++)\r\n	{\r\n		cout << p[i] << endl;\r\n	}\r\n	cout << endl;\r\n	////////////////////////////////////////////////\r\n	array<double, 4>a2 = { 1.3,5.62,5.5,63.5 };  //而这种创建数组的方式就是要先定义数组的长度；\r\n	array<double, 4>a3;\r\n	a3 = a2;   //这里可以直接对数组进行赋值；\r\n	for (i = 0; i < 4; i++)\r\n	{\r\n		cout << a2[i] << endl;\r\n	}\r\n	cout << endl;\r\n	for (i = 0; i < 4; i++)\r\n	{\r\n		cout << a3[i] << endl;\r\n	}\r\n	///////////////////////////////////////////////\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (24, 'C++ 自加运算', 1, '##自加运算\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	int a = 1;\r\n	int b = 2;\r\n	int c = a++;\r\n	int d = ++b;\r\n	cout << a << endl;      //a和b的值都+1了;\r\n	cout << b << endl;       \r\n	cout << c << endl;      //c的值是a原来的值;\r\n	cout << d << endl;      //d的值进行了+1;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (25, 'C++ for循环阶乘', 1, '##for循环阶乘\r\n```\r\n#include<iostream>\r\nconst int m = 17;            //限定符，更改这个m的数值就可以计算不同的阶乘；\r\nusing namespace std;\r\nint main()\r\n{\r\n	long long  a[m];\r\n	a[0] = 1ll;       //long long 格式的后缀是ll；\r\n	int i;\r\n	for (i = 1; i < m; i++)\r\n	{\r\n	   \r\n		a[i] = i * a[i-1];          //每一个数的阶乘都是这个数*前一个数的阶乘；例如 15!=15*14!;\r\n		cout << a[i] << endl;\r\n	\r\n	}\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (26, 'C++ 基于范围的for循环', 1, '##基于范围的for循环\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a[3] = { 20,50,31 };\r\n	for (int &x : a)\r\n	{\r\n		cout << x << endl;\r\n	}\r\n	for(int &x:a)\r\n	{\r\n	x=x*0.8;\r\n	cout << x << endl;\r\n	}\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (27, 'C++ switch', 1, '##switch\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int i;\r\n	cin >> i;\r\n	switch (i)      //这里必须是整形表达式;\r\n	{\r\n	case 1:cout << \"myk\" << endl;\r\n		break;\r\n	case 2:cout << \"xyh\" << endl;\r\n		break;\r\n	case 3:cout << \"dcj\" << endl;\r\n		break;\r\n	default:\r\n		cout << \"无法显示\" << endl;\r\n\r\n	}\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (28, 'C++ goto', 1, '##goto\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a, b, c;\r\n	for(a = 0; a < 10; a++)\r\n	{\r\n		for (b = 0; b < 3; b++)\r\n		{\r\n			for (c = 0; c < 5; c++)\r\n			{\r\n				cout << \"Hello\" << endl;\r\n				goto myk;\r\n			}\r\n		}\r\n	}\r\n\r\nmyk:cout << \"hello\" << endl;        //goto 一般不要使用，一般用于跳出多重循环；这里myk的标签可以不写东西，那么就只是输出Hello;\r\n	//continue是结束本次循环，break是跳出所在循环；\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (29, 'C++ 延时循环', 1, '##延时循环\r\n```\r\n#include<iostream>\r\n#include<ctime>                    //添加ctime头文件；ctime文件将clock_t做为类型别名，也就是说可以将变量声明为clock_t类型;\r\nusing namespace std;\r\nint main()\r\n{\r\n	double s;\r\n	\r\n	cin >> s;                                //输入一个时间，单位是秒；\r\n	\r\n	clock_t delay = s * CLOCKS_PER_SEC;        //delay延时时长为这个s数乘计算机的时间单位，CLOCKS_PER_SER（1000ms）；\r\n    cout << \"strating\" << endl;        \r\n	clock_t start = clock();                // clock()取当前的计算机时间，\r\n	while (clock() - start < delay)      //这里做个空循环，取系统当前时间-之前取的系统当前时间，如果小于延时就一直循环；\r\n	{                       \r\n		                                 //每次循环结束进入下一次循环这个clock（）都会更新；\r\n	};                                 //空循环；\r\n	cout << \"done\";\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (30, 'C++ 类型别名', 1, '##类型别名\r\n```\r\n#include<iostream>\r\n#define char_t char               //利用char替换所有的char_t,从而是char_t称为char的别名；\r\ntypedef double double_t;          //使用C++的关键字typedef来创建别名，将double_t作为double的别名；\r\nusing namespace std;\r\nint main()\r\n{\r\n	char_t a = \'m\';\r\n	double_t b = 56.15;\r\n	cout << a << endl;\r\n	cout << sizeof(a) << endl;\r\n	cout << b << endl;\r\n	cout << sizeof(b) << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (31, 'C++ cctype', 1, '##cctype\r\n```\r\n#include<iostream>\r\n#include<cctype>                    //字符库函数；\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	char ch;\r\n	int a,b,c,d,e;\r\n	a = 0;\r\n	b = 0;\r\n	c = 0;\r\n	d = 0;\r\n	e = 0;\r\n	cin.get(ch);\r\n	while(ch!=\'@\')\r\n	{\r\n		if(isalpha(ch))             //如果是字母，返回true；\r\n			a++; //对返回的次数进行计数；                    \r\n		else if(isspace(ch))        //如果是空白字符（空格，进纸，换行符，回车，水平制表符，垂直制表符），返回true；\r\n			b++; //对返回的次数进行计数；\r\n		else if(isdigit(ch))        //如果是数字0-9，返回true；\r\n			c++; //对返回的次数进行计数；\r\n		else if(ispunct(ch))       //如果是标点符号，返回true；\r\n			d++; //对返回的次数进行计数；\r\n		else                       \r\n			e++;//对返回的次数进行计数；\r\n		cin.get(ch);\r\n		\r\n	}\r\n	cout<<a<<endl;\r\n	cout<<b<<endl;\r\n	cout<<c<<endl;\r\n	cout<<d<<endl;\r\n	cout<<e<<endl;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//isalnum();     如果参数是字母或数字，返回true；\r\n//isalpha();     如果参数是字母，返回true；\r\n//iscntrl();     如果参数是控制字符，返回true；\r\n//isdigit();     如果参数是数字0-9，返回true；\r\n//isgraph();     如果参数是除空格外的打印字符，返回true；\r\n//islower();     如果参数是小写字母，返回true；\r\n//isprint();     如果参数是打印字符，返回true；\r\n//ispunct();     如果参数是标点符号，返回true；\r\n//isspace();     如果参数是标准空白字符（空格，进纸，换行符，回车，水平制表符，垂直制表符），返回true；\r\n//isupper();     如果参数是大写字母，返回true；\r\n//isxdigit();    如果参数是十六进制数字，返回true；\r\n//tolowe();      如果参数是大写字符，返回其小写，否则返回参数；\r\n//toupper();     如果参数是小写字符，返回其大写，否则人返回参数；\r\n```', 0);
INSERT INTO `blog_course` VALUES (32, 'C++ ?三操作数运算符', 1, '##三操作数的运算符\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a ,b;\r\n	cin>>a>>b;\r\n	/*expression1 ? expression2 : expression3;*/    //?(三操作数的运算符)：如果表达式1为true，那么整个表达式的值为expression2的值，否则为expression3的值；\r\n	int c = a > b? (2*a):(3*b);    //这里就是输入a，b，如果a>b,那么值为2*a，否则为3*b；\r\n	cout<<c<<endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n\r\n\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (33, 'C++ 文本文件的输出', 1, '##文本文件的输出\r\n```\r\n#include<iostream>\r\n#include<fstream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	char name[20];\r\n	double height;\r\n	double weight;\r\n	ofstream outFile;      //创建一个ofstream对象;文本文件输入；\r\n	outFile.open(\"MYK.txt\");//outFile 与一个文本文件关联；\r\n	cout << \"输入名字：\";\r\n	cin.getline(name, 20);\r\n	cout << \"输入height:\";\r\n	cin >> height;\r\n	cout << \"输入weight：\";\r\n	cin >> weight;\r\n\r\n	//cout控制台输出前面输入的信息\r\n	cout << fixed;                    //以普通的形式输出，而不是科学计算法；\r\n	cout.precision(2);                //保留2位小数精度；\r\n	cout.setf(ios_base::showpoint);     //显示小数点后面的0；\r\n	cout << \"Name:\" << name << endl; \r\n	cout << \"Height:\" << height << endl;\r\n	cout << \"Weight:\" << weight << endl;\r\n\r\n	//outFile 把信息写入到文本文件\r\n	outFile << fixed;\r\n	outFile.precision(2);\r\n	outFile.setf(ios_base::showpoint);\r\n	outFile << \"Name:\" << name << endl;\r\n	outFile << \"Height:\" << height << endl;\r\n	outFile << \"Weight:\" << weight << endl;\r\n	outFile.close();                  //使用完进行关闭；\r\n	system(\"pause\");\r\n	return 0;\r\n\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (34, 'C++ 文本文件的输入', 1, '##文本文件的输入\r\n```\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cstdlib>                       //exit()函数的头文件；\r\nusing namespace std;\r\nint main()\r\n{\r\n	char Name[50];\r\n	ifstream InFile;                  //创建一个对象用来输入\r\n	cout << \"输入文件的名字：\";\r\n	cin.getline(Name, 50); \r\n	cout << Name << endl;\r\n	InFile.open(Name);                 //打开名为。。。的文件；\r\n	if (!InFile.is_open())             //判断文件是否已经被正常打开，若没有打开则提示文件没有打开，并退出；\r\n	{\r\n		cout << \"不能打开文件\" << Name << endl;\r\n		exit(EXIT_FAILURE);\r\n	}\r\n	double value;\r\n	double sum = 0.0;\r\n	int count = 0;\r\n	InFile >> value;           //文本输入value；就像cin>>;\r\n	while (InFile.good())    //good()函数 ，检测输入流是否正常\r\n	{\r\n		++count;\r\n		sum = sum + value;\r\n		InFile >> value;\r\n	}\r\n	if (InFile.eof())        //eof()函数，文件输入流结束\r\n		cout << \"文件搜索结束\";\r\n	else if (InFile.fail())  //fail()，文件输入流错误；\r\n		cout << \"输入数据不匹配终止\";\r\n	else\r\n		cout << \"未知原因终止输入\";\r\n\r\n	if (count == 0)\r\n	{\r\n		cout << \"未处理数据\";\r\n	}\r\n	else\r\n	{\r\n		cout << \"项目改为：\" << count << endl;\r\n		cout << \"总和\" << sum << endl;\r\n		cout << \"平均值\" << sum / count << endl;\r\n	}\r\n	InFile.close();\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (35, 'C++ 函数', 1, '##函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nvoid cheers(int);  //函数的声明，没有返回值\r\ndouble cube(double); //函数声明，返回值是double类型；\r\nint main()\r\n{\r\n	cheers(5);                        //调用函数cheers；将实参5，带入函数进行使用；\r\n	double a;\r\n	cin >> a; \r\n	cout << cube(a) << endl;         //调用函数cube；\r\n	cheers(cube(2));                //同时调用函数cheers和函数cube；\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid cheers(int n)          //函数定义；没有返回值；\r\n{\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		cout << \"Cheers!\" << endl;\r\n	}\r\n}\r\ndouble cube(double x)      //函数定义cube函数，返回值为double类型；\r\n{\r\n	return x * x*x;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (36, 'C++ 函数与数组', 1, '##函数与数组\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nconst int Arsize = 8;\r\nint sum_arr(int *arr, int n);\r\nint main()\r\n{\r\n	int cookies[Arsize] = { 1,2,4,8,16,32,64,128 };\r\n	cout << cookies << \"是cookies的地址\" << endl;\r\n	cout << sizeof(cookies) << endl;                          //取cookies数组的长度；\r\n\r\n	int sum = sum_arr(cookies, Arsize);\r\n	cout << sum << endl;\r\n	sum = sum_arr(cookies, 3);\r\n	cout << sum << endl;\r\n	sum = sum_arr(cookies + 4, 4);\r\n	cout << sum << endl;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nint sum_arr(int* arr, int n)             //定义函数的时候，数组做为参数时，实际上的形参时指针，就像这样，这样才是本质。当然数组名也代表的是数组首地址；\r\n{\r\n	int total = 0;\r\n	cout << arr << \"是arr的地址\"<< endl;                     \r\n	cout << sizeof(arr) << endl;                            //取指针的长度（程序的结果是从一个使用4字节地址的系统中获得的）；\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		total = total + arr[i];\r\n	}\r\n	return total;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (37, 'C++ 函数与C风格字符串', 1, '##函数与C风格字符串\r\n\r\n```\r\n//查询一个字符串数组中，一个字符出现的次数；\r\n#include<iostream>\r\nint str1(const char *str, char ch);                    \r\nusing namespace std;\r\nint main()\r\n{\r\n\r\n	const char mmm[20] = \"msinfaofmmfon\";\r\n	cout << str1(mmm, \'m\');\r\n	const char*p = \"safafj\";\r\n	cout << str1(p, \'a\');\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nint str1(const char *str, char ch)            //定义一个数组时候实际上数组是一个指针，而str本身就是字符串数组的首地址；\r\n{\r\n	int count = 0;\r\n	while (*str)      //(*(&str[0]))                        //str所表示的时字符串数组的首地址，那么*str就是str字符串数组第一个元素的值；         \r\n	{\r\n		if (*str == ch)                         \r\n			count++;\r\n		str++;                            //进行一次循环，其地址偏移量加1；再次进入循环，直至遇到\"\\0“;\r\n	}\r\n	return count;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (38, 'C++ 函数和结构体(按值传递)', 1, '##函数与结构体(按值传递)\r\n```\r\n#include<iostream>\r\n#include<cmath>\r\n#define pai 3.1415926   \r\nusing namespace std;\r\nstruct shuju                       //定义一个结构，放入我们需要用到的值；\r\n{\r\n	double x;                       //x的值；\r\n	double y;                       //y的值；\r\n	double distance;                //点到原点的距离；\r\n	double hudu;                    //原点与点的连线与x轴的角度；\r\n}; \r\nvoid juli(shuju xy);              //声明一个函数，用来计算distance和hudu的值；\r\n/*void display(shuju xy);  */             //声明一个函数进行输出；\r\nint main()\r\n{\r\n	shuju xy;                          //主函数内定义一个结构体类型的变量；\r\n	cin >> xy.x;                      //输入x，y的值\r\n	cin >> xy.y;         \r\n	/*display(juli(xy));       */   \r\n	juli(xy);\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid juli(shuju xy )                      //结构体类型定义一个变量；shuju xy；\r\n{\r\n	                       \r\n	xy.distance = sqrt(xy.x*xy.x + xy.y*xy.y);        //求distance；\r\n    xy.hudu = atan2(xy.y, xy.x)*pai;                 //求hudu；\r\n	cout << xy.distance << endl;\r\n	cout << xy.hudu << endl;\r\n	/*return JL;*/                                     //返回distance和hudu的值；\r\n} \r\n//void display(shuju jl)                           //这个函数定义一个结构体变量来调用distance和hudu的值；\r\n//{\r\n//	cout << jl.distance << endl;\r\n//	cout << jl.hudu << endl;\r\n//}\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (39, 'C++ 函数和结构体(按地址传递)', 1, '##函数与结构体(按地址传递)\r\n```\r\n#include<iostream>\r\n#include<cmath>\r\n#define pai 3.1415926\r\nusing namespace std;\r\nstruct shuju           //创建一个结构体shuju；\r\n{\r\n	double x;                         //x的值；\r\n	double y;                        //y的值；\r\n	double distance;                 //到原点的距离；\r\n	double hudu;                      //连线与x轴的角度；\r\n};\r\nvoid dist_and_hd(shuju *pxy);        //声明一个函数，用来输出距离和弧度；\r\nint main()\r\n{\r\n	shuju xy;                       //定义一个结构体类型的变量，用来调用结构体的内的类型；\r\n	cin >> xy.x;\r\n	cin >> xy.y;\r\n	dist_and_hd(&xy);                //()内放地址类型数据；   \r\n	system(\"pause\");\r\n	return 0; \r\n}\r\nvoid  dist_and_hd(shuju*pxy)                //定义之前声明的函数；\r\n{\r\n	pxy->distance = sqrt(pxy->x*pxy->x + pxy->y*pxy->y);       //用指针调用结构体内的值；\r\n	pxy->hudu = atan2(pxy->y, pxy->x)*pai;\r\n	cout << pxy->distance << endl;\r\n	cout << pxy->hudu << endl;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (40, 'C++ 函数的递归', 1, '##函数的递归\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nvoid digui(int n);\r\nint main()\r\n{\r\n	int a;\r\n	cin >> a;\r\n	digui(a);\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid digui(int n)\r\n{\r\n	\r\n	if (n < 4)\r\n	{\r\n		cout << n << \" \" << &n << endl;\r\n		digui(n + 1);\r\n	}\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (41, 'C++ 递归计算阶乘', 1, '##递归计算阶乘\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nint xunhuan(int);\r\nint digui(int);\r\nint main()\r\n{\r\n	int x;\r\n	cin >> x;\r\n	cout << xunhuan(x) << endl;\r\n\r\n	int y;\r\n	cin >> y;\r\n	cout << digui(y) << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nint xunhuan(int a)\r\n{\r\n	\r\n	int s=1;                           //s为阶乘；\r\n	for (int i=a; a > 1; a--)           //s的阶乘为s*(s-1)的阶乘；\r\n		s = s * a;\r\n\r\n		return s;                     //将s值返回给主函数；\r\n	\r\n}\r\nint digui(int b)\r\n{\r\n	int s;\r\n	if (b > 0)\r\n		s = b * digui(b - 1);\r\n	else\r\n		s = 1;\r\n	return s;\r\n\r\n}\r\n//递归，假设s=5；\r\n//s = 5 * digui（4）；\r\n//s = 5 * 4 * digui（3）；\r\n//s = 5 * 4 * 3 * digui（2）；\r\n//s = 5 * 4 * 3 * 2 * digui（1）；\r\n//s = 5 * 4 * 3 * 2 * 1 * digui(0);\r\n//digui(0)时 ，s=1；\r\n\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (42, 'C++ 递归画尺', 1, '##递归画尺\r\n```\r\n#include<iostream>\r\nconst int len = 120;               //限定标尺的长度；\r\nconst int n =8;                    //限定标尺的精确层数；\r\nvoid rule(int level, char arr[], int low, int high);//声明一个函数，函数内进行递归操作，将一个长度的标尺进行划分，\r\nusing namespace std;\r\nint main()\r\n{\r\n	char LLL[len];                  //定义一个字符串数组；数组的大小是100个字符；\r\n	for (int i = 1; i < len-2; i++) //将数组的初始化，两边都是‘|’,而中间都是空格，从数组的第二个字符到数组倒数第三个元素都是空格(最后一位是‘\\0’)\r\n	{\r\n		LLL[i] = \' \';\r\n	}\r\n	LLL[len-1] = \'\\0\';              //字符串要有结束字符，所以最后一位是\\0;\r\n	int max = len-2 ;               //定义数组的第一位和倒数第二位（最后一位是“\\0”）\r\n	int min = 0;\r\n	LLL[min] = LLL[max] = \'|\';      //初始化这两位是‘|’;\r\n	cout << LLL << endl;            //打印初始化后的字符串数组；\r\n	for (int i = 1; i <= n; i++)    //做一个循环，从第二层开始，因为第一层与其他的没有递归关系，一共循环7层；\r\n	{\r\n		rule(i, LLL, min, max);     //调用递归函数rule（第i+1层，数组LLL，min（low），max（high））；\r\n		cout << LLL << endl;        //输出第i+1层的LLL字符串数组；\r\n	}\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid rule(int level,char arr[],int low,int high)  //递归函数的定义，函数内包括变量精确层数，每一层都是一组数组，没精确到的层数用空格表示，精确到的地方用符号‘|’表示；\r\n{\r\n	if (level == 0)                               //递归函数的终止，level到0的时候停止递归；\r\n		return;\r\n	int mid = (low + high) / 2;                   //取两个边缘点的中间放入第一个‘|’;\r\n	arr[mid] = \'|\';\r\n	rule(level - 1, arr, low, mid);               //第一个mid分好之后分为左右两边，这时候左边low=low，high=mid。右边low=mid。high=high；所以一次函数调用两次递归；\r\n	rule(level - 1, arr, mid,high);\r\n}\r\n/**\r\n总结：\r\n  递归做标尺：\r\n  先取整块的最中间的位置做标记，这样标尺被分为左右俩侧，再对两侧进行划分。\r\n  每一侧再去中间做标记，这样左侧被分为两边，右侧也同样分成两边，依次递归进行划分。\r\n  首先先定义标尺的长度；\r\n  再次定义标尺的精度（递归的层数）；\r\n  构建递归函数：\r\n  递归函数要有终止，这里终止则设置为精度（层数）位0的时候；\r\n  每个划分标尺用的标记我们用字符‘|’,其中间的部分我们用空格来实现；\r\n  那么我们就有这几个变量：精度（层数），字符串，标尺的首位置和末位置；\r\n  函数里还要有中间位置mid，mid的值就是（首位置+莫位置）/2；每次划分之后首位置和末位置的值都会发生变化，这时候我们在使用递归函数时各个元素的值要进行改变；\r\n  构建主函数：\r\n  注意：当精度为0时并不是标尺不存在，而是为0时标尺仅有两端的值，不适应递归函数，所以这个问题我们在主函数这里进行处理；\r\n  首先我们把精度为0时字符串的情况进行赋值，之后的递归调用其实都是对字符串中间位置的值进行重新赋值成“|”;\r\n  首先首位置的值和末位置的值都是‘|’;其他的位置都是空格；\r\n  然后就是循环对函数进行调用了；\r\n*/\r\n```', 0);
INSERT INTO `blog_course` VALUES (43, 'C++ 函数指针', 1, '##函数指针\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\ndouble betsy(int);                        //声明函数betsy，函数接收int类型的数据，其返回值为double型；\r\ndouble pam(int);\r\nvoid estimate(int lines, double(*p)(int));//函数声明，函数第二个元素是一个函数的指针p，这个函数的返回值是double类型，只接受int类型的参数；\r\nint main()\r\n{\r\n	int code;                    \r\n	cin >> code;\r\n	estimate(code, betsy);      //调用函数estimate，函数内参数为code，和指针betsy（函数名就是函数的地址）；注意：betsy后面没有（）；有了就是函数的调用了；\r\n	estimate(code, pam);\r\n\r\n	cout << betsy(code) << endl;  //打印函数的值；\r\n	cout << pam(code) << endl;   //打印函数的值；\r\n	cout << betsy << endl;       //打印函数地址；\r\n	cout << pam << endl;         //打印函数地址；\r\n	cout << &betsy << endl;     //和其他元素一样，可以用取地址符来打印地址；\r\n	cout << &pam << endl;\r\n	double(*p1)(int);            //定义一个函数指针，函数的返回值是double类型，函数接受int类型的数据；\r\n	p1 = betsy;                  //指针指向betsy函数；*p1=betsy；\r\n	cout << p1 << endl;       //打印函数地址\r\n	cout << *p1 << endl;      //打印函数本身，其实也是地址\r\n	cout << p1(code) << endl;    //用指针调用函数的值\r\n	cout << (*p1)(code) << endl; //用函数调用函数的值，其原理和betsy（code）一样；\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ndouble betsy(int lns)  //函数定义\r\n{\r\n	return 0.05*lns;      \r\n}\r\ndouble pam(int lns)  //函数定义\r\n{\r\n	return 0.03*lns + 0.0004*lns*lns;\r\n}\r\nvoid estimate(int lines, double(*p)(int))  //estimate函数的定义\r\n{\r\n	cout << lines << endl;                 //输出主函数输入的值；\r\n	cout << (*p)(lines) << endl;          //输出函数的值；\r\n	cout << p << endl;                    //输出函数参数的地址；\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (44, 'C++ 深入探讨函数指针', 1, '##深入探讨函数指针\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n//这三种声明的方式都是一个意思\r\n//创建一个函数，其返回值是const double*类型，函数名为f1，f2，f3，函数成员为数组类型，整形类型；\r\nconst double * f1(const double ar[], int n);       //常规声明，函数（）内：double数组类型，数组名ar，int类型，成员名n；\r\nconst double * f2(const double[], int);            //声明函数时候可以省略标识符，而只显示成员类型：double 数组类型，int类型；\r\nconst double * f3(const double*, int);             //声明函数内成员数组时候其实际上是对其地址进行声明，所以可以写成double*ar，而这个可以简化为double*；\r\nint main()\r\n{\r\n	double av[3] = { 11112.3,1542.6,2227.9 };\r\n	const double*(*p1)(const double arr[], int n) = f1;  //定义一个函数，函数的成员为：double类型的数组，int类型的数据；\r\n	                                                     //返回值为double*类型（返回值是个地址）；\r\n	                                                     //同时定义了一个指针p1,指向这个函数，将f1的值赋值给了p1；\r\n	auto p2 = f2;                                        //自动判断类型，直接将指针f2赋值给了指针p；\r\n\r\n	cout << (*p1)(av, 3) << \":\" << *(p1)(av, 3) << endl; //用数组名（*p1）来调用函数f1；返回的是数组av的第一个元素的地址（11112.3的地址）；后面是值11112.3\r\n\r\n	cout << p2(av, 3) << \":\" << *p2(av, 3) << endl;      //p2代表地址的意思，同时可以是数组名f2；所以这里是用地址来调用函数f2；\r\n\r\n	const double*(*pa[3])(const double arr[], int n) = { f1,f2,f3 };\r\n	//这里创建的不是函数，而是一个指针数组(是个数组)，数组内存储三个函数的地址；而这个数组的类型为 const double*(*pa)（const double arr[],int n）;\r\n	//理论上这个数组应该是  const double*(*pa)(const double arr[],int n)[3],但是C++规定我们要把【3】写到前面；\r\n	auto pb = pa;    //自动判断类型，将指针数组pa赋值给pb；\r\n	for (int i = 0; i < 3; i++)    //使用循环将利用指针数组调用依次打印数组的地址和数组的值；\r\n	{\r\n		cout << pb[i](av, 3) << \":\" << *pb[i](av, 3) << endl;\r\n	}\r\n	auto pc = &pa;                  //自动判断类型取指针数组pa的地址；\r\n	//pc也就代表数组pa的地址，那么*p就代表指针数组本身pa；\r\n	cout << (*pc)[0](av, 3) << \":\" << *(*pc)[0](av, 3) << endl;  //利用*+指针数组地址来遍历数组内的元素；\r\n	const double*(*((*pd)[3]))(const double arr[], int n) = &pa;\r\n	//(*pd)[3] (const double arr[], int n): 指针数组pd\r\n	//(double*)*（（*pd）[3]）(const double arr[], int n) ：创建一个指针，指向指针数组，指针名为pd；\r\n	const double *pdb = (*pd)[1]( av,3 );  //定义一个指针pdb，将*pd（pd为指针数组的数组地址，*pd就是数组本身）的第二个元素赋值给pdb，\r\n	cout << pdb << \":\" << *pdb << endl;\r\n	cout << (*(*pd)[2])(av, 3) << \":\" << *(*(*pd)[2])(av, 3) << endl;\r\n	//*pd是数组本身，*pd[2]就是数组第三个元素的值（f1），f1是地址，那么*f1就是元素的值；\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nconst double*f1(const double ar[], int n)//函数定义；\r\n{\r\n	return ar;              //返回的是数组第一个元素的地址；\r\n}\r\nconst double *f2(const double ar[], int n)\r\n{\r\n	return ar + 1;      //由于地址+1，那么返回值就是第二个元素的地址；\r\n}\r\nconst double *f3(const double *ar, int n)\r\n{\r\n	return ar + 2;    //返回数组第三个元素的地址；\r\n}\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (45, 'C++ 内联函数', 1, '##内联函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\ninline double sq(double x)   //内联函数，函数声明和定义的时候前面要加上 inline ， \r\n{\r\n	return x * x;\r\n}\r\nint main()\r\n{\r\n	double x;\r\n	cin >> x;\r\n	cout << sq(x) << endl;\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (46, 'C++ 引用，指针，值', 1, '##引用，指针，值\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nvoid change1(int& a, int& b);           //引用变量\r\nvoid change2(int*pa, int*pb);\r\nvoid change3(int a, int b);\r\nint main()\r\n{\r\n	int A = 300;\r\n	int B = 400;\r\n	change1(A, B);                         //这里对AB的值进行了交换；\r\n	cout << \"A:\" << A << endl;            //400\r\n	cout << \"B:\" << B << endl;            //300\r\n	change2(&A, &B);                      //这里也对AB的值进行了交换\r\n	cout << \"A:\" << A << endl;            //300\r\n	cout << \"B:\" << B << endl;            //400\r\n	change3(A, B);\r\n	cout << \"A:\" << A << endl;\r\n	cout << \"B:\" << B << endl; \r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid change1(int& a, int& b)         //这里是按引用传递，看似是按值传递，但是&使得元素是按地址传递；\r\n{\r\n	int temp;             //先定义一个第三个元素；\r\n	temp = a;             //将a的值赋给它；\r\n	a = b;                //先将b的值赋值给a，这样b的值就交换过去了\r\n	b = temp;            //再将temp的值赋给b，这样a的值也交换给了b；\r\n}\r\nvoid change2(int*pa, int*pb)        //这里是按地址传递；\r\n{\r\n	int temp;\r\n	temp = *pa;\r\n	*pa = *pb; \r\n	*pb = temp;\r\n}\r\nvoid change3(int a, int b)   //这里a，b的值是复制了A，B值的“新变量”，因此改变a，b的值不会影响A，B的值。\r\n{\r\n	int temp;\r\n	temp = a;\r\n	a = b;\r\n	b = temp;\r\n}\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nvoid change1(int& a, int& b);           //引用变量\r\nvoid change2(int*pa, int*pb);\r\nvoid change3(int a, int b);\r\nint main()\r\n{\r\n	int A = 300;\r\n	int B = 400;\r\n	change1(A, B);                         //这里对AB的值进行了交换；\r\n	cout << \"A:\" << A << endl;            //400\r\n	cout << \"B:\" << B << endl;            //300\r\n	change2(&A, &B);                      //这里也对AB的值进行了交换\r\n	cout << \"A:\" << A << endl;            //300\r\n	cout << \"B:\" << B << endl;            //400\r\n	change3(A, B);\r\n	cout << \"A:\" << A << endl;\r\n	cout << \"B:\" << B << endl; \r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid change1(int& a, int& b)         //这里是按引用传递，看似是按值传递，但是&使得元素是按地址传递；\r\n{\r\n	int temp;             //先定义一个第三个元素；\r\n	temp = a;             //将a的值赋给它；\r\n	a = b;                //先将b的值赋值给a，这样b的值就交换过去了\r\n	b = temp;            //再将temp的值赋给b，这样a的值也交换给了b；\r\n}\r\nvoid change2(int*pa, int*pb)        //这里是按地址传递；\r\n{\r\n	int temp;\r\n	temp = *pa;\r\n	*pa = *pb; \r\n	*pb = temp;\r\n}\r\nvoid change3(int a, int b)   //这里a，b的值是复制了A，B值的“新变量”，因此改变a，b的值不会影响A，B的值。\r\n{\r\n	int temp;\r\n	temp = a;\r\n	a = b;\r\n	b = temp;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (47, 'C++ 引用与结构体', 1, '##引用与结构体\r\n```\r\n#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\nstruct jiegou\r\n{\r\n	string name;         \r\n	int made;\r\n	int attempts;\r\n	float percent;\r\n};\r\nvoid display(const jiegou &ft);   //声明函数，函数接受结构类型的形参，并引用形参；并对其限定（使其调用时不改变实参的值）；\r\nvoid set_pc(jiegou &ft);//声明函数，函数接受结构类型的形参，并引用形参，但是不对其限定；\r\njiegou &accumulate(jiegou &target, const jiegou & source);//函数声明，返回值为jiegou&类型，函数接受的形参为结构类型并引用，第二个形参前面加了限定；\r\nint main()\r\n{\r\n	jiegou one = { \"A\",13,14 };            //定义出6个结构类型的变量；\r\n	jiegou two = { \"B\",10,16 };\r\n	jiegou three = { \"C\",7,9 };\r\n	jiegou four = { \"D\",5,9 };\r\n	jiegou five = { \"E\",6,14 };\r\n	jiegou team = { \"F\",0,0 };              //accumulate \r\n\r\n	jiegou dup;\r\n	set_pc(one);             //先调用set_pc函数，对percent进行赋值；\r\n\r\n	display(one);            //显示完整的one；\r\n	accumulate(team, one);   //team.attempts=0;                                   team.made=0;\r\n	                         //one.attempts=14 ;                                  one.made=13;\r\n	                         //team.attempts=team.attempts+one.attempts=14;       team.made=team.made+one.made=13;\r\n	display(team);           //显示完整的team；\r\n\r\n	display(two);            //显示完整的two； 由于percent没有被定义那么就是0；\r\n	accumulate(accumulate(team, three), four);  //将three的值加算给team，返回team，再将four的值加算给team，那么team的值就是four的值；\r\n	                                            //team.made=13,team.attempts=14;\r\n	                                            //team.made=20,team.attempts=23;\r\n	                                            //team.made=25,team.attempts=32;\r\n	display(team);           //显示赋值后的team；\r\n\r\n	dup = accumulate(team, five);   //dup=team;   \r\n	                                //team.made=25,team.attempts=32;\r\n	                                //team.made=31,team.attempts=46;\r\n\r\n	display(team);             //显示team；//team.made=31,team.attempts=46;\r\n	display(dup);              //显示dup，dup的值和team是一样的；\r\n\r\n	set_pc(four);             //调用函数set_pc;  four.percent=55.555\r\n	accumulate(dup, five) = four;  //将five的值加算给dup，并回dup，再将four整体赋值给dup；\r\n	display(dup);             //显示dup的值和four是一样的55.555\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid display(const jiegou & ft)   //函数定义，直接输出ft在结构内各个类型的值；\r\n{\r\n	cout <<\"Name:\"<< ft.name << endl;\r\n	cout << \"Made:\" << ft.made << endl;\r\n	cout << \"Attempts:\" << ft.attempts << endl;\r\n	cout << \"Percent:\" << ft.percent << endl;\r\n}\r\nvoid set_pc(jiegou &ft)\r\n{\r\n	if (ft.attempts != 0)         \r\n	{\r\n		ft.percent = 100.0f*float(ft.made) / float(ft.attempts);\r\n	}\r\n	else\r\n		ft.percent = 0;\r\n}\r\njiegou &accumulate(jiegou &target, const jiegou & source)   \r\n{\r\n	target.attempts = target.attempts + source.attempts;\r\n	target.made = target.made + source.made;\r\n	set_pc(target);\r\n	return target;\r\n}\r\n//target：目标\r\n//source：分数\r\n//attempts：尝试\r\n//percent：百分比\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (48, 'C++ 函数重载', 1, '##函数重载\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nunsigned long left(unsigned long num, int ct);              //函数定义，函数接受长整形num，int ct整形；\r\nchar*left(const char*str, int n = 1);                       //函数重载，特征标必须不同；注意：是特征表不同，返回值类型可以不同，const和非const不区分特征标，引用和非引用也不进行区分特征\r\n                                                            //函数重载，函数接受char类型数据str，int类型n\r\nint main()\r\n{\r\n	const char*p = \"Hawaii!!\";\r\n	unsigned long n = 12345678;\r\n	int i;\r\n	char* temp;\r\n	for (i = 1; i < 10; i++)\r\n	{\r\n		cout << left(n, i) << endl;\r\n		temp = left(p, i);\r\n		cout << temp << endl;\r\n		delete[]temp;\r\n	}\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nunsigned long left(unsigned long num, int ct)\r\n{\r\n	int digits = 1;\r\n	unsigned long n = num;\r\n	if (ct == 0 || num == 0)\r\n	{\r\n		return 0;\r\n	}\r\n	while (n /= 10)   //自除运算,n=n/10;\r\n		digits++;\r\n	if (digits > ct)\r\n	{\r\n		ct = digits - ct;\r\n		while (ct--)\r\n			num /= 10;\r\n		return num;\r\n	}\r\n	else\r\n		return num;\r\n}\r\nchar *left(const char*str, int n)\r\n{\r\n	if (n < 0)\r\n		n = 0;\r\n	char*p = new char[n + 1];\r\n	int i;\r\n	for (i = 0; i < n&&str[i]; i++)\r\n	{\r\n		p[i] = str[i];\r\n	}\r\n	while (i <= n)\r\n		p[i++] = \'\\0\';\r\n	return p;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (49, 'C++ 函数模板', 1, '##函数模板\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\ntemplate<typename T>                    //创建一个模板T；\r\nvoid Swap( T &a, T &b);\r\nint main()\r\n{\r\n	int i = 10;\r\n	int j = 20;\r\n	cout << i << \",\" << j << endl;\r\n	Swap(i, j);\r\n	cout << i << \",\" << j << endl;\r\n	double x = 24.5;\r\n	double y = 81.7;\r\n	cout << x << \",\" << y << endl;\r\n	Swap(x, y);\r\n	cout << x << \",\" << y << endl;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ntemplate<typename T>\r\nvoid Swap( T &a,  T &b)\r\n{\r\n	T temp;\r\n	temp = a;\r\n	a = b;\r\n	b = temp;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (50, 'C++ 模板重载', 1, '##模板重载\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\ntemplate<typename T>\r\nvoid Swap(T &a, T &b);\r\n\r\ntemplate<typename T>     //模板声明\r\nvoid Swap(T*a, T*b, int n);\r\n\r\nvoid Show(int a[]);\r\n\r\nconst int Lim = 8;\r\nint main()\r\n{\r\n	int i = 10;\r\n	int j = 20;\r\n	cout << i << \",\" << j << endl;\r\n\r\n	Swap(i, j);\r\n	cout << i << \",\" << j << endl;\r\n\r\n	int d1[Lim] = { 0,7,0,4,1,7,7,6 };\r\n	int d2[Lim] = { 0,7,2,0,1,9,6,7 };\r\n\r\n	Show(d1);\r\n	Show(d2);\r\n\r\n	Swap(d1, d2, Lim);\r\n\r\n	Show(d1);\r\n	Show(d2);\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ntemplate<typename T>\r\nvoid Swap(T &a, T &b)\r\n{\r\n	T temp;\r\n	temp = a;\r\n	a = b;\r\n	b = temp;\r\n}\r\ntemplate<typename T>\r\nvoid Swap(T *a, T *b, int n)\r\n{\r\n	T temp;\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		temp = a[i];\r\n		a[i] = b[i];\r\n		b[i] = temp;\r\n	}\r\n}\r\nvoid Show(int a[])\r\n{\r\n	cout << a[0] << a[1] << \"/\";\r\n	cout << a[2] << a[3] << \"/\";\r\n	for (int i = 4; i < Lim; i++)\r\n	{\r\n		cout << a[i];\r\n	}\r\n	cout << endl;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (51, 'C++ 模板的局限性', 1, '##模板的局限性\r\n\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\ntemplate<typename T>    //常规模板，用来交换两个数据\r\nvoid Swap(T &a, T &b);\r\nstruct job              //创建一个结构\r\n{\r\n	char name[40];\r\n	double salary;\r\n	int floor;\r\n};\r\ntemplate<>\r\nvoid Swap<job>(job &j1, job &j2);  //声明函数，指明其函数接受数据的类型用<>,在前面加上template关键字（显示实例化）\r\n\r\nvoid Show(job &j);  //创建一个函数用来输出结构类型的数据；\r\nint main()\r\n{\r\n	cout.precision(2);\r\n	cout.setf(ios::fixed,ios::floatfield);\r\n	int i = 10;\r\n	int j = 20;\r\n	cout << i << \" \" << j << endl;\r\n	Swap(i, j);\r\n	cout << i << \",\" << j << endl;\r\n\r\n	job sue = { \"myk\",73000.60,7 };\r\n	job sidney = { \"xyh\",78060.72,9 };\r\n	\r\n	Show(sue);\r\n	Show(sidney);\r\n\r\n	swap(sue, sidney);\r\n\r\n	Show(sue);\r\n	Show(sidney);\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ntemplate<typename T>\r\nvoid Swap(T &a, T &b)    //函数定义，交换a，b；\r\n{\r\n	T temp;\r\n	temp = a;\r\n	a = b;\r\n	b = temp;\r\n}\r\ntemplate<>\r\nvoid Swap<job>(job &j1, job &j2)\r\n{\r\n	double t1;\r\n	int t2;\r\n	t1 = j1.salary;\r\n	j1.salary = j2.salary;\r\n	j2.salary = t1;\r\n\r\n	t2 = j1.floor;\r\n	j1.floor = j2.floor;\r\n	j2.floor = t2;\r\n}\r\nvoid Show(job &j)\r\n{\r\n	cout << j.name << \",\" << j.salary << \",\" << j.floor << endl;\r\n}\r\n\r\n//实例化有两种形式，分别为显示实例化和隐式实例化。模板并不是函数定义。\r\n//显示实例化：\r\n//显示实例化意味着可以直接命令编译器创建特定的实例\r\n//1.比如这么个模板函数\r\n//      template <typename T>\r\n//      void Swap(T &a,T &b)\r\n//第一种方法声明所需的种类，用<>符号来指定类型，并在声明前加上关键字 template\r\n//例如：  template void Swap<int>(int &,int &);\r\n//第二种方法是直接在程序中使用函数创建，\r\n//例如：   Swap<int>(a,b);\r\n//\r\n//隐式实例化:就是最简单的调用 Swap(a,b),编译器根据参数来定义函数实例；\r\n//显示具体化：template<> void Swap<job>(job& a,job &b);\r\n//            template<> void Swap(job &a, job &b);\r\n//备注：隐式实例化和显示实例化和显示具体化统称为具体化，它们的相同在于都用具体类型的函数定义，\r\n//而不是通用描述\r\n//\r\n//\r\n//总结：显示实例化，用来实例化常规的类型；  而显示具体化，用来具体的将结构内，类，中的具体类型进行实例化；\r\n//显示实例化：template void Swap<int>(int &,int &);         \r\n//显示具体化：template <> void Swap<job>(job &a,job &b);     \r\n//两种具体化的关键字是不一样的；\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (52, 'C++ new运算符和定位符', 1, '##new运算符和定位符\r\n```\r\n#include <iostream>\r\n#include<new>      //头文件new才可以使用new定位符\r\nusing namespace std;\r\nconst int BUF = 512;\r\nconst int N = 5;\r\nchar buffer[BUF];     //全局变量\r\nint main()\r\n{\r\n\r\n	double *p1= new double[N];;           //创建一个double类型，大小为N的数组空间，并将地址赋值给p1；\r\n	double *p2= new(buffer)double[N];;    //从buffer里申请N个double类型的空间，并将地址赋值给p2；\r\n	\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		p2[i] = p1[i] = 1000 + 20.0*i;\r\n	}\r\n	cout <<p1<<\",\"<<(void*) buffer << endl;     //打印p1指针，和buffer地址，由于buffer 是char类型数组，所以不能直接输出数组名来打印地址；\r\n\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		cout << p1[i] << \",\" << &p1[i] << endl;\r\n		cout << p2[i] << \",\" << &p2[i] << endl;   //循环打印p1 p2空间的数据和对应的地址；\r\n	}\r\n	cout << endl;\r\n	double *p3;\r\n	double *p4;\r\n	p3 = new double[N];\r\n	p4 = new (buffer)double[N];\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		p4[i] = p3[i] = 1000 + 40.0*i;\r\n	}\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		cout << p3[i] << \",\" << &p3[i] << endl;\r\n		cout << p4[i] << \",\" << &p4[i] << endl;\r\n	}\r\n	delete[]p1;\r\n	cout << endl;\r\n	p1 = new double[N];\r\n	p2 = new(buffer + N * sizeof(double))double[N];   //从buffer数组的开头开始进行分配内存，大小为N，并将地址赋值给p2；\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		p2[i] = p1[i] = 1000 + 60 * i;\r\n	}\r\n	for (int i = 0; i < N; i++)\r\n	{\r\n		cout << p1[i] << \",\" << &p1[i] << endl;\r\n		cout << p2[i] << \",\" << &p2[i] << endl;\r\n	}\r\n	delete[]p1;\r\n	delete[]p3;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//注意：由new定位符申请的空间不需要用delete释放\r\n```', 0);
INSERT INTO `blog_course` VALUES (53, 'C++ 命名空间', 1, '##命名空间\r\n\r\n```\r\n#include<iostream>\r\n#include\"namesp.h\"\r\nusing namespace std;\r\nnamespace pers\r\n{\r\n	void getPerson(Person & rp)\r\n	{\r\n		cout << \"Enter first name:\";\r\n		cin >> rp.fname;\r\n		cout << \"Enter last name:\";\r\n		cin >> rp.lname;\r\n	}\r\n	void showPerson(const Person &rp)\r\n	{\r\n		cout << rp.lname << \",\" << rp.fname;\r\n	}\r\n}\r\nnamespace debts\r\n{\r\n	void getDebt(Debt &rd)\r\n	{\r\n		getPerson(rd.name);\r\n		cout << \"Enter debt:\";\r\n		cin >> rd.amount;\r\n	}\r\n	void showDebt(const Debt&rd)\r\n	{\r\n		showPerson(rd.name);\r\n		cout << \":$\" << rd.amount << endl;\r\n	}\r\n	double sumDebts(const Debt ar[], int n)\r\n	{\r\n		double total = 0;\r\n		for (int i = 0; i < n; i++)\r\n		{\r\n			total = total + ar[i].amount;\r\n		}\r\n		return total;\r\n	}\r\n}\r\n```\r\n#头文件\r\n```\r\n#pragma once\r\n#include<string>\r\nnamespace pers\r\n{\r\n	struct Person\r\n	{\r\n		std::string fname;\r\n		std::string lname;\r\n	};\r\n	void getPerson(Person &);\r\n	void showPerson(const Person &);\r\n\r\n}\r\nnamespace debts\r\n{\r\n	using namespace pers;\r\n	struct Debt\r\n	{\r\n		Person name;\r\n		double amount;\r\n	};\r\n	void getDebt(Debt &);\r\n	void showDebt(const Debt &);\r\n	double sumDebts(const Debt ar[], int n);\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (54, 'C++ 类与对象', 1, '##类与对象\r\n```\r\n#include<iostream>\r\n//注意这个函数是用来实现每一个函数的，另一个头文件是用来调用的；\r\n#include \"stock00.h\"     //打开头文件  ，头文件内包含着函数的声明和变量；\r\nvoid Stock::acquire(const std::string &co, long n, double pr)   //一个一个实现头文件里类的函数；\r\n{\r\n	//函数的内部可以直接使用类中的成员；\r\n	company = co;\r\n	if (n < 0)\r\n	{\r\n		std::cout << \"Number of share can\'t be negative;\" << company << \"share set to 0.\" << std::endl;\r\n		shares = 0;\r\n	}\r\n	else\r\n		shares = n;\r\n	share_val = pr;\r\n	set_tot();\r\n}\r\nvoid Stock::buy(long num, double price)\r\n{\r\n	if (num < 0)\r\n	{\r\n		std::cout << \"Number of share can\'t be negative;\" << \"Transaction is aborted.\" << std::endl;\r\n	}\r\n	else\r\n	{\r\n		shares = shares + num;\r\n		share_val = price;\r\n		set_tot();\r\n	}\r\n}\r\nvoid Stock::sell(long num, double price)\r\n{\r\n	using std::cout;\r\n	if (num < 0)\r\n	{\r\n		cout << \"Number of shares sold can\'t be negative.\" << \"Transaction is aborted.\" << std::endl;\r\n	}\r\n	else\r\n	{\r\n		shares = shares + num;\r\n		share_val = price;\r\n		set_tot();\r\n	}\r\n}\r\nvoid Stock::update(double price)\r\n{\r\n	share_val = price;\r\n	set_tot();\r\n}\r\nvoid Stock::show()\r\n{\r\n	std::cout << \"Company:\" << company << \"Shares:\" << shares << std::endl\r\n		<< \"Share Price:$\" << share_val << \"Total Worth:$\" << total_val << std::endl;\r\n}\r\n```\r\n\r\n##stock00.h\r\n\r\n```\r\n#pragma once\r\n#include<string>\r\n\r\nclass Stock\r\n{\r\nprivate:\r\n	std::string company;   //公司名\r\n	long shares;            //股票\r\n	double share_val;       \r\n	double total_val;\r\n	void set_tot()    //内联函数,\r\n		//内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都用的，最简单的方法是：将内联函数定义放在定义类的头文件中\r\n	{\r\n		total_val = shares * share_val;\r\n	}\r\npublic:\r\n\r\n	void acquire(const std::string &co, long n, double pr);\r\n	void buy(long num, double price);\r\n	void sell(long num, double price);\r\n	void update(double price);\r\n	void show();\r\n};\r\n\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (55, 'C++ 构造函数', 1, '##构造函数\r\n```\r\n#include<iostream>\r\n\r\nclass Student\r\n{\r\npublic://private\r\n	int num;\r\n	int age;\r\npublic:\r\n\r\n	Student()   //系统自带的构造函数\r\n	{\r\n	}\r\n	//默认构造函数\r\n	Student()                  //如果变量是私有的时候需要使用构造函数对其进行初始化\r\n	{                                  \r\n		//没有参数，\r\n		//直接进行赋值\r\n		num = 1001;\r\n		age = 18;        //直接在函数内对其进行赋值\r\n	}\r\n	//初始化构造函数\r\n	Student(int a, int b):num(a),age(b)   //初始化列表\r\n	{//传参，将传进来的a，b的值传给类中的 num，和 age\r\n	\r\n	}\r\n\r\n	//有参构造函数\r\n	Student(int a, int b)     //赋值\r\n	{\r\n		num = a;\r\n		age = b;\r\n	}\r\n	//拷贝构造函数\r\n	Student(Student &a) :num(a.num), age(a.age)  \r\n	{\r\n		//(1):用一个已有的对象初始化一个新对象的时候\r\n		//(2)：将一个对象以值的传递方式传递给形参的时候\r\n		//(3):函数返回一个对象的时候；\r\n	}\r\n	void show()\r\n	{\r\n		std::cout << num << \",\" << age << std::endl;\r\n	}\r\n};\r\nint main()\r\n{\r\n\r\n	using namespace std;\r\n	//当类中的值是公有时可以这样对其赋值初始化\r\n	Student s1;\r\n	s1.age = 1011;\r\n	s1.num = 20;\r\n	s1.show();\r\n	\r\n	//使用默认构造函数\r\n	Student s2;\r\n	s2.show();\r\n\r\n	//使用有参构造函数对成员进行初始化；\r\n	Student s3(20.3, 30.5);\r\n	s3.show();\r\n\r\n	Student s4(s3);  //调用拷贝构造函数；\r\n	//Student s4=s3     //这里同样是调用拷贝构造函数，但是这里s4是不存在的，要通过s3对其进行构造和初始化\r\n	s4.show();\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (56, 'C++ 列表初始化和析构函数', 1, '##列表初始化和析构函数\r\n```\r\n#include<iostream>\r\nconst int M = 10;\r\nstruct  ceshi\r\n{\r\n	int a;\r\n	double b;\r\n};\r\nclass Person\r\n{\r\nprivate:\r\n	int *a;\r\n	ceshi* b;\r\n\r\npublic:\r\n	Person(int *p, ceshi *b) //构造函数\r\n	{\r\n		a = p;\r\n		this->b = b;\r\n		std::cout << \"构造函数\" << std::endl;\r\n	}\r\n	~Person()           //析构函数\r\n	{\r\n		std::cout << \"析构函数\" << std::endl;\r\n	}\r\n	void show()\r\n	{\r\n		for (int i = 0; i < M; i++)\r\n		{\r\n			std::cout << a[i] << \" \";\r\n		}\r\n		std::cout << (*b).a << \",\" << (*b).b << std::endl;\r\n	}\r\n};\r\nint main()\r\n{\r\n	using namespace std;\r\n	int *p = new int[M];\r\n	int b;\r\n	for (int i = 0; i < M; i++)\r\n	{\r\n		cin >> b;\r\n		p[i] = b;\r\n	}\r\n	ceshi *b1 = new ceshi;\r\n	*b1 = { 1,2.3 };\r\n	Person*a = new Person(p, b1);    //调用一次构造函数\r\n	a->show();                        //调用show函数\r\n\r\n	Person p2(p,b1);        //这里就不需要使用delete进行释放，函数会自动调用析构函数对对象进行释放；\r\n\r\n	p2.show();       \r\n\r\n\r\n	delete p;               //当使用new创建空间的时候 要使用delete进行释放，\r\n	delete b1;             \r\n	//delete a;       //new创建的对象，需要使用delete进行释放，只有使用delete时才会调用析构函数\r\n	\r\n	return 0;\r\n}\r\n////指针是个好东西；\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (57, 'C++ this指针', 1, '##this指针\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nclass Person\r\n{\r\nprivate:\r\n	int a;\r\npublic:\r\n	Person(int a)\r\n	{\r\n		this->a = a;           //区分类中的变量和参数变量\r\n		this->show();          //this指针不是成员，是类成员函数的隐藏参数；\r\n	}\r\n	//this是特殊指针，this指针指向用来调用成员函数的对象\r\n	Person *this_t()           //返回对象的地址   //创建一个返回值类型为Person*类型的函数，并且输出对象的地址\r\n	{\r\n		cout << this << endl;\r\n		return 0;\r\n	}\r\n\r\n	void show()\r\n	{\r\n		cout << a << endl;\r\n	}\r\n};\r\nint main()\r\n{\r\n	int a;\r\n	cin >> a;\r\n	Person p(a);\r\n	p.show();\r\n	p.this_t();\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (58, 'C++ 常函数', 1, '##常函数\r\n```\r\n#include <iostream>\r\n\r\nclass Student\r\n{\r\nprivate:\r\n	int id;\r\npublic:\r\n	Student(int id);\r\n	void show() const;  //常函数，不能修改数据成员，但是可以使用,可以更好的声明函数（这里是只能输出，不能进行其他操作）\r\n	void fun();\r\n};\r\nvoid Student::fun()\r\n{\r\n	std::cout << id << std::endl;\r\n}\r\nStudent::Student(int id)\r\n{\r\n	this->id = id;\r\n}\r\nvoid Student::show()const\r\n{\r\n	int a = 10;\r\n	a = this->id*a;       //内部成员是可以修改的，\r\n	std::cout << a << std::endl;\r\n}\r\nint main()\r\n{\r\n	const Student st1(5);  //常对象只能调用常函数\r\n	st1.show();\r\n	//st1.fun();       //错误\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (59, 'C++ static成员', 1, '##static成员\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nclass Box\r\n{\r\nprivate:\r\n	double length;\r\n	double breadth;\r\n	double height;\r\n	\r\npublic:\r\n	static int objectCount;       //类内静态成员不可以直接进行初始化，（这里是声明）\r\n	//static const int  objectCount = 5;  可以使用const对整形静态成员进行初始化，但是初始化就不能再进行更改，使用const进行定义后就变成常量了\r\n	//构造函数\r\n	Box(double l, double b, double h )    //在这里只能进行赋值，不能进行初始化和定义\r\n	{\r\n		this->length = l;\r\n		this->breadth = b;\r\n		this->height = h;\r\n		objectCount++;\r\n	}\r\n	double Volume() \r\n	{\r\n		return length + breadth + height;\r\n	}\r\n	//如果把成员函数声明为静态的，就可以把函数与类的任何对象独立开来，静态成员函数即使在类对象不存在的情况下也能被调用\r\n	//静态函数只要使用类名加范围解析运算符：：就可以访问\r\n	//注意：1.静态成员函数只能访问静态成员数据，其他静态成员函数和类外部的其他函数；\r\n	      //2.静态成员函数有一个范围，所以不能访问类的this指针\r\n	static int getCount()             //静态成员函数\r\n	{\r\n		return objectCount;\r\n	}\r\n};\r\nint Box::objectCount = 5;    //类外初始化类内静态成员\r\nint main()\r\n{\r\n	Box*b1 = new Box(3.3, 1.2, 1.5);\r\n	Box*b2 = new Box(8.5, 6.0, 2.0);\r\n\r\n	cout << b1->Volume() << endl;\r\n	cout << b2->Volume() << endl;\r\n	cout << Box::objectCount << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//静态成员遍历在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存\r\n//如果不加定义就会报错，初始化是一个初始值，而定义是分配内存；\r\n```', 0);
INSERT INTO `blog_course` VALUES (60, 'C++ 拷贝构造函数(浅拷贝)', 1, '##拷贝构造函数(浅拷贝)\r\n```\r\n#include<iostream>\r\nclass Student\r\n{\r\nprivate:\r\n	int b;\r\n	char c[4];\r\npublic:\r\n	Student()\r\n	{\r\n		b = 50;\r\n		strcpy_s(c, sizeof(c), \"acb\");    //对字符串进行初始化\r\n	}\r\n	Student(const Student &a)   //拷贝构造函数就是利用已有对象对其他对象进行初始化赋值(浅拷贝)\r\n	{\r\n		this->b = a.b;\r\n		strcpy_s(this->c, sizeof(a.c), a.c);\r\n	}\r\n};\r\nvoid fun(Student s)\r\n{\r\n\r\n}\r\nStudent fun()\r\n{\r\n	Student a;\r\n	return a;\r\n}\r\nint main()\r\n{\r\n\r\n	Student s1;\r\n	Student s2(s1);    //调用拷贝函数\r\n	Student s3 = s1;   //调用拷贝函数\r\n	Student s4 = Student(s1);   //调用拷贝函数\r\n	Student*s5 = new Student(s1);  //调用拷贝构造函数\r\n	Student s6;\r\n	s6 = s1;   //单纯的赋值，什么都没有调用\r\n\r\n	fun(s1);   //当函数以对象为参数的时候，这里调用拷贝构造函数\r\n	fun();   //当程序运行到return a 的时候fun函数调用拷贝构造函数\r\n\r\n	return 0;\r\n}\r\n//注意系统自带是有默认的拷贝构造函数的\r\n//也可以自己创建拷贝构造函数,这样程序就会走自己创建的构造函数\r\n```', 0);
INSERT INTO `blog_course` VALUES (61, 'C++ 拷贝构造函数(深拷贝)', 1, '##拷贝构造函数(深拷贝)\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nclass Student\r\n{\r\nprivate:\r\n	int *a;                    //指针成员不可以调用浅拷贝构造函数\r\npublic:\r\n	Student(int x,int y)   //构造函数\r\n	{\r\n		a = new int[2];   //对数组进行赋值\r\n		a[0] = x;\r\n		a[1] = y;\r\n		cout << \"构造函数\" << endl;	\r\n	}\r\n	Student(const Student &b)    //拷贝构造函数\r\n	{\r\n		this->a = new int[2];         //自己写拷贝构造，这样重新申请一块空间，这样就不会释放同一块地址了\r\n		this->a[0] = b.a[0];\r\n		this->a[1] = b.a[1];\r\n		cout << \"拷贝构造函数\" << endl;\r\n	}\r\n\r\n	~Student()                  //析构函数\r\n	{\r\n		cout << \"析构函数\" << endl;\r\n		delete []a;\r\n	}\r\n	void display()\r\n	{\r\n		cout << a[0] << \",\" << a[1] << endl;\r\n	}\r\n};\r\nconst Student &fun(const Student& s)    //对象做参数的时候，系统会创建一个局部对象s，调用拷贝构造函数\r\n//当这里使用引用做参数的时候，这里的&s就是传进来的s1,（因为按引用传递的本质是按地址进行传递）就省去了系统自动创建局部对象的过程。\r\n//同是也省去了系统调用拷贝构造函数对局部对象进行赋值的过程。\r\n//当引用做返回值的时候，系统在return s的时候，也是直接把这个s进行返回了，省去了再创建临时对象的过程。\r\n{\r\n	return s;\r\n}                       //函数结束的时候会调用析构函数来释放掉临时对象\r\nint main()\r\n{\r\n	Student *s1=new Student(10,20);\r\n	s1->display();\r\n\r\n	Student*s2 = new Student(*s1);      //如果不重写拷贝构造函数，就会产生释放同一块地址的bug，导致程序崩溃\r\n	s2->display();\r\n	cout << endl;\r\n\r\n	Student s3 = fun(*s1);                  //用对象s1对局部对象s进行初始化\r\n	s3.display();\r\n	cout << endl;\r\n\r\n	delete s1;\r\n	delete s2;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (62, 'C++ 内联函数', 1, '```\r\n//内联函数是当你调用该函数的时候会直接把内联函数的代码复制在调用的部分，不需要跳转，但是会使代码的数量增加\r\n#include<iostream>\r\nusing namespace std;\r\n#define SUM(x) x*x\r\n\r\ninline int fun(int i);   //当代码十分短的时候可以使用内联函数\r\n\r\nclass Student\r\n{\r\nprivate:\r\n	int a;\r\npublic:\r\n	Student(int s)\r\n	{\r\n		a = s;\r\n	}\r\n	void fun()     //隐式定义   inline ,\r\n	{\r\n		cout << a << endl;\r\n	}\r\n	//类内的函数都是内联函数\r\n	void fun1();\r\n};\r\n\r\nvoid Student::fun1()  //类外定义的不是内联函数\r\n{\r\n\r\n}\r\nint main()\r\n{\r\n	cout << SUM(2 + 3) << endl;  //纯属替换的过程  2+3*2+3  ，先计算的乘法，在执行加法\r\n	cout << fun(2 + 3) << endl;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ninline int fun(int i)\r\n{\r\n	return i * i;\r\n}\r\n//注意：递归函数不能是内联函数\r\n//内联函数一般都写在头文件里\r\n```', 0);
INSERT INTO `blog_course` VALUES (63, 'C++ 运算符重载(计算时间)', 1, '##运算符重载(计算时间)\r\n```\r\n#include<iostream>\r\n#include \"mytime0.h\"\r\n\r\nint main()\r\n{\r\n	using std::cout;\r\n	using std::endl;\r\n\r\n	Time planning;\r\n	Time coding(2, 40);\r\n	Time fixing(5, 55);\r\n	Time total;\r\n\r\n	cout << \"planning time =\";\r\n	planning.Show();\r\n	cout << endl;\r\n	\r\n	cout << \"coding time =\";\r\n	coding.Show();\r\n	cout << endl;\r\n\r\n	cout << \"fixing time =\";\r\n	fixing.Show();\r\n	cout << endl;\r\n\r\n	Time a = planning + coding + fixing;\r\n	a.Show();\r\n	cout << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###mytime0.h定义\r\n```\r\n#include<iostream>\r\n#include \"mytime0.h\"\r\n\r\nTime::Time()\r\n{\r\n	hours = 0;\r\n	minutes = 0;\r\n}\r\nTime::Time(int h, int m)\r\n{\r\n	hours = h;\r\n	minutes = m;\r\n}\r\nvoid Time::AddMin(int m)  //分钟相加\r\n{\r\n	minutes = minutes + m;\r\n	hours = hours + minutes / 60;  //小时数等于分钟数除60+原小时\r\n	minutes = minutes % 60;        //之后的分钟数等于对60取余的值\r\n}\r\nvoid Time::AddHr(int h)\r\n{\r\n	hours = hours + h;\r\n}\r\nvoid Time::Reset(int h, int m)  //重新设置时间\r\n{\r\n	hours = h;\r\n	minutes = m;\r\n}\r\nTime Time::operator+(const Time&t)const         \r\n{\r\n	Time sum;\r\n	sum.minutes = minutes + t.minutes;\r\n	sum.hours = t.hours + sum.minutes / 60;\r\n	sum.minutes = sum.minutes % 60;\r\n	return sum;\r\n}\r\nvoid Time::Show()const\r\n{\r\n	std::cout << hours << \"hours,\" << minutes << \"minutes\";	\r\n}\r\n```\r\n\r\n###mytime0.h\r\n\r\n```\r\n#pragma once\r\nclass Time\r\n{\r\nprivate:\r\n	int hours;      //小时\r\n	int minutes;    //分钟\r\npublic:\r\n	Time();//无参构造函数\r\n	Time(int h, int m = 0);//有参构造函数\r\n	void AddMin(int m);\r\n	void AddHr(int h);\r\n	void Reset(int h = 0, int m = 0);\r\n	Time operator+(const Time&t)const;\r\n	void Show()const;\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (64, 'C++ 运算符重载(加法)', 1, '##运算符重载(加法)\r\n```\r\n#include<iostream>\r\n//运算符重载是为了让对象之间可进行运算\r\nclass Student\r\n{\r\npublic:\r\n	int a;\r\n	int b;\r\npublic:\r\n	Student(int a,int b)\r\n	{\r\n		this->a = a;\r\n		this->b = b;\r\n	}\r\n	void show()\r\n	{\r\n		std::cout << a << b << std::endl;\r\n	}\r\n\r\n};\r\nint operator+(Student& s1, Student &s2)\r\n{\r\n	return s1.a + s2.a;\r\n}\r\nint main()\r\n{\r\n	Student s1(5,6);\r\n	Student s2(10, 11);\r\n\r\n	int s3 = s1 + s2;//不允许\r\n	std::cout << s3 << std::endl;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (65, 'C++ 其他运算符重载', 1, '##其他运算符重载\r\n```\r\n#include<iostream>\r\n#include \"mytime2.h\"\r\n\r\nint main()\r\n{\r\n	using std::cout;\r\n	using std::endl;\r\n	Time weeding(4, 35);\r\n	Time waxing(2, 47);\r\n	Time total;\r\n	Time diff;\r\n	Time adjusted;\r\n\r\n	cout << \"weeding time = \";\r\n	weeding.show();\r\n	cout << endl;\r\n\r\n	cout << \"waxing time = \";\r\n	waxing.show();\r\n	cout << endl;\r\n\r\n	cout << \"total work time = \";\r\n	total = weeding + waxing;\r\n	total.show();\r\n	cout << endl;\r\n\r\n	diff = weeding - waxing;\r\n	cout << \"weeding time - waxing time =\";\r\n	diff.show();\r\n	cout << endl;\r\n\r\n	adjusted = total * 1.5;\r\n	cout << \"adjusted work time = \";\r\n	adjusted.show();\r\n	cout << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###mytime2.h定义\r\n```\r\n#include <iostream>\r\n#include \"mytime2.h\"\r\n\r\nTime::Time()\r\n{\r\n	hours = 0;\r\n	minutes = 0;\r\n}\r\nTime::Time(int h, int m)\r\n{\r\n	hours = h;\r\n	minutes = m;\r\n}\r\nvoid Time::AddMin(int m)\r\n{\r\n	minutes = m;\r\n	hours = hours + minutes / 60;\r\n	minutes = minutes % 60;\r\n}\r\nvoid Time::AddHr(int h)\r\n{\r\n	hours = hours + h;\r\n}\r\nvoid Time::Reset(int h, int m)\r\n{\r\n	hours = h;\r\n	minutes = m;\r\n}\r\nTime Time::operator+(const Time &t)const    //重载+号\r\n{\r\n	Time sum;\r\n	sum.minutes = this->minutes + t.minutes;\r\n	sum.hours = this->hours + t.hours;\r\n	sum.minutes = sum.minutes % 60;\r\n	return sum;\r\n}\r\nTime Time::operator-(const Time&t)const    //重载-号\r\n{\r\n	Time diff;\r\n	int tot1;\r\n	int tot2;\r\n	tot1 = t.minutes + 60 * t.hours;\r\n	tot2 = this->minutes + 60 * hours;\r\n	diff.minutes = (tot2 - tot1) % 60;\r\n	diff.hours = (tot2 - tot1) / 60;\r\n	return diff;\r\n}\r\nTime Time::operator*(double mult)const   //重载*号\r\n{\r\n	Time result;\r\n	long totalminutes = hours * mult * 60 + minutes * mult;\r\n	result.hours = totalminutes / 60;\r\n	result.minutes = totalminutes % 60;\r\n	return result;\r\n}\r\nvoid Time::show()const\r\n{\r\n	std::cout << hours << \"hours,\" << minutes << \"minutes\";\r\n}\r\n```\r\n\r\n#mytime2.h\r\n```\r\n#pragma once\r\nclass Time\r\n{\r\nprivate:\r\n	int hours;\r\n	int minutes;\r\npublic:\r\n	Time();\r\n	Time(int h, int m = 0);\r\n	void AddMin(int m);\r\n	void AddHr(int h);\r\n	void Reset(int h = 0, int m = 0);\r\n	Time operator+(const Time & t)const;  //重载运算符+\r\n	Time operator-(const Time & t)const;  //重载运算符-\r\n	Time operator*(double n)const;        //重载运算符*；\r\n	void show()const;\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (66, 'C++ 友元函数', 1, '##友元函数\r\n```\r\n//友元有3种：友元函数，友元类，友元成员函数\r\n#include<iostream>\r\nusing namespace std;\r\nclass Time\r\n{\r\nprivate:\r\n	int hours;\r\n	int minutes;\r\n	int seconds;\r\npublic:\r\n	//构造函数\r\n	Time();\r\n	Time(int hours, int minutes, int seconds);\r\n	//运算符重载\r\n	Time operator+(const Time& t1)const;\r\n	Time operator*(const double& x)const;\r\n	friend Time operator*(double m, const Time &t);  //友元函数声明的时候要放在类内，并加上关键字 friend\r\n	//注意：函数定义的时候不需要加friend，由于他不是类内的成员，所以也无需用类名加作用域解析符：：\r\n	void display();\r\n};\r\nTime::Time()\r\n{\r\n	hours = 0;\r\n	minutes = 0;\r\n	seconds = 0;\r\n\r\n}\r\nTime::Time(int hours, int minutes, int seconds)\r\n{\r\n	this->hours = hours;\r\n	this->minutes = minutes;\r\n	this->seconds = seconds;\r\n}\r\nTime Time::operator+(const Time &t1)const\r\n{\r\n	Time sum;\r\n	sum.seconds = this->seconds + t1.seconds;\r\n	sum.minutes = this->minutes + t1.minutes + sum.seconds / 60;\r\n	sum.hours = this->hours + t1.hours + sum.minutes / 60;\r\n	sum.seconds = sum.seconds % 60;\r\n	sum.minutes = sum.minutes % 60;\r\n\r\n	return sum;\r\n}\r\n \r\nTime Time::operator*(const double &x)const    //重载乘法\r\n{\r\n	Time sum;\r\n	sum.seconds = this->seconds*x;\r\n	sum.minutes = sum.seconds / 60 + this->minutes*x;\r\n	sum.hours = sum.minutes / 60 + this->hours*x;\r\n	sum.seconds = sum.seconds % 60;\r\n	sum.minutes = sum.minutes % 60;\r\n	return sum;\r\n}\r\n\r\nvoid Time::display()\r\n{\r\n	cout << \"总时间为：\" << hours << \"小时\" << \" \" << minutes << \"分钟\" << \" \" << seconds << \"秒\" << \" \" << endl;\r\n}\r\n\r\n Time operator*(double m, const Time &t)   \r\n{\r\n	//这样就可以让第一个数为double类型，第二个参数为对象\r\n	//但是由于类外定义的自定义函数无法操作类内的私有成员，所以就有了友元函数，使其可以操作类种的私有成员\r\n	 Time sum;\r\n	 sum.seconds = t.seconds*m;\r\n	 sum.minutes = sum.seconds / 60 + t.minutes*m;\r\n	 sum.hours = sum.minutes / 60 + t.hours*m;\r\n	 sum.seconds = sum.seconds % 60;\r\n	 sum.minutes = sum.minutes % 60;\r\n	 return sum;\r\n}\r\nint main()\r\n{\r\n\r\n	Time t1(5, 30, 50);\r\n	Time t2(2, 20, 35);\r\n	Time t4(4, 5, 30);\r\n	Time t3 = t1 + t2 + t4;\r\n	t3.display();\r\n\r\n	//Time t5 = t1.operator*(2);   //类内重载   //因为operator是类内的一个函数，所以调用的时候用 ‘.’就行\r\n	Time t5 = t1 * 2;\r\n	Time t6 = operator*(2, t1);\r\n	//Time t6 = 2 * t1;            //类外重载  //operator是类外的一个函数，所以调用的时候需要正常传参。\r\n	t5.display();\r\n	t6.display();\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//A=B*2.75；\r\n//A=B.operator*(2.75);\r\n//A=2.75*B//这种就是错的，因为没有运算符重载函数能与其匹配\r\n//解决方法：在类外进行自定义重载运算符\r\n```', 0);
INSERT INTO `blog_course` VALUES (67, 'C++ 友元函数重载‘<<’运算符', 1, '##友元函数重载‘<<’运算符	\r\n```\r\n//想要cout输出的是对象，就要对运算符<<进行重载\r\n//1.第一种重载，在类内对<<进行重载，那么重载函数的第一个参数就是此类的对象。而输出的模式也是 trip<<cout    ，trip.operator<<(ostream cout)\r\n//2.第二种重载，在类外对<<进行重载，那么可以这样 void operator<<(ostream & os,const Time & t),这样第一个参数就是ostream对象\r\n//但是这种重载不能满足cout<<x<<y;连续输出两个对象.cout<<trip,这样输出一个对象是因为，重载运算符的左边是一个ostream对象，cout.operator<<(Time &t)调用了重载运算符的函数\r\n//但是这个函数的返回值没有，所以y的左边不是一个ostream,所以重载函数的返回值应该是一个ostream类型的对象，\r\n\r\n//利用友元函数重载<<运算符\r\n#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\nclass Student\r\n{\r\nprivate:\r\n	string name;\r\n	int id;\r\npublic:\r\n	Student(string name, int id)\r\n	{\r\n		this->name = name;\r\n		this->id = id;\r\n	}\r\n	friend ostream &operator<<(ostream &os, Student s);\r\n};\r\nostream &operator<<(ostream&os, Student s)   //代替display()函数\r\n{\r\n	os << s.id << \",\" << s.name << endl;\r\n	return os;\r\n}\r\nint main()\r\n{\r\n	Student s1(\"马永康\", 961226);\r\n	Student s2(\"刑宇浩\", 9527);\r\n	cout << s1 << s2 << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (68, 'C++ 自加自减运算符重载', 1, '##自加自减运算符重载	\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nclass Student\r\n{\r\nprivate:\r\n	int a;\r\npublic:\r\n	Student(int a)\r\n	{\r\n		this->a = a;\r\n	}\r\n	int operator++()     //前置++重载\r\n	{\r\n		int m = this->a + 1;\r\n		return m;\r\n	}\r\n	int operator++(int n)//后置++重载\r\n	{\r\n		n = a;\r\n		a = a + 1;\r\n		return n;\r\n	}\r\n	friend ostream &operator<<(ostream& os, Student &s);\r\n};\r\nostream&operator<<(ostream&os, Student &s)\r\n{\r\n	os << s.a << endl;\r\n	return os;\r\n}\r\nint main()\r\n{\r\n	Student s1(10);\r\n	cout << ++s1 << endl;\r\n\r\n	cout << s1++ << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (69, 'C++ 对象的转换', 1, '##对象的转换	\r\n```\r\n#include<iostream>\r\n#include\"stonewt.h\"\r\nusing std::cout;\r\n/*explicit*/Stonewt::Stonewt(double lbs)//可以使用关键字explicit来关闭自动隐式转换\r\n{\r\n	stone = int(lbs) / Lbs_per_stn;\r\n	pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);\r\n	pounds = lbs;\r\n}\r\nStonewt::Stonewt(int stn, double lbs)\r\n{\r\n	stone = stn;\r\n	pds_left = lbs;\r\n	pounds = stn * Lbs_per_stn + lbs;\r\n}\r\nStonewt::Stonewt()\r\n{\r\n	stone = pounds = pds_left = 0;\r\n}\r\nStonewt::~Stonewt()\r\n{\r\n\r\n}\r\nvoid Stonewt::show_stn()const\r\n{\r\n	cout << stone << \"stone,\" << pds_left << \"pounds\" << std::endl;\r\n}\r\nvoid Stonewt::show_lbs()const\r\n{\r\n	cout << pounds << \"pounds\" << std::endl;\r\n}\r\n```\r\n###stonewt.h定义\r\n```\r\n#include<iostream>\r\nusing std::cout;\r\n#include \"stonewt.h\"\r\nvoid display(const Stonewt&st, int n);\r\nint main()\r\n{\r\n	Stonewt incognito; //将一个浮点数转换为Stonewt型对象\r\n	incognito = 19.6;\r\n	//C++中，接受一个参数的构造函数为将类型与该参数相同的值转换为类提供了蓝图。\r\n	//这创建对象的时候，函数调用无参构造函数，创建对象的值为无参构造函数给的值。\r\n	//incognito=19.6这里将调用单参构造函数，创建一个临时对象，并将19.6的值传入单参构造函数，并对临时对象进行赋值。\r\n	//最后再将临时对象中的内容复制回给incognito对象，这种属于隐式类型转换，自动进行（将对象转换为double类型的数据）\r\n	//可以对其进行强制转换\r\n	//Stonewt incognito\r\n	//incognito=(Stonewt)19.6//显示强制类型转换\r\n	//\r\n\r\n	Stonewt wolfe(285.7);\r\n	Stonewt taft(21, 8);\r\n\r\n	cout << \"The celebrity weighed \";\r\n	incognito.show_stn();\r\n	cout << \"The detective weighed \";\r\n	wolfe.show_stn();\r\n	cout << \"The President weighed \";\r\n	taft.show_lbs();\r\n	incognito = 276.8;\r\n	taft = 325;\r\n	cout << \"After dinner,the celebrity weighed \";\r\n	incognito.show_stn();\r\n	cout << \"After dinner,the President weighed \";\r\n	taft.show_lbs();\r\n	display(taft, 2);\r\n	cout << \"The wrestler weighed even more.\" << std::endl;\r\n	display(422, 2);\r\n	cout << \"No stone left unearned\" << std::endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid display(const Stonewt&st, int n)\r\n{\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		cout << \"Wow!\";\r\n		st.show_stn();\r\n	}\r\n}\r\n```\r\n\r\n\r\n###stonewt.h\r\n\r\n```\r\n#pragma once\r\nclass Stonewt\r\n{\r\nprivate:\r\n	enum { Lbs_per_stn = 14 };\r\n	int stone;\r\n	double pds_left;\r\n	double pounds;\r\npublic:\r\n	 /*explicit*/ Stonewt(double lbs);   //double pounds 的构造器\r\n	Stonewt(int stn, double lbs);\r\n	Stonewt();\r\n	~Stonewt();\r\n	void show_lbs()const;\r\n	void show_stn()const;\r\n};\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (70, 'C++ 转换函数', 1, '##转换函数	\r\n```\r\n#include<iostream>\r\n#include \"stonewt1.h\"\r\nint main()\r\n{\r\n	using std::cout;\r\n	Stonewt poppins(9, 2.8);//调用双参构造函数\r\n	double p_wt = poppins;  //调用重载函数等同于double (poppins)，将对象转换为double类型\r\n	cout << \"Convert to double = > \";\r\n	cout << \"Poppins:\" << p_wt << \" pounds.\\n\";   \r\n	cout << \"Convert to int = > \" ;\r\n	cout << \"Poppins: \" << int(poppins) << \" pounds.\\n\";//调用重载int()函数，把对象转换为int类型\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n} \r\n```\r\n###stonewt1.h实现\r\n```\r\n#include <iostream>\r\nusing std::cout;\r\n#include\"stonewt1.h\"\r\nStonewt::Stonewt(double lbs)\r\n{\r\n	stone = int(lbs) / Lbs_per_stn;\r\n	pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);\r\n	pounds = lbs;\r\n}\r\nStonewt::Stonewt(int stn, double lbs)\r\n{\r\n	stone = stn;\r\n	pds_left = lbs;\r\n	pounds = stn * Lbs_per_stn + lbs;\r\n}\r\nStonewt::Stonewt()\r\n{\r\n	stone = pounds = pds_left = 0;\r\n}\r\nStonewt::~Stonewt()\r\n{\r\n\r\n}\r\nvoid Stonewt::show_stn()const\r\n{\r\n	cout << stone << \"stone,\" << pds_left << \"pounds\\n\";\r\n}\r\nvoid Stonewt::show_lbs()const\r\n{\r\n	cout << pounds << \"pounds\\n\";\r\n}\r\nStonewt::operator int() const          //重载类型转换，将对象转化为基本类型 \r\n{\r\n	return int(pounds + 0.5);\r\n}\r\nStonewt::operator double()const \r\n{\r\n	return pounds;\r\n}\r\n```\r\n\r\n###stonewt1.h\r\n\r\n```\r\n#pragma once\r\nclass Stonewt\r\n{\r\nprivate:\r\n	enum {Lbs_per_stn=14};\r\n	int stone;\r\n	double pds_left;\r\n	double pounds;\r\npublic:\r\n	Stonewt(double lbs);\r\n	Stonewt(int stn, double lbs);\r\n	Stonewt();\r\n	~Stonewt();\r\n	void show_lbs()const;\r\n	void show_stn()const;\r\n\r\n	operator int()const;    //重载类型转换为int类型\r\n	operator double()const; //重载类型转换为double类型\r\n};\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (71, 'C++ 动态内存和类(模拟string类)', 1, '##动态内存和类(模拟string类)\r\n```\r\n#include<iostream>\r\n#include \"strngbad.h\"\r\nusing namespace std;\r\nvoid callme1(StringBad &);\r\nvoid callme2(StringBad &);\r\nint main()\r\n{\r\n	cout << \"Starting an inner block.\" << endl;\r\n	StringBad headline1(\"Celery Stalks at Midnight\");\r\n	StringBad headline2(\"Lettuce Prey\");\r\n	StringBad sports(\"Spinach Leaves Bowl for Dollars\");\r\n	cout << \"headline1:\" << headline1 << endl;\r\n	cout << \"headline2:\" << headline2 << endl;\r\n	cout << \"sports\" << sports << endl;\r\n	callme1(headline1);\r\n	cout << \"headline1\" << headline1 << endl;\r\n	callme2(headline2);\r\n	cout << \"headline2\" << headline2 << endl;\r\n	cout << \"Initialize one object to another:\" << endl;\r\n	StringBad sailor = sports;\r\n	cout << \"sailor\" << sailor << endl;\r\n	cout << \"Assign one object to another:\" << endl;\r\n	StringBad knot;\r\n	knot = headline1;\r\n	cout << \"knot:\" << knot << endl;\r\n	cout << \"Exiting the block.\" << endl;\r\n\r\n	cout << \"End of main()\" << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid callme1(StringBad &rsb)\r\n{\r\n	cout << \"String passed by reference:\" << endl;\r\n	cout << \"    \\\"\" << rsb << \"\\\"\" << endl;\r\n}\r\nvoid callme2(StringBad &sb)\r\n{\r\n	cout << \"String passed by value:\" << endl;\r\n	cout << \"    \\\"\" << sb << \"\\\"\" << endl;\r\n}\r\n```\r\n\r\n###strngbad.h定义\r\n```\r\n#include<string.h>\r\n#include<memory.h>\r\n#include\"strngbad.h\"\r\nusing namespace std;\r\nint StringBad::num_strings = 0;  //定义静态成员为0；\r\nStringBad::StringBad(const char*s)\r\n{\r\n	len = strlen(s);\r\n	str = new char[len + 1];\r\n	memcpy(str, s,sizeof(char)*(len+1));   //这里使用strcpy是最安全的，但是要看到错误的结果而使用这种不安全的函数\r\n	num_strings++;\r\n	cout << num_strings << \": \\\"\" << str << \"\\\"object create\" << endl;\r\n}\r\nStringBad::StringBad()\r\n{\r\n	len = 4;\r\n	str = new char[4];\r\n	strcpy_s(str, sizeof(str),\"C++\");\r\n	num_strings++;\r\n	cout << num_strings << \": \\\"\" << str << \"\\\"default object create\" << endl;\r\n}\r\nStringBad::~StringBad()\r\n{\r\n	cout << \"\\\"\" << str << \"\\\"object deleted,\";\r\n	--num_strings;\r\n	cout << num_strings << \" letf\" << endl;\r\n	delete[]str;\r\n}\r\nostream &operator<<(ostream & os, const StringBad &st)\r\n{\r\n	os << st.str;\r\n	return os;\r\n}\r\nStringBad::StringBad(const StringBad &s)\r\n{\r\n	num_strings++;\r\n	this->len = s.len;\r\n	this->str = new char[len+1];\r\n	memcpy(str, s.str,sizeof(char)*(len+1));\r\n	cout << num_strings << \": \\\"\" << str << \"\\\"object created\\n\";\r\n\r\n}\r\nStringBad& StringBad::operator=(const StringBad & s)   //重载=赋值运算符，这里要对指针先进行释放，因为这个指针在前面是被使用过的，正常释放是在程序末尾，所以要提前在这里进行释放\r\n{\r\n	if (this == &s)\r\n		return *this;\r\n	delete[]str;\r\n	len = s.len;\r\n	str = new char[len + 1];   //这里的char的大小一定要+1，因为会考虑到\\0\r\n	memcpy(str, s.str, sizeof(char)*(len+1));\r\n	return *this;\r\n}\r\n```\r\n\r\n\r\n###strngbad.h\r\n\r\n```\r\n#pragma once\r\n#include<iostream>\r\nclass StringBad\r\n{\r\nprivate:\r\n	char*str;\r\n	int len;\r\n	static int num_strings;\r\npublic:\r\n	StringBad(const char *s);//构造函数，用来初始化char指针\r\n	StringBad();//无参构造函数\r\n	~StringBad();\r\n	StringBad(const StringBad&s);\r\n	StringBad &operator=(const StringBad & s);\r\n\r\n	friend std::ostream & operator<<(std::ostream&os, const StringBad &st);//友元函数重载输出运算符\r\n\r\n};\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (72, 'C++ 改进后的string类', 1, '##改进后的string类\r\n```\r\n#include<iostream>\r\n#include \"string1.h\"\r\nusing namespace std;\r\nconst int Arsize = 10;\r\nconst int MaxLen = 81;\r\nint main()\r\n{\r\n	String name;\r\n	cout << \"Hi,what\'s your name?\\n>>\";\r\n	cin >> name;\r\n\r\n	cout << name << \",please enter up to \" << Arsize << \" short saying <empty line to quit>:\\n\";\r\n	String sayings[Arsize];\r\n	char temp[MaxLen];\r\n	int i;\r\n	for ( i = 0; i < Arsize; i++)\r\n	{\r\n		cout << i + 1 << \":\";\r\n		cin.get(temp, MaxLen);\r\n		while (cin && cin.get() != \'\\n\')\r\n			continue;\r\n		if (!cin || temp == \'\\0\')\r\n			break;\r\n		else\r\n			sayings[i] = temp;\r\n	}\r\n	int total = i;\r\n	if (total > 0)\r\n	{\r\n		cout << \"Here are your sayings:\\n\";\r\n		for (i = 0; i < total; i++)\r\n			cout << sayings[i][0] << sayings[i] << endl;\r\n		int shortest = 0;\r\n		int first = 0;\r\n		for (i = 1; i < total; i++)\r\n		{\r\n			if (sayings[i].length() < sayings[shortest].length())\r\n				shortest = i;\r\n			if (sayings[i] < sayings[first])\r\n				first = i;\r\n		}\r\n		cout << \"Shortest saying:\\n\" << sayings[shortest] << endl;\r\n		cout << \"First alphabetically:\\n\" << sayings[first] << endl;\r\n		cout << \"This program used\" << String::HowMany() << \"String object .Bye.\\n\";\r\n\r\n	}\r\n	else\r\n		cout << \"No input! Bye.\\n\";\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n\r\n###string1.h实现\r\n```\r\n//C++11的空指针  \r\n//int *p=nullptr;                           !!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n#include<cstring>\r\n#include<memory.h>\r\n#include\"string1.h\"\r\n\r\nusing namespace std;\r\n\r\nint String::num_strings = 0;\r\n//静态方法\r\nint String::HowMany()\r\n{\r\n	return num_strings;\r\n}\r\nString::String(const char * s)     //构造函数，用来传入一个字符串\r\n{\r\n	len = strlen(s);\r\n	str = new char[len + 1];\r\n	memcpy(str, s, sizeof(char)*(len + 1));\r\n	num_strings++;\r\n}\r\nString::String()\r\n{\r\n	len = 4;\r\n	str = new char[1];   //这里一定要使用[]因为每一个构造函数内的指针都要与析构函数内的delete匹配\r\n	str[0] = \'\\0\';\r\n	num_strings++;\r\n}\r\n//拷贝构造函数\r\nString::String(const String&s)          //用来实现字符串之间的赋值String str1(str2)\r\n{\r\n	num_strings++;\r\n	len = s.len;\r\n	str = new char[len + 1];\r\n	memcpy(str, s.str, sizeof(char)*(len + 1));\r\n}\r\n//析构函数\r\nString::~String()   //析构函数，用来释放传进来的指针\r\n{\r\n	--num_strings;\r\n	delete[]str;\r\n}\r\nString & String::operator=(const String& st)//重载赋值运算符，用来对两个字符串进行赋值 string str2=str1;\r\n{\r\n	if (this == &st)     //如果str字符串相等了，直接返回任何一个值都可以\r\n		return *this;                    \r\n	delete[]str;         //释放指针 str1\r\n	len = st.len;\r\n	str = new char[len + 1];\r\n	memcpy(str, st.str, sizeof(char)*(len + 1));\r\n}\r\nString &String::operator=(const char*s)\r\n{\r\n	delete[]str;\r\n	len = strlen(s);\r\n	str = new char[len + 1];\r\n	memcpy(str, s, sizeof(char)*(len + 1));\r\n	return *this;\r\n}\r\nchar &String::operator[](int i)  //重载[]运算符，用来实现取出String对象内的单个字符\r\n{\r\n	return str[i];\r\n}\r\n\r\n//重载友元\r\nbool operator<(const String &st1, const String &st2)\r\n{\r\n	//return (strcmp(st1.str, st2.str) < 0);\r\n	if (strcmp(st1.str, st1.str) > 0)\r\n		return false;\r\n	if (strcmp(st1.str, st1.str) < 0)\r\n		return true;\r\n}\r\nbool operator>(const String &st1, const String &st2)\r\n{\r\n	//return (strcmp(st1.str, st2.str) > 0);\r\n	if (strcmp(st1.str, st1.str) < 0)\r\n		return false;\r\n	if (strcmp(st1.str, st1.str) > 0)\r\n		return true;\r\n}\r\nbool operator==(const String &st1, const String &st2)\r\n{\r\n	if (strcmp(st1.str, st2.str) == 0)\r\n		return true;\r\n	else\r\n		return false;\r\n}\r\nostream & operator<<(ostream & os, const String &st)\r\n{\r\n	os << st.str;\r\n	return os;\r\n}\r\nistream & operator>>(istream & is, String & st)   //重载输入运算符，\r\n{\r\n	char temp[String::CINLIM];\r\n	is.get(temp, String::CINLIM);\r\n	if (is)\r\n	{\r\n		st = temp;\r\n	}\r\n	while (is&&is.get() != \'\\n\')\r\n		continue;\r\n	return is;\r\n}\r\n//注意：当类成员中，有类类型的时候要写拷贝构造函数\r\n```\r\n###string1.h\r\n```\r\n#pragma once\r\n#include <iostream>\r\nusing std::ostream;\r\nusing std::istream;\r\n\r\nclass String\r\n{\r\nprivate:\r\n	char*str;\r\n	int len;\r\n	static int num_strings;\r\n	static const int CINLIM = 80;\r\npublic:\r\n	String(const char *s);\r\n	String();//无参构造函数\r\n	String(const String & s);//拷贝构造函数\r\n	~String();//析构函数\r\n	int length()const\r\n	{\r\n		return len;     //内联函数，用来获取字符串长度\r\n	}\r\n\r\n	//重载函数\r\n	String&operator=(const String &s);//重载复制运算符，用来对象与对象之间的赋值\r\n	String&operator=(const char *);//重载赋值运算符\r\n	char &operator[](int i);//重载[]运算符\r\n	const char &operator[](int i)const;\r\n\r\n	//友元重载\r\n	friend bool operator<(const String &st, const String&st2);\r\n	friend bool operator>(const String &st, const String&st2);\r\n	friend bool operator==(const String &st, const String&st2);\r\n	friend ostream &operator<<(ostream&os, const String & st);\r\n	friend istream &operator>>(istream &is, String & st);\r\n\r\n	//静态成员函数\r\n	static int HowMany();\r\n};\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (73, 'C++ 再谈定位new运算符', 1, '##再谈定位符string类\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include<new>\r\nusing namespace std;\r\nconst int BUF = 512;\r\nclass JustTesting\r\n{\r\nprivate:\r\n	string words;\r\n	int number;\r\npublic:\r\n	JustTesting(const string &s = \"Just Testing\", int n = 0)\r\n	{\r\n		words = s;\r\n		number = n;\r\n		cout << words << \"constructed\" << endl;\r\n	}\r\n	~JustTesting()\r\n	{\r\n		cout << words << \"destroyed\" << endl;\r\n	}\r\n	void Show()const\r\n	{\r\n		cout << words << \",\" << number << endl;\r\n	}\r\n};\r\nint main()\r\n{\r\n	char * buffer = new char[BUF];\r\n	JustTesting * pc1, *pc2;\r\n	pc1 = new(buffer)JustTesting;  //在buffer字符串数组内申请一块内存空间\r\n	pc2 = new JustTesting(\"Heap1\", 20);//通过析构函数对堆区内存进行释放\r\n	cout << \"Memory block address:\\n\" << \"buffer:\" << (void*)buffer << \"    heap:\" << pc2 << endl;\r\n	cout << \"Memory contents:\\n\";\r\n	cout << pc1 << \": \";\r\n	pc1->Show();\r\n	cout << pc2 << \": \";\r\n	pc2->Show();\r\n	JustTesting*pc3, *pc4;\r\n	pc3 = new(buffer+sizeof(JustTesting))JustTesting(\"Bad Idea\", 6); //管理定位的内存不重叠\r\n	pc4 = new JustTesting(\"Heap2\", 10);//通过析构函数对堆区内存进行释放\r\n\r\n	cout << \"Memory contents:\\n\";\r\n	cout << pc3 << \": \";\r\n	pc3->Show();\r\n	cout << pc4 << \": \";\r\n	pc4->Show();\r\n\r\n	pc1->~JustTesting();    //相对new定位运算符申请的空间进行释放可以显示的调用析构函数\r\n	pc3->~JustTesting();\r\n	delete pc2;\r\n	delete pc4;\r\n	delete[]buffer;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (74, 'C++ 队列模拟银行', 1, '##队列模拟银行\r\n```\r\n#include<iostream>\r\n#include \"queue.h\"\r\n#include<ctime>\r\n#include<cstdlib>\r\nconst int MIN_PER_HR = 60;\r\n\r\nbool newcustomer(double x);\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	srand(time(nullptr));//随机种子\r\n	cout << \"Case Study:Bank of Heather Automatic Teller\" << endl;\r\n	cout << \" Enter maximum size of queue:\";\r\n	int qs;\r\n	cin >> qs;\r\n	Queue line(qs);\r\n\r\n	cout << \"Enter the number of simulation hours: \";\r\n	int hours;\r\n	cin >> hours;\r\n	long cyclelimit = MIN_PER_HR * hours;\r\n\r\n	cout << \"Enter the average number of customers per hour:\";\r\n	double perhour;\r\n	cin >> perhour;\r\n	double min_per_cust;\r\n	min_per_cust = MIN_PER_HR / perhour;\r\n\r\n	Item temp;\r\n	long turnaways = 0;\r\n	long customers = 0;\r\n	long served = 0;\r\n	long sum_line = 0;\r\n	int wait_time = 0;\r\n	long line_wait = 0;\r\n\r\n	for (int cycle = 0; cycle < cyclelimit; cycle++)\r\n	{\r\n		if (newcustomer(min_per_cust))\r\n		{\r\n			if (line.isfull())\r\n			{\r\n				turnaways++;\r\n			}\r\n			else\r\n			{\r\n				customers++;\r\n				temp.set(cycle);\r\n				line.enqueue(temp);\r\n			}\r\n		}\r\n		if (wait_time <= 0 && line.isempty())\r\n		{\r\n			line.dequeue(temp);\r\n			wait_time = temp.ptime();\r\n			line_wait + line_wait + cycle - temp.when();\r\n			served++;\r\n		}\r\n		if (wait_time > 0)\r\n		{\r\n			wait_time--;\r\n		}\r\n		sum_line = sum_line + line.queuecount();\r\n	}\r\n	if (customers > 0)\r\n	{\r\n		cout << \"customers accepted: \" << customers << endl;\r\n		cout << \" customers served: \" << served << endl;\r\n		cout << \"           turnaways:\" << turnaways << endl;\r\n		cout << \"average queue size: \";\r\n		cout.precision(2);\r\n		cout.setf(ios_base::fixed, ios_base::floatfield);\r\n		cout << (double)sum_line / cyclelimit << endl;\r\n		cout << \" average wait time:\" << (double)line_wait / served << \" minutes\" << endl;\r\n	}\r\n	else\r\n		cout << \" No customers!\" << endl;\r\n	cout << \"Done!\\n\";\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nbool newcustomer(double x)\r\n{\r\n	return (rand()*x / RAND_MAX < 1);\r\n}\r\n```\r\n\r\n###queue.h实现\r\n```\r\n///*队列特征：\r\n//队列存储有序的项目序列\r\n//队列所能容纳的项目数有一定的限制\r\n//应当能够创建空队列\r\n//应当能够检查队列是否为空\r\n//应当能够将此队列是否是满的\r\n//应当能够在队尾添加项目\r\n//应当能够在队首删除项目\r\n//应当能够确定队列中项目数\r\n//*/\r\n#include<cstdlib>\r\n#include \"queue.h\"\r\nQueue::Queue(int qs) :qsize(qs)\r\n{\r\n	front = rear = nullptr;\r\n	items = 0;\r\n}\r\nQueue::~Queue()\r\n{\r\n	Node * temp; \r\n	while (front != nullptr)  //当队列中不为空\r\n	{\r\n		temp = front;\r\n		front = front->next; //front 的地址为next的地址\r\n		delete temp;\r\n	}\r\n}\r\nbool Queue::isempty()const\r\n{\r\n	return items == 0;\r\n}\r\nbool Queue::isfull()const\r\n{\r\n	return items == qsize;\r\n}\r\nint Queue::queuecount()const\r\n{\r\n	return items;\r\n}\r\nbool Queue::enqueue(const Item & item)\r\n{\r\n	if (isfull())\r\n		return false;\r\n	Node*add = new Node;\r\n	add->item = item;\r\n	add->next = nullptr;\r\n	items++;\r\n	if (front == nullptr)\r\n	{\r\n		front = add;\r\n	}\r\n	else\r\n		rear->next = add;\r\n	rear = add;\r\n	return true;\r\n}\r\nbool Queue::dequeue(Item & item)\r\n{\r\n	if (front == nullptr)\r\n	{\r\n		return false;\r\n	}\r\n	item = front->item;\r\n	items--;\r\n	Node * temp = front;\r\n	front = front->next;\r\n	delete temp;\r\n	if (items == 0)\r\n	{\r\n		rear = nullptr;\r\n	}\r\n	return true;\r\n}\r\nvoid Customer::set(long when)\r\n{\r\n	processtime == std::rand() % 3 + 1;\r\n	arrive = when;\r\n}\r\n```\r\n\r\n\r\n####queue.h\r\n```\r\n#pragma once\r\nclass Customer\r\n{\r\nprivate:\r\n	long arrive;\r\n	int processtime;\r\npublic:\r\n	Customer()\r\n	{\r\n		arrive = processtime = 0;\r\n	}\r\n	void set(long when);\r\n	long when()const\r\n	{\r\n		return arrive;\r\n	}\r\n	int ptime()const\r\n	{\r\n		return processtime;\r\n	}\r\n};\r\ntypedef Customer Item;\r\n\r\nclass Queue\r\n{\r\nprivate:\r\n	struct Node  //节点\r\n	{\r\n		Item item;   //数据域为Customer对象\r\n		Node*next;   //指针域\r\n	};\r\n	enum { Q_SIZE = 10 };  //对队列的容纳量进行约束\r\n	Node *front;     //第一个节点的地址\r\n	Node *rear;      //最后一个节点的地址\r\n	int items;      \r\n	const int qsize;   //项目数量的最大量\r\n	Queue(const Queue & q) :qsize(0)\r\n	{\r\n\r\n	}\r\n	Queue &operator=(const Queue &q)\r\n	{\r\n		return *this;\r\n	}\r\npublic:\r\n	Queue(int qs = Q_SIZE);\r\n	~Queue();\r\n	bool isempty()const;   //实现查看是否为空\r\n	bool isfull()const;    //实现查看是否已满\r\n	int queuecount()const; //实现查看当前数量\r\n	bool enqueue(const Item &item);  //实现向队列末尾添加项目\r\n	bool dequeue(Item&item); //实现从队列的首位删除项目\r\n};\r\n\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (75, 'C++ 继承', 1, '##继承\r\n```\r\n#include <iostream>\r\n#include \"tabtenn0.h\"\r\nint main()\r\n{\r\n	using std::cout;\r\n	using std::endl;\r\n	TableTennisPlayer *player1 = new TableTennisPlayer(\"Chuck\", \"Blizzard\", true);\r\n	TableTennisPlayer *player2 = new TableTennisPlayer(\"Tara\", \"Boomdea\", false);\r\n	player1->Name();\r\n	if (player1->HasTable())\r\n	{\r\n		cout << \": has a table.\\n\";\r\n	}\r\n	else\r\n	{\r\n		cout << \": hasn\'t a table.\\n\";\r\n	}\r\n	player2->Name();\r\n	if (player2->HasTable())\r\n	{\r\n		cout << \": has a table\";\r\n	}\r\n	else\r\n		cout << \": hasn\'t a table.\\n\";\r\n\r\n	delete player1;\r\n	delete player2;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###tabtenn0.h\r\n```\r\n#include \"tabtenn0.h\"\r\n#include <iostream>\r\nTableTennisPlayer::TableTennisPlayer(const string & fn,const string & ln,bool ht):firstname(fn),lastname(ln),hasTable(ht)\r\n{\r\n	//这样的string类构造函数会省去调用拷贝函数的过程\r\n}\r\nvoid TableTennisPlayer::Name()const\r\n{\r\n	cout << lastname << \" ,\" << firstname;\r\n}\r\n\r\n//派生类构造函数定义\r\nRatedPlayer::RatedPlayer(unsigned int r, const string & fn, const string & ln, bool ht) :TableTennisPlayer(fn, ln, ht)\r\n{\r\n	rating = r;\r\n}\r\nRatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp) : TableTennisPlayer(tp), rating(r)\r\n{\r\n\r\n}\r\n```\r\n\r\n#tabtenn0.h\r\n```\r\n#pragma once\r\n#include <string>\r\nusing namespace std;\r\nclass TableTennisPlayer\r\n{\r\nprivate:\r\n	string firstname;\r\n	string lastname;\r\n	bool hasTable;\r\npublic:\r\n	TableTennisPlayer(const string & fn = \"none\", const string & ln = \"none\", bool ht = false);//构造函数\r\n	void Name()const;\r\n\r\n	TableTennisPlayer(const TableTennisPlayer & tp)\r\n	{\r\n		this->firstname = tp.firstname;\r\n		this->lastname = tp.lastname;\r\n		this->hasTable = tp.hasTable;\r\n	}\r\n\r\n\r\n	bool HasTable()const\r\n	{\r\n		return hasTable;\r\n	}\r\n	void ResetTable(bool v)\r\n	{\r\n		hasTable = v;\r\n	}\r\n};\r\nclass RatedPlayer :public TableTennisPlayer   //继承基类\r\n{\r\nprivate:\r\n	unsigned int rating;\r\npublic:\r\n	RatedPlayer(unsigned int r = 0, const string & fn = \"none\", const string & ln = \"none\", bool ht = false);\r\n\r\n	RatedPlayer(unsigned int r, const TableTennisPlayer & tp);//这将隐式调用基类的拷贝构造函数\r\n	\r\n	//构造函数必须给新成员和继承的成员提供数据，在第一个RatedPlayer构造函数中，每个成员对应一个形参\r\n	//第二个Ratedplayer构造函数使用一个TableTennisPlayer参数，该参数包括基类中的所有数据成员\r\n	unsigned int Rating()const\r\n	{\r\n		return rating;\r\n	}\r\n	void ResetRating(unsigned int r)\r\n	{\r\n		rating = r;\r\n	}\r\n};\r\n/*\r\n构造函数：访问权限的考虑：\r\n派生类不能直接访问基类的私有成员，而必须通过基类的方法进行访问。这里就是派生类构造函数必须使用基类构造函数\r\n首先执行派生类的析构函数，然后自动调用基类的析构函数\r\n*/\r\n\r\n\r\n/*派生类构造函数的要点如下：\r\n1.首先创建基类对象\r\n2.派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；\r\n3.派生类构造函数应初始化派生类新增的数据成员\r\n*/\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (76, 'C++ 派生', 1, '##派生\r\n```\r\n/*使用公有派生，基类的公有成员将称为派生类的公有成员，基类的私有部分也将成为派生类的一部分\r\n但是只能通过基类的公有和保护方法访问\r\n1.派生类对象存储了基类的数据成员（派生类继承了基类的实现）\r\n2.派生类对象可以使用基类的方法（派生类继承了基类的接口）\r\n\r\n3.派生类需要自己的构造函数\r\n4.派生类可以根据需要添加额外的数据成员和成员函数。\r\n*/\r\n#include<iostream>\r\n#include \"tabtenn0.h\"    //上一节的头文件\r\nint main()\r\n{\r\n	using std::cout; \r\n	using std::endl;\r\n	TableTennisPlayer player1(\"Tara\", \"Boomdea\", false);\r\n	RatedPlayer rplayer1(1140, \"Mallory\", \"Duck\", true);\r\n	rplayer1.Name();//子类调用父类的函数\r\n	if (rplayer1.HasTable())\r\n	{\r\n		cout << \": has a table .\\n\";\r\n	}\r\n	else\r\n	{\r\n		cout << \": hasn\'t a table .\\n\";\r\n	}\r\n	cout << \"Name:\";\r\n	rplayer1.Name();\r\n	cout << \"; Rating:\" << rplayer1.Rating() << endl;\r\n	RatedPlayer rplayer2(1212, player1);//用基类的对象做参数来创建派生类的对象\r\n	cout << \"Name:\";\r\n	rplayer2.Name();\r\n	cout << \"; Rating: \" << rplayer2.Rating() << endl;\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (77, 'C++ 继承限定词与析构函数', 1, '##继承限定词与析构函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nclass Student\r\n{\r\nprivate:\r\n	int a;\r\nprotected:\r\n	int b;\r\npublic:\r\n	Student(int a1,int b1) :a(a1),b(b1)\r\n	{\r\n\r\n	}\r\n	Student()\r\n	{\r\n\r\n	}\r\n	~Student()\r\n	{\r\n		//执行完子类析构函数才执行父类的析构函数\r\n	}\r\n\r\nprivate:\r\n	void fun1()\r\n	{\r\n		cout << a << endl;\r\n	}\r\npublic:\r\n	void fun2()\r\n	{\r\n		cout << a << endl;\r\n	}\r\nprotected:\r\n	void fun3()\r\n	{\r\n		cout << a << endl;\r\n	}\r\n};\r\n/*******************************************************************************************************************************/\r\nclass S1:public Student    //这里使用public父类怎样，子类就怎样\r\n{\r\nprivate:\r\n	int c;\r\npublic:\r\n	S1(int a1, int b1,int c1) :Student(a1,b1),c(c1)   //对基类成员和派生类成员进行初始化\r\n	{\r\n		fun3();                 //子类可以使用父类的protected成员，在不使用父类提供的方法时\r\n		//fun1();\r\n	}\r\n	~S1()\r\n	{\r\n		//先执行子类的析构函数\r\n	}\r\n};\r\n/*******************************************************************************************************************************/\r\nclass S2 :protected Student    //将父类的成员降为自己同级，若父类成员是public则为protected，若与自己同级或低级则不变\r\n{                            //若私有继承基类，那么所有继承下来的成员都变为私有\r\nprivate:\r\n	int c;\r\npublic:\r\n	S2(int a1, int b1, int c1) :Student(a1, b1), c(c1)   //对基类成员和派生类成员进行初始化\r\n	{\r\n		fun3();\r\n		fun2();\r\n	}\r\n	~S2()\r\n	{\r\n\r\n	}\r\n};\r\n/*******************************************************************************************************************************/\r\nint main()\r\n{\r\n	//创建子类对象\r\n	S1 *s = new S1(5, 10,15);\r\n	s->fun2();    //只能调用fun2这里public函数\r\n	S2* s2 = new S2(5, 10,15);\r\n	//子类创建的对象不可以访问父类的protected成员\r\n\r\n\r\n	delete s;\r\n	delete s2;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (78, 'C++ 覆盖', 1, '##覆盖\r\n```\r\n#include <iostream>\r\nusing namespace std;\r\nclass MyClass\r\n{\r\nprivate:\r\n	int a;\r\n\r\npublic:\r\n	MyClass(int a1) :a(a1)\r\n	{\r\n\r\n	}\r\n	void fun(int b)\r\n	{\r\n		cout << b << endl;\r\n	}\r\n	friend ostream & operator<<(ostream & os, MyClass &m);  //友元函数无法被继承\r\n};\r\n//重载友元函数\r\nostream &operator<<(ostream & os, MyClass & m)   //该友元只属于父类\r\n{\r\n	os << m.a;\r\n	return os;\r\n}\r\n\r\nclass son :public MyClass\r\n{\r\nprivate:\r\n	int c;\r\npublic:\r\n	son(int a1, int c1) :MyClass(a1), c(c1)\r\n	{\r\n\r\n	}\r\n	void fun()\r\n	{\r\n		cout << c << endl;\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	son s1(1,2);\r\n	s1.fun();   //这里默认调用的是子类的fun函数\r\n	s1.MyClass::fun(5);//这里调用的是父类的fun函数，二者不并不是重载的关系，而是覆盖的关系，需要使用类名作用域来调用父类的同名函数成员\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (79, 'C++ 多态与虚函数', 1, '##多态与虚函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nclass CFather\r\n{\r\nprivate:\r\n	int a;\r\npublic:\r\n	CFather(int a1) :a(a1)\r\n	{\r\n\r\n	}\r\n   	virtual~CFather()\r\n	{\r\n		cout << \"父类析构\" << endl;\r\n	}\r\n\r\n	//父类虚函数会放在虚表中，当运行到子类的虚函数时，会把子类的虚函数覆盖父类的同名虚函数，这样调用时就会调用虚函数\r\n\r\n	//在虚表中32位编辑器的指针都是4字节的\r\n	virtual void fun()   //虚函数关键字,虚函数不能是内联函数   //void(*)()\r\n	{\r\n		cout << \"父类\" << endl;\r\n	}\r\n	virtual void fun2()\r\n	{\r\n		cout << \"fun2\" << endl;\r\n	}\r\n	virtual void fun3()\r\n	{\r\n		cout << \"fun3\" << endl;\r\n	}\r\n	int getA()\r\n	{\r\n		return a;\r\n	}\r\n};\r\n\r\nclass CSon:public CFather\r\n{\r\npublic:\r\n	CSon(int a1) :CFather(a1)\r\n	{\r\n\r\n	}\r\n	virtual~CSon()\r\n	{\r\n		cout << \"子类析构\" << endl;\r\n	}\r\n	virtual void fun()  //子类重写父类的函数\r\n	{\r\n		cout << \"子类\" << endl;\r\n	}\r\n};\r\nint main()\r\n{\r\n	CFather*fa = new CSon(123);\r\n	//父类创建指针可以调用子类重写父类的同名函数\r\n	fa->fun();    //父类添加了virtual后，那么fa指针就会调用子类的fun函数\r\n	fa->CFather::fun();\r\n	//虚表中存储的都是地址\r\n	//fa;                 //虚表首地址（虚表中第一个元素的地址）\r\n	//(int *)fa;          //将第一个元素的地址转化为4字节的int*类型\r\n	//*(int *)fa;         //在对其地址解析取元素（第一个函数的地址）\r\n	//(int *)*(int *)fa;  //将第一个指针类型的元素转换为int*类型，这样就将虚表元素类型同一了\r\n\r\n	//typedef  void(*p)();  //最后在将元素地址转换为函数指针，函数指针：数据类型（*指针名）（参数列表名）,这里给函数指针取个名字\r\n\r\n\r\n	////将元素和地址都转化为int*类型，才能实现自加1取元素\r\n	//((p)(*((int*)*(int*)fa)))();     //虚表中第一个元素对应的函数\r\n	//((p)(*((int*)*(int*)fa + 1)))(); //虚表中第二个元素对应的函数\r\n	//((p)(*((int*)*(int*)fa + 2)))(); //虚表中第三个元素对应的函数\r\n\r\n	//int *pp = (int*)*(int*)fa + 3;\r\n\r\n\r\n	//p=[p1,p2,p3]   像这样指针数组，p就是代表数组p的首地址（第一个元素的地址），强制类型转换为int类型的指针（int*）p，  取第一个元素 *（int*）p（一个虚函数的地址），强制转换-- （int*）*（int*）p\r\n	//则 *（（int*）*（int*）p）为虚表第一个元素对应的虚函数\r\n\r\n\r\n	delete fa;     //不添加 virtual 则默认调用父类的析构函数，不会调用子类\r\n	//delete (CSon*)fa;  //可以通过显示来调用子类的析构\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (80, 'C++ 纯虚函数', 1, '##纯虚函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nclass CFather\r\n{\r\nprivate:\r\n	int a;\r\npublic:\r\n	CFather(int a)\r\n	{\r\n		this->a = a;\r\n	}\r\n	virtual void fun() = 0;  //纯虚函数,有纯虚函数的类不能实例化对象,有纯虚函数的类必须通过子类继承父类重写父类的方法才能实例化；\r\n\r\n	//有纯虚函数的类都是抽象类\r\n\r\n	//全都是纯虚函数的类是接口类\r\n	int GetA()\r\n	{\r\n		return a;\r\n	}\r\n};\r\nclass CSon :public CFather\r\n{\r\npublic:\r\n	CSon(int a) :CFather(a)\r\n	{\r\n	}\r\n	virtual void fun()\r\n	{\r\n		cout << GetA() << endl;\r\n	}\r\n};\r\nint main()\r\n{\r\n	CFather *fa = new CSon(5);\r\n	fa->fun();\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (81, 'C++ 模拟银行服务', 1, '##模拟银行服务\r\n```\r\n#include<iostream>\r\n#include \"brass.h\"\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	Brass Piggy(\"Porcelot Pigg\", 381299, 4000.00);//创建一个普通用户\r\n	BrassPlus Hoggy(\"Horatio Hogg\", 382288, 3000.00);//创建会员用户\r\n	Piggy.ViewAcct();\r\n	cout << endl;\r\n	Hoggy.ViewAcct();\r\n	cout << endl;\r\n\r\n	//存入1000到Hoggy账户\r\n	Hoggy.Deposit(1000.00);\r\n	//查看余额\r\n	cout << Hoggy.Balance() <<endl;\r\n\r\n	//从Piggy账户取出4200；\r\n	Piggy.Withdraw(4200.00);\r\n	cout << Piggy.Balance() << endl;\r\n\r\n	//从Hoggy账户取出4200；\r\n	Hoggy.Withdraw(4200.00);\r\n	Hoggy.ViewAcct();\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###brass.h定义\r\n```\r\n#include<iostream>  //对头文件进行定义\r\n#include \"brass.h\"\r\nusing namespace std;\r\n\r\ntypedef ios_base::fmtflags format;\r\ntypedef streamsize precis;\r\nformat setFormat();\r\nvoid restore(format f, precis p);\r\n\r\n\r\n/******父类的方法*****/\r\nBrass::Brass(const string & s, long an, double bal)\r\n{\r\n	fullName = s;\r\n	accNum = an;\r\n	balance = bal;\r\n}//构造函数\r\nvoid Brass::Deposit(double amt)//存款\r\n{\r\n   \r\n	if (amt < 0) \r\n    { \r\n		\"您输入的金额不合法\";\r\n	}\r\n	else\r\n	balance = balance + amt;\r\n}\r\nvoid Brass::Withdraw(double amt)//去款\r\n{\r\n	format initialState = setFormat();\r\n	precis prec = cout.precision(2);\r\n	if (amt < 0) \r\n	{\r\n		cout << \"您输入的金额不合法\";\r\n	}\r\n	else if (amt <= balance)\r\n	{\r\n		balance = balance - amt;\r\n	}\r\n	else\r\n	{\r\n		cout << \"您的余额不足\" << endl;\r\n	}\r\n	restore(initialState, prec);\r\n}\r\ndouble Brass::Balance()const  //显示金额\r\n{\r\n	return balance;\r\n}\r\nvoid Brass::ViewAcct()const\r\n{\r\n	format initialState = setFormat();\r\n	precis prec = cout.precision(2);\r\n	cout << \"姓名：\" << fullName << endl;\r\n	cout << \"账号：\" << accNum << endl;\r\n	cout << \"余额：￥\" << balance << endl;\r\n	restore(initialState, prec);\r\n}\r\n\r\n/*************子类的方法******************/\r\n\r\n//构造函数\r\nBrassPlus::BrassPlus(const string & s, long an, double bal, double ml, double r) :Brass(s, an, bal)\r\n{\r\n	maxLoan = ml;\r\n	oweBank = 0.0;\r\n	rate = r;\r\n}\r\nBrassPlus::BrassPlus(const Brass & ba, double ml, double r) :Brass(ba)\r\n{\r\n	maxLoan = ml;\r\n	oweBank = 0.0;\r\n	rate = r;\r\n}\r\n\r\n\r\nvoid BrassPlus::ViewAcct()const\r\n{\r\n	format initialState = setFormat();\r\n	precis prec = cout.precision(2);\r\n\r\n	Brass::ViewAcct();\r\n	cout << \"透支上限：￥\" << maxLoan << endl;\r\n	cout << \"当前已透支金额：\" << oweBank << endl;\r\n	cout.precision(3);\r\n	cout << \"透支利率：\" << 100 * rate << \"%\\n\";\r\n	restore(initialState, prec);\r\n}\r\nvoid BrassPlus::Withdraw(double amt)\r\n{\r\n	format initialState = setFormat();\r\n	precis prec = cout.precision(2);\r\n\r\n	double bal = Balance();  //当前余额\r\n	if (amt <= bal)\r\n	{\r\n		Brass::Withdraw(amt);\r\n	}\r\n	else if (amt <= bal + maxLoan - oweBank)\r\n	{\r\n		double advance = amt - bal;  //透支金额\r\n		oweBank = oweBank - advance * (1.0 + rate);\r\n		cout << \"当前余额：\" << advance << endl;\r\n		cout << \"产生利息：\" << advance * rate << endl;\r\n		Deposit(advance);\r\n		Brass::Withdraw(amt);\r\n	}\r\n	else\r\n		cout << \"额度不足\" << endl;\r\n	restore(initialState, prec);\r\n\r\n}\r\nformat setFormat()\r\n{\r\n	return cout.setf(ios_base::fixed, ios_base::floatfield);\r\n}\r\nvoid restore(format f, precis p)\r\n{\r\n	cout.setf(f, ios_base::floatfield);\r\n	cout.precision(p);\r\n}\r\n\r\n```\r\n\r\n###brass.h\r\n```\r\n/*\r\n多态公有继承：同一个方法在派生类和基类中的行为是不同的。\r\n方法的行为应取决于调用该方法的对象。---这种复杂的行为称为-具有多种形态。\r\n1.在派生类中重新定义基类的方法\r\n2.使用虚方法\r\n*/\r\n/*\r\n例：银行要求您完成的第一项工作是开发两个类。\r\n1.Brass Account类，用于基本的支票账户。\r\n2.Brass Plus支票账户，它添加了透支保护特性---如果用户签出一张超出其存款余额的支票，但是超出的数额并不是很大，银行将支付这张支票，对超出的部分取额外的费用，并追加罚款\r\nBrassAccount:\r\n属性：\r\n1.用户姓名\r\n2.账号\r\n3.当前结余\r\n\r\n方法：\r\n1.创建账户\r\n2.存款\r\n3.取款\r\n4.显示账户信息\r\n\r\nBrass Plus包含Brass Account的所有信息及如下属性\r\n1.透支上限\r\n2.透支贷款利率\r\n3.当前的透支总额\r\n\r\n方法：\r\n\r\n1.对于取款操作，必须考虑透支保护\r\n2.显示操作必须显示Brass Plus账户的其他信息\r\n\r\n1.plus账户限制了客户的透支款额。默认是500，但是有些客户的限额可能不同\r\n2.银行可以修改客户的透支限额\r\n3.plus账户对贷款收取利息。默认是11.125%，但是有些客户的利率可能不同\r\n4.银行可以修改客户的利率\r\n5.账户记录客户所欠银行的金额（透支数额+利息）。用户不能通过常规存款或从其他账户转账的放偿付，而必须以现金的方式交给特定的银行工作人员，欠款偿还后，欠款金额将归零\r\n\r\n*/\r\n#pragma once\r\n#include<string>\r\nclass Brass\r\n{\r\nprivate:\r\n	std ::string fullName;//客户名字\r\n	long accNum;     //账号\r\n	double balance;  //当前结余\r\npublic:\r\n	//构造函数，用来创建账户\r\n	Brass(const std::string & s, long an, double bal);\r\n	//存款函数\r\n	void Deposit(double amt);\r\n\r\n	//取款函数 ，由于会员与普通用户不同，所以在会员子类中进行重写\r\n	virtual void Withdraw(double amt);\r\n	//显示金额\r\n	double Balance()const;\r\n	virtual void ViewAcct()const;\r\n\r\n	//析构函数\r\n	virtual~Brass()\r\n	{\r\n	}\r\n};\r\nclass BrassPlus :public Brass  //继承普通的用户属性和方法\r\n{\r\nprivate:\r\n	//添加会员拥有的属性\r\n	double maxLoan;    //透支上限\r\n	double rate;       //透支利率\r\n	double oweBank;    //当前透支总额\r\npublic:\r\n	//会员的方法\r\n\r\n	//构造函数\r\n	BrassPlus(const std::string & s = \"NullBody\", long an = -1, double bal = 0.0, double ml = 500, double r = 0.11125);\r\n\r\n	BrassPlus(const Brass & ba, double ml = 500, double r = 0.11125);\r\n\r\n	virtual void ViewAcct()const;//重写父类的虚函数\r\n	virtual void Withdraw(double amt);\r\n	void ResetMax(double m)   //修改透支上限\r\n	{\r\n		maxLoan = m;\r\n	}\r\n	void ResetRate(double r) //修改利率\r\n	{\r\n		rate = r;\r\n	}\r\n	void ResetOwes()   //修改透支总额\r\n	{\r\n		oweBank = 0;\r\n	}\r\n\r\n};\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (82, 'C++ 虚继承(多继承情况下)', 1, '##虚继承(多继承情况下)\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nclass A\r\n{\r\nprivate:\r\n	int a = 25;\r\npublic:\r\n	int getA()\r\n	{\r\n		return a;\r\n	}\r\n\r\n};\r\nclass B:virtual public A\r\n{\r\n\r\n};\r\nclass C:virtual public A   //加入虚继承就不会报错\r\n{\r\n\r\n};\r\nclass D :public B, public C\r\n{\r\n\r\n};\r\nint main()\r\n{\r\n	D d;\r\n	d.getA();  //此时将报错，因为D不清楚调用哪个类的 getA()\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (83, 'C++ 单例模式', 1, '##单例模式\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nclass Person\r\n{\r\nprivate:\r\n	int a;\r\n	Person()  //将构造函数设置为私有\r\n	{\r\n	}\r\n	Person(int a)\r\n	{\r\n		this->a = a;\r\n	}\r\n	Person(const Person & p)\r\n	{\r\n		this->a = p.a;\r\n	}\r\npublic:\r\n	static int Z;           //设置动态数据，用来限制对象的多次创建\r\n	static Person*CreateOJ()   //创建静态成员函数，函数返回一个地址\r\n	{\r\n		if (Z == 1)\r\n		{\r\n			return new Person();\r\n			Z = 0;\r\n		}\r\n		else\r\n			return nullptr;\r\n	}\r\n	void setA(int a)\r\n	{\r\n		this->a = a;\r\n	}\r\n};\r\nint Person:: Z = 1;   //定义静态成员\r\nint main()\r\n{\r\n	Person *p = Person::CreateOJ(5);\r\n	\r\n\r\n\r\n	delete p;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (84, 'C++ 抽象基类(应用ABC的概念)', 1, '##抽象基类(应用ABC概念)\r\n```\r\n#include<iostream>\r\n#include \"acctabc.h\"\r\n#include<string>\r\nusing namespace std;\r\nconst int CLIENTS = 4;\r\nint main()\r\n{\r\n	AcctABC * p_clients[CLIENTS];\r\n	string temp;\r\n	long tempnum;\r\n	double tempbal;\r\n	char kind;\r\n	for (int i = 0; i < CLIENTS; i++)\r\n	{\r\n		cout << \"输入用户名：\";\r\n		getline(cin, temp);\r\n		cout << \"输入账号：\";\r\n		cin >> tempnum;\r\n		cout << \"输入余额：￥\";\r\n		cin >> tempbal;\r\n		cout << \"输入1选择普通用户，输入2选择会员用户\";\r\n		while (cin >> kind && (kind != \'1\'&& kind != \'2\'))\r\n		{\r\n			cout << \"请输入1或2\";\r\n		}\r\n		if (kind == \'1\')\r\n		{\r\n			p_clients[i] = new Brass(temp, tempnum, tempbal);\r\n		}\r\n		else\r\n		{\r\n			double tmax, trate;\r\n			cout << \"输入透支上限：￥\";\r\n			cin >> tmax;\r\n			cout << \"输入透支利率：\";\r\n			cin >> trate;\r\n			p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate);\r\n		}\r\n		while (cin.get() != \'\\n\')\r\n			continue;\r\n	}\r\n	cout << endl;\r\n	for (int i = 0; i < CLIENTS; i++)\r\n	{\r\n		p_clients[i]->VeiwAcct();\r\n		cout << endl;\r\n	}\r\n	for (int i = 0; i < CLIENTS; i++)\r\n	{\r\n		delete p_clients[i];\r\n	}\r\n	cout<<\"Done.\\n\";\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n\r\n###acctabc.h定义\r\n```\r\n#include<iostream>\r\n#include \"acctabc.h\"\r\nusing namespace std;\r\n//AcctABC方法\r\nAcctABC::AcctABC(const string & s, long an, double bal)\r\n{\r\n	fullName = s;\r\n	acctNum = an;\r\n	balance = bal;\r\n}\r\n//存款\r\nvoid AcctABC::Deposit(double amt)\r\n{\r\n	if (amt < 0)\r\n	{\r\n		cout << \"您输入的金额不合法\";\r\n	}\r\n	else\r\n		balance = balance + amt;\r\n}\r\n//取款\r\nvoid AcctABC::Withdraw(double amt)\r\n{\r\n	balance = balance = amt;\r\n}\r\nAcctABC::Formatting AcctABC::setFormat()const\r\n{\r\n	Formatting f;\r\n	f.flag = cout.setf(ios_base::fixed, ios_base::floatfield);\r\n	f.pr = cout.precision(2);\r\n	return f;\r\n}\r\nvoid AcctABC::Restore(Formatting & f)const\r\n{\r\n	cout.setf(f.flag, ios_base::floatfield);\r\n	cout.precision(f.pr);\r\n}\r\n\r\n//brass 方法\r\nBrass::Brass(const string & s, long an, double bal):AcctABC(s,an,bal)\r\n{\r\n\r\n}\r\n void Brass::Withdraw(double amt)\r\n{\r\n	if (amt < 0)\r\n	{\r\n		cout << \"您的余额不足\";\r\n	}\r\n	else if (amt <= Balance())\r\n	{\r\n		AcctABC::Withdraw(amt);\r\n	}\r\n	else\r\n		cout << \"您的余额不足\";\r\n}\r\nvoid Brass::VeiwAcct()const\r\n{\r\n	Formatting f = setFormat();\r\n	cout << \"客户名：\" << FullName() << endl;\r\n	cout << \"账号：\" << AccNum() << endl;\r\n	cout << \"账户余额：￥\" << Balance() << endl;\r\n	Restore(f);\r\n}\r\n\r\n//会员账户方法\r\nBrassPlus::BrassPlus(const string & s, long an, double bal, double ml, double r) :AcctABC(s, an, bal)\r\n{\r\n	maxLoan = ml;\r\n	oweBank = 0.0;\r\n	rate = r;\r\n}\r\nBrassPlus::BrassPlus(const Brass & ba, double ml, double r) :AcctABC(ba)\r\n{\r\n	maxLoan = ml;\r\n	oweBank = 0.0;\r\n	rate = r;\r\n}\r\nvoid BrassPlus::VeiwAcct()const\r\n{\r\n	Formatting f = setFormat();\r\n\r\n	cout << \"客户名：\" << FullName() << endl;\r\n	cout << \"账号：\" << AccNum() << endl;\r\n	cout << \"账户余额：\" << Balance() << endl;\r\n	cout << \"透支上限：￥\" << maxLoan << endl;\r\n	cout << \"已透支金额：￥\" << oweBank << endl;\r\n	cout.precision(3);\r\n	cout << \"利率:\" << 100 * rate << \"%\\n\";\r\n	Restore(f);\r\n}\r\nvoid BrassPlus::Withdraw(double amt)\r\n{\r\n	Formatting f = setFormat();\r\n\r\n	double bal = Balance();\r\n	if (amt <= bal)\r\n	{\r\n		AcctABC::Withdraw(amt);\r\n	}\r\n	else if (amt < bal + maxLoan - oweBank)\r\n	{\r\n		double advance = amt - bal;\r\n		oweBank = oweBank + advance * (1.0 + rate);\r\n		cout << \"已透支：￥\" << advance << endl;\r\n		cout << \"产生利息：￥\" << advance * rate << endl;\r\n		Deposit(advance);\r\n		AcctABC::Withdraw(amt);\r\n	}\r\n	else\r\n		cout << \"您的余额不足\" << endl;\r\n	Restore(f);\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n###acctabc.h\r\n\r\n```\r\n#pragma once\r\n#include <iostream>\r\n#include<string>\r\nusing namespace std;\r\nclass AcctABC//Abstract Base class\r\n{\r\nprivate:\r\n	string fullName;\r\n	long acctNum;\r\n	double balance;\r\nprotected:\r\n	struct Formatting  //格式化\r\n	{\r\n		ios_base::fmtflags flag;\r\n		streamsize pr;\r\n	};\r\n	\r\n	//get方法\r\n	const string & FullName()const\r\n	{\r\n		return fullName;\r\n	}\r\n	long AccNum()const\r\n	{\r\n		return acctNum;\r\n	}\r\n	Formatting setFormat()const;\r\n	void Restore(Formatting & f)const;\r\n\r\npublic:\r\n	AcctABC(const string & s = \"NullBody\", long an = -1, double bal = 0.0);\r\n	void Deposit(double amt);  //存款\r\n	virtual void Withdraw(double amt) = 0; //取款\r\n	virtual void VeiwAcct()const = 0;  //纯虚函数 ，抽象方法，需要在子类中重写\r\n	double Balance()const\r\n	{\r\n		return balance;\r\n	}\r\n	\r\n	virtual ~AcctABC()\r\n	{\r\n\r\n	}\r\n\r\n};\r\n\r\nclass Brass :public AcctABC  //继承AcctABC\r\n{\r\npublic:\r\n	Brass(const string & s = \"NullBody\", long an = -1, double bal = 0.0);	\r\n\r\n	virtual void Withdraw(double amt); //取款\r\n	virtual void VeiwAcct()const;  //纯虚函数 ，抽象方法，需要在子类中重写\r\n	virtual~Brass()\r\n	{\r\n\r\n	}\r\n};\r\n\r\nclass BrassPlus :public AcctABC\r\n{\r\nprivate:\r\n	double maxLoan;\r\n	double rate;\r\n	double oweBank;\r\npublic:\r\n	BrassPlus(const string & s = \"NullBody\", long an = -1, double bal = 0.0, double ml = 500, double r = 0.1);\r\n	BrassPlus(const Brass & ba, double ml = 500, double r = 0.1);\r\n	virtual void VeiwAcct()const;\r\n	virtual void Withdraw(double amt);\r\n	void ResetMax(double m)\r\n	{\r\n		maxLoan = m;\r\n	}\r\n	void ResetRate(double r)\r\n	{\r\n		rate = r;\r\n	}\r\n	void ResetOwes()\r\n	{\r\n		oweBank = 0;\r\n	}\r\n};\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (85, 'C++ 继承中的new和delete的使用', 1, '##继承中的new和delete的使用\r\n```\r\n#include<iostream>\r\n#include \"dma.h\"\r\nusing namespace std;\r\nint main()\r\n{\r\n	baseDMA shirt(\"Portabelly\", 8);\r\n	lacksDMA balloon(\"red\", \"Blimpo Keys\", 4);\r\n	hasDMA map(\"Mercator\", \"Buffalo Keys\", 5);\r\n	cout<<\"显示父类：\"<<endl;\r\n	cout << shirt << endl;\r\n	cout << \"显示 lackDMA子类:\" << endl;\r\n	cout << balloon << endl;\r\n	cout << \"显示hasDMA子类：\" << endl;\r\n	cout << map << endl;\r\n	lacksDMA balloon2(balloon);  //使用拷贝构造\r\n	cout << \"lackDMA拷贝结果：\" << endl;\r\n	cout << balloon2 << endl;\r\n	hasDMA map2;\r\n	map2 = map;\r\n	cout << \"hasDMA对象赋值结果：\" << endl;\r\n	cout << map2 << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###dma.h定义\r\n```\r\n#include \"dma.h\"\r\n#include<string>\r\n#include<memory.h>\r\nusing namespace std;\r\nbaseDMA::baseDMA(const char * l, int r)\r\n{\r\n	int len = strlen(l);\r\n	label = new char[len + 1];\r\n	memcpy(label,l,sizeof(char)*(len+1));\r\n	rating = r;\r\n}\r\n\r\nbaseDMA::baseDMA(const baseDMA & rs)//显示写拷贝构造函数，以免释放的同一块地址\r\n{\r\n	int len = strlen(rs.label);\r\n	label = new char[len + 1];\r\n	memcpy(label, rs.label,sizeof(char)*(len+1));\r\n	rating = rs.rating;\r\n}\r\n\r\nbaseDMA::~baseDMA()\r\n{\r\n	delete[]label;\r\n}\r\nbaseDMA & baseDMA::operator=(const baseDMA & rs)\r\n{\r\n	if (this == &rs)\r\n		return *this;\r\n	delete[] label;    //这里的一定要先释放内存，因为进行对象赋值的时候，第一个对象已经使用了该空间，并且没有被释放\r\n	int len = strlen(rs.label);\r\n	label = new char[len + 1];\r\n	memcpy(label, rs.label, sizeof(char)*(len+1));\r\n	rating = rs.rating;\r\n	return *this;\r\n}\r\n\r\nostream & operator<<(ostream & os, const baseDMA & rs)\r\n{\r\n	os << rs.label << endl;\r\n	os << rs.rating << endl;\r\n	return os;\r\n}\r\n\r\n//lacksDMA子类方法\r\nlacksDMA::lacksDMA(const char * c, const char * l, int r):baseDMA(l,r)//构造函数\r\n{\r\n	strncpy_s(color,sizeof(color), c, 39);    //将字符串的39位赋值给color\r\n	color[39] = \'\\0\';           //字符串的最后一位是\'\\0\';\r\n}\r\n\r\nlacksDMA:: lacksDMA(const char * c, const baseDMA & rs):baseDMA(rs)\r\n{\r\n	strncpy_s(color, sizeof(color),c, 39);\r\n	color[39] = \'\\0\';\r\n}\r\nostream & operator <<(ostream & os, const lacksDMA & ls)\r\n{\r\n	os << (const baseDMA &)ls << ls.color << endl;   //使用父类重载的重载的<<运算符\r\n	return os;\r\n}\r\n\r\n//hasDMA方法\r\n\r\nhasDMA::hasDMA(const char * s, const char * l, int r) :baseDMA(l, r)//构造函数\r\n{\r\n	int len = strlen(s);\r\n	style = new char[len+ 1];\r\n	memcpy(style, s, sizeof(char)*(len+1));\r\n}\r\nhasDMA::hasDMA(const char * s, const baseDMA & rs):baseDMA(rs)\r\n{\r\n	int len = strlen(s);\r\n	style = new char[len + 1];\r\n	memcpy(style, s, sizeof(char)*(len+1));\r\n}\r\nhasDMA::hasDMA(const hasDMA & hs):baseDMA(hs)  //子类的拷贝构造\r\n{\r\n	int len = strlen(hs.style);\r\n	style = new char[strlen(hs.style) + 1];\r\n	memcpy(style, hs.style, sizeof(char)*(len+1));\r\n}\r\nhasDMA::~hasDMA()\r\n{\r\n	delete[]style;\r\n}\r\nhasDMA & hasDMA::operator=(const hasDMA & hs)   //子类的重载赋值=运算符\r\n{\r\n	if (this == &hs)\r\n		return *this;\r\n	baseDMA::operator=(hs);\r\n	delete[]style;\r\n	int len = strlen(hs.style);\r\n	style = new char[strlen(hs.style) + 1];\r\n	memcpy(style, hs.style,sizeof(char)*(len+1));\r\n	return *this;\r\n}\r\nostream & operator<<(ostream & os, const hasDMA & hs)\r\n{\r\n	os << (const baseDMA &)hs;\r\n	os << hs.style << endl;\r\n	return os;\r\n}\r\n```\r\n\r\n###dma.h\r\n```\r\n#pragma once\r\n#include<iostream>\r\nclass baseDMA\r\n{\r\nprivate:\r\n	char* label;\r\n	int rating;\r\npublic:\r\n	baseDMA(const char*l = \"null\", int r = 0);  //构造函数\r\n	baseDMA(const baseDMA & rs);  //拷贝构造函数\r\n	virtual ~baseDMA();  \r\n	baseDMA & operator=(const baseDMA & rs);  //重载=赋值运算符\r\n	friend std::ostream & operator<<(std::ostream & os, const baseDMA & rs);//友元重载<<运算符\r\n};\r\nclass lacksDMA :public baseDMA\r\n{\r\nprivate :\r\n	enum { COL_LEN = 40 };\r\n	char color[COL_LEN];\r\npublic:\r\n	lacksDMA(const char* c = \"blank\", const char * l = \"null\", int r = 0);\r\n	lacksDMA(const char * c, const baseDMA & rs);\r\n	friend std::ostream & operator<<(std::ostream & os, const lacksDMA & rs);\r\n};\r\n\r\nclass hasDMA :public baseDMA\r\n{\r\nprivate:\r\n	char * style;\r\npublic:\r\n	hasDMA(const char * s = \"none\", const char * l = \"null\", int r = 0);\r\n	hasDMA(const char * s, const baseDMA & rs);\r\n	hasDMA(const hasDMA & hs);\r\n	~hasDMA();\r\n	hasDMA & operator=(const hasDMA & rs);\r\n	friend std::ostream & operator<<(std::ostream & os, const hasDMA & rs);\r\n};\r\n\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (86, 'C++ 多重继承', 1, '##多重继承\r\n```\r\n#include <iostream>\r\n#include \"Worker0.h\"\r\nconst int LIM = 4;\r\nint main() \r\n{\r\n	Waiter bob(\"Bob Apple\", 314L, 5);\r\n	Singer bev(\"Beverly Hills\", 522L, 3);\r\n	Waiter w_temp;\r\n	Singer s_temp;\r\n	Worker * pw[LIM] = { &bob,&bev,&w_temp,&s_temp };\r\n	int i;\r\n	for (i = 2; i < LIM; i++)\r\n	{\r\n		pw[i]->Set();\r\n	}\r\n	for (i = 0; i < LIM; i++)\r\n	{\r\n		pw[i]->Show();\r\n		cout << endl;\r\n	}\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###Worker0.h定义\r\n```\r\n#include<iostream>\r\n#include \"Worker0.h\"\r\nusing namespace std;\r\n//实现基类\r\nWorker::~Worker()\r\n{\r\n	//实现虚析构\r\n}\r\nvoid Worker::Set()\r\n{\r\n	cout << \"请输入名字：\";\r\n	getline(cin, fullname);\r\n	cout << \"请输入id\";\r\n	cin >> id;\r\n	while (cin.get() != \'\\n\')\r\n		continue;\r\n}\r\nvoid Worker::Show()const\r\n{\r\n	cout << \"姓名：\" << fullname << endl;\r\n	cout << \"用户id：\" << id << endl;\r\n}\r\n//waiter 方法\r\nvoid Waiter::Set()\r\n{\r\n	Worker::Set();//调用父类的set方法\r\n	cout << \"请输入waiter 的 panache rating：\";\r\n	cin >> panache;\r\n	while (cin.get() != \'\\n\')\r\n		continue;\r\n}\r\nvoid Waiter::Show()const\r\n{\r\n	cout << \"Category : waiter\" << endl;\r\n	Worker::Show();\r\n	cout << \"Panache rating:\" << panache << endl;\r\n}\r\n//Singer 方法\r\n\r\nchar * Singer::pv[] = {(char*)\"other\", (char*)\"alto\", (char*)\"contralto\",\r\n\r\n            (char*)\"soprano\", (char*)\"bass\", (char*)\"baritone\", (char*)\"tenor\"};//强制类型转换\r\n\r\nvoid Singer::Set()\r\n{\r\n	Worker::Set();\r\n	cout << \"Enter number for singer\'s vocal range:\" << endl;\r\n	int i;\r\n	for (i = 0; i < Vtypes; i++)\r\n	{\r\n		cout << i << \":\" << pv[i] << \"  \";\r\n		if (i % 4 == 3)\r\n		{\r\n			cout << endl;\r\n		}\r\n	}\r\n	if (i % 4 != 0)\r\n	{\r\n		cout << endl;\r\n	}\r\n	while (cin >> voice && (voice < 0 || voice >= Vtypes))\r\n	{\r\n		cout << \"Please enter a value>=0 and <\" << Vtypes << endl;;\r\n	}\r\n	while (cin.get() != \'\\n\')\r\n		continue;\r\n\r\n}\r\nvoid Singer::Show()const\r\n{\r\n	cout << \"Category:singer\" << endl;\r\n	Worker::Show();\r\n	cout << \"Vocal rang:\" << pv[voice] << endl;\r\n}\r\n```\r\n\r\n### Worker0.h\r\n\r\n```\r\n#pragma once\r\n#include<string>\r\nusing namespace std;\r\nclass Worker  //抽象基类\r\n{\r\nprivate:\r\n	string fullname;\r\n	long id;\r\npublic:\r\n	Worker() :fullname(\"no one\"), id(0L) {}  //内联无参构造函数\r\n	Worker(const string & s, long n) :fullname(s), id(n) {}  \r\n	virtual~Worker() = 0; //纯虚析构\r\n	virtual void Set();\r\n	virtual void Show()const;\r\n};\r\nclass Waiter :public Worker   //子类\r\n{\r\nprivate:\r\n	int panache;\r\npublic:\r\n	Waiter() :Worker(), panache(0) {}  //无参子类构造函数\r\n	Waiter(const string & s, long n, int p = 0) :Worker(s, n), panache(p) {}\r\n	Waiter(const Worker & wk, int p = 0) :Worker(wk), panache(p) {}\r\n	virtual void Set();\r\n	virtual void Show()const;\r\n};\r\nclass Singer :public Worker\r\n{\r\nprotected:\r\n	enum {other,alto,contralto,soprano,bass,baritone,tenor};\r\n	enum {Vtypes=7};\r\nprivate:\r\n	 static char*pv[Vtypes];  //char型指针数组\r\n	int voice;\r\npublic:\r\n	Singer():Worker(), voice(other) {}\r\n	Singer(const string & s, long n, int v = other) :Worker(s, n), voice(v) {}\r\n	Singer(const Worker & wk, int v = other) :Worker(wk), voice(v) {}\r\n	void Set();\r\n	void Show()const;\r\n};\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (87, 'C++ 虚继承', 1, '## 虚继承\r\n```\r\n#include <iostream>\r\n#include \"workermi.h\"\r\n#include <cstring>\r\nusing namespace std;\r\nconst int SIZE = 5;\r\nint main()\r\n{\r\n	Worker*lolas[SIZE];\r\n	int ct;\r\n	for (ct = 0; ct < SIZE; ct++)\r\n	{\r\n		char choice;\r\n		cout << \"请输入员工种类：\" << endl;\r\n		cout << \"w:waiter  s:singer  t:singing waiter  q:quit\" << endl;\r\n		cin >> choice;\r\n		while (strchr(\"wstq\", choice) == NULL)\r\n		{\r\n			cout << \"请输入一个 w,s,t或q：\";\r\n			cin >> choice;\r\n		}\r\n		if (choice == \'q\')\r\n			break;\r\n		switch (choice)\r\n		{\r\n		case \'w\':lolas[ct] = new Waiter;\r\n			break;\r\n		case \'s\':lolas[ct] = new Singer;\r\n			break;\r\n		case \'t\':lolas[ct] = new SingingWaiter;\r\n			break;\r\n		}\r\n		cin.get();\r\n		lolas[ct]->Set();\r\n	}\r\n	cout << \"\\n这是你的员工：\\n\";\r\n	int i;\r\n	for (i = 0; i < ct; i++)\r\n	{\r\n		cout << endl;\r\n		lolas[i]->Show();\r\n	}\r\n	for (i = 0; i < ct; i++)\r\n	{\r\n		delete lolas[i];\r\n	}\r\n	cout << \"Bye.\" << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n### 头文件函数实现\r\n```\r\n#include \"workermi.h\"\r\n#include <iostream>\r\nusing namespace std;\r\n/************************************************************************/\r\n/*          worker虚继类方法*/\r\n/************************************************************************/\r\nWorker::~Worker()\r\n{\r\n\r\n}\r\n//protected方法\r\nvoid Worker::Date()const\r\n{\r\n	cout << \"Name:\" << fullname << endl;\r\n	cout << \"Employee ID:\" << id << endl;\r\n}\r\nvoid Worker::Get()\r\n{\r\n	getline(cin, fullname);\r\n	cout << \"请输入worker的id：\";\r\n	cin >> id;\r\n	while (cin.get() != \'\\n\')\r\n		continue;\r\n}\r\n/************************************************************************/\r\n/* waiter类的方法                                                                     */\r\n/************************************************************************/\r\nvoid Waiter::Set()\r\n{\r\n	cout << \"请输入 waiter的名字:\";\r\n	Worker::Get();\r\n	Get();\r\n}\r\nvoid Waiter::Show()const\r\n{\r\n	cout << \"类别：waiter\" << endl;\r\n	Worker::Date();\r\n	Date();\r\n}\r\n//protected 方法\r\nvoid Waiter::Date()const\r\n{\r\n	cout << \"panache ratring\" << panache << endl;\r\n}\r\nvoid Waiter::Get()\r\n{\r\n	cout << \"输入waiter的panache rating:\";\r\n	cin >> panache;\r\n	while (cin.get() != \'\\n\')\r\n		continue;\r\n}\r\n/************************************************************************/\r\n/*             singer类方法                                                         */\r\n/************************************************************************/\r\nchar * Singer::pv[Singer::Vtypes] = { (char*)\"other\",(char*)\"alto\",(char*)\"contralto\",(char*)\"soprano\",(char*)\"bass\",(char*)\"baritone\",(char*)\"tenor\" };\r\nvoid Singer::Set()\r\n{\r\n	cout << \"请输入Singer的名字:\";\r\n	Worker::Get();\r\n	Get();\r\n}\r\nvoid Singer::Show()const\r\n{\r\n	cout << \"类别：singer\" << endl;\r\n	Worker::Date();\r\n	Date();\r\n}\r\n//protected 方法\r\nvoid Singer::Data()const\r\n{\r\n	cout << pv[voice] << endl;\r\n}\r\nvoid Singer::Get()\r\n{\r\n	cout << \"请输入singer的音域：\" << endl;\r\n	int i;\r\n	for (i = 0; i < Vtypes; i++)\r\n	{\r\n		cout << i << \":\" << pv[i] << \"  \";\r\n		if (i % 4 == 3)\r\n		{\r\n			cout << endl;\r\n		}\r\n		if (i % 4 != 0)\r\n		{\r\n			cout << endl;\r\n		}\r\n		cin >> voice;\r\n		while (cin.get() != \'\\n\')\r\n			continue;\r\n	}\r\n}\r\n/************************************************************************/\r\n/* singerwaiter类方法                                                                     */\r\n/************************************************************************/\r\nvoid SingingWaiter::Data()const\r\n{\r\n	Singer::Data();\r\n	Waiter::Date();\r\n}\r\nvoid SingingWaiter::Get()\r\n{\r\n	Waiter::Get();\r\n	Singer::Get();\r\n}\r\nvoid SingingWaiter::Set()\r\n{\r\n	cout << \"请输入 singer waiter的名字：\";\r\n	Worker::Get();\r\n	Get();\r\n}\r\nvoid SingingWaiter::Show()const\r\n{\r\n	cout << \"类别：singer waiter\" << endl;\r\n	Worker::Date();\r\n	Date();\r\n}\r\n```\r\n\r\n### workermi.h\r\n\r\n```\r\n#pragma once\r\n#include<string>\r\nusing namespace std;\r\nclass Worker   //基类\r\n{\r\nprivate :\r\n	string fullname;\r\n	long id;\r\nprotected:                //只在类内部中使用，辅助show函数的构建\r\n	virtual void Date()const;  \r\n	virtual void Get();     //虚函数可以在子类中进行重写\r\npublic:\r\n	Worker() :fullname(\"np one\"), id(0l) {}\r\n	Worker(const string & s, long n) :fullname(s), id(n) {}\r\n\r\n	virtual~Worker() = 0;  //纯虚函数，必须在子类中重写\r\n	virtual void Set() = 0;\r\n	virtual void Show()const = 0;\r\n};\r\nclass Waiter :virtual public Worker  //虚继承\r\n{\r\nprivate:\r\n	int panache;\r\nprotected:\r\n	virtual void Date()const;\r\n	virtual void Get();\r\npublic:\r\n	Waiter() :Worker(), panache(0) {}\r\n	Waiter(const string & s, long n, int p = 0) :Worker(s, n), panache(p) {}\r\n	Waiter(const Worker & wk, int p = 0) :Worker(wk), panache(p) {}\r\n	virtual void Set();\r\n	virtual void Show()const;\r\n};\r\nclass Singer : virtual public Worker  //虚继承\r\n{\r\nprotected:\r\n	enum { other, alto, contralto, soprano,bass,baritone, tenor };\r\n	enum {Vtypes = 7};\r\n	virtual void Data()const;\r\n	virtual void Get();\r\nprivate:\r\n	static char * pv[Vtypes];\r\n	int voice;\r\npublic:\r\n	Singer() :Worker(), voice(other) {}\r\n	Singer(const string & s, long n, int v = other) :Worker(s, n), voice(v) {}\r\n	Singer(const Worker & wk, int v = other) :Worker(wk), voice(v) {}\r\n	virtual void Set();\r\n	virtual void Show() const;\r\n};\r\n//虚继成后，waiter和singer将共享虚基类的对象（仅仅是共享，即可以使用）这样孙子类继承这两个类的时候不会产生二义性了\r\n//所继承的类也是祖先类的成员，而不是这两个父类的\r\nclass SingingWaiter :public Singer, public Waiter\r\n{\r\nprotected:\r\n	void Data()const;\r\n	void Get();\r\npublic:\r\n	//SingingWaiter(const Worker & wk, int p, int v = Singer::other) :Waiter(wk, p), Singer(wk, v) {}\r\n	//这种构造函数是无效的，因为，这样会导致，worker对象会以两种不同的方式传递给基类，为了避免冲突，C++禁止信息通过中间类传递给基类\r\n	//这样写会直接使用worker 的默认构造函数，如果不希望使用worker的默认的构造函数，则需要显示的调用基类的构造函数。\r\n	//下面这样写的就可以了\r\n	SingingWaiter() {}\r\n	SingingWaiter(const string & s, long n, int p = 0, int v = other) :Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {}\r\n	SingingWaiter(const Worker & wk, int p, int v = other) :Worker(wk), Waiter(wk, p), Singer(wk, v) {}\r\n	SingingWaiter(const Waiter & wt,int v=other):Worker(wt),Waiter(wt),Singer(wt,v){}\r\n	SingingWaiter(const Singer & wt, int p = 0) :Worker(wt), Waiter(wt, p), Singer(wt) {}\r\n	void Set();\r\n	void Show()const;//show函数要在派生类中重写最好的，而不是直接使用基类继承的，因为这样会产生二义性；\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (88, 'C++ 类模板', 1, '##类模板\r\n```\r\n#include <iostream>\r\n#include <string>\r\n#include <cctype>\r\n#include \"stacktp.h\"\r\nusing namespace std;\r\nint main()\r\n{\r\n	Stack<string>st;\r\n	char ch;\r\n	string po;\r\n	cout << \"Please enter A to add a purchase order,\\n\";\r\n	cout << \"P to process a PO,or Q to quit.\\n\";\r\n	while (cin >> ch && toupper(ch) != \'Q\') //如果参数是小写则返回其大写\r\n	{\r\n		while (cin.get() != \'\\n\')\r\n			continue;\r\n		if (!isalpha(ch))\r\n		{\r\n			cout << \'\\a\';\r\n			continue;\r\n		}\r\n		switch (ch)\r\n		{\r\n		case \'A\':\r\n		case \'a\':cout << \"Enter a PO number to add:\";\r\n			cin >> po;\r\n			if (st.isfull())\r\n				cout << \"stack already full\" << endl;\r\n			else\r\n				st.push(po);\r\n			break;\r\n		case \'p\':\r\n		case \'P\':if (st.isempty())\r\n			cout << \"stack already empty\" << endl;\r\n				 else \r\n		         {\r\n			st.pop(po);\r\n			cout << \"PO #\" << po << \" popped\" << endl;\r\n			break;\r\n		         }\r\n\r\n		}\r\n		cout << \"Please enter A to add a purchase order,\" << endl;\r\n		cout << \"P to process a PO,or Q to quit.\" << endl;\r\n	}\r\n	cout << \"Bye\" << endl;\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n### stacktp.h\r\n```\r\n#pragma once\r\ntemplate<class Type>\r\nclass Stack\r\n{\r\nprivate:\r\n	enum MyEnum{MAX=10};\r\n	Type items[MAX];\r\n	int top;\r\npublic:\r\n	Stack();\r\n	bool isempty();\r\n	bool isfull();\r\n	bool push(const Type & item);\r\n	bool pop(Type & item);\r\n};\r\ntemplate<class Type>\r\nStack<Type>::Stack()\r\n{\r\n	top = 0;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::isempty()\r\n{\r\n	return top == 0;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::isfull()\r\n{\r\n	return top == MAX;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::push(const Type & item)\r\n{\r\n	if (top < MAX)\r\n	{\r\n		items[top++] = item;\r\n		return true;\r\n	}\r\n	else\r\n		return false;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::pop(Type & item)\r\n{\r\n	if (top > 0)\r\n	{\r\n		item = items[--top];\r\n		return true;\r\n	}\r\n	else\r\n		return false;\r\n}\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (89, 'C++ 模板指针', 1, '##模板指针\r\n```\r\n#include<iostream>\r\n#include <cstdlib>\r\n#include<ctime>\r\n#include \"stack1.h\"\r\nusing namespace std;\r\nconst int Num = 10;\r\nint main()\r\n{\r\n	srand(time(0));\r\n	cout << \"Please enter stack size:\";\r\n	int stacksize;\r\n	cin >> stacksize;\r\n	Stack<const char * >st(stacksize);\r\n	const char*in[Num] =\r\n	{\r\n		\"1:Hank Gilgamesh\",\"2:Kiki Ishtar\",\r\n		\"3:Betty Rocker\",\"4:Ian Flagranti\",\r\n		\"5:Wolfgang Kibble\",\"6:Portia Koop\",\r\n		\"7:Joy Almondo\",\"8:Xaverie Paprika\",\r\n		\"9:Juan Moore\",\"10:Misha Mache\"\r\n	};\r\n	const char* out[Num];\r\n	int processed = 0;\r\n	int nextin = 0;\r\n	while (processed < Num)\r\n	{\r\n		if (st.isempty())\r\n			st.push(in[nextin++]);\r\n		else if (st.isfull())\r\n			st.pop(out[processed++]);\r\n		else if (rand() % 2 && nextin < Num)\r\n			st.push(in[nextin++]);\r\n		else\r\n			st.pop(out[processed++]);\r\n	}\r\n	for (int i = 0; i < Num; i++)\r\n	{\r\n		cout << out[i] << endl;\r\n	}\r\n	cout << \"Bye.\\n\";\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n### stack1.h\r\n```\r\n#pragma once\r\ntemplate <class Type>\r\nclass Stack\r\n{\r\nprivate:\r\n	enum { SIZE = 10 };\r\n	int stacksize;\r\n	Type * items;\r\n	int top;\r\npublic:\r\n	explicit Stack(int ss = SIZE);\r\n	Stack(const Stack & st);  //因为用到指针，所以要书写深拷贝，防止二次释放内存\r\n	~Stack()\r\n	{\r\n		delete[]items;\r\n	}\r\n	bool isempty()\r\n	{\r\n		return top == 0;\r\n	}\r\n	bool isfull()\r\n	{\r\n		return top == stacksize;\r\n	}\r\n	bool push(const Type & item);\r\n	bool pop(Type & item);\r\n	Stack & operator=(const Stack & st);//重载=赋值运算符\r\n};\r\ntemplate<class Type>\r\nStack<Type>::Stack(int ss) :stacksize(ss), top(0)\r\n{\r\n	items = new Type[stacksize];\r\n}\r\ntemplate<class Type>\r\nStack<Type>::Stack(const Stack & st)\r\n{\r\n	stacksize = st.stacksize;\r\n	top = st.top;\r\n	items = new Type[stacksize];\r\n	for (int i = 0; i < top; i++)\r\n	{\r\n		items[i] = st.items[i];\r\n	}\r\n}\r\ntemplate <class Type>\r\nbool Stack<Type>::push(const Type & item)\r\n{\r\n	if (top < stacksize)\r\n	{\r\n		items[top++] = item;\r\n		return true;\r\n	}\r\n	else\r\n		return false;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::pop(Type & item)\r\n{\r\n	if (top > 0)\r\n	{\r\n		item = items[--top];\r\n		return true;\r\n	}\r\n	else\r\n		return false;\r\n}\r\ntemplate<class Type>\r\nStack<Type>&Stack<Type>::operator=(const Stack<Type> & st)\r\n{\r\n	if (this == &st)\r\n		return *this;\r\n	delete[]items;\r\n	stacksize = st.stacksize;\r\n	top = st.top;\r\n	items = new Type[stacksize];\r\n	for (int i = 0; i < top; i++)\r\n	{\r\n		items[i] = st.items[i];\r\n	}\r\n	return *this;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (90, 'C++ 多个参数模板类', 1, '##多个参数模板类\r\n```\r\n#include<iostream>\r\n#include <string>\r\ntemplate<class T1,class T2>\r\nclass Pair\r\n{\r\nprivate:\r\n	T1 a;\r\n	T2 b;\r\npublic:\r\n	T1 & first();//返回引用，这样可以重新设置对象内数据的值，因为传引用会改变值\r\n	T2 & second();\r\n	T1 first()const\r\n	{\r\n		return a;\r\n	}\r\n	T2 & second()const\r\n	{\r\n		return b;\r\n	}\r\n	Pair(const T1 & aval, const T2 & bval) :a(aval), b(bval)\r\n	{\r\n\r\n	}\r\n	Pair()\r\n	{\r\n\r\n	}\r\n};\r\ntemplate<class T1,class T2>\r\nT1 & Pair<T1, T2>::first()\r\n{\r\n	return a;\r\n}\r\ntemplate<class T1,class T2>\r\nT2 & Pair<T1, T2>::second()\r\n{\r\n	return b;\r\n}\r\nint main()\r\n{\r\n	using namespace std;\r\n	Pair<string, int>rating[4] =//模板类数组\r\n	{\r\n		Pair<string ,int>(\"The Purpled Duck\",5),   //隐式实例化\r\n		Pair<string,int>(\"Jaquie\'s Frisco A1 Fresco\",4),\r\n		Pair<string,int>(\"Cafe Souffle\",5),\r\n		Pair<string,int>(\"Betie\'s Eats\",3)\r\n	};\r\n	int  joints = sizeof(rating) / sizeof(Pair<string, int>);  //每个对象占用48字节\r\n	cout << sizeof(rating) << endl;\r\n	cout << sizeof(Pair<string, int>) << endl;\r\n	cout << joints << endl;\r\n	cout << \"Rating:\\t Eatery\\n\";\r\n	for (int i = 0; i < joints; i++)\r\n	{\r\n		cout << rating[i].second() << \":\\t\" << rating[i].first() << endl;\r\n	}\r\n	cout << \"Oops!Revised rating:\\n\";\r\n	rating[3].first() = \"Bertie\'s Fab Eats\";\r\n	rating[3].second() = 6;\r\n	cout << rating[3].second() << \":\\t\" << rating[3].first() << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//模板类显示实例化 template class ArrayTP<string,100>\r\n```', 0);
INSERT INTO `blog_course` VALUES (91, 'C++ 函数模板具体化', 1, '##函数模板具体化\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nstruct Node \r\n{\r\n	int a;\r\n	double b;\r\n};\r\n//函数模板\r\ntemplate<typename T>\r\nvoid fun(T a)\r\n{\r\n	cout<< a;\r\n}\r\n//模板具体化\r\n\r\ntemplate<>\r\nvoid fun<Node>(Node n)   //用来处理原模板不支持的类型，但是前提要有与其匹配的模板\r\n{\r\n	cout << n.a << \",\" << n.b << endl;\r\n}\r\n\r\ntemplate void fun<int>(int a); //模板显示实例化\r\nvoid fun(int a)\r\n{\r\n	cout << a << endl;\r\n}\r\n\r\nint main()\r\n{\r\n	int a;\r\n	cin >> a;\r\n	Node n = { 5,6.5 };\r\n	fun(n);\r\n	//cout << fun(n) << endl;   模板类不能接收结构体类型，所以这里就需要模板具体化\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (92, 'C++ 类模板具体化', 1, '##类模板具体化\r\n```\r\n#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\ntemplate<class T1,class T2>\r\nclass Point\r\n{\r\nprivate:\r\n	T1 m_x;\r\n	T2 m_y;\r\npublic:\r\n	Point(T1 x, T2 y) :m_x(x), m_y(y)\r\n	{\r\n		//构造函数\r\n	}\r\n	void display()const;\r\n\r\n};\r\ntemplate<class T1,class T2>\r\nvoid Point<T1, T2>::display()const\r\n{\r\n	cout << \"x = \" << m_x << \",\" << \"y = \" << m_y << endl;\r\n}\r\n\r\n\r\n//类模板具体化\r\n template<>class Point<char*, int> \r\n{\r\nprivate:\r\n	char*x;\r\n	int size;\r\npublic:\r\n	Point(const char*x1,int size)  //这一定要加const\r\n	{\r\n		this->size = size;\r\n		x = new char[this->size];\r\n		strcpy_s(x, sizeof(x), x1);\r\n	}\r\n	Point(const Point&p)//拷贝构造\r\n	{\r\n		this->size = p.size;\r\n		x = new char[size];\r\n		strcpy_s(x, sizeof(x), p.x);\r\n	}\r\n\r\n	~Point()\r\n	{\r\n		delete x;\r\n	}\r\n	void display()const;\r\n\r\n};\r\ntypedef Point<char*, int>t1;  //类型别名\r\n//注意这里没有template<>\r\nvoid Point<char*, int>::display()const\r\n{\r\n	for (int i = 0; i < size; i++)\r\n	{\r\n		cout << x[i];\r\n	}\r\n}\r\nint main()\r\n{\r\n	typedef const char * pc1;\r\n	using pc2 = const char*;\r\n	//这两种别名是等价的，但是using = 只能用于非模板\r\n\r\n	Point<int, int >p1(10, 20);\r\n	p1.display();\r\n\r\n	Point<char*, int>p2(\"C++\",4);   //\"C++\"属于常量，所以构造函数要加const\r\n	p2.display();\r\n	\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (93, 'C++ 成员模板', 1, '##成员模板\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\ntemplate<typename t>\r\nclass beta\r\n{\r\nprivate:\r\n	template<typename v>  //类内模板类\r\n	class hold\r\n	{\r\n	private:\r\n		v val;\r\n	public:\r\n		hold(v v = 0) :val(v)\r\n		{\r\n			//内部模板类的构造函数\r\n		}\r\n		void show()const  \r\n		{\r\n			cout << val << endl;\r\n		}\r\n		v value()const\r\n		{\r\n			return val;\r\n		}\r\n	};\r\n	hold<t>q;\r\n	hold<int>n;\r\npublic:\r\n	beta(t t, int i) :q(t), n(i)\r\n	{\r\n		//构造函数\r\n	}\r\n	template<typename u>   //函数模板\r\n	u blab(u u, t t)    //模板函数返回一个模板类型\r\n	{\r\n		return n.value() + q.value()*u / t;\r\n	}\r\n	void show()const\r\n	{\r\n		q.show();\r\n		n.show();\r\n	}\r\n};\r\nint main()\r\n{\r\n	beta<double>guy(3.5, 3);//创建模板类对象，并隐式初始化为double类型\r\n	cout << \"t was set to double\\n\";\r\n	guy.show();\r\n	cout << \"v was set to t,which is double,then v was set to int\\n\";\r\n	cout << guy.blab(10, 2.3) << endl;\r\n	cout << \"u was set to int\\n\";\r\n	cout << guy.blab(10.0, 2.3) << endl;\r\n	cout << \"u was set to double\\n\";\r\n	cout << \"done\\n\";\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (94, 'C++ 将模板作为参数', 1, '##将模板作为参数\r\n```\r\n#include<iostream>\r\n#include \"stacktp.h\"\r\ntemplate<template<typename T> class Thing>\r\nclass Crab\r\n{\r\nprivate:\r\n	Thing<int>s1;\r\n	Thing<double>s2;\r\npublic:\r\n	Crab()\r\n	{\r\n\r\n	}\r\n	bool push(int a, double x)\r\n	{\r\n		return s1.push(a) && s2.push(x);\r\n	}\r\n	bool pop(int & a, double & x)\r\n	{\r\n		return s1.pop(a) && s2.pop(x);\r\n	}\r\n};\r\nint main()\r\n{\r\n	using namespace std;\r\n	Crab<Stack>nebula;\r\n	int ni;\r\n	double nb;\r\n	cout << \"Enter int double pairs,such as 4 3.5(0 0 to end):\\n\";\r\n	while (cin >> ni >> nb && ni > 0 && nb > 0)\r\n	{\r\n		if (!nebula.push(ni, nb))\r\n			break;\r\n	}\r\n	while (nebula.pop(ni, nb))\r\n	{\r\n		cout << ni << \",\" << nb << endl;\r\n	}\r\n	cout << \"Done.\\n\";\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###stacktp.h\r\n```\r\n#pragma once\r\ntemplate<class Type>\r\nclass Stack\r\n{\r\nprivate:\r\n	enum MyEnum{MAX=10};\r\n	Type items[MAX];\r\n	int top;\r\npublic:\r\n	Stack();\r\n	bool isempty();\r\n	bool isfull();\r\n	bool push(const Type & item);\r\n	bool pop(Type & item);\r\n};\r\ntemplate<class Type>\r\nStack<Type>::Stack()\r\n{\r\n	top = 0;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::isempty()\r\n{\r\n	return top == 0;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::isfull()\r\n{\r\n	return top == MAX;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::push(const Type & item)\r\n{\r\n	if (top < MAX)\r\n	{\r\n		items[top++] = item;\r\n		return true;\r\n	}\r\n	else\r\n		return false;\r\n}\r\ntemplate<class Type>\r\nbool Stack<Type>::pop(Type & item)\r\n{\r\n	if (top > 0)\r\n	{\r\n		item = items[--top];\r\n		return true;\r\n	}\r\n	else\r\n		return false;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (95, 'C++ 模板类的非模板友元函数', 1, '##模板类的非模板友元函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\ntemplate<class T>\r\nclass HasFriend\r\n{\r\nprivate:\r\n	T item;\r\n	static int ct;\r\npublic:\r\n	HasFriend(const T & i) :item(i)\r\n	{\r\n		ct++;   //静态成员用来监视构造函数被调用的次数\r\n	}\r\n	~HasFriend()\r\n	{\r\n		ct--;\r\n	}\r\n	friend void counts();  //它将是所有模板类实例化的友元：例如它是 HasFriend<int>和HasFriend<string>的友元\r\n	friend void reports(HasFriend<T>&);  //为友元类提供模板类参数，所以必须要使用友元定义的显示具体化\r\n	//HasFriend类模板有一个 静态成员ct，这意味着这个类的每一个特定的具体化都将有自己的静态成员，count()方法是所有HasFriend具体化的友元\r\n	//它报告两个特定的具体化HasFriend<int>,HasFriend<double>的静态ct值。\r\n};\r\ntemplate<class T>\r\nint HasFriend<T>::ct = 0;//对静态模板成员进行定义\r\nvoid counts()   //定义友元函数\r\n{\r\n	cout << \"HasFriend<int>:\" << HasFriend<int>::ct << \";\";\r\n	cout << \"double count:\" << HasFriend<double>::ct << endl;\r\n}\r\nvoid reports(HasFriend<int> & hf)\r\n{\r\n	cout << \"HasFriend<int>: \" << hf.item << endl;\r\n}\r\nvoid reports(HasFriend<double> & hf)      //重载reports函数\r\n{\r\n	cout << \"HasFriend<double>: \" << hf.item << endl;\r\n}\r\n\r\nint main()\r\n{\r\n\r\n	cout << \"No object declared: \";\r\n	counts();\r\n	HasFriend<int>hfi1(10);\r\n	cout << \"After hfil declared: \";\r\n	counts();\r\n	HasFriend<int>hfi2(20);\r\n	cout << \"After hfi2 declared: \";\r\n	counts();\r\n\r\n	HasFriend<double>hfdb(10.5);\r\n	cout << \"After hfdb declared: \";\r\n	reports(hfi1);\r\n	reports(hfi2);\r\n	reports(hfdb);\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (96, 'C++ 模板类的约束模板和友元函数', 1, '##模板类的约束模板和友元函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\ntemplate<class tt>void counts(); \r\ntemplate<class tt>void report(tt &); //在类定义前声明每一个模板函数\r\n\r\n//在编译器进行编译时，编译器会产生类的模板函数声明，当实际确认类型后调用，会根据调用的类型进行再次帮我们生成对应类型的函数声明和定义。我们称为二次编译。\r\n//因为这个机制，会经常报错找不到类的函数的实现。在模板类的友元函数外部定义时，也会出现这个错误。解决方法是“类的前置声明和函数的前置声明”；\r\n\r\ntemplate<class tt>\r\nclass hasfriendt\r\n{\r\nprivate:\r\n	tt item;\r\n	static int ct;\r\npublic:\r\n	hasfriendt(const tt & i) :item(i)\r\n	{\r\n		ct++;\r\n	}\r\n	~hasfriendt()\r\n	{\r\n		ct--;\r\n	}\r\n	friend void counts<tt>();   //因为counts函数没有参数，所以必须使用模板参数语法（<tt>）来指名其具体化\r\n	friend void report<hasfriendt<tt>>(hasfriendt<tt> &);\r\n	//模板的具体化，<>可以为空。因为可以从函数参数推断模板类型参数\r\n	\r\n	//如果普通的模板函数声明在类的内部，定义在类的外部，不会出现任何错误；\r\n	//但是如果是友元函数就会出现报错，因为有二次编译这个机制存在\r\n	\r\n\r\n};\r\ntemplate<class tt>\r\nint hasfriendt<tt>::ct = 0;//定义并初始化静态成员\r\n\r\n//类友元函数\r\ntemplate<class tt>   //类友元函数定义   //证明类内的友元函数优先级高于类外的普通模板函数\r\nvoid counts()\r\n{\r\n	cout << \"template size :\" << sizeof(hasfriendt<tt>) << \"; \";\r\n	cout << \"template counts(): \" << hasfriendt<tt>::ct << endl;\r\n}\r\ntemplate<class tt>\r\nvoid report(tt &hf)\r\n{\r\n	cout << hf.item << endl;\r\n}\r\nint main()\r\n{\r\n	counts<int>();\r\n	hasfriendt<int>hfil(10);\r\n	hasfriendt<int>hfi2(20);\r\n	hasfriendt<double>hfdb(10.5);\r\n	report(hfil);\r\n	report(hfi2);\r\n	report(hfdb);\r\n	cout << \"count<int>()output:\\n\";\r\n	counts<int>();\r\n	cout << \"count<double>()output:\\b\";\r\n	counts<double>();\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (97, 'C++ 模板类的非约束模板和友元函数', 1, '##模板类的非约束模板和友元函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n//声明和定义分别在不同的文件。尽量将模板函数与友元函数放在一个文件下\r\n//1.类的声明与函数的声明写在.h文件\r\n//2.类的实现及函数的实现写在.cpp文件\r\n//3.将.cpp文件改成.hpp文件\r\n//4.在主函数中调用.hpp文件，而不是引用.h文件\r\n\r\ntemplate<class T>\r\nclass ManyFriend\r\n{\r\nprivate:\r\n	T item;\r\npublic:\r\n	ManyFriend(const T & i) :item(i)\r\n	{\r\n\r\n	}\r\n	template<class C, class D>friend void show2(C&, D&);   //模板友元  这里友元参数模板与类模板是不同的\r\n};\r\ntemplate<class C, class D>void show2(C&c, D&d)  //是所有ManyFrienf具体化的友元\r\n{\r\n	cout << c.item << \",\" << d.item << endl;\r\n}\r\nint main()\r\n{\r\n	ManyFriend<int>hfi1(10);\r\n	ManyFriend<int>hfi2(20);\r\n	ManyFriend<double>hfdb(10.5);\r\n	cout << \"hfi1,hfi2\";\r\n	show2(hfi1, hfi2);\r\n	cout << \"hfdb\", \"hfi2:\";\r\n	show2(hfdb, hfi2);\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n为了方便可以给模板具体化个别名，方便使用\r\n例：typedef array<double, 12>arrd;\r\n```', 0);
INSERT INTO `blog_course` VALUES (98, 'C++ 模板类继承', 1, '##模板类继承\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\ntemplate <typename T>\r\nclass Parent {\r\npublic:\r\n	Parent(T p)\r\n	{\r\n		this->p = p;\r\n	}\r\n\r\nprivate:\r\n	T p;\r\n};\r\n\r\n//如果子类不是模板类，需要指明父类的具体类型\r\nclass ChildOne :public Parent<int> {\r\n\r\npublic:\r\n	ChildOne(int a, int b) :Parent(b)\r\n	{\r\n		this->cone = a;\r\n	}\r\n\r\nprivate:\r\n	int cone;\r\n};\r\n\r\n\r\n//如果子类是模板类，可以用子类的泛型来表示父类\r\ntemplate <typename T>\r\nclass ChildTwo :public Parent<T> {\r\n\r\npublic:\r\n	ChildTwo(T a, T b) :Parent<T>(b)\r\n	{\r\n		this->ctwo = a;\r\n	}\r\n\r\nprivate:\r\n	T ctwo;\r\n};\r\n\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (99, 'C++ 友元类(遥控器-电视机)', 1, '##友元类\r\n```\r\n#include <iostream>\r\n#include \"tv.h\"\r\nint main()\r\n{\r\n	using std::cout;\r\n	using std::endl;\r\n	Tv s42;\r\n	cout << \"Initial settings for 42\\\"TV:\" << endl;\r\n	s42.settings();\r\n	s42.onoff();\r\n	s42.chanup();\r\n	cout << \"\\nAdjusted setting for 42\\\"TV:\" << endl;\r\n	s42.chanup();\r\n	cout << \"\\nAdjusted settings for 42\\\"TV:\" << endl;\r\n	s42.settings();\r\n\r\n	Remote grey;\r\n	grey.set_chan(s42, 10);\r\n	grey.volup(s42);\r\n	grey.volup(s42);\r\n	cout << \"\\n42\\\"settings after using remote:\" << endl;\r\n	s42.settings();\r\n	Tv s58(Tv::On);\r\n	s58.set_mode();\r\n	grey.set_chan(s58, 28);\r\n	cout << \"\\n58\\\"settings:\" << endl;\r\n	s58.settings();\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###tv.h 类函数实现\r\n```\r\n#include<iostream>\r\n#include \"tv.h\"\r\nbool Tv::volup()\r\n{\r\n	if (volume < MaxVal)\r\n	{\r\n		volume++;\r\n		return true;\r\n	}\r\n	else\r\n		return false;\r\n}\r\nbool Tv::voldown()\r\n{\r\n	if (volume > MinVal)\r\n	{\r\n		volume--;\r\n		return true;\r\n	}\r\n	else\r\n		return false;\r\n}\r\nvoid Tv::chanup()\r\n{\r\n	if (channel < maxchannel)\r\n	{\r\n		channel++;\r\n	}\r\n	else\r\n	{\r\n		channel--;\r\n	}\r\n}\r\nvoid Tv::chandown()\r\n{\r\n	if (channel > 1)\r\n	{\r\n		channel--;\r\n	}\r\n	else\r\n		channel = maxchannel;\r\n}\r\nvoid::Tv::settings()const\r\n{\r\n	using std::cout;\r\n	using std::endl;\r\n	cout << \"TV is\" << (state == Off ? \"Off\" : \"On\") << endl;\r\n	if (state == On)\r\n	{\r\n		cout << \"Volume setting = \" << volume << endl;\r\n		cout << \"Channel setting = \" << channel << endl;\r\n		cout << \"Mode = \" << (mode == Antenna ? \"antenna\" : \"cable\") << endl;\r\n		cout << \"Input = \" << (input == TV ? \"TV\" : \"DVD\") << endl;\r\n	}\r\n}\r\n\r\n\r\n```\r\n\r\n###tv.h\r\n```\r\n#pragma once\r\nclass Tv    //电视类\r\n{\r\nprivate:\r\n	int state;     //开关\r\n	int volume;    //音量\r\n	int maxchannel;//最大信道数\r\n	int channel;   //信道\r\n	int mode;      //有限tv或广播tv\r\n	int input;     //tv或dvd\r\npublic:\r\n	friend class Remote;  //友元类\r\n	enum { Off, On };   //设置枚举常量，用于开关\r\n	enum { MinVal, MaxVal = 20 };//最大最小音量\r\n	enum { Antenna, Cable };     //有限或广播\r\n	enum { TV, DVD };            //tv或dvd\r\n	Tv(int s = Off, int mc = 125) :state(s), volume(5), maxchannel(mc), channel(2), mode(Cable), input(TV)\r\n	{\r\n		//构造函数\r\n		//电视对象默认是关闭状态；\r\n		//音量默认是5；\r\n		//最大信道数是125；\r\n		//信道默认是2；\r\n		//播放模式默认为广播tv\r\n		//音频模式默认是TV模式\r\n	}\r\n	void onoff()\r\n	{\r\n		state = (state == On) ? Off : On;\r\n	}\r\n	bool ison()const\r\n	{\r\n		return state == On;\r\n	}\r\n	bool volup();\r\n	bool voldown();\r\n	void chanup();\r\n	void chandown();\r\n	void set_mode()\r\n	{\r\n		mode = (mode == Antenna) ? Cable : Antenna;\r\n	}\r\n	void set_input()\r\n	{\r\n		input = (input == TV) ? DVD : TV;\r\n	}\r\n	void settings()const;\r\n\r\n};\r\nclass Remote    //遥控器类 ,遥控器具备让电视改变状态的方法，那么遥控器就需要调用电视类的方法\r\n{\r\nprivate:\r\n	int mode;   //调控TV或DVD\r\npublic:\r\n	Remote(int m = Tv::TV) :mode(m)\r\n	{\r\n\r\n	}\r\n	bool volup(Tv & t)\r\n	{\r\n		return t.volup();\r\n	}\r\n	bool voldown(Tv& t)\r\n	{\r\n		return t.voldown();\r\n	}\r\n	void onoff(Tv & t)\r\n	{\r\n		t.onoff();\r\n	}\r\n	void chanup(Tv & t)\r\n	{\r\n		t.chanup();\r\n	}\r\n	void chandown(Tv & t)\r\n	{\r\n		t.chandown();\r\n	}\r\n	void set_chan(Tv & t, int c)\r\n	{\r\n		t.channel = c;\r\n	}\r\n	void set_mode(Tv& t)\r\n	{\r\n		t.set_mode();\r\n	}\r\n	void set_input(Tv & t)\r\n	{\r\n		t.set_input();\r\n	}\r\n\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (100, 'C++ 两个类的时间同步(互为友元)', 1, '##互为友元\r\n```\r\nclass Analyzer;\r\nclass Probe\r\n{\r\n	friend void sync(Analyzer & a, const const Probe & p);\r\n	friend void sync(Probe & p, const Analyzer & a);\r\n};\r\nclass Analyzer\r\n{\r\n	friend void sync(Analyzer & a, const const Probe & p);\r\n	friend void sync(Probe & p, const Analyzer & a);\r\n};\r\ninline void sync(Analyzer & a, const Probe & p)\r\n{\r\n\r\n}\r\ninline void sync(Probe & p, const Analyzer &a)\r\n{\r\n\r\n}\r\n//假定这两个类一个测量设备，一个分析设备，两个类都有内部时钟，而且希望同步\r\n```', 0);
INSERT INTO `blog_course` VALUES (101, 'C++ 嵌套类使用', 1, '##嵌套类使用\r\n```\r\n#include <iostream>\r\n#include <string>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <valarray>\r\n#include \"queuetp.h\"\r\nusing std::cout;\r\nusing std::endl;\r\ntemplate<class Type>\r\nQueue<Type>::Queue(int size) : maxSize(size) \r\n{\r\n	front = rear = 0;\r\n	curSize = 0;\r\n}\r\ntemplate<class Type>\r\nQueue<Type>::~Queue()\r\n{\r\n	Node *tmp;\r\n	while (front != 0)\r\n	{\r\n		tmp = front;\r\n		front = front->next;\r\n		delete tmp;\r\n	}\r\n}\r\ntemplate<class Type>\r\nbool Queue<Type>::isFull() const \r\n{\r\n	return curSize >= maxSize;\r\n}\r\ntemplate<class Type>\r\nbool Queue<Type>::isEmpty() const \r\n{\r\n	return curSize == 0;\r\n}\r\ntemplate<class Type>\r\nbool Queue<Type>::enQueue(const Type data)\r\n{\r\n	if (isFull()) \r\n	{\r\n		return false;\r\n	}\r\n	Node *node = new Node(data);\r\n	if (front == 0)\r\n	{\r\n		front = node;\r\n	}\r\n	else \r\n	{\r\n		rear->next = node;\r\n	}\r\n	rear = node;\r\n	curSize++;\r\n	return true;\r\n}\r\ntemplate<class Type>\r\nbool Queue<Type>::deQueue() \r\n{\r\n	if (isEmpty())\r\n	{\r\n		return false;\r\n	}\r\n	Node *tmpNode = front;\r\n	front = front->next;\r\n	delete tmpNode;\r\n	if (front == 0) \r\n	{\r\n		rear = 0;\r\n	}\r\n	curSize--;\r\n	return true;\r\n} \r\ntemplate<class Type>\r\nvoid Queue<Type>::tarverseQueue() const \r\n{\r\n	Node *head = front;\r\n	while (head != 0) \r\n	{\r\n		cout << head->data << endl;\r\n		head = head->next;\r\n	}\r\n}\r\nint main(int argc, char *argv[]) \r\n{\r\n	Queue<int> queue(10);\r\n	queue.enQueue(11);\r\n	queue.enQueue(12);\r\n	queue.tarverseQueue();\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n###queuetp.h\r\n```\r\n#ifndef QUEUE_H_\r\n#define QUEUE_H_\r\ntemplate<class Type>\r\nclass Queue {\r\n\r\nprivate:\r\n	enum { Q_SIZE = 10 };\r\n	class Node \r\n	{\r\n	public:\r\n		Type data;\r\n		Node * next;\r\n		Node(const Type data) : data(data), next(0) {}\r\n	};\r\n\r\n	Node *front;\r\n	Node *rear;\r\n	int curSize;\r\n	int maxSize;\r\npublic:\r\n	Queue(int size = Q_SIZE);\r\n	~Queue();\r\n	bool isFull() const;\r\n	bool isEmpty() const;\r\n	bool enQueue(const Type data);\r\n	bool deQueue();\r\n	void tarverseQueue() const;\r\n};\r\n#endif\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (102, 'C++ try_catch异常处理', 1, '##try_catch异常处理\r\n```\r\n#include <iostream>\r\ndouble hmean(double a, double b);\r\n\r\nint main()\r\n{\r\n	double x, y, z;\r\n	while (1)\r\n	{\r\n		std::cin >> x >> y;\r\n		try\r\n		{\r\n			z = hmean(x, y);   //这里可能会引发异常\r\n		}\r\n		catch (const char * s)//引发异常，catch体将异常的内容赋值给变量s\r\n		{\r\n			std::cout << s << std::endl;\r\n			std::cout << \"重新一组新的数\";\r\n			continue;\r\n		}\r\n		std::cout << x << \",\" << y << \",\" << z << std::endl;\r\n	}\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ndouble hmean(double a, double b)\r\n{\r\n	if (a == -b)\r\n		throw\"bad hmean() arguments:a = -b not allowed\";  //执行这里时出发异常\r\n	//执行throw语句类似于执行返回语句，因为它将终止函数的执行，但是throw不是将控制权返回给调用程序，而是导致程序沿函数调用序列后退，直到找到包含try块的函数\r\n\r\n	return 2.0*a*b / (a + b);\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (103, 'C++ 异常调用abort()', 1, '##异常调用abort()\r\n```\r\n#include<iostream>\r\n#include <cstdlib>\r\ndouble hmean(double a, double b);//此函数用来计算两个数的调和平均数\r\n\r\nint main()\r\n{\r\n	double x, y, z;\r\n	std::cout << \"Enter two numbers:\";\r\n	while (std::cin >> x >> y)\r\n	{\r\n		z = hmean(x, y);\r\n		std::cout << \"Harmonic mean of \" << x << \" and\" << y << \" is \" << z << std::endl;\r\n		std::cout << \" Enter next set of numbers<q to quit>:\";\r\n	}\r\n	std::cout << \"Bye!\" << std::endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ndouble hmean(double a, double b)\r\n{\r\n	if (a == -b)\r\n	{\r\n		std::cout << \"ntenable arguments to hmean()\\n\";\r\n		std::abort();   //如果a=-b那么将违背数学定律分母不可为0；调用abort（）函数。该函数存在<cstdlib>头文件中\r\n		//执行函数会使程序终止退回父进程\r\n	}\r\n	return 2.0*a*b / (a + b);\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (104, 'C++ 抛出对象异常', 1, '##抛出对象异常\r\n```\r\n#include <iostream>\r\n#include <cmath>\r\n#include \"exc_mean.h\"\r\n\r\ndouble hmean(double a, double b);\r\ndouble gmean(double a, double b);\r\nint main()\r\n{\r\n	using std::cout;\r\n	using std::cin;\r\n	using std::endl;\r\n	double x, y;\r\n	while (1)\r\n	{\r\n		cin >> x >> y;\r\n		try\r\n		{\r\n			cout << hmean(x,y) << endl;\r\n			cout << gmean(x, y) << endl;\r\n		}\r\n		catch (bad_hmean & bg)\r\n		{\r\n			bg.mesg();\r\n			cout << \"请重新输入\" << endl;\r\n			continue;\r\n		}\r\n		catch (bad_gmean & hg)\r\n		{\r\n			cout << hg.mesg();\r\n			cout << hg.v1 << \",\" << hg.v2 << endl;\r\n			break;\r\n		}\r\n	}\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ndouble hmean(double a, double b)\r\n{\r\n	if (a == -b)\r\n		throw bad_hmean(a, b);    //抛出对象，抛出时要抛出引用或指针，否则会调用拷贝构造\r\n	return 2.0*a*b / (a + b);\r\n}\r\ndouble gmean(double a, double b)\r\n{\r\n	if (a < 0 || b < 0)\r\n		throw bad_gmean(a, b);\r\n	return std::sqrt(a*b);\r\n}\r\n\r\n//double marm()noexcept  关键字指出函数不会引发异常\r\n```\r\n\r\n###exc_mean\r\n\r\n```\r\n#pragma once\r\n#include <iostream>\r\nclass bad_hmean\r\n{\r\nprivate:\r\n	double v1;\r\n	double v2;\r\npublic:\r\n	bad_hmean(double a = 0, double b = 0):v1(a),v2(b)\r\n	{\r\n\r\n	}\r\n	void mesg();\r\n};\r\ninline void bad_hmean::mesg()\r\n{\r\n	std::cout << \"hmean(\" << v1 << \",\" << v2 << \"):\" << \"invalid arguments : a = -b\\n\";\r\n}\r\nclass bad_gmean\r\n{\r\npublic:\r\n	double v1;\r\n	double v2;\r\n	bad_gmean(double a = 0, double b = 0) :v1(a), v2(b)\r\n	{\r\n\r\n	}\r\n	const char* mesg();\r\n};\r\ninline const char * bad_gmean::mesg()\r\n{\r\n	return \"gmean() arguments should be >= 0\\n\";\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (105, 'C++ 栈解退', 1, '##栈解退\r\n```\r\n#include<iostream>\r\n#include <cmath>\r\n#include <string>\r\n#include \"exc_mean.h\"\r\nclass demo\r\n{\r\nprivate:\r\n	std::string word;\r\npublic:\r\n	demo(const std::string & str)\r\n	{\r\n		word = str;\r\n		std::cout << \"demo\" << word << \" created\\n\";   //用于监视被调用的次数\r\n	}\r\n	~demo()\r\n	{\r\n		std::cout << \"demo\" << word << \" destroyed\\n\";\r\n	}\r\n	void show()const\r\n	{\r\n		std::cout << \"demo \" << word << \" lives!\\n\";\r\n	}\r\n};\r\n\r\n\r\ndouble hmean(double a, double b);\r\ndouble gmean(double a, double b);\r\ndouble means(double a, double b);\r\nint main()\r\n{\r\n	using std::cout;\r\n	using std::cin;\r\n	using std::endl;\r\n	double x, y, z;\r\n	{\r\n		demo d1(\"found in block in main()\"); //创建一个demo类对象\r\n		cout << \"Enter two numbers\";\r\n		while (1)\r\n		{\r\n			cin >> x >> y;\r\n			try\r\n			{\r\n				z = means(x, y);\r\n				cout << \"The mean mean of \" << x << \" and \" << y << \" is \" << z << endl;\r\n				cout << \"Enter next pair:\";\r\n			}\r\n			catch (bad_hmean & bg)\r\n			{\r\n				bg.mesg();\r\n				cout << \"Try again.\\n\";\r\n				continue;\r\n			}\r\n			catch (bad_gmean & hg)\r\n			{\r\n				cout << hg.mesg();\r\n				cout << \"Values used: \" << hg.v1 << \",\" << hg.v2 << endl;\r\n				cout << \"Sorry,you don\'t get to play any more.\\n\";\r\n				break;\r\n			}\r\n		}\r\n		d1.show();\r\n	}\r\n	cout << \"Bye!\\n\";\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ndouble hmean(double a, double b)\r\n{\r\n	if (a == -b)\r\n		throw bad_hmean(a, b);   //上抛异常\r\n	return 2.0*a*b / (a + b);\r\n}\r\ndouble gmean(double a, double b) \r\n{\r\n	if (a < 0 || b < 0)\r\n		throw bad_gmean(a, b);//抛出对象，对象可以装多种不同的信息。然后将异常提示放在类中\r\n	return std::sqrt(a*b);\r\n}\r\ndouble means(double a, double b)  //求三数之和的平均数\r\n{\r\n	double am, hm, gm;\r\n	demo d2(\"founf in means()\");\r\n	am = (a + b) / 2.0;\r\n	try\r\n	{\r\n		hm = hmean(a, b);    //这里可能会出现异常，所以进行try\r\n		gm = gmean(a, b);\r\n	}\r\n	catch (bad_hmean & bg)  \r\n	{\r\n		bg.mesg();   //捕获hmean异常\r\n		std::cout << \"Caught int means()\\n\";\r\n		throw;  //终止程序\r\n	}\r\n	d2.show();//没有被执行，means提前终止，但是d2还是调用了析构函数\r\n	return (am + hm + gm) / 3.0;\r\n\r\n}\r\n//被一个函数调用的函数的调用的函数出现异常\r\n```\r\n\r\n###exc_mean\r\n\r\n```\r\n#pragma once\r\n#include <iostream>\r\nclass bad_hmean\r\n{\r\nprivate:\r\n	double v1;\r\n	double v2;\r\npublic:\r\n	bad_hmean(double a = 0, double b = 0):v1(a),v2(b)\r\n	{\r\n\r\n	}\r\n	void mesg();\r\n};\r\ninline void bad_hmean::mesg()\r\n{\r\n	std::cout << \"hmean(\" << v1 << \",\" << v2 << \"):\" << \"invalid arguments : a = -b\\n\";\r\n}\r\nclass bad_gmean\r\n{\r\npublic:\r\n	double v1;\r\n	double v2;\r\n	bad_gmean(double a = 0, double b = 0) :v1(a), v2(b)\r\n	{\r\n\r\n	}\r\n	const char* mesg();\r\n};\r\ninline const char * bad_gmean::mesg()\r\n{\r\n	return \"gmean() arguments should be >= 0\\n\";\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (106, 'C++ exception类', 1, '##exception类\r\n```\r\n//通过继承重写exception虚方法what（）\r\n#include<exception>\r\nclass bad_hmean :public std::exception\r\n{\r\npublic:\r\n	const char * what()\r\n	{\r\n		return \"bad arguments to hmean()\";\r\n	}\r\n};\r\nclass bad_gmean :public std::exception\r\n{\r\npublic:\r\n	const char * what()\r\n	{\r\n		return \"bad arguments to gmean()\";\r\n	}\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (107, 'C++ stdexecpt类', 1, '##stdexcept类\r\n```\r\n#include<iostream>\r\n#include<exception>\r\n#include<string>\r\n#include<stdexcept>\r\nusing namespace std;\r\n//头文件stdexcept定义了其他几个异常类，首先定义了logic_error和runtime_error类，他们都是以公有的方式从exception派生而来的\r\nclass logic_error :public exception\r\n{\r\npublic:\r\n	explicit logic_error(const string & what_arg);\r\n};\r\nclass domain_error :public logic_error\r\n{\r\npublic:\r\n	explicit domain_error(const string & what_arg);\r\n};\r\n\r\n//异常系列类logic_error描述了典型的逻辑错误,每个类都有一个类似于logic_error的构造函数，然您能够提供一个供方法what()返回的字符串\r\n//domain_error:\r\n//定义域由参数的可能取值组成，值域由函数可能的返回值组成。例如正弦函数的定义域为负无穷大到整无穷大，但是值域为-1到+1。\r\n//如果参数不在定义域内就会引发domain_error异常\r\n//invalid_arguments;\r\n//如果函数希望接受一个这样的字符串，每个字符要么是‘0’要么是‘1’，当传递其他字符时救护引发invalid_argument异常\r\n//length_error;\r\n//用于指出没有足够的空间来执行所需操作。例如string类的append(）方法在合并得到的字符串长度超过最大允许长度时将引发length_error异常\r\n//out_of_bounds\r\n//通常用于指出索引错误，例如您可以定义一个类似于数组的类，其operator()[]在使用索引无效引发out_of_bounds异常\r\n\r\n//异常系列类runtime_error描述了可能在运行期间发生但难以预计和防范的错误，每个类的名称指出它用于报告的错误类型\r\n//range_error;\r\n//overflow_error\r\n//underflow_erroe\r\n//每一个类独有一个类似于runtime_error的构造函数，让您能够提供一个方法what()返回的字符串。\r\n//unerflow错误在浮点数计算中，一般而言，存在浮点类型可以表示的最小非零值，计算结果比这个值还小时将导致下溢错误，\r\n//overflow整形和浮点型都可能发生上溢错误，当计算结果超过了某种类型能够表达的最大数量级时将发生上溢错误\r\n//计算结果可能不在函数允许范围内，但没有发生上溢或下溢错误，在这种情况下可以使用range_error异常\r\n```', 0);
INSERT INTO `blog_course` VALUES (108, 'C++ bad_alloc异常和new', 1, '##bad_alloc异常和new\r\n```\r\n//对于使用new导致的内存分配问题，C++的最新处理方式时让new引发bad_alloc异常。头文件new包含bad_alloc类的声明\r\n#include <iostream>\r\n#include<new>\r\n#include <cstdlib>\r\nusing namespace std;\r\nstruct Big\r\n{\r\n	double stuff[20000];\r\n};\r\nint main()\r\n{\r\n	Big * pb;\r\n	try\r\n	{\r\n		cout << \"Trying to get a big block of memory:\\n\";\r\n		pb = new (nothrow)Big[10000];\r\n		cout << \"Got past the new request:\\n\";\r\n	}\r\n	catch (bad_alloc & ba)\r\n	{\r\n		cout << \"Caught the exception!\\n\";\r\n		cout << ba.what() << endl;\r\n		exit(EXIT_FAILURE);\r\n	}\r\n	cout << \"Memory successfully allocated\\n\";\r\n	pb[0].stuff[0] = 4;\r\n	cout << pb[0].stuff[0] << endl;\r\n	delete[]pb;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (109, 'C++ 异常继承', 1, '##异常继承\r\n```\r\n#include<iostream>\r\n#include\"sales.h\"\r\nint main()\r\n{\r\n	using namespace std;\r\n	double vals1[12] = \r\n	{\r\n		1220,1100,1122,2212,1232,2334,\r\n		2884,2393,3302,3822,3002,3544\r\n	};\r\n	double vals2[12] =\r\n	{\r\n		12,11,22,21,32,34,\r\n		28,29,33,29,32,35\r\n	};\r\n	Sales sales1(2011, vals1, 12);\r\n	LabeleSales sales2(\"Blogstar\", 2012, vals2, 12);\r\n	cout << \"First try block:\\n\";\r\n	try\r\n	{\r\n		int i;\r\n		cout << \"Year = \" << sales1.Year() << endl;\r\n		for (i = 0; i < 12; i++)\r\n		{\r\n			cout << sales1[i] << \' \';\r\n			if (i % 6 == 5)\r\n			{\r\n				cout << endl;\r\n			}\r\n		}\r\n		cout << \"Year = \" << sales2.Label() << endl;\r\n		cout << \"Label = \" << sales2.Year() << endl;\r\n		for (i = 0; i <= 12; i++)\r\n		{\r\n			cout << sales2[i] << \' \';\r\n			if (i % 6 == 5)\r\n			{\r\n				cout << endl;\r\n			}\r\n		}\r\n		cout << \"End of try block 1.\\n\";\r\n	}\r\n	catch (LabeleSales::nbad_index& bad)\r\n	{\r\n		cout << bad.what();\r\n		cout << \"bad index:\" << bad.bi_val() << endl;\r\n	}\r\n	cout << \"\\nNext try block:\\n\";\r\n	try\r\n	{\r\n		sales2[2] = 37.5;\r\n		sales1[20] = 23345;\r\n		cout << \"End of try block 2.\\n\";\r\n	}\r\n	catch (LabeleSales::nbad_index & bad)\r\n	{\r\n		cout << bad.what();\r\n		cout << \"Company:\" << bad.label_val() << endl;\r\n		cout << \"bad index:\" << bad.bi_val() << endl;\r\n	}\r\n	catch (Sales::bad_index & bad)\r\n	{\r\n		cout << bad.what();\r\n		cout << \"bad index:\" << bad.bi_val() << endl;\r\n	}\r\n	cout << \"\\nNext try block:\\n\";\r\n	try\r\n	{\r\n		sales2[2] = 37.5;\r\n		sales1[20] = 23345;\r\n		cout << \"End of try block  2.\\n\";\r\n	}\r\n	catch (LabeleSales::nbad_index& bad)\r\n	{\r\n		cout << bad.what();\r\n		cout << \"Company:\" << bad.label_val() << endl;\r\n		cout << \"bad index:\" << bad.bi_val() << endl;\r\n	}\r\n	catch (Sales::bad_index & bad)\r\n	{\r\n		cout << bad.what();\r\n		cout << \"bad index:\" << bad.bi_val() << endl;\r\n	}\r\n	cout << \"done\\n\";\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```\r\n\r\n###头文件sales.h成员函数定义\r\n```\r\n#include \"sales.h\"\r\nusing std::string;\r\nSales::bad_index::bad_index(int ix, const string & s) :std::logic_error(s), bi(ix)\r\n{\r\n\r\n}\r\nSales::Sales(int yy)\r\n{\r\n	year = yy;\r\n	for (int i = 0; i < MONTHS; i++)\r\n	{\r\n		gross[i] = 0;\r\n	}\r\n}\r\nSales::Sales(int yy, const double * gr, int n)\r\n{\r\n	year = yy;\r\n	int lim = (n < MONTHS) ? n : MONTHS;\r\n	int i;\r\n	for (i = 0; i < lim; i++)\r\n	{\r\n		gross[i] = gr[i];\r\n	}\r\n	for (; i < MONTHS; i++)\r\n	{\r\n		gross[i] = 0;\r\n	}\r\n}\r\ndouble Sales::operator[](int i)const \r\n{\r\n	if (i < 0 || i >= MONTHS)\r\n	{\r\n		throw bad_index(i);\r\n	}\r\n	return gross[i];\r\n}\r\ndouble & Sales::operator[](int i)\r\n{\r\n	if (i < 0 || i >= MONTHS)\r\n	{\r\n		throw bad_index(i);\r\n	}\r\n	return gross[i];\r\n}\r\nLabeleSales::nbad_index::nbad_index(const string & lb, int ix, const string & s) :Sales::bad_index(ix, s)\r\n{\r\n	lb1 = lb;\r\n}\r\nLabeleSales::LabeleSales(const string & lb, int yy, const double * gr, int n ):Sales(yy, gr, n)\r\n{\r\n	label = lb;\r\n}\r\ndouble LabeleSales::operator[](int i)const\r\n{\r\n	if (i < 0 || i >= MONTHS)\r\n	{\r\n		throw nbad_index(Label(), i);\r\n	}\r\n	return Sales::operator[](i);\r\n}\r\ndouble & LabeleSales::operator[](int i)\r\n{\r\n	if (i < 0 || i >= MONTHS)\r\n	{\r\n		throw nbad_index(Label(), i);\r\n	}\r\n	return Sales::operator[](i);\r\n}\r\n```\r\n\r\n###sales.h头文件\r\n```\r\n#pragma once\r\n#include <stdexcept>   //逻辑异常类的头文件\r\n#include<string>\r\nclass Sales\r\n{\r\npublic:\r\n	enum { MONTHS = 12 };\r\n	class bad_index :public std::logic_error  //定义一个类继承逻辑异常类\r\n	{\r\n	private:\r\n		int bi;\r\n	public:\r\n		explicit bad_index(int ix, const std::string & s = \"Index error in Sales object\\n\");\r\n		int bi_val()const\r\n		{\r\n			return bi;\r\n		}\r\n		virtual~bad_index()throw()\r\n		{\r\n\r\n		}\r\n	};\r\n	explicit Sales(int yy = 0);\r\n	Sales(int yy, const double * gr, int n);\r\n	virtual~Sales()\r\n	{\r\n\r\n	}\r\n	int Year()const\r\n	{\r\n		return year;\r\n	}\r\n	virtual double operator[](int i)const;\r\n	virtual double & operator[](int i);\r\n\r\nprivate:\r\n	double gross[MONTHS];\r\n	int year;\r\n\r\n};\r\n\r\nclass LabeleSales :public Sales\r\n{\r\nprivate:\r\n	std::string label;\r\npublic:\r\n	class nbad_index :public Sales::bad_index\r\n	{\r\n	private:\r\n		std::string lb1;\r\n	public:\r\n		nbad_index(const std::string & lb, int x ,const std::string & s = \"Index error in LabeledSales object\\n\");\r\n		const std::string & label_val()const\r\n		{\r\n			return lb1;\r\n		}\r\n		virtual~nbad_index()throw()\r\n		{\r\n		}\r\n	};\r\n	explicit LabeleSales(const std::string & lb = \"none\", int yy = 0);\r\n	LabeleSales(const std::string & lb, int yy, const double*gr, int n);\r\n	virtual~LabeleSales()\r\n	{\r\n	}\r\n	const std::string & Label()const \r\n	{\r\n		return label;\r\n	}\r\n	virtual double operator[](int i)const;\r\n	virtual double &operator[](int i);\r\n};\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (110, 'C++ 定义新的异常', 1, '##定义新的异常\r\n```\r\n#include<iostream>\r\n#include <exception>\r\nusing namespace std;\r\n\r\nstruct MyException :public exception\r\n{\r\n	const char * what()const throw() //异常规格说明，表示what函数可以抛出的异常类型，类型说明放在（）里，这里没有类型，就是声明这个函数不抛出异常。\r\n	{\r\n		return \"C++ Exception\";\r\n	}\r\n};\r\nint main()\r\n{\r\n	try\r\n	{\r\n		throw MyException();\r\n	}\r\n	catch (MyException & e)\r\n	{\r\n		std::cout << \"MyException caught\" << std::endl;\r\n		std::cout << e.what() << std::endl;\r\n	}\r\n	catch (std::exception & e)\r\n	{\r\n		//其他错误\r\n	}\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n} \r\n```', 0);
INSERT INTO `blog_course` VALUES (111, 'C++ RTTI(运行阶段类型识别)dynamic_cast', 1, '##RTTI(运行阶段类型识别)dynamic_cast\r\n```\r\n#include<iostream>\r\n#include<cstdlib>\r\n#include<ctime>\r\nusing namespace std;\r\n#define randow(x) rand()%3\r\nclass Grand\r\n{\r\nprivate:\r\n	int hold;\r\npublic:\r\n	Grand(int h = 0) :hold(h)\r\n	{\r\n\r\n	}\r\n	virtual void Speak()const\r\n	{\r\n		cout << \"I\'am a grand class!\\n\";\r\n	}\r\n	virtual int Value()const\r\n	{\r\n		return hold;\r\n	}\r\n};\r\nclass Superd :public Grand   //继承grand父类\r\n{\r\npublic:\r\n	Superd(int h = 0) :Grand(h)\r\n	{\r\n\r\n	}\r\n	void Speak()const   //重写父类方法\r\n	{\r\n		cout << \"I am a superb class!!\\n\";\r\n	}\r\n	virtual void Say()const\r\n	{\r\n		cout << \"I hold the superd value of\" << Value() << \"!\\n\";//调用父类的Value()函数\r\n	}\r\n};\r\nclass Magnificent :public Superd\r\n{\r\nprivate:\r\n	char ch;\r\npublic:\r\n	Magnificent(int h = 0, char c = \'A\') :Superd(h), ch(c)\r\n	{\r\n\r\n	}\r\n	void Speak()const//重写父类方法\r\n	{\r\n		cout << \"I am a magnificent class!!!\\n\";\r\n	}\r\n	void Say()const\r\n	{\r\n		cout << \"I hold the character \" << ch << \" and the integer \" << Value() << \"!\\n\";\r\n	}\r\n};\r\n\r\nGrand * GetOne();\r\n\r\nint main()\r\n{\r\n	srand(time(0));\r\n	Grand * grand;\r\n	Superd * super;\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		grand = GetOne();   //祖先类指针指向随机一个子类对象地址\r\n		grand->Speak();\r\n		if (super = dynamic_cast<Superd *>(grand))  //检测是否可以将grant指针转化为Surper类型指针\r\n		{\r\n			super->Say();\r\n		}\r\n		cout << sizeof(grand) << endl;\r\n		//有关C++类继承实例化对象的大小\r\n		//1.普通继承：类中含有基本类型成员的大小，以最大的为主，编译器进行对其，比如说int，char，那么大小就是4*2；\r\n		//2.基类含有虚函数的时候，当有虚函数的时候，就会产生虚表的指针，每个指针在32位系统占用4字节\r\n		//3.如果是虚继承的情况下，基类大小+加上派生大小+每个类的虚表指针的大小\r\n	}\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nGrand * GetOne()\r\n{\r\n	Grand * p;\r\n	int i = randow(3);\r\n	switch (i)\r\n	{\r\n	case 0:p = new Grand(randow(100));\r\n		break;\r\n	case 1:p = new Superd(randow(100));\r\n		break;\r\n	case 2:p = new Magnificent(randow(100), \'A\' + randow(26));\r\n		break;\r\n	}\r\n	return p;\r\n}\r\n///将基类转换为子类时，基类要有多态的属性：即子类重写父类的虚函数，才能将父类转换为子类，即父类指针指向子类空间\r\n```', 0);
INSERT INTO `blog_course` VALUES (112, 'C++ RTTI(运行阶段类型识别)typeid和type_info', 1, '##RTTI(运行阶段类型识别)typeid和type_info\r\n```\r\n//typeid运算符使得能够确定两个对象是否位同种类型。与sizeof有些相似，可以接受两种参数：类名，结果为对象表达式\r\n//typeid运算符返回一个对type_info对象的引用，type_info是在头文件typeinfo中定义的一个类，重载了==和！=运算符\r\n//如：typeid(Magnificent) == typeid（*pg）\r\n//如果pg是空指针，程序将引发bad_typeid异常，该类从exception派生，在头文件typeinfo中声明\r\n//type_info类包含一个name()成员，该函数返回一个字符串，通常是类的名称。\r\n#include<iostream>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#include<typeinfo>\r\nusing namespace std;\r\nclass Grand\r\n{\r\nprivate:\r\n	int hold;\r\npublic:\r\n	Grand(int h = 0) :hold(h)\r\n	{\r\n\r\n	}\r\n	virtual void Speak()const\r\n	{\r\n		cout << \"Grand Speak()！\" << endl;\r\n	}\r\n	virtual int Value()const\r\n	{\r\n		return hold;\r\n	}\r\n};\r\nclass Superb :public Grand\r\n{\r\npublic:\r\n	Superb(int h = 0) :Grand(h)\r\n	{\r\n\r\n	}\r\n	//重写父类Speak（）\r\n	virtual void Speak()const\r\n	{\r\n		cout << \"Superb Speak()!!\" << endl;\r\n	}\r\n	virtual void Say()const\r\n	{\r\n		cout << \"Superb value:\" << Value() << \"!\" << endl;\r\n	}\r\n};\r\nclass Magnificent :public Superb\r\n{\r\nprivate:\r\n	char ch;\r\npublic:\r\n	Magnificent(int h = 0, char cv = \'A\') :Superb(h), ch(cv)\r\n	{\r\n\r\n	}\r\n	virtual void Speak()const\r\n	{\r\n		cout << \"Magnificent Speak()!!!\" << endl;\r\n	}\r\n	virtual void Say()const\r\n	{\r\n		cout << \"Magnificent value:\" << Value() << \"!\" << endl;\r\n	}\r\n};\r\nGrand * GetOne();\r\nint main()\r\n{\r\n	srand(time(nullptr));\r\n	Grand * grand;\r\n	Superb * superb;\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		grand = GetOne();\r\n		cout << \"Now processing type \" << typeid(*grand).name() << \".\" << endl;\r\n		grand->Speak();\r\n		if (superb = dynamic_cast<Superb*>(grand))  //检测Grand对象是否可以转化为Superd对象\r\n		{\r\n			superb->Say();\r\n		}\r\n		if (typeid(Magnificent) == typeid(*grand))   //判断Grand指针是否指向Manificent类\r\n		{\r\n			cout << \"Yes,you\'re really magnificent.\" << endl;\r\n		}\r\n	}\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nGrand * GetOne()\r\n{\r\n	Grand * p;\r\n	switch (rand() % 3)\r\n	{\r\n	case 0:p = new Grand(rand() % 100);\r\n		break;\r\n	case 1:p = new Superb(rand() % 100);\r\n		break;\r\n	case 2:p = new Magnificent(rand() % 100, \'A\' + rand() % 26);\r\n		break;\r\n	}\r\n	return p;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (113, 'C++ 类型转换const_cast', 1, '##类型转换const_cast\r\n```\r\n//将const类型转换为非const类型指针\r\n#include<iostream>\r\nusing std::cout;\r\nusing std::endl;\r\n\r\nvoid change(const int * p, int n);\r\n\r\nint main()\r\n{\r\n	int pop1 = 38383;   //通过类型转换\r\n	const int pop2 = 2000;//没有通过类型转换；\r\n	cout << \"pop1,pop2:\" << pop1 << \",\" << pop2 << endl;\r\n	change(&pop1, -103);\r\n	change(&pop2, -103);\r\n	cout << \"pop1,pop2:\" << pop1 << \",\" << pop2 << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\nvoid change(const int * p, int n)  //const_cast可以删除const int * p 中的const是编译器可以接受\r\n{\r\n	int * pc;\r\n	pc = const_cast<int *>(p);\r\n	*pc = *pc + n;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (114, 'C++ 类型转换static_cast', 1, '##类型转换const_cast\r\n```\r\n//static_cast<type-name>(expression)\r\n#include<iostream>\r\nusing namespace std;\r\nclass Father\r\n{\r\n\r\n};\r\nclass Son :public Father\r\n{\r\n\r\n};\r\nint main()\r\n{\r\n	Father fa;\r\n	Son s;\r\n\r\n	Father * fp = static_cast<Father*>(&s);   //从Son*转换为Father*\r\n\r\n	Son * sp = static_cast<Son *>(&fa);//从Father* 转换为Son*\r\n	//枚举值可以转化为整形，也可使用static_cast将整形转换为枚举值\r\n	//double---->int,,float---->long等等都可以\r\n\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (115, 'C++ 类型转换reinterpret_cast', 1, '##类型转换reinterpret_cast\r\n```\r\n//reinterpret_cast<type-name>(expression)\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nstruct dat\r\n{\r\n	short a;\r\n	short b;\r\n};\r\nint main()\r\n{\r\n	long value = 0xA2224B118;\r\n	dat * pd = reinterpret_cast<dat*>(&value);\r\n	cout << hex << pd->a;\r\n\r\n	\r\n	//通常这样的类型适用于实现底层的编程奇数，是不可移植的，例如，不同的系统在存储多字节整形时，而可能以不同的顺序存储其中的字节。\r\n	//reinterprete_cast运算符并不支持所有类型，例如可以将指针类型转换为足以存储指针表示的整形，但不能将指针转换为更小的整形或浮点型。\r\n	//不能将函数指针转换为数据指针，反之一样。\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (116, 'C++ 【STL】--string的构造函数', 1, '##【STL】string类--string的构造函数\r\n- STL属于C++学习的重中之重，理解其中的原理和使用对以后的代码理解将会有一个非常好的帮助！\r\n\r\n**说明**: string并不是STL泛型编程中的类，但是这里我还是要放在这里，因为string拥有的\r\n功能与语法和其他STL类基本一样，实现原理也都大同小异。\r\n```\r\n#include<iostream>\r\n#include<string>\r\nint main()\r\n{\r\n	using namespace std;\r\n	string one(\"Lottery Winner!\");//string(const char * s)\r\n	cout << one << endl;\r\n	string two(20, \'$\');          //string(size_type n,char c) //创建一个包含n个元素的string对象，其中每个元素都被初始化为字符c。\r\n	//size_type是一个依赖于实现的整形，是在头文件string中定义的。string类将string::nops定义为字符串的最大长度，通常为 unsigned int的最大值\r\n	cout << two << endl;\r\n\r\n	string three(one);            //string(const string & str)//拷贝构造函数\r\n	cout << three << endl;\r\n	string four;                  //string() //默认构造函数\r\n	four = one;\r\n	cout << four << endl;\r\n\r\n	char alls[] = \"ALL\'s well that end well\";\r\n	string five(alls, 20);        //string(const char * s,size_type n)将string对象初始化为s指向NBTS的前n个字符，即时超过了NBTS的结尾\r\n	cout << five << endl;\r\n\r\n	string six1(alls + 6, alls + 10);//template<class T> string(T begin,T end)//将string对象初始化为区间[begin,end）内的字符，其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end\r\n	cout << six1<< endl;\r\n	string six2(&five[6], &five[10]); \r\n	cout << six2 << endl;\r\n\r\n	string seven(four, 7, 16);//string (const string & str,string size_type pos=0,size_type n=nops)  //将一个string对象初始化为str中从位置pos开始到结尾的字符，或从位置pos开始的n个字符\r\n	cout << seven << endl;\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (117, 'C++ 从文件读取字符串', 1, '##从文件读取字符串\r\n```\r\n#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include <cstdlib>\r\nint main()\r\n{\r\n	using namespace std;\r\n	ifstream fin;     //定义一个输入流对象\r\n	fin.open(\"kkk.txt\");//打开文件\r\n	if (fin.is_open() == false)   //进行错误判断\r\n	{\r\n		cerr << \"Can\'t open file\" << endl;\r\n		exit(EXIT_FAILURE);\r\n	}\r\n	string item;\r\n	int count = 0;\r\n	while (fin)\r\n	{\r\n		getline(fin, item, \':\');     //读取文件中的字符串，并用string类型的item来接着读取的字符串，读取方式以“：”分割\r\n		//指定分隔符后，换行符将被视为常规字符\r\n		cout << count << \": \" << item << endl;  \r\n		count++;\r\n	}\r\n\r\n	cout << \"Done\" << endl;\r\n\r\n	fin.close();\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (118, 'C++ 重载的find方法', 1, '##重载的find()方法\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#include<cctype>\r\n#define random(x) rand()%x\r\nusing namespace std;\r\n\r\nconst int NUM = 26;\r\nconst string wordlist[NUM] =\r\n{\r\n	\"apiary\",\"beetle\",\"cereal\",\"danger\",\"ensign\",\"florid\",\"garage\",\"health\",\"insult\",\r\n	\"jackal\",\"keeper\",\"loaner\",\"manage\",\"nonce\",\"onset\",\"plaid\",\"quilt\",\"remote\",\"stolid\",\r\n	\"train\",\"useful\",\"valid\",\"whence\",\"xeono\",\"yearn\",\"zippy\"\r\n};\r\n\r\nint main()\r\n{\r\n	char play;\r\n	cout << \"will you play a word game?<y/n>\";\r\n	cin >> play;\r\n	play = tolower(play);//字符转换为小写\r\n	while (play == \'y\')\r\n	{\r\n		string target = wordlist[random(NUM)];  //随机一个小于26的数\r\n		int length = target.length();  //获取字符串长度；\r\n		string attempt(length, \'-\');   //定义一个length大小的字符串，并将每个字符出初始化为‘-’\r\n		string badchars;\r\n		int guesses = 6;\r\n		cout << \"Guess my secret word.It has \" << length << \"letters,and you guess \\n\" << \"one letter at a time.You get \" << guesses << \" wrong guesses.\" << endl;\r\n		cout << \"Your word: \" << attempt << endl;\r\n\r\n		while (guesses > 0 && attempt != target)\r\n		{\r\n			char letter;\r\n			cout << \"Guess a letter: \";\r\n			cin >> letter;\r\n			if (badchars.find(letter) != string::npos || attempt.find(letter) != string::npos)\r\n			{\r\n				cout << \"You already guessed that.Try again.\" << endl;\r\n				continue;\r\n			}\r\n			int loc = target.find(letter);\r\n			if(loc == string::npos)\r\n			{\r\n				cout << \"Oh,bad guess!\" << endl;\r\n				--guesses;\r\n				badchars = badchars + letter;\r\n			}\r\n			else\r\n			{\r\n				cout << \"Good guess!\" << endl;\r\n				attempt[loc] = letter;\r\n				loc = target.find(letter, loc + 1);\r\n				while (loc != string::npos)\r\n				{\r\n					attempt[loc] = letter;\r\n					loc = target.find(letter, loc + 1);\r\n				}\r\n			}\r\n			cout << \"Your word:\" << attempt << endl;\r\n			if (attempt != target)\r\n			{\r\n				if (badchars.length() > 0)\r\n				{\r\n					cout << \"Bad choices:\" << badchars << endl;\r\n					cout << guesses << \"bad guesses left\" << endl;\r\n				}\r\n			}\r\n		}\r\n		if (guesses > 0)\r\n		{\r\n			cout << \"That\'s right!\" << endl;\r\n		}\r\n		else\r\n		{\r\n			cout << \"Sorry,the word is\" << target << \".\\n\";\r\n		}\r\n		cout << \"will you play another?<y/n>\";\r\n		cin >> play;\r\n		play = tolower(play);\r\n	}\r\n	cout << \"Bye\\n\";\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n//size_type find(const string & str,size_type pos=0)const//从字符串的pos位置开始，查找子字符串str，如果找到返回其索引\r\n//size_type find(const char * s,size_type pos=0)const \r\n\r\n//size_type fin(const char *s,size_type pos=0,size_type n)//从pos开始，查找s的前n个字符组成的子字符串\r\n\r\n//size_type find(char ch,size_type pos=0)cosnt     //从pos开始查找字符ch，找到返回首次出现的位置，否则返回string::npos\r\n\r\n//rfind()查找子字符串或字符最后一次出现的位置\r\n//find_first_of()查找参数中任意一个字符首次出现的位置。例： int where = str.find_first_of(\"hark\")\r\n//find_last_of()\r\n\r\n//find_first_not_of()方法查找第一个不包含在参数中的字符。例：int where = str.find_not_of(\"hark\");\r\n```', 0);
INSERT INTO `blog_course` VALUES (119, 'C++ string的其他方法', 1, '##string的其他方法\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include <fstream>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	string empty;\r\n	string small = \"bit\";\r\n	string larger = \"Elephants are a girl\'s best friend\";\r\n	cout << \"Sizes:\" << endl;\r\n	cout << \"\\tempty: \" << empty.size() << endl;\r\n	cout << \"\\tsmall:\" << small.size() << endl;    //size()字符的个数\r\n	cout << \"\\tlargee: \" << larger.size() << endl;\r\n	cout << \"Capacities:\" << endl;\r\n	cout << \"\\tempty:\" << empty.capacity() << endl;  //方法返回当前分配给字符串穿的内存块大小，每次溢出15个大小的空间，string对象分配的空间将扩大16字节\r\n	cout << \"\\tsmall: \" << small.capacity() << endl;\r\n	cout << \"\\tlarger:\" << larger.capacity() << endl;\r\n	empty.reserve(50);  //将字符串容量设置为一个不小于指定数字的大小，这里3次溢出共多余申请48字节，再加上15就是63个字节\r\n	cout << \"Capacity after empty.reserve(50):\" << empty.capacity() << endl;\r\n\r\n	larger.resize(5);   //该方法可以进行字符串的的截断或加长，为字符串制定一个新的大小；如果重新定义大小的数目超过当前容量，则增加16个容量\r\n	cout << larger << endl;\r\n	cout << larger.size() << endl;   //5\r\n	cout << larger.capacity() << endl;  //47,\r\n	try\r\n	{\r\n		cout << larger.at(8) << endl;   //类似于[]运算符，取出指定索引出的字符\r\n	}\r\n	catch(...)\r\n	{\r\n		cout << \"越界了！\" << endl;\r\n	}\r\n\r\n\r\n\r\n	empty.resize(empty.size() + 5, \'a\');\r\n	cout << empty << endl;\r\n	cout << empty.size() << endl;\r\n	cout << empty.capacity() << endl;\r\n\r\n\r\n\r\n\r\n	//如果有一个string对象，但是需要C-风格的字符串。例：打开一个名称存储在string对象中的文件\r\n\r\n	string filename;\r\n	cout << \"Enter file name:\";\r\n	cin >> filename;\r\n	ofstream font;\r\n	font.open(filename.c_str());  //该方法返回一个指向C-风格字符串的指针。\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (120, 'C++ 智能模板指针', 1, '##能模板指针\r\n```\r\n//智能模板指针对象申请的堆空间无需手动对其进行释放，系统会自动释放其内存，防止经过异常导致后面的堆区内存无法释放\r\n#include<iostream>\r\n#include<string>\r\n#include <memory>   //智能模板指针头文件\r\nusing namespace std;\r\nclass Report\r\n{\r\nprivate:\r\n	string str;\r\npublic:\r\n	Report(const string s) :str(s)\r\n	{\r\n		cout << \"Object deleted!\\n\";  //这里输出一个字符串来监视构造器的调用情况\r\n	}\r\n	~Report()\r\n	{\r\n		cout << \"Object deleted!\\n\";  //输出一个字符串监视析构函数的调用\r\n	}\r\n	void comment()const\r\n	{\r\n		cout << str << endl;\r\n	}\r\n};\r\nint main()\r\n{\r\n\r\n	//智能指针模板构造函数\r\n\r\n	//template <class T>\r\n	//class auto_ptr\r\n	//{\r\n	//public:\r\n	//	explicit auto_ptr(T*p = 0) throw();\r\n	//};\r\n\r\n\r\n\r\n	{\r\n		auto_ptr<Report>ps(new Report(\"using auto_ptr\"));   //其中这种智能指针是被C++11摒弃的，因为这种模板类并不严格，当两个指针进行赋值时，两个指针指向同一块空间，会造成内存的重复释放\r\n		ps->comment();\r\n\r\n		//这里不对new Report堆区变量进行释放，智能指针会自动调用其析构函数进行释放\r\n\r\n		//该模板类接受一个Report泛型，并创建对象，其接受参数 new Report(\".....\")\r\n	}\r\n	{\r\n		shared_ptr<Report>ps(new Report(\"using shared_ptr\"));   //最优模板指针类\r\n		ps->comment();\r\n	}\r\n	{\r\n		unique_ptr<Report>ps(new Report(\"using unique_ptr\"));\r\n		ps->comment();\r\n	}\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (121, 'C++ auto_ptr为什么会被摒弃', 1, '##auto_ptr为什么会被摒弃\r\n```\r\n#include <iostream>\r\n#include <string>\r\n#include <memory>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	auto_ptr<string>films[5] =\r\n	{\r\n		auto_ptr<string>(new string(\"auto1\")),\r\n		auto_ptr<string>(new string(\"auto2\")),\r\n		auto_ptr<string>(new string(\"auto3\")),\r\n		auto_ptr<string>(new string(\"auto4\")),\r\n		auto_ptr<string>(new string(\"auto5\")),\r\n	};\r\n	auto_ptr<string> pwin;      //auto_ptr不能接受数组参数进行自动释放\r\n	pwin = films[2];  //auto3的所有权被给予pwin，当使用film[2]时程序就会终止报错\r\n                      //当使用unique_ptr时这里程序将会认为这里非法，不允许被使用\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		cout << *films[i] << endl;\r\n	}\r\n\r\n	cout << \"The winner is\" << *pwin << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (122, 'C++ string的迭代器', 1, '##string的迭代器\r\n```\r\n#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	string::iterator ite;     \r\n\r\n	//迭代器实际上是一个内部类，类名为iterator，使用::作用域解析符来使用迭代器创建一个内部类对象，string的iterator就是模仿指针\r\n\r\n	//每个容器都有自己特定的迭代器\r\n\r\n	string str(\"ailuoliaaaaaaaaaaaaaaaaa\");\r\n	ite = str.begin();   //迭代器（指针）指向str字符串的首地址\r\n	//当前迭代器只能遍历当前字符串的字符，如果对字符串进行追加修改了，溢出了15个，那么字符串就会重新申请一个空间来存储字符串，就需要重新将字符串指针赋值给迭代器对象。\r\n\r\n	string str1(\"abc\");\r\n	str.append(str1.begin(), str1.begin() + 3);//追加字符\r\n	cout << str << endl;\r\n\r\n	str.erase(str.begin(), str.begin() + 5);  //删除字符\r\n	cout << str << endl;\r\n\r\n	str.insert(str.begin() + 2, 5, \'k\');      //插入字符\r\n	cout << str << endl;\r\n\r\n\r\n\r\n	*(ite+1) = \'j\';  //通过迭代器对字符串进行赋值\r\n	ite[3] = \'j\';\r\n	/************************************************************************/\r\n	/* \r\n	迭代器其实现的原理和原因：\r\n	1.迭代器是为了遍历容器内的元素\r\n	2.迭代器模仿了指针，可以通过指针解除引用来获取值\r\n	3应该能够将一个迭代器赋值给另一个。\r\n	4.迭代器能够将一个迭代器与另一个进行比较\r\n	*/\r\n	/************************************************************************/\r\n\r\n\r\n	for (int i = 0; i < str.size(); i++)\r\n	{\r\n		cout << *ite;\r\n		ite++;\r\n	}\r\n\r\n	ite = str.end();\r\n	//cout << *ite << endl;  //end()返回字符串的最后一位‘\\0’;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n////遍历一个double类型数组，寻找一个与参数相同的值\r\n//double * find_ar(double * ar, int n, const double & val)\r\n//{\r\n//	for (int i = 0; i < n; i++)\r\n//	{\r\n//		if (ar[i] == val)\r\n//			return &ar[i];\r\n//	}\r\n//	return 0;\r\n//}\r\n//\r\n////当容器类不是用数组进行实现时，是用链表实现时\r\n//struct Node\r\n//{\r\n//	double item;\r\n//	Node* p_next;\r\n//};\r\n//Node * find_all(Node* head, const double & val)\r\n//{\r\n//	Node * start;\r\n//	for (start = head; start != 0; start = start->p_next)\r\n//	{\r\n//		if (start->item == val)\r\n//			return start;\r\n//	}\r\n//	return 0;\r\n//}\r\n//\r\n//\r\n////将查找方法封装为迭代器\r\n//typedef double * iterator_i;\r\n//iterator_i find_ar(iterator_i ar, int n, const double & val)\r\n//{\r\n//	for (int i = 0; i < n; i++, ar++)\r\n//	{\r\n//		if (*ar == val)\r\n//			return ar;\r\n//	}\r\n//	return 0;\r\n//}\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (123, 'C++ string算法的使用', 1, '##string的算法使用\r\n- 有必要说明一下啊 STL的核心思想是 ： 容器，迭代器，算法。 迭代器是连接容器与算法的桥梁\r\n- 喜欢深入的可以自行去搜索资料学习\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include<algorithm>\r\n#include<functional>\r\nusing namespace std;\r\nvoid fun(char);\r\nint main()\r\n{\r\n	string str1(\"acdb\");\r\n	for_each(str1.begin(), str1.end(), fun);  //遍历算法，将for循环包装后为这个for_each,fun为for循环内的行为\r\n	cout << endl;\r\n\r\n	sort(str1.begin(), str1.end());    //排序算法，默认从小到大\r\n	for_each(str1.begin(), str1.end(), fun);\r\n\r\n	cout << endl;\r\n\r\n	sort(str1.begin(), str1.end(), greater<char>());   //第三个参数仿函数，从大到小\r\n	for_each(str1.begin(), str1.end(), fun);\r\n\r\n	\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid fun(char c)\r\n{\r\n	cout << c;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (124, 'C++ 【STL】--vector的构造函数', 1, '##【STL】--vertor的构造函数\r\n**说明**:vertor容器是STL我们要学习的第一个容器，迭代器和算法的使用与string基本一样\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include<vector>\r\nusing namespace std;\r\nconst int NUM = 5;\r\n\r\nint main()\r\n{\r\n	vector<int>rating(NUM);\r\n	vector<string>titles(NUM);\r\n	int i;\r\n	for (i = 0; i < NUM; i++)\r\n	{\r\n		cout << \"Enter title #\" << i + 1 << \": \";\r\n		getline(cin, titles[i]);\r\n\r\n		cout << \"Enter your rating(0-10):\";\r\n		cin >> rating[i];\r\n		cin.get();\r\n	}\r\n	for (i = 0; i < NUM; i++)\r\n	{\r\n		cout << rating[i] << \"\\t\" << titles[i] << endl;\r\n	}\r\n\r\n\r\n	//vector的构造函数\r\n	vector<int> vec;      //无参构造函数  vector()\r\n\r\n	vector<int>vec0(5);    //vector(size_type_conunt)  ，创建一个容器大小为5\r\n	vec0[0] = 2;\r\n	cout<<*vec0.begin()<<endl;\r\n\r\n	vector<int>vec1(5, \'c\');  //vector(size_type_count,const type & val)  //第二个参数为某种类型参数的引用\r\n\r\n	vector<int>vec2(vec1);   //vector(const vector & vec)  //拷贝构造函数\r\n\r\n	vector<int>vec3(vec2.begin(), vec2.end()); //使用另一个容器类的迭代器对容器初始化\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (125, 'C++ vector的迭代器和方法', 1, '##vector容器类的迭代器与与一些方法的使用\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include<vector>\r\nusing namespace std;\r\nstruct Review\r\n{\r\n	string title;\r\n	int rating;\r\n};\r\nbool FillReview(Review & rr);\r\nvoid ShowReview(const Review & rr);   //用来输出结构体类型数据\r\n\r\nint main()\r\n{\r\n	vector<Review>books;\r\n	Review temp;\r\n	while (FillReview(temp))\r\n	{\r\n		books.push_back(temp);   //容器数据的追加,超过容器存储空间，每次增加容器空间的一半\r\n	}\r\n	int num = books.size();  //返回容器的大小\r\n\r\n	if (num > 0)\r\n	{\r\n		for (int i = 0; i < num; i++)\r\n		{\r\n			ShowReview(books[i]);\r\n		}\r\n		vector<Review>::iterator pr;   //定义个vector<Review>的迭代器\r\n		for (pr = books.begin(); pr != books.end(); pr++)\r\n		{\r\n			ShowReview(*pr);      //使用迭代器遍历容器内数据\r\n		}\r\n\r\n		vector<Review>oldlist(books);\r\n		if (num > 3)\r\n		{\r\n			books.erase(books.begin() + 1, books.begin() + 3);//删除容器内的的数据\r\n			for (pr = books.begin(); pr != books.end(); pr++)\r\n			{\r\n				ShowReview(*pr);\r\n			}\r\n			books.insert(books.begin(), oldlist.begin() + 1, oldlist.begin() + 2); //向容器内插入数据，向books容器插入oldlist的第二个数据和第三个数据的插入到begin之前\r\n			for (pr = books.begin(); pr != books.end(); pr++)\r\n			{\r\n				ShowReview(*pr);\r\n			}\r\n		}\r\n	}\r\n\r\n	cout << books.empty() << endl;  //该方法判断容器是否为空，是空返回1\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nbool FillReview(Review & rr)\r\n{\r\n	getline(cin, rr.title);\r\n	if (rr.title == \"quit\")\r\n	{\r\n		return false;\r\n	}\r\n	cin >> rr.rating;\r\n	if (!cin)\r\n		return false;\r\n	while (cin.get() != \'\\n\')\r\n		continue;\r\n	return true;\r\n}\r\nvoid ShowReview(const Review & rr)\r\n{\r\n	cout << rr.rating << \"\\t\" << rr.title << endl;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (126, 'C++ vector算法的使用', 1, '##vector算法的使用\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include<vector>\r\n#include<algorithm>     //算法头文件\r\n\r\nusing namespace std;\r\n\r\nstruct Review\r\n{\r\n	string title;\r\n	int rating;\r\n};\r\nbool operator<(const Review & r1, const Review & r2);  //重载<号，用来比较结构体类型数据\r\nbool worseThan(const Review & r1, const Review & r2);  //完整弱排序\r\nbool FillReview(Review & rr);\r\nvoid ShowReview(const Review & rr);\r\n\r\nint main()\r\n{\r\n	vector<Review>books;\r\n	Review temp;\r\n	while (FillReview(temp))\r\n		books.push_back(temp);\r\n	if (books.size() > 0)\r\n	{\r\n		cout << books.size() << endl;\r\n		for_each(books.begin(), books.end(), ShowReview);   //遍历，第三个参数为用来输出的函数指针\r\n		cout << endl;\r\n\r\n		sort(books.begin(), books.end());  //默认排序\r\n		for_each(books.begin(), books.end(), ShowReview);\r\n		cout << endl;\r\n\r\n		sort(books.begin(), books.end(), worseThan);\r\n		for_each(books.begin(), books.end(), ShowReview);\r\n		cout << endl;\r\n\r\n		random_shuffle(books.begin(), books.end());   //随机排列容器参数\r\n		for_each(books.begin(), books.end(), ShowReview);\r\n\r\n		//基于范围的for循环遍历容器\r\n		for (auto x : books)\r\n			ShowReview(x);\r\n\r\n		//利用基于范围的for循环修改容器内指定的内容\r\n		for (auto & x : books)   //此处传参应该为引用，因为传引用会改变本值\r\n			InflateReview(x);\r\n	}\r\n	else\r\n		cout << \"No entries.\";\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\nbool operator<(const Review & r1, const Review & r2)\r\n{\r\n	if (r1.title < r2.title)\r\n		return true;\r\n	else if (r1.title == r2.title&&r1.rating < r2.rating)\r\n		return true;\r\n	else\r\n		return false;\r\n}\r\n\r\nbool worseThan(const Review & r1, const Review & r2)\r\n{\r\n	if (r1.rating < r2.rating)\r\n		return true;\r\n	else\r\n		return false;\r\n}\r\n\r\nbool FillReview(Review & rr)\r\n{\r\n	cout << \"Enter book title(quit to quit):\";\r\n	getline(cin, rr.title);\r\n	if (rr.title == \"quit\")\r\n		return false;\r\n	cout << \"Enter book rating:\";\r\n	cin >> rr.rating;\r\n	if (!cin)\r\n		return false;\r\n	while (cin.get() != \'\\n\')\r\n		continue;\r\n	return true;\r\n}\r\nvoid ShowReview(const Review & rr)\r\n{\r\n	cout << rr.rating << \"\\t\" << rr.title << endl;\r\n}\r\n\r\n\r\n///////////////////\r\nvoid InflateReview(Review & r)\r\n{\r\n	r.rating++;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (127, 'C++ copy(),istream，ostream迭代器，反向迭代器', 1, '##copy() istream迭代器，ostream迭代器，反向迭代器\r\n```\r\n#include<iostream>\r\n#include<iterator>\r\n#include<vector>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n\r\n	int casts[10] = { 6,7,2,9,4,11,8,7,10,5 };\r\n	vector<int>dice(10);\r\n\r\n	//将casts数组用来初始化dice\r\n	copy(casts, casts + 10, dice.begin());  //第一个参数：被赋值数组的第一个元素地址，第二个参数：数组最后元素的地址，第三个参数：复制到容器的位置\r\n\r\n	ostream_iterator<int, char>out_iter(cout, \" \");  //输出迭代器，第一个模板参数：迭代器接受的数据的类型，第二个模板参数：输出迭代器要输出的参数类型\r\n	//第一个参数为要使用的输出流，第二个参数为输出的间隔，也可以不使用此参数\r\n	copy(dice.begin(), dice.end(), out_iter);     //将容器内的数据赋值到输出流上\r\n	cout << endl;\r\n\r\n	copy(dice.rbegin(), dice.rend(), out_iter);   //使用反向迭代器将数据赋值到输出流上\r\n	//反向迭代器：rbegin()返回一个容器第一个元素的反向迭代器指针，rend返回容器超尾的反向迭代器指针\r\n	cout << endl;\r\n\r\n	vector<int>::reverse_iterator ri;  //迭代器适配器，允许向后遍历数据\r\n	for (ri = dice.rbegin(); ri != dice.rend(); ++ri)\r\n	{\r\n		cout << *ri << \' \';\r\n	}\r\n	cout << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (128, 'C++ back_insert_iterator和insert_iterator', 1, '##back_insert_iterator和insert_iterator\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include <iterator>\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\nvoid output(const string & s)\r\n{\r\n	cout << s << \" \";\r\n}\r\n\r\nint main()\r\n{\r\n	string s1[4] = { \"fine\",\"fish\",\"fashion\",\"fate\" };\r\n	string s2[2] = { \"busy\",\"bats\" };\r\n	string s3[2] = { \"silly\",\"singers\" };\r\n\r\n	vector<string>words(4);\r\n	copy(s1, s1 + 4, words.begin());\r\n	for_each(words.begin(), words.end(), output);\r\n	cout << endl;\r\n\r\n	copy(s2, s2 + 2, back_insert_iterator<vector<string>>(words)); //在words的尾部插入s2\r\n	for_each(words.begin(), words.end(), output);\r\n	cout << endl;\r\n\r\n	copy(s3, s3 + 2, insert_iterator<vector<string>>(words,words.begin()));//在指定位置插入数据\r\n	//这里是在words.begin()出插入s3\r\n	for_each(words.begin(), words.end(),output);\r\n	cout << endl;\r\n\r\n	//这些都属于预定义迭代器\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (129, 'C++ 【STL】--list容器的构造函数和使用', 1, '##【STL】--list容器\r\n```\r\n#include<iostream>\r\n#include<list>               //list是用双向链表实现的\r\n#include<iterator>\r\n#include<algorithm>\r\n\r\nvoid outint(int n)\r\n{\r\n	std::cout << n << \" \";\r\n}\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n\r\n	list<int> li();  //无参构造\r\n	list<int> li1(5);    //将所有的值初始化为零\r\n	list<int> li2(5, 3); //将5个参数初始化为3\r\n	list<int> li3(li2);  //拷贝构造\r\n	list<int> li4(li3.begin(), li3.end());//用另一个容器得一段来初始化此容器\r\n\r\n	//注意list迭代器没有ite+count  ，只能++；即不支持随机访问\r\n	//list没有容量的概念，即用即加\r\n	cout << li2.back() << endl;\r\n	cout << li2.front() << endl;\r\n\r\n	li2.push_back(6);   //头添加\r\n	li2.push_front(7);   //尾添加\r\n	for_each(li2.begin(), li2.end(), outint);\r\n\r\n	li2.insert(li2.begin(), 10);     //在指定位置添加指定元素\r\n	li2.insert(li2.begin()++, 2, 8);     //在li2的指定位置后面添加2个8；\r\n	li2.insert(li2.begin(), li3.begin(), li3.end());   //在li2的指定为添加另一个容器的一部分\r\n	for_each(li2.begin(), li2.end(), outint);\r\n\r\n\r\n\r\n	           \r\n	list<int>one(5, 2);\r\n	int stuff[5] = { 1,2,4,8,6 };\r\n	list<int>two;\r\n	two.insert(two.begin(), stuff, stuff + 5);  //在two的开始插入one\r\n	int more[6] = { 6,4,2,4,6,5 };\r\n	list<int>three(two);\r\n	three.insert(three.end(), more, more + 6);\r\n\r\n	for_each(one.begin(), one.end(), outint);\r\n	cout << endl;\r\n	for_each(two.begin(), two.end(), outint);\r\n	cout << endl;\r\n	for_each(three.begin(), three.end(), outint);\r\n	cout << endl;\r\n\r\n	three.remove(2);   //删除three中的2，时间复杂度为线性\r\n	for_each(three.begin(), three.end(), outint);\r\n	cout << endl;\r\n\r\n	three.splice(three.begin(), one);  //将链表one的内容插入到three.begin前面，one将为空，时间复杂度为固定时间\r\n	for_each(three.begin(), three.end(), outint);\r\n	cout << endl;\r\n	for_each(one.begin(), one.end(), outint);\r\n	cout << endl;\r\n\r\n	three.unique();//将连续的相同元素压缩为单个元素，这个函数的时间复杂度为线性\r\n	for_each(three.begin(), three.end(), outint);\r\n	cout << endl;\r\n\r\n	three.sort();   //先排序\r\n	three.unique();  //再去除连续相同的元素\r\n	for_each(three.begin(), three.end(), outint);\r\n	cout << endl;\r\n\r\n	two.sort();\r\n	three.merge(two);  //链表two与three链表合并，两个链表必须已经排序，合并后经过排序的链表保存再调用链表中，two为空，时间复杂度为线性\r\n	for_each(three.begin(), three.end(), outint);\r\n	cout << endl;\r\n\r\n	list<int>::iterator ite = find(three.begin(), three.end(), 5);  //find算法查找链表中的值，前两个参数为链表的首末指针，找到返回其迭代器指针，找不到程序崩溃\r\n\r\n	cout << *ite << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (130, 'C++ 【STL】--deque容器的使用', 1, '##【STL】--deque容器\r\n```\r\n#include<iostream>\r\n#include<deque>   //double_end_queen\r\n#include<algorithm>\r\nusing namespace std;\r\nvoid output(int a)\r\n{\r\n	cout << a;\r\n}\r\n\r\nint main()\r\n{\r\n	//deque的函数与其他的函数基本一样的操作，支持随机访问，头插和尾插//但是执行速度不如vector\r\n	//支持随机删除，但是执行速度不如list\r\n\r\n	deque<int> d;\r\n	deque<int>d1(3);\r\n	deque<int>d2(5, 2);\r\n	deque<int>d3(3, 1, d2.get_allocator());   //d2.get_allocator()返回d2.构造对象，可以不写，就默认了\r\n	for_each(d3.begin(), d3.end(), output);\r\n\r\n	deque<int>d4(d2);\r\n	deque<int>d5(d4.begin(),d4.end());\r\n	deque<int>d6(d4.begin(), d4.end(), d2.get_allocator());\r\n	deque<int>d7({ 1,2,3,4 });\r\n	initializer_list<int>iList{ 5,6,7,8 };\r\n\r\n	deque<int>d8(iList);\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (131, 'C++ 【STL】--map容器', 1, '##【STL】--map容器\r\n```\r\n\r\n#include<iostream>\r\n#include<map>   //map容器的底层是红黑树，平衡二叉树，其key值不能重复，会自动排序。同样跟list一样没有容量概念\r\n#include<algorithm>  //算法头文件\r\n#include<string>\r\n#include<functional>  //仿函数头文件\r\nusing namespace std;\r\n\r\nvoid output(pair<int,string> p)\r\n{\r\n	cout << p.first << \":\" << p.second << endl;\r\n}\r\nvoid outi(pair<int, int> p)\r\n{\r\n	cout << p.first << \":\" << p.second << endl;\r\n}\r\nint main()\r\n{\r\n	//map 的构造函数\r\n	typedef pair<int, int> Int_Pair;\r\n	map <int, int> m0();         //无参构造\r\n	map <int, int, less<int> > m1;\r\n	map<int, int, greater<int>> m2;  //将key值从大到小排序\r\n	m2.insert(Int_Pair(1, 10));\r\n	m2.insert(Int_Pair(2, 15));\r\n	for_each(m2.begin(), m2.end(), outi);\r\n	cout << endl;\r\n\r\n	map <int, int> m4(m1);   //拷贝构造\r\n	map<int, int>m5(m1.begin(), m1.end());\r\n\r\n\r\n	map<int, string> m;    //左模板参数为为key值，右模板参数为value值\r\n\r\n	//三种插入函数\r\n\r\n	m.insert(pair<int, string>(1, \"马永康\"));   //map容器内的值类型为pair类型\r\n	m.insert(pair<int, string>(2, \"郭浩\"));\r\n	for_each(m.begin(), m.end(), output);\r\n	cout << endl;\r\n\r\n\r\n	//第一种插入，该插入只接受一个pair对象。并且该插入返回一个pair类型的对象，pair类接受两个固定的模板参数<iterator,bool>\r\n    pair<map<int, string>::iterator, bool> pr;  //创建一个pair对象pr，并给出模板参数map，bool;\r\n	pr = m.insert(pair<int, string>(3, \"lll\"));      //函数原型   pair<iterator,bool>insert(const pair<KEY_TYPE,VALUE_TYPE> & val);\r\n	cout << \"返回插入值：\" << pr.second << endl;   //插入成功返回1\r\n	for_each(m.begin(), m.end(), output);\r\n	cout << endl;\r\n\r\n\r\n	//第二种插入,该插入接受一个迭代器指针，在指针位置插入所要插入的元素,但是元素还是根据key值进行排序。并且该插入返回一个指向该位置的迭代器指针\r\n	map<int,string>::iterator ite2 = m.insert(m.begin(), pair<int, string>(4, \"kkk\"));   //函数原型  iterator insert(iterator pos,const pair<KEY_TYPE,VALUE_TYPE> & val);\r\n	//该函数返回一个指向该元素的迭代器指针\r\n	cout << \"插入该位置的值： \" <<(*ite2).first <<\",\"<< (*ite2).second << endl;\r\n	for_each(m.begin(), m.end(), output);\r\n	cout << endl;\r\n\r\n	//第三种插入，将一个容器的元素插入另一个容器\r\n	map<int, string>mn;\r\n	pr = mn.insert(pair<int, string>(1, \"马永康\"));   //没有插入但覆盖\r\n	cout << \"返回插入值：\" << pr.second << endl;\r\n	m.insert(mn.begin(), mn.end());\r\n	for_each(m.begin(), m.end(), output);\r\n	cout << endl;\r\n\r\n	//删除函数\r\n	m.erase(m.begin());\r\n	for_each(m.begin(), m.end(), output);\r\n	cout << endl;\r\n\r\n	m.erase(2);\r\n	for_each(m.begin(), m.end(), output);\r\n	cout << endl;\r\n\r\n	//查找函数\r\n	map<int, string>::iterator ite3 = m.find(3);    //该函数返回该key值的迭代器，没有找到返回尾部迭代器/\r\n	cout << (*ite3).second << endl;\r\n	cout << endl;\r\n\r\n	//其他函数  \r\n	cout << (*(m.lower_bound(1))).second << endl;;   //返回不小于key值第一个元素的迭代器\r\n\r\n	cout << (*(m.upper_bound(3))).second << endl;    //返回大于key值得第一个元素的迭代器\r\n\r\n	pair<map<int, string>::iterator, map<int, string>::iterator> p1 = m.equal_range(3);//该算法返回 lower_bound和upper_bound的迭代器\r\n	cout << p1.first->first <<\":\"<<p1.first->second<< endl;\r\n	cout << p1.second->first << \":\" << p1.second->second << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (132, 'C++ 【STL】--multimap容器', 1, '##【STL】--multimap容器\r\n```\r\n#include<iostream>\r\n#include<map>     //multimap头文件  //与map 的区别是允许key值的重复\r\n#include<algorithm>\r\n#include<string>\r\nusing namespace std;\r\n\r\nvoid out(pair<int, int> p)\r\n{\r\n	cout << p.first << \":\" << p.second << endl;\r\n}\r\nvoid out2(pair<int, string> p)\r\n{\r\n	cout << p.first << \":\"<< p.second << endl;\r\n}\r\n\r\ntypedef int KeyType;\r\ntypedef pair<const KeyType, string> Pair;\r\ntypedef multimap<KeyType, string>MapCode;\r\n\r\nint main()\r\n{\r\n	multimap<int, int> ml;\r\n	ml.insert(pair<int, int>(1, 5));\r\n	ml.insert(pair<int, int>(1, 6));\r\n	for_each(ml.begin(), ml.end(), out);\r\n\r\n\r\n	MapCode codes;     //创建一个multimap集合\r\n\r\n	codes.insert(Pair(415, \"San Francisco\"));\r\n	codes.insert(Pair(510, \"Oakland\"));\r\n	codes.insert(Pair(718, \"Brooklyn\"));\r\n	codes.insert(Pair(718, \"Staten Island\"));\r\n	codes.insert(Pair(415, \"San Rafael\"));\r\n	codes.insert(Pair(510, \"Berkeley\"));\r\n\r\n	cout << codes.count(415) << endl;\r\n	cout << codes.count(718) << endl;\r\n	cout << codes.count(510) << endl;\r\n\r\n	for_each(codes.begin(), codes.end(), out2);\r\n	cout << endl;\r\n\r\n	pair<MapCode::iterator, MapCode::iterator>range = codes.equal_range(718);\r\n	\r\n	MapCode::iterator ite;\r\n	for (ite = range.first; ite != range.second; ++ite)\r\n	{\r\n		cout << (*ite).second << endl;\r\n	}\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (133, 'C++ 【STL】--set容器', 1, '##【STL】--set容器\r\n```\r\n#include<iostream>\r\n#include<set>      //set容器的key值和value值是一样的，所以模板参数默认只有一个，还可以添加仿函数来规定升序或降序。key值也是唯一不能重复。\r\n                   //高效访问，数据结构也是红黑树，时间复杂度为  x=log2^N,同样没有容量的概念\r\n#include<algorithm>\r\n#include<functional>\r\n#include<string>\r\n#include<iterator>\r\nusing namespace std;\r\n\r\nvoid output(string  s)\r\n{\r\n	cout << s << endl;\r\n}\r\n\r\nint main()\r\n{\r\n	//set容器构造函数\r\n	set<string,greater<string>> s;   //无参构造\r\n	s.insert(string(\"abc\"));\r\n	s.insert(string(\"abd\"));\r\n	s.insert(string(\"abe\"));\r\n	s.insert(string(\"abf\"));\r\n	s.insert(string(\"abg\"));\r\n	for_each(s.begin(), s.end(), output);\r\n	cout << s.max_size() << endl;   //返回容器最大容量\r\n\r\n	set<string, greater<string>> s1(s);  //拷贝构造函数\r\n\r\n	set<string, greater<string>> s2(s.begin(), s.end());   //用一个容器的一段初始化该容器\r\n	//其他函数与map一样\r\n\r\n	const int N = 6;\r\n	string s3[N] = { \"button\",\"thinkers\",\"for\",\"heavy\",\"can\",\"for\" };\r\n	string s4[N] = { \"metal\",\"any\",\"food\",\"elegant\",\"deliver\",\"for\" };\r\n\r\n	set<string> A(s3, s3 + N);\r\n	set<string> B(s4, s4 + N);\r\n\r\n	ostream_iterator<string>out(cout, \" \");   //第一个参数为输出流指针，第二个参数为输出流分割指针\r\n	cout << \"Set A:\";\r\n	copy(A.begin(), A.end(), out); //复制A集合到out迭代器中\r\n	cout << endl;\r\n\r\n	cout << \"Set B:\";\r\n	copy(B.begin(), B.end(), out);\r\n	cout << endl;\r\n\r\n	//set_union函数\r\n	set_union(A.begin(), A.end(), B.begin(), B.end(), out);//显示两个集合的并集，会自动排序并且去掉相同的元素\r\n	cout << endl;\r\n\r\n	//set_intersection\r\n	cout << \"查找交集：\";\r\n	set_intersection(A.begin(), A.end(), B.begin(), B.end(), out);  //查找交集\r\n	cout << endl;\r\n\r\n	//set_difference\r\n	cout << \"查找集合差：\";\r\n	set_difference(A.begin(), A.end(), B.begin(), B.end(), out);   //查找两个集合的差\r\n	cout << endl;\r\n\r\n\r\n	set<string> C;\r\n\r\n	//插入并集\r\n	set_union(A.begin(), A.end(), B.begin(), B.end(), insert_iterator<set<string>>(C, C.begin()));//将并集插入到C集合\r\n	copy(C.begin(), C.end(), out);\r\n	cout << endl;\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (134, 'C++ 【STL】--multiset容器', 1, '##【STL】--set容器\r\n```\r\n#include<iostream>\r\n#include<set>         //multiset  允许key值重复，其他与set一样\r\n#include<algorithm>\r\n#include<functional>\r\n#include<string>\r\n\r\nvoid out(std::string s)\r\n{\r\n	std::cout << s << std::endl;\r\n}\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	multiset<string, greater<string>> ms;\r\n	ms.insert(string(\"abc\"));\r\n	ms.insert(string(\"abc\"));\r\n	ms.insert(string(\"abd\"));\r\n	for_each(ms.begin(), ms.end(), out);\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (135, 'C++ 函数符', 1, '##函数符\r\n```\r\n//将函数通过类进行封装，就是函数符 ，也叫仿函数。被封装函数为bool类型，并且是重载()运算符\r\n#include<iostream>\r\n#include<list>\r\n#include<iterator>\r\n#include<algorithm>\r\n\r\ntemplate <class T>    //模板类，和函数符\r\nclass TooBig\r\n{\r\nprivate:\r\n	T cutoff;\r\npublic:\r\n	TooBig(const T & t) :cutoff(t)\r\n	{\r\n\r\n	}\r\n	bool operator()(const T &v)  //重载()运算符，并返回bool类型\r\n	{\r\n		return v > cutoff;\r\n	}\r\n};\r\nvoid outint(int n)\r\n{\r\n	std::cout << n << \" \";\r\n}\r\n\r\nbool mmm(int i)\r\n{\r\n	return i > 100;\r\n}\r\n\r\nint main()\r\n{\r\n	using std::list;\r\n	using std::cout;\r\n	using std::endl;\r\n\r\n\r\n	int vals[10] = { 50,100,90,180,60,210,415,88,188,201 };\r\n	list<int>yadayada(vals, vals + 10);// 用val对链表初始化\r\n	list<int>etcetera(vals, vals + 10);\r\n\r\n	for_each(yadayada.begin(), yadayada.end(), outint);\r\n	cout << endl;\r\n\r\n	for_each(etcetera.begin(), etcetera.end(), outint);\r\n	cout << endl;\r\n\r\n	yadayada.remove_if(mmm);//直接使用一个一元谓词\r\n\r\n	TooBig<int> f(100);\r\n	\r\n\r\n	yadayada.remove_if(TooBig<int>(100));   //调用运算符重载()  \r\n\r\n	etcetera.remove_if(TooBig<int>(200));\r\n\r\n	for_each(yadayada.begin(), yadayada.end(), outint);\r\n	cout << endl;\r\n\r\n\r\n	for_each(etcetera.begin(), etcetera.end(), outint);\r\n	cout << endl;\r\n\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (136, 'C++ 自适应函数符和函数适配器', 1, '##自适应函数符和函数适配器\r\n```\r\n#include<iostream>\r\n#include<vector>\r\n#include<iterator>\r\n#include<algorithm>\r\n#include<functional>\r\n\r\nvoid show(double);\r\nconst int LIM = 6;\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	double arr1[LIM] = { 28,29,30,35,38,59 };\r\n	double arr2[LIM] = { 63,65,69,75,80,99 };\r\n	vector<double> gr8(arr1, arr1 + LIM);\r\n	vector<double> m8(arr2, arr2 + LIM);\r\n	cout.setf(ios_base::fixed);\r\n	cout.precision(1);\r\n	cout << \"gr8:\\t\";\r\n	for_each(gr8.begin(), gr8.end(), show);\r\n	cout << endl;\r\n\r\n	cout << \"m8\\t\";\r\n	for_each(m8.begin(), m8.end(), show);\r\n	cout << endl;\r\n\r\n	vector<double>sum(LIM);\r\n	transform(gr8.begin(), gr8.end(), m8.begin(), sum.begin(), plus<double>());  //考虑函数，用来执行对两个容器之间的操作,plus函数对象执行两个容器每个参数相加\r\n	cout << \"sum:\\t\";\r\n	for_each(sum.begin(), sum.end(), show);\r\n	cout << endl;\r\n\r\n	vector<double> prod(LIM);\r\n	transform(gr8.begin(), gr8.end(), prod.begin(), bind1st(multiplies<double>(), 2.5)); //由于multipies是二元函数，这我们需要一个单参函数，bindlst函数会自动帮我们转换\r\n	//multiplies函数会自动绑定第一个参数为指定值，将二元函数对象转换为一元函数对象\r\n	cout << \"prod\\t\";\r\n	for_each(prod.begin(), prod.end(), show);\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid show(double v)\r\n{\r\n	std::cout.width(6);\r\n	std::cout << v << \' \';\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (137, 'C++ 使用STL', 1, '##自适应函数符和函数适配器\r\n```\r\n#include<iostream>\r\n#include<string>\r\n#include<vector>\r\n##使用STL\r\n```\r\n#include<set>\r\n#include<map>\r\n#include<iterator>\r\n#include<algorithm>\r\n#include<cctype>\r\n\r\nusing namespace std;\r\n\r\nchar toLower(char ch)\r\n{\r\n	return tolower(ch);\r\n}\r\nstring & ToLower(string & st);\r\nvoid display(const string & s);\r\n\r\nint main()\r\n{\r\n	vector<string> words;\r\n	cout << \"Enter words(enter quit to quit):\\n\";\r\n	string input;\r\n	while (cin >> input && input != \"quit\")\r\n	{\r\n		words.push_back(input);\r\n	}\r\n	cout << \"You enterd the following words:\\n\";\r\n	for_each(words.begin(), words.end(), display);\r\n	cout << endl;\r\n\r\n	set<string>wordset;\r\n	transform(words.begin(), words.end(), insert_iterator<set<string>>(wordset, wordset.begin()), ToLower);  //因为int tolower (int)所以要 返回类型转化为char类型,与传进的参数一样\r\n	cout << \"\\nAlphabetic list of words:\\n\";\r\n	for_each(wordset.begin(), wordset.end(), display);\r\n	cout << endl;\r\n\r\n	map<string, int>wordmap;\r\n	set<string>::iterator si;\r\n	for (si = wordset.begin(); si != wordset.end(); si++)\r\n	{\r\n		wordmap[*si] = count(words.begin(), words.end(), *si);   //map重载类[]运算符，set中存储了map中的所有key值，所以这里可以这样写\r\n	}\r\n	//for (si = wordset.begin(); si != wordset.end(); si++)\r\n	//{\r\n	//	wordmap.insert(pair<string, int>(*si, count(words.begin(), words.end(), *si)));\r\n	//}\r\n\r\n\r\n\r\n	cout << \"\\nWord frequency:\\n\";\r\n	for (si = wordset.begin(); si != wordset.end(); si++)\r\n	{\r\n		cout << *si << \":\" << wordmap[*si] << endl;\r\n	}\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\nstring & ToLower(string & st)\r\n{\r\n	transform(st.begin(), st.end(), st.begin(), toLower);  //将字符串拷贝到st，并转化为小写\r\n	return st;\r\n}\r\nvoid display(const string & s)\r\n{\r\n	cout << s << \" \";\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (138, 'C++ vecor和valarry', 1, '##vector和valarray\r\n```\r\n#include<iostream>\r\n#include<valarray>   //该模板类是面向计算的，不是STL的一部分，没有push_back()和insert()方法，但是提供了大量的直观简单的数学计算接口\r\n//而array是为了替代内置数组而设计的，它通过更好的，安全的接口，让数组更紧凑，效率更高。同样也是固定长度的数组，不支持push_back()和insert方法\r\n//但是提供了多个STL方法，begin(),end(),rbegin(),rend()\r\n\r\n\r\n#include<vector>\r\n#include<algorithm>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	vector<double>data;\r\n	double temp;\r\n	cout << \"Enter numbers(<0 to quit):\\n\";\r\n	while (cin >> temp && temp > 0)\r\n	{\r\n		data.push_back(temp);\r\n	}\r\n	sort(data.begin(), data.end());\r\n	int size = data.size();\r\n\r\n	valarray<double>numbers(size);\r\n	int i;\r\n	for (i = 0; i < size; i++)\r\n	{\r\n		numbers[i] = data[i];   //使用vector对valarray进行初始化；\r\n	}\r\n	valarray<double>sq_rts(size);\r\n	sq_rts = sqrt(numbers);\r\n	valarray<double>result(size);\r\n	result = numbers + 2.0*sq_rts;  //因为valarray重载了所有数学运算符所以可以直接对数组容器进行操作\r\n	cout.setf(ios_base::fixed);\r\n	cout.precision(4);\r\n	for (i = 0; i < size; i++)\r\n	{\r\n		cout.width(8);\r\n		cout << numbers[i] << \": \";\r\n		cout.width(8);\r\n		cout << result[i] << endl;\r\n	}\r\n	//注意valarray类不可以使用stl的算法，例如sort()\r\n	//但是C++11新增了对其排序的方法\r\n	sort(begin(result), end(result));\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (139, 'C++ valarray的其他特性slice类', 1, '##valarray的其他特性slice类\r\n```\r\n#include<iostream>\r\n#include<valarray>\r\n#include<cstdlib>\r\nusing namespace std;\r\nconst int SIZE = 12;\r\ntypedef valarray<int> vint;\r\nvoid show(const vint & v, int cols);\r\n\r\nint main()\r\n{\r\n\r\n	vint valint(SIZE);\r\n\r\n	for (int i = 0; i < SIZE; ++i)\r\n	{\r\n		valint[i] = std::rand() % 10;\r\n	}\r\n	cout << \"Original array:\\n\";\r\n	show(valint, 3);\r\n\r\n	vint vcol(valint[slice(1, 4, 3)]);  //该类是将得到valint从第1个元素开始的4个元素，每个元素之间跨距为3\r\n	cout << \"Second column:\\n\";\r\n	show(vcol, 1);\r\n	vint vrow(valint[slice(3, 3, 1)]);\r\n	cout << \"Second row:\\n\";\r\n	show(vrow, 3);\r\n	valint[slice(2, 4, 3)] = 10;\r\n	cout << \"Set last colunm wo10:\\n\";\r\n	show(valint, 3);\r\n	cout << \"Set first column to sum of next two:\\n\";\r\n\r\n	valint[slice(0, 4, 3)] = vint(valint[slice(1, 4, 3)]) + vint(valint[slice(2, 4, 3)]);\r\n	show(valint, 3);\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nvoid show(const vint & v, int cols)\r\n{\r\n	int lim = v.size();\r\n	for (int i = 0; i < lim; ++i)\r\n	{\r\n		cout.width(3);\r\n		cout << v[i];\r\n		if (i%cols == cols - 1)\r\n		{\r\n			cout << endl;\r\n		}\r\n		else\r\n			cout << \' \';\r\n	}\r\n	if (lim%cols != 0)\r\n	{\r\n		cout << endl;\r\n	}\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (140, 'C++ initializer_list', 1, '##initializer_list\r\n```\r\n#include<iostream>\r\n#include<initializer_list>     //C++11新增的特性，使容器类可以用列表初始化的方式来初始化容器\r\n#include<list>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\ndouble sum(initializer_list<double>il);\r\ndouble average(const initializer_list<double> & ril);\r\n\r\nvoid sh(int a)\r\n{\r\n	cout << a << endl;\r\n}\r\n\r\nint main()\r\n{\r\n	list<int> a{ 1,2,3,4 };  //使用列表初始化的方式来初始化容器\r\n	for_each(a.begin(), a.end(), sh);\r\n\r\n\r\n\r\n	cout << \"List 1:sum =\" << sum({ 2,3,4 }) << \",ave = \" << average({ 2,3,4 }) << endl;\r\n	initializer_list<double> dl = { 1.1,2.2,3.3,4.4,5.5 };  //使用列表初始化的方式来初始化容器\r\n	cout << \"List 2:sum = \" << sum(dl) << \",ave = \" << average(dl) << endl;\r\n	dl = { 16.0,25.0,36.0,40.0,64.0 };\r\n	cout << \"List 3:sum =\" << sum(dl) << \",ave = \" << average(dl) << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\ndouble sum(initializer_list<double> il)\r\n{\r\n	double tot = 0;\r\n	for (initializer_list<double>::iterator p = il.begin(); p != il.end(); p++)\r\n		tot = tot + *p;\r\n	return tot;\r\n}\r\n\r\ndouble average(const initializer_list<double> & ril)\r\n{\r\n	double tot = 0;\r\n	int n = ril.size();\r\n	double ave = 0.0;\r\n	if (n > 0)\r\n	{\r\n		for (auto p = ril.begin(); p != ril.end(); p++)\r\n		{\r\n			tot = tot + *p;\r\n		}\r\n		ave = tot / n;\r\n	}\r\n	return ave;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (141, 'C++ cout输出流的write()方法的原理', 1, '##cout输出流的write()方法的原理\r\n```\r\n#include<iostream>\r\n#include<cstring>\r\n#include<string>\r\nint main()\r\n{\r\n	using std::cout;\r\n	using std::endl;\r\n\r\n	//write()方法模板原型：basic_ostream<charT,traits> write(const char_type * s,streamsize n)\r\n\r\n	const char * state1 = \"Florida\";\r\n	const char * state2 = \"Kansas\";\r\n	const char * state3 = \"Euphoria\";\r\n\r\n	int len = std::strlen(state2);\r\n	cout << \"Increasing loop index:\\n\";\r\n	for (int i = 1; i <= len; i++)\r\n	{\r\n		cout.write(state2, i);   //该方法不会因为遇到空格或换行符而停止打印，而是打印指定的字符数，即便越界！\r\n		cout << endl;\r\n	}\r\n\r\n	cout << \"Decreasing loop index:\\n\";\r\n	for (int i = len; i > 0; i--)\r\n	{\r\n		cout.write(state2, i) << endl;\r\n	}\r\n\r\n	cout << \"Exceeding stringl length:\\n\";\r\n	cout.write(state2, len + 5) << endl;  //此处为越界\r\n\r\n	long val = 560031841;\r\n	cout.write((char *)&val, sizeof(long))<<endl;  //该数字将被显示为4个字符的组合\r\n\r\n\r\n	cout << \"Hello\" << std::flush;    //刷新缓冲区，不插入换行符\r\n	std::string name;\r\n	std::cin >> name;\r\n	cout << name << endl;    //刷新缓冲区并插入换行符\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (142, 'C++ 使用cout默认格式', 1, '##使用cout默认格式\r\n```\r\n#include<iostream>\r\n\r\nint main()\r\n{\r\n	using std::cout;\r\n	cout << \"12345678901234567890\\n\";\r\n	char ch = \'K\';\r\n	int t = 273;\r\n	cout << ch << \":\\n\";\r\n	cout << t << \":\\n\";\r\n	cout << -t << \":\\n\";\r\n\r\n	double f1 = 1.200;\r\n	cout << f1 << \":\\n\";                //默认不显示小数点的0\r\n	cout << (f1 + 1.0 / 9.0) << \":\\n\";  //浮点数只显示6位\r\n\r\n	double f2 = 1.67E2;\r\n	cout << f2 << \":\\n\";\r\n	f2 = f2 + 1.0 / 9.0;\r\n	cout << f2 << \":\\n\";\r\n	cout << (f2*1.0e4) << \":\\n\";\r\n\r\n	double f3 = 2.3e-4;\r\n	cout << f3 << \":\\n\";\r\n	cout << f3 / 10 << \":\\n\";\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (143, 'C++ 输出模式进制符', 1, '##输出模式控制符(进制数)\r\n```\r\n#include<iostream>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	cout << \"Enter an integer\";\r\n	int n;\r\n	cin >> n;\r\n\r\n	cout << \"n       n*n\\n\";\r\n	cout << n << \"      \" << \"(decimal)\\n\";\r\n\r\n	cout << hex;  //设置输出为十六进制\r\n	cout << n << \"         \";\r\n	cout << n * n << \"  (hexadecimal)\\n\";\r\n\r\n	cout << oct << n << \"     \" << n * n << \"  (octal)\\n\";   //设置为八进制输出\r\n\r\n	dec(cout);   //设置为八十进制输出\r\n	cout << n << \"      \" << n * n << \"   (decimal)\\n\";\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (144, 'C++ 字段宽度设置', 1, '##字段宽度设置\r\n```\r\n#include<iostream>\r\nint main()\r\n{\r\n	using std::cout;\r\n\r\n\r\n	//width()只能影响接下来显示的一个项目。然后字段宽度恢复默认值\r\n	int w = cout.width(30);\r\n	cout << \"default field width = \" << w << \":\\n\";\r\n	cout.width(5);\r\n	cout << \"N\" << \':\';\r\n	cout.width(8);\r\n	cout << \"N * N\" << \":\\n\";\r\n	for (long i = 1; i <= 100; i = i * 10)\r\n	{\r\n		cout.width(5);\r\n		cout << i << \':\';\r\n		cout.width(8);\r\n		cout << i * i << \":\\n\";\r\n	}\r\n\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (145, 'C++ 填充字符fill()', 1, '##字段填充符fill()\r\n```\r\n#include<iostream>\r\n\r\nint main()\r\n{\r\n	using std::cout;\r\n	cout.fill(\'*\');   //为使用的部分用*来填充\r\n	const char * staff[2] = { \"Waldo Whipsnade\",\"Wilmarie Wooper\" };\r\n	long bonus[2] = { 900,1350 };\r\n\r\n	for (int i = 0; i < 2; i++)\r\n	{\r\n		cout << staff[i] << \": $\";\r\n		cout.width(7);   //设置字段宽度为7  \r\n		cout << bonus[i] << \"\\n\";\r\n	}\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (146, 'C++ 设置浮点数的显示精度', 1, '##设置浮点数的显示精度\r\n```\r\n#include<iostream>\r\n\r\nint main()\r\n{\r\n	using std::cout;\r\n	float pricel = 20.40;\r\n	float price2 = 1.9 + 8.0 / 9.0;\r\n\r\n	cout << \"\\\"Furry Friends\\\" is $\" << pricel << \"!\\n\";\r\n	cout << \"\\\"Furry Firends\\\" is $\" << price2 << \"!\\n\";\r\n\r\n	cout.precision(2);   //保留2位有效数字\r\n	cout << \"\\\"Furry Friends\\\" is $\" << pricel << \"!\\n\";\r\n	cout << \"\\\"Furry Firends\\\" is $\" << price2 << \"!\\n\";\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (147, 'C++ 打印小数末尾的0', 1, '##打印小数末尾的0\r\n```\r\n#include<iostream>\r\n\r\nint main()\r\n{\r\n	using std::cout;\r\n	using std::ios_base;\r\n\r\n	float price1 = 20.40;\r\n	float price2 = 1.9 + 8.0 / 9.0;\r\n\r\n	cout.setf(ios_base::showpoint);   //显示小数点后面的0  //showpoint是ios_base类的静态常量，因此调用父类的成员需要作用域解析符\r\n	cout << \"\\\"Furry Friends\\\" is $\" << price1 << \"!\\n\";\r\n	cout << \"\\\"Furry Firends\\\" is $\" << price2 << \"!\\n\";\r\n\r\n	cout.precision(2);  //保留两位有效数字\r\n	cout << \"\\\"Furry Friends\\\" is $\" << price1 << \"!\\n\";\r\n	cout << \"\\\"Furry Firends\\\" is $\" << price2 << \"!\\n\";\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (148, 'C++ setf函数的成员', 1, '##setf函数的成员\r\n```\r\n#include<iostream>\r\n#include<cmath>\r\nint main()\r\n{\r\n	using namespace std;\r\n\r\n	//fmtflags setf(fmflags)\r\n	int temperture = 63;\r\n	cout << \"Today\'s water temperature:\";\r\n	cout.setf(ios_base::showpos); //在指定非负字段插入一个+号\r\n	cout << temperture << endl;  \r\n\r\n	cout << \"For our programming friends,that\'s\\n\";\r\n	cout << hex << temperture << endl;\r\n\r\n	cout.setf(ios_base::uppercase);  //对于16进制输出，使用大写字母，E表示法\r\n	cout.setf(ios_base::showbase);  //指定插入一个显示已生成整数字段的前缀。\r\n	cout << \"or\\n\";\r\n	cout << temperture << endl;\r\n\r\n	cout << \"How\" << true << \"! opps--How\";\r\n	cout.setf(ios_base::boolalpha);  //输入和输出bool值，可以为true或false\r\n	cout << true << \"!\\n\";\r\n\r\n	cout << endl;\r\n\r\n	//fmtflags setf(fmtflags,fmtflags)\r\n	cout.setf(ios_base::left, ios_base::adjustfield);  //使用左对齐\r\n	cout.setf(ios_base::showpos);  //显示前缀\r\n	cout.setf(ios_base::showpoint);  //显示小数点后面的0\r\n	cout.precision(3);  //保留3位小数\r\n	ios_base::fmtflags old = cout.setf(ios_base::scientific, ios_base::floatfield);  //使用科学计数法\r\n	cout << \"Left Justification:\\n\";\r\n	long n;\r\n\r\n	for (n = 1; n <= 41; n = n + 10)\r\n	{\r\n		cout.width(4);\r\n		cout << n << \"|\";\r\n		cout.width(12);\r\n		cout << sqrt(double(n)) << \"|\\n\";\r\n	}\r\n\r\n	cout.setf(ios_base::internal, ios_base::adjustfield);  //符号或基数前缀左对齐，值右对齐\r\n	cout.setf(old, ios_base::floatfield);  //恢复以前的设置\r\n\r\n	cout << \"Internal Justfication:\\n\";\r\n	for (n = 1; n <= 41; n = n + 10)\r\n	{\r\n		cout.width(4);\r\n		cout << n << \"|n\";\r\n		cout.width(12);\r\n		cout << sqrt(double(n)) << \"|\\n\";\r\n	}\r\n\r\n	cout.setf(ios_base::right, ios_base::adjustfield);//使用右对齐\r\n	cout.setf(ios_base::fixed, ios_base::floatfield);  //使用定点计数法\r\n	cout << \"Right Justification:\\n\";\r\n	for (n = 1; n <= 41; n = n + 10)\r\n	{\r\n		cout.width(4);\r\n		cout << n << \"|\";\r\n		cout.width(12);\r\n		cout << sqrt(double(n)) << \"|\\n\";\r\n	}\r\n\r\n	//setf()效果可以通过unsetf()消除   void unsetf(fmtflags mask);\r\n	//cout.setf(0,ios_base::floatfield)\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\n注意：系统提供了许多控制符，可以使用控制符来格式化\r\n```', 0);
INSERT INTO `blog_course` VALUES (149, 'C++ 头文件iomanip', 1, '##头文件iomanip\r\n```\r\n#include<iostream>\r\n#include<iomanip>\r\n//头文件iomanip中提供了其他控制符，表示起来比iostream工具更方便\r\n\r\n\r\n#include<cmath>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	cout << fixed << right;\r\n\r\n	cout << setw(6) << \"N\" << setw(14) << \"square root\" << setw(15) << \"fourth root\\n\";\r\n\r\n	double root;\r\n	for (int n = 10; n <= 100; n = n + 10)\r\n	{\r\n		root = sqrt(double(n));\r\n		cout << setw(6) << setfill(\'*\') << n << setfill(\'.\')\r\n			<< setw(12) << setprecision(3) << root\r\n			<< setw(14) << setprecision(4) << sqrt(root)\r\n			<< endl;\r\n	}\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (150, 'C++ IO异常处理', 1, '##IO异常处理\r\n```\r\n#include<iostream>\r\n#include<exception>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	cin.exceptions(ios_base::failbit);  //exceptions()方法返回一个位字段，包含3位，分别对应eofbit,failbit,badbit\r\n	cout << \"Enter numbers:\";\r\n	int sum = 0;\r\n	int input;\r\n	try\r\n	{\r\n		while (cin >> input)\r\n		{\r\n			sum = sum + input;\r\n		}\r\n	}\r\n	catch (ios_base::failure &bf)  //io异常类failure\r\n	{\r\n		cout << bf.what() << endl;\r\n		cout << \"0!the horror!\\n\";\r\n	}\r\n	cout << \"Last value entered = \" << input << endl;\r\n	cout << \"Sum  = \" << sum << endl;\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (151, 'C++ 字符串输入', 1, '##字符串输入\r\n```\r\n#include<iostream>\r\nconst int  Limit = 255;\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n\r\n	//istream & get(char*,int,char)\r\n	//istream & get(char*,int)\r\n	//istream & getline(char*, int, char)\r\n	//istream & getline(char *,int)\r\n	//这些函数都是直到读取到最大数目字符或遇到换行符为止\r\n	//get()与getline()的区别：get()将换行符留在输入流中，这样接卸来的操作首先看到的换行符。\r\n	//而getline()抽取并丢弃输入流中的换行符\r\n	//同样三个参数的读取函数get也是将分界符留在输入流中\r\n\r\n	char input[Limit];\r\n	cout << \"Enter a string for getline() processing :\\n\";\r\n	cin.getline(input, Limit, \'#\');\r\n	cout << \"Here is your input:\\n\";\r\n	cout << input << \"\\nDone with phase 1\\n\";\r\n\r\n	char ch;\r\n	cin.get(ch);\r\n	cout << \"The next input character is\" << ch << endl;\r\n\r\n	if (ch != \'\\n\')\r\n	{\r\n		cin.ignore(Limit, \'\\n\');  //指定要读取的最大字符数，另一个是字符，用作输入分节符\r\n		//读取并抛弃接下来的255个字符或直到遇到第一个换行符\r\n	}\r\n	cout << \"Enter a string for get() processing:\\n\";\r\n	cin.get(input, Limit, \'#\');\r\n	cout << \"Here is your input:\\n\";\r\n	cout << input << \"\\nDone with phase 2\\n\";\r\n\r\n	cin.get(ch);\r\n	cout << \"The next input character is \" << ch << endl;\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (152, 'C++ istream的其他方法', 1, '##istream的其他方法\r\n```\r\n#include<iostream>\r\nint main()\r\n{\r\n	using namespace std;\r\n\r\n	char ch;\r\n	//while (cin.get(ch))\r\n	//{\r\n	//	if (ch != \'#\')\r\n	//	{\r\n	//		cout << ch;\r\n	//	}\r\n	//	else\r\n	//	{\r\n	//		cin.putback(ch);//该函数将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。该方法接受一个char参数，返回类型是istream\r\n	//		break;\r\n	//	}\r\n	//}\r\n	//if (!cin.eof())\r\n	//{\r\n	//	cin.get(ch);\r\n	//	cout << endl << ch << \" is next inpur character.\\n\";\r\n	//}\r\n	//else\r\n	//{\r\n	//	cout << \"End of file reached.\\n\";\r\n	//	std::exit(0);\r\n	//}\r\n	while (cin.peek() != \'#\') //peek函数返回输入中的下一个字符，但不抽取输入流中的字符\r\n	{\r\n		cin.get(ch);\r\n		cout << ch;\r\n	}\r\n	if (!cin.eof())\r\n	{\r\n		cin.get(ch);\r\n		cout << endl << ch << \" is next input character.\\n\";\r\n	}\r\n	else\r\n	{\r\n		cout << \"End of file reached.\\n\";\r\n	}\r\n	//gcount()方法返回最后一个非格式化抽取方法读取的字符数\r\n	//read()函数读取指定数目的字节，并存储在指定的位置中。\r\n	//char.gross[144];\r\n	//cin.read(gross,144)：\r\n	//与getline()和get()不同的是read()不会再输入后加上一个空值字符，因此不能将输入转换位字符串。\r\n	//read()方法不是专为键盘设计的，它最常与ostream.write()函数结合使用，来完成文件输入和输出。返回类型是istream &，因此可以拼接\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (153, 'C++ peek()方法来确定是否读取了整行', 1, '##peek方法来确定是否读取了整行\r\n```\r\n#include<iostream>\r\nconst int SLEN = 10;\r\ninline void eatline()\r\n{\r\n	while (std::cin.get()!=\'\\n\')\r\n	{\r\n		continue;\r\n	}\r\n}\r\nint main()\r\n{\r\n	using namespace std;\r\n	char name[SLEN];\r\n	char title[SLEN];\r\n	cout << \"Enter your name:\";\r\n	cin.get(name, SLEN);\r\n	if (cin.peek() != \'\\n\')\r\n	{\r\n		cout << \"Sorry,we only have enough room for\" << name << endl;\r\n	}\r\n	eatline();\r\n	cout << \"Deae \" << name << \",enter your title:\\n\";\r\n	cin.get(title, SLEN);\r\n	if (cin.peek() != \'\\n\')\r\n	{\r\n		cout << \"we were forced to truncate your title.\\n\";\r\n	}\r\n	eatline();\r\n	cout << \" Name:\" << name << \"\\nTitle: \" << title << endl;\r\n\r\n\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (154, 'C++ 一个简单文本文件的输入输出', 1, '##一个简单的文本文件输入输出\r\n```\r\n#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	string filename;\r\n	cout << \"Enter name for new file\";\r\n	cin >> filename;\r\n\r\n	//文本输出流\r\n	ofstream fout(filename.c_str()); //该构造函数只接受一个C风格的字符串\r\n	fout << \"For your eyes only!\\n\";\r\n	cout << \"Enter your secret number: \";\r\n	float secret;\r\n	cin >> secret;\r\n	fout << \"Your secret number is \" << secret << endl;\r\n	fout.close();\r\n\r\n	//文本输入流\r\n	ifstream fin(filename.c_str());\r\n	cout << \"Here are the contents of \" << filename << \":\\n\";\r\n	char ch;\r\n	while (fin.get(ch)) //单个字符读取文本内容，直到遇到换行符\r\n	{\r\n		cout << ch;    //输出字符\r\n	}\r\n	fin.close();\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (155, 'C++ 命令行处理技术', 1, '##命令行处理技术\r\n```\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cstdlib>\r\n\r\nint main(int argc,char * argv[])  //argc是命令参数的数目，将命令存储在argv[]字符串里\r\n{\r\n	using namespace std;\r\n	if (argc == 1)\r\n	{\r\n		cerr << \"Usage:\" << argv[0] << \"filename[s]\\n\";\r\n		exit(EXIT_FAILURE);\r\n	}\r\n	ifstream fin;   //创建一个文件输入流\r\n	long count;\r\n	long total = 0;\r\n	char ch;\r\n\r\n	for (int file = 1; file < argc; file++)\r\n	{\r\n		fin.open(argv[file]);\r\n		if (!fin.is_open())\r\n		{\r\n			cerr << \"Could not open \" << argv[file] << endl;\r\n			fin.clear();\r\n			continue;\r\n		}\r\n		count = 0;\r\n		while (fin.get(ch))\r\n		{\r\n			count++;\r\n		}\r\n		cout << count << \"characters in\" << argv[file] << endl;\r\n		total = total + count;\r\n		fin.clear();\r\n		fin.close();\r\n	}\r\n	cout << total << \" characters in all files\\n\";\r\n\r\n\r\n\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (156, 'C++ 文件追加', 1, '##文件追加\r\n```\r\n#include<iostream>   //包含头文件的时候自动创建8个流对象\r\n#include<fstream>\r\n#include<string>\r\n#include<cstdlib>\r\n\r\nconst char * file = \"MYK.txt\";\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	char ch;\r\n	ifstream fin;\r\n	fin.open(file);  \r\n\r\n	if (fin.is_open())\r\n	{\r\n		cout << \"Here are the current contents of the \" << file << \" file:\\n\";\r\n		while (fin.get(ch))\r\n		{\r\n			cout << ch;\r\n		}\r\n		fin.close();\r\n	}  \r\n	ofstream fout(file, ios_base::out | ios_base::app);  //打开写入只追加\r\n	if (!fout.is_open())\r\n	{\r\n		cerr << \"Can\'t open \" << file << \" file for output.\\n\";\r\n		exit(EXIT_FAILURE);\r\n	}\r\n	cout << \"Enter guest names(enter a blank line to quit):\\n\";\r\n	string name;\r\n	while (getline(cin, name) && name.size() > 0)\r\n	{\r\n		fout << name << endl;\r\n	}\r\n	fout.close();\r\n\r\n	fin.clear();\r\n	fin.open(file);\r\n	if (fin.is_open())\r\n	{\r\n		cout << \"Here are the new contents of the \" << file << \" file:\\n\";\r\n		while (fin.get(ch))\r\n			cout << ch;\r\n		fin.close();\r\n	}\r\n	cout << \"Done.\\n\";\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\nios_base::in                                      打开以读取\r\nios_base::out                                     等价于ios_base::out|ios_base::truec\r\nios_base::out|ios_base::trunc                     打开以写入，如果已经存在，则截短文件\r\nios_base::out|ios_base::app                       打开以写入，只追加\r\nios_base::out|ios_base::out                       打开以读写，在文件允许的位置写入\r\nios_base::out|ios_base::out|ios_base::trunc       打开以读写，如果存在，则首先截短文件\r\nc++mode|ios_base::binary                          以C++mode和二进制模式打开\r\nc++mode|ios_base::ate                             以C++指定的模式打开，并移到文件尾。\r\n注意：ios_base::ate和ios_base::app都将文件指针指向打开的文件尾。区别在于，ios_base::app模式只允许将数据添加到文件尾，而ios_base::ate模式将指针放到文件尾\r\n```', 0);
INSERT INTO `blog_course` VALUES (157, 'C++ 二进制文件', 1, '##二进制文件\r\n```\r\n#include<iostream>\r\n#include<fstream>\r\n#include<iomanip>\r\n#include<cstdlib>\r\n\r\ninline void eatline()\r\n{\r\n	while (std::cin.get() != \'\\n\')\r\n	{\r\n		continue;\r\n	}\r\n}\r\nstruct planet\r\n{\r\n	char name[20];\r\n	double population;\r\n	double g;\r\n};\r\nconst char * file = \"MYK.txt\";\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	planet pl;\r\n	cout << fixed << right;\r\n\r\n	ifstream fin;\r\n	fin.open(file, ios_base::in | ios_base::binary);//打开文件读取权限，并为二进制读取\r\n	if (fin.is_open())\r\n	{\r\n		cout << \"Here are the current contents of the \" << file << \" file:\\n\";\r\n		while (fin.read((char*)&pl, sizeof(pl)))  //因为read接受char*类型，和一个int类型，所以这里要进行转换\r\n		{\r\n			cout << setw(20) << pl.name << \": \" << setprecision(0) << setw(12) << pl.population << setprecision(2) << setw(6) << pl.g << endl;\r\n		}\r\n		fin.close();\r\n	}\r\n\r\n	ofstream fout(file, ios_base::out | ios_base::app | ios_base::binary); //打开写入权限，追加写入，以二进制模式\r\n	if (!fout.is_open())\r\n	{\r\n		cerr << \"Can\'t open\" << file << \" file for output:\\n\";\r\n		exit(EXIT_FAILURE);\r\n	}\r\n	cout << \"Enter planet name(enter a blank line to quit):\\n\";\r\n	cin.getline(pl.name, 20);  //cin.get()\r\n	while (pl.name[0]!=\'\\0\')\r\n	{\r\n		//eatline();//内嵌eatline()函数\r\n		cout << \"Enter planetary population: \";\r\n		cin >> pl.population;\r\n		cout << \"Enter planet\'s acceleration of gravity: \";\r\n		cin >> pl.g;\r\n		//eatline();\r\n		fout.write((char*)&pl, sizeof(pl));  \r\n		cout << \"Enter planet name(enter a blank line to quit):\\n\";\r\n		cin.getline(pl.name, 20); //cin.get()\r\n	}\r\n	fout.close();\r\n\r\n\r\n	fin.clear();\r\n	fin.open(file, ios_base::in | ios_base::binary);\r\n	if (fin.is_open())\r\n	{\r\n		cout << \"Here are the new contents of the \" << file << \" file:\\n\";\r\n		while (fin.read((char*)&pl, sizeof(pl)))\r\n		{\r\n			cout << setw(20) << pl.name << \": \" << setprecision(0) << setw(12) << pl.population << setprecision(2) << setw(6) << pl.g << endl;\r\n		}\r\n		fin.close();\r\n	}\r\n	cout << \"Done.\\n\";\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (158, 'C++ 随机存取', 1, '##随机存取\r\n```\r\n#include<iostream>\r\n#include<fstream>\r\n#include<iomanip>  //格式化输出\r\n#include<cstdlib>\r\n\r\nconst int LIM = 20;\r\nstruct planet\r\n{\r\n	char name[LIM];\r\n	double population;\r\n	double g;\r\n};\r\n\r\nconst char * file = \"planet.dat\";\r\ninline void eatline()\r\n{\r\n	while (std::cin.get() != \'\\n\')\r\n	{\r\n		continue;\r\n	}\r\n}\r\nint main()\r\n{\r\n	using namespace std;\r\n	planet p1;\r\n	cout << fixed;\r\n\r\n	fstream finout;\r\n	finout.open(file, ios_base::in | ios_base::out | ios_base::binary);//打开文件，并给与二进制读取写入的权限\r\n    \r\n	int ct = 0;\r\n	if (finout.is_open())\r\n	{\r\n		finout.seekg(0);  //随机访问函数，将输入指针移到指定位置\r\n		//函数原型：basic_istream<charT,traits> &seekg(off_type,ios_base::seekdir)\r\n		          //basic_istream<charT,traits> &seekg(pos_type)\r\n		//char具体化：\r\n		//istream & seekg(streamoff, ios_base::seekdir);\r\n		//istream & seekg(streampos);\r\n		//seekp()：将输入指针移到指定的文件位置（缓冲区，不是实际文件）\r\n\r\n		//ios_base::beg相对于文件开始出的偏移量\r\n		//ios_base::cur相对于当前位置的偏移量；\r\n		//ios_base::end相对于文件尾的偏移量；\r\n\r\n		//如果要返回文件所在指针的位置对于输入流可以使用tellg()方法，对于输出流可以使用tellp()方法。它们都返回一个表示当前位置的streampos值\r\n		cout << \"Here are the current contents of the\" << file << \" file:\\n\";\r\n		while (finout.read((char*)&p1, sizeof(p1)))\r\n		{\r\n			cout << ct++ << \": \" << setw(LIM) << p1.name << \": \" << setprecision(0) << setw(12) << p1.population << setprecision(2) << setw(6) << p1.g << endl;\r\n		}\r\n		if (finout.eof())\r\n			finout.clear();//如果到达文件尾说明对文件操作完毕，则清除此流\r\n		else\r\n		{\r\n			cerr << \"Error in reading \" << file << \".\\n\";\r\n			exit(EXIT_FAILURE);\r\n		}\r\n	}\r\n	else\r\n	{\r\n		cerr << file << \"could not be opend -- bye.\\n\";\r\n		exit(EXIT_FAILURE);\r\n	}\r\n\r\n	//改变记录\r\n	cout << \"Enter the record number you wish to change:\";\r\n	long rec;\r\n	cin >> rec;   //输入记录号，其字节编号为 rec * sizeof p1;\r\n	eatline();\r\n	if (rec < 0 || rec >= ct)\r\n	{\r\n		cerr << \"Invalid record number -- bye\\n\";\r\n		exit(EXIT_FAILURE);\r\n	}\r\n	streampos place = rec * sizeof p1;  //指定一个位置类型。它可以是类。如果是类，这个类将包含一个接受streamoff参数的构造函数和一个接受整数参数的构造函数，以便将这两种类型转换为streampos值\r\n\r\n	//文件的位置指针是一个streampos类型\r\n\r\n	finout.read((char*)&p1, sizeof p1);\r\n	cout << \"Your selection:\\n\";\r\n	cout << rec << \": \" << setw(LIM) << p1.name << \": \" << setprecision(0) << setw(12) << p1.population << setprecision(2) << setw(6) << p1.g << endl;\r\n	if (finout.eof())\r\n		finout.clear();  //清除错误标志\r\n\r\n	cout << \"Enter planet name: \";\r\n	cin.get(p1.name, LIM);\r\n	eatline();\r\n	cout << \"Enter planetary population: \";\r\n	cin >> p1.g;\r\n	finout.seekg(place);\r\n	finout.write((char*)&p1, sizeof p1) << flush;  //向记录处写入数据并刷新缓冲区\r\n	if (finout.fail())\r\n	{\r\n		cerr << \"Error on attempted write\\n\";\r\n		exit(EXIT_FAILURE);\r\n	}\r\n\r\n\r\n	//查看文件\r\n	ct = 0;\r\n	finout.seekg(0);  //指针指向开始处\r\n	cout << \"Here are the new contents of the \" << file << \" file:\\n\";\r\n	while (finout.read((char*)&p1, sizeof p1))\r\n	{\r\n		cout << ct++ << \": \" << setw(LIM) << p1.name << \": \" << setprecision(0) << setw(12) << p1.population << setprecision(2) << setw(6) << endl;\r\n	}\r\n	finout.close();\r\n	cout << \"Done.\\n\";\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (159, 'C++ 临时文件', 1, '##临时文件	\r\n```\r\n#include<cstdio>  //常量L_tmpnam和TMP_MAX在此定义的，限制了文件名包含的字符数以及在确保当前目录中不生成重复文件名的情况下tmpnam()可被调用的最多次数\r\n#include<iostream>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	cout << \"This system can generate up to \" << TMP_MAX << \"temporary names of up to \" << L_tmpnam << \" characters.\\n\";\r\n	char pszName[L_tmpnam] = { \'\\0\' }; //260\r\n	cout << \"Here are ten names:\\n\";\r\n	for (int i = 0; 10 > i; i++)\r\n	{\r\n		tmpnam(pszName);  //tmpnam()函数创建一个临时文件名，\r\n		//函数原型：char*tmpnam(char * pszName);\r\n		cout << pszName << endl;\r\n	}\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (160, 'C++ IO文本与string对象', 1, '##IO文本图string对象\r\n```\r\n#include<iostream>\r\n#include<sstream>\r\n//sstream定义了一个从ostream类派生而来的ostringstream类。如果创建了一个ostringstream对象，则可以将信息写入其中，它将存储这些信息。\r\n//istringstream类允许使用istream方法读取istringstream对象中的数据，istringstream对象可以使用string对象进行初始化。\r\n#include<string>\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	ostringstream outstr;\r\n	string hdisk;\r\n	cout << \"What\'s the name of your hard disk?\";\r\n	getline(cin, hdisk);\r\n	int cap;\r\n	cout << \"What\'s the its capacity in GB?\";\r\n	cin >> cap;\r\n	outstr << \"The hard disk \" << hdisk << \" has a capacity of\" << cap << \" gigabytes.\\n\";\r\n\r\n	string result = outstr.str();//将ostringstream类转化为string对象\r\n	cout<<result;\r\n\r\n\r\n	string lit = \"It was a dark and stormy day,and the full moon glowed birlliantly.\";\r\n	istringstream instr(lit);\r\n	string word;\r\n	while (instr >> word)\r\n		cout << word << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (161, 'C++ 【C++ 11新标准】关键字declype和返回类型后置', 1, '##【C++ 11新标准】关键字decltype和返回类型后置\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nauto f1(double, int)->double;\r\ntemplate<class T, class U>\r\nauto eff(T t, U u)->decltype(t*u);\r\nint main()\r\n{\r\n	double x;\r\n	int n;\r\n	decltype(x*n) q;  //q的类型为表达式x*n的类型 ，该关键字在定义模板时比较有用\r\n\r\n\r\n	return 0;\r\n}\r\ntemplate<class T,class U>\r\nvoid ef(T t, U u)\r\n{\r\n	decltype(T*U) tu;//因为不确定tu 的类型，所以可以这样定义\r\n	cout << tu << endl;\r\n}\r\n//返回类型后置\r\nauto f1(double a ,int b)->double\r\n{\r\n	cout << a + b << endl;\r\n}\r\n\r\n//返回类型后置和表达式类型结合\r\ntemplate<class T,class U>\r\nauto eff(T t, U u)->decltype(t*u)\r\n{\r\n	cout << t * u << endl;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (162, 'C++ 右值引用', 1, '##右值引用\r\n```\r\n#include<iostream>\r\n\r\ninline double f(double tf)\r\n{\r\n	return 5.0*(tf - 32.0) / 9.0;\r\n}\r\n\r\nint main()\r\n{\r\n	using namespace std;\r\n	double tc = 21.5;\r\n	double && rd1 = 7.07;\r\n	double && rd2 = 1.8*tc + 32.0;\r\n	double && rd3 = f(rd2);\r\n\r\n	cout << tc << \",\" << &tc << endl;\r\n	cout << rd1 << \",\" << &rd1 << endl;\r\n	cout << rd2 << \",\" << &rd2 << endl;\r\n	cout << rd3 << \",\" << &rd3 << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (163, 'C++ 移动语义', 1, '##移动语义--移动构造函数\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nclass Useless\r\n{\r\nprivate:\r\n	int n;\r\n	char * pc;   //定义一个C风格字符串\r\n	static int ct;  //静态变量\r\n	void ShowObject()const;\r\n\r\npublic:\r\n	Useless();\r\n	explicit Useless(int k);\r\n	Useless(int k, char ch);\r\n	Useless(const Useless & f);   //常规拷贝构造函数\r\n	Useless(Useless && f);   //移动拷贝构造函数\r\n	~Useless();\r\n\r\n	Useless operator+(const Useless & f)const;   //重载+号运算符，使两个类可以相加\r\n	void ShowData()const;\r\n};\r\nint Useless::ct = 0;  //初始化定义静态常量\r\n\r\n//类成员函数实现\r\nUseless::Useless()\r\n{\r\n	++ct;  //监控构造函数被调用的情况\r\n	n = 0;\r\n	pc = nullptr;\r\n	cout << \"default constructor called;number of objects:\" << ct << endl;\r\n	ShowObject();\r\n}\r\n\r\nUseless::Useless(int k) :n(k)\r\n{\r\n	++ct;\r\n	cout << \"int constructor called;number of objects:\" << ct << endl;\r\n	pc = new char[n];   \r\n	ShowObject();\r\n}\r\n\r\nUseless::Useless(int k, char ch):n(k)\r\n{\r\n	++ct;\r\n	cout << \"int ,char constructor called;number of objects:\" << ct << endl;\r\n	pc = new char[n];\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		pc[i] = ch;   //将C风格字符串中字符都初始化为ch\r\n	}\r\n	ShowObject();\r\n\r\n}\r\n\r\nUseless::Useless(const Useless & f):n(f.n)\r\n{\r\n	++ct;\r\n	cout << \"copy constructor calle ; number of objects:\" << ct << endl;\r\n	pc = new char[n];   //再次申请空间 ，防止二次释放内存\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		pc[i] = f.pc[i];\r\n	}\r\n	ShowObject();\r\n}\r\n//移动构造函数\r\nUseless::Useless(Useless&&f) :n(f.n)\r\n{\r\n	++ct;\r\n	cout << \"move constructor called;number of objects:\" << ct << endl;\r\n	pc = f.pc;     //偷取f对象中pc字符串的地址\r\n	f.pc = nullptr;//将f对象中的pc指针置空\r\n	f.n = 0;\r\n	ShowObject();\r\n}\r\n\r\nUseless::~Useless()\r\n{\r\n	cout << \"desturctor called;objects left:\" << --ct << endl;\r\n	cout << \"deleted object:\\n\";\r\n	ShowObject();\r\n	delete[]pc;\r\n}\r\n\r\nUseless Useless::operator+(const Useless & f)const\r\n{\r\n	cout << \"Entering operator+()\\n\";\r\n	Useless temp = Useless(n + f.n);\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		temp.pc[i] = pc[i];  //先将一个字符串赋值给temp的pc\r\n	}\r\n	for (int i = n; i < temp.n; i++)//在刚才的后面借着给temp的pc赋值\r\n	{\r\n		temp.pc[i] = f.pc[i - n];\r\n	}\r\n	cout << \"temp objects:\\n\";\r\n	cout << \"Leaving operator+()\\n\";\r\n	return temp;\r\n}\r\n\r\nvoid Useless::ShowObject()const //显示当前字符串信息\r\n{\r\n	cout << \"Number of elements: \" << n;\r\n	cout << \"Data address\" << (void*)pc << endl;\r\n}\r\nvoid Useless::ShowData()const  //输出字符串\r\n{\r\n	if (n == 0)\r\n	{\r\n		cout << \"(Object empty)\";\r\n	}\r\n	else\r\n		for (int i = 0; i < n; i++)\r\n			cout << pc[i];  \r\n	cout << endl;\r\n}\r\n\r\nint main()\r\n{\r\n	Useless one(10, \'x\');\r\n	Useless two = one;  //调用拷贝构造\r\n	Useless three(20, \'o\');\r\n	Useless four(one + three);  //调用移动构造函数  \r\n								//one+three会调用operator+，因此创建出一个临时对象，那么其引用就会指向这个临时对象，而移动构造函数的参数就是右值对象引用，也就是临时对象，所以这里会先调用运算符重载，然后调用移动构造\r\n	                            //临时对象，使用就会被程序销毁，但是由于移动构造函数偷取了其地址就会一直使用它，four对象没有调用任何构造函数也就是没有给与分配空间，而是使用operator+而来的空间\r\n	cout << \"object one:\";\r\n	one.ShowData();\r\n	cout << \"object two:\";\r\n	two.ShowData();\r\n	cout << \"object three:\";\r\n	three.ShowData();\r\n	cout << \"object four:\";\r\n	four.ShowData();\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (164, 'C++ 强制移动', 1, '##强制移动\r\n```\r\n#include<iostream>\r\n#include<utility>   //强转右值引用的头文件\r\n//C++11 提供的强转方式，将左值转化为右值\r\nclass Useless\r\n{\r\nprivate:\r\n	int n;\r\n	char * pc;\r\n	static int ct;\r\n	void ShowObject()const;\r\npublic:\r\n	Useless();\r\n	explicit Useless(int k);\r\n	Useless(int k, char ch);\r\n	Useless(const Useless & f);\r\n	Useless(Useless && f);\r\n	~Useless();\r\n	Useless operator+(const Useless & f)const;\r\n	Useless & operator = (const Useless & f);\r\n	Useless & operator =(Useless && f);\r\n	void ShowData()const;\r\n};\r\n\r\nint Useless::ct = 0;\r\n\r\nUseless::Useless()\r\n{\r\n	++ct;\r\n	n = 0;\r\n	pc = nullptr;\r\n}\r\n\r\nUseless::Useless(int k) :n(k)\r\n{\r\n	++ct;\r\n	pc = new char[n];\r\n}\r\n\r\nUseless::Useless(int k, char ch) :n(k)\r\n{\r\n	++ct;\r\n	pc = new char[n];\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		pc[i] = ch;\r\n	}\r\n}\r\n\r\nUseless::Useless(const Useless & f) :n(f.n)\r\n{\r\n	++ct;\r\n	pc = new char[n];\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		pc[i] = f.pc[i];\r\n	}\r\n}\r\n\r\nUseless::Useless(Useless && f) :n(f.n)\r\n{\r\n	++ct;\r\n	pc = f.pc;\r\n	f.pc = nullptr;\r\n	f.n = 0;\r\n}\r\n\r\nUseless::~Useless()\r\n{\r\n	delete[]pc;\r\n}\r\n\r\nUseless & Useless::operator=(const Useless & f)\r\n{\r\n	if (this == &f)\r\n	{\r\n		return *this;  //如果调用对象地址与目标对象地址一致，直接返回调用对象\r\n	}\r\n	delete[]pc;   //释放掉f形参的pc\r\n	n = f.n;\r\n	pc = new char[n];\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		pc[i] = f.pc[i];\r\n	}\r\n	return *this;\r\n}\r\n\r\nUseless & Useless::operator=(Useless && f)  //移动赋值重载\r\n{\r\n	if (this == &f)\r\n	{\r\n		return *this;\r\n	}\r\n	delete[] pc;\r\n	n = f.n;\r\n	pc = f.pc;   //将临时对象的地址赋值给调用对象，并将之前的临时对象地址置空；\r\n	f.n = 0;\r\n	f.pc = nullptr;\r\n	return *this;  //返回偷取临时对象地址后的对象\r\n}\r\n\r\nUseless Useless::operator+(const Useless & f)const\r\n{\r\n	Useless temp = Useless(n + f.n);\r\n	for (int i =0 ; i < n; i++)\r\n	{\r\n		temp.pc[i] = pc[i];\r\n	}\r\n	for (int i = n; i < temp.n; i++)\r\n	{\r\n		temp.pc[i] = f.pc[i - n];\r\n	}\r\n	return temp;\r\n}\r\nvoid Useless::ShowObject()const\r\n{\r\n	std::cout << \"Number of elements: \" << n;\r\n	std::cout << \" Data address: \" << (void*)pc << std::endl;\r\n}\r\n\r\nvoid Useless::ShowData()const\r\n{\r\n	if (n == 0)\r\n	{\r\n		std::cout << \"(object empty)\";\r\n	}\r\n	else\r\n		for (int i = 0; i < n; i++)\r\n			std::cout << pc[i];\r\n	std::cout << std::endl;\r\n}\r\n\r\nint main()\r\n{\r\n	using std::cout;\r\n\r\n	Useless one(10, \'x\');\r\n	Useless two = one + one;\r\n	cout << \"object one: \";\r\n	one.ShowData();\r\n	cout << \"object two:\";\r\n	two.ShowData();\r\n	Useless three, four;\r\n	cout << \"three = one\\n\";\r\n	three = one;\r\n	cout << \"now object three = \";\r\n	three.ShowData();\r\n	cout << \"and object one = \";\r\n	one.ShowData();\r\n	cout << \"four = one + two\\n\";\r\n	four = one + two;\r\n	cout << \"now object four = \";\r\n	four.ShowData();\r\n	cout << \" four = move(one)\\n\";\r\n	cout <<std::endl;\r\n\r\n\r\n	four = std::move(one);//将左值转化为右值\r\n	cout << \"now object four = \";\r\n	four.ShowData();\r\n	cout << \" and object one = \";\r\n	one.ShowData();    //此时one为空\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (165, 'C++ 特殊成员函数default和delete', 1, '##特殊成员函数default和delete\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nclass Someclass\r\n{\r\npublic:\r\n	Someclass(const Someclass & s) = delete;\r\n	Someclass(Someclass && s);\r\n	//当类中提供了拷贝构造和移动拷贝构造时，系统会提供一个默认的赋值运算符和一个默认的移动运算符\r\n\r\n	//其原型如下\r\n	//Someclass & operator = (const Someclass & s);\r\n	//Someclass & operator =(Someclass && s);\r\n	//如果没有析构函数，系统也会提供一个默认的\r\n\r\n	//但是当只提供了拷贝构造和赋值运算符，那么系统不会提供默认的移动构造和移动赋值\r\n	//反之，只提供移动构造和移动赋值，那么系统也不会提供默认的拷贝构造和赋值\r\n\r\n	//例如当只声明移动构造的情况，那么系统不会提供默认的构造，拷贝构造，拷贝赋值\r\n	//可以显示声明默认的\r\n	Someclass() = default;\r\n	//也可以使用delete用于\r\n	Someclass & operator =(const Someclass & s) = delete;\r\n	//也可以用在普通成员函数上\r\n	void redo(double);\r\n	void redo(int) = delete;  //正常如果传入整形数据就会默认将int提升为double类型，这样传入double类型就会报错；\r\n\r\n\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (166, 'C++ 委托构造函数和继承构造函数', 1, '##委托构造函数和继承构造函数\r\n```\r\n#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\n//委托构造函数，用已有的构造函数初始化其他的构造函数\r\nclass Notes\r\n{\r\nprivate:\r\n	int k;\r\n	double x;\r\n	string st;\r\npublic:\r\n	Notes();\r\n	Notes(int);\r\n	Notes(int, double);\r\n	Notes(int, double,string);\r\n};\r\n\r\nNotes::Notes(int kk, double xx, string str) :k(kk), x(xx), st(str)\r\n{\r\n\r\n}\r\n//委托构造函数\r\nNotes::Notes() : Notes(0, 0.1, \"Oh\")  //用上一个构造函数给此构造函数提供默认值\r\n{\r\n\r\n}\r\nNotes::Notes(int kk) : Notes(kk, 0.01, \"Ah\")\r\n{\r\n\r\n}\r\nNotes::Notes(int kk, double xx) : Notes(kk, xx, \"Uh\")\r\n{\r\n\r\n}\r\n\r\n//继承构造函数\r\nclass BS\r\n{\r\nprivate:\r\n	int q;\r\n	double w;\r\npublic:\r\n	BS() :q(0), w(0)\r\n	{\r\n\r\n	}\r\n	BS(int k) :q(k), w(100)\r\n	{\r\n\r\n	}\r\n	BS(double x) :q(-1), w(x)\r\n	{\r\n\r\n	}\r\n	BS(int k, double x) :q(k), w(x)\r\n	{\r\n\r\n	}\r\n	void Show()const\r\n	{\r\n		cout << q << \",\" << w << endl;\r\n	}\r\n};\r\n\r\nclass DR :public BS\r\n{\r\n	short j;\r\npublic:\r\n	using BS::BS;    //使用using让子类可以使用父类的所有BS构造函数\r\n	DR() :j(-100) {}\r\n	DR(double x) :BS(x), j(int(x)) {}\r\n	DR(int i) :j(-2), BS(i) {}\r\n	void Show()const\r\n	{\r\n		cout << j << \",\"<< endl;\r\n		BS::Show();\r\n	}\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (167, 'C++ 管理虚方法和override和final', 1, '##管理虚方法override和final\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\nclass Action\r\n{\r\nprivate:\r\n	int a;\r\npublic:\r\n	Action(int i = 0) :a(i)\r\n	{\r\n\r\n	}\r\n	int val()const\r\n	{\r\n		return a;\r\n	}\r\n	virtual void f(char ch)const \r\n	{\r\n		cout << val() << ch << endl;\r\n	}\r\n	virtual void ff(char ch)const final  //被final声明的方法无法被重写\r\n	{\r\n		cout << ch << endl;\r\n	}\r\n};\r\nclass Bingo :public Action\r\n{\r\npublic:\r\n	Bingo(int i = 0) :Action(i)\r\n	{\r\n\r\n	}\r\n\r\n\r\n	virtual void f(char  ch )const override  //用override 声明的成员函数必须是重写父类的方法。\r\n	{\r\n		cout << val() << ch << endl;\r\n	}\r\n\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (168, 'C++ lambda表达式（1）', 1, '##lambda表达式(1)\r\n```\r\n#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<cmath>\r\n#include<ctime>\r\n\r\nconst long Size1 = 39L;\r\nconst long Size2 = 100 * Size1;\r\nconst long Size3 = 100 * Size2;\r\nbool f3(int x)\r\n{\r\n	return x % 3 == 0;\r\n}\r\n\r\nbool f13(int x)\r\n{\r\n	return x % 13 == 0;\r\n}\r\nint main()\r\n{\r\n	using namespace std;\r\n	vector<int>numbers(Size1);\r\n	srand(time(0));\r\n	generate(numbers.begin(), numbers.end(), rand);\r\n	//generate()函数将容器中每个值都赋值为第三个参数的返回值\r\n	int count3 = count_if(numbers.begin(), numbers.end(), f3);\r\n	cout << count3 << endl;\r\n	int count13 = count_if(numbers.begin(), numbers.end(), f13);\r\n	cout << count13 << endl;\r\n	cout << endl;\r\n\r\n	numbers.resize(Size2);\r\n	generate(numbers.begin(), numbers.end(), rand);\r\n\r\n	class f_mod   //写一个函数对象\r\n	{\r\n	private:\r\n		int dv;\r\n	public:\r\n		f_mod(int d = 1) :dv(d)\r\n		{\r\n\r\n		}\r\n		bool operator()(int x)\r\n		{\r\n			return x % dv == 0;\r\n		}\r\n	};\r\n	f_mod obj(3); //obj.operator()\r\n	count3 = count_if(numbers.begin(), numbers.end(), obj);\r\n	cout << count3 << endl;\r\n	count13 = count_if(numbers.begin(), numbers.end(), f_mod(13));  //查看count_if可以查看operator()的使用\r\n	cout << count13 << endl;\r\n	cout << endl;\r\n\r\n	numbers.resize(Size3);\r\n	generate(numbers.begin(), numbers.end(), rand);\r\n\r\n\r\n	//lambda表达式\r\n	//lambda表达式是一个匿名函数，[]代替了函数名 （）内存放形参，返回类型自动推断\r\n	count3 = count_if(numbers.begin(), numbers.end(), [](int x)->bool { return x % 3 == 0; });  //也可以显示指出返回类型\r\n	cout << count3 << endl;\r\n\r\n	count13 = count_if(numbers.begin(), numbers.end(), [](int x) {return x % 13 == 0; });\r\n	cout << count13 << endl;\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (169, 'C++ lambda表达式（2）', 1, '##lambda表达式(2)\r\n```\r\n#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<cmath>\r\n#include<ctime>\r\n\r\nusing namespace std;\r\n\r\nconst long Size = 390000L;\r\n\r\nint main()\r\n{\r\n	vector<int>numbers(Size);\r\n	srand(time(nullptr));\r\n	generate(numbers.begin(), numbers.end(), rand);\r\n	int count3 = count_if(numbers.begin(), numbers.end(), [](int x) {return x % 3 == 0; });\r\n	cout << count3 << endl;\r\n	cout << endl;\r\n\r\n	int count13 = 0;\r\n	for_each(numbers.begin(), numbers.end(), [&count13](int x) {count13 += x % 13 == 0; });\r\n	cout << count13 << endl;\r\n	cout << endl;\r\n\r\n	count3 = count13 = 0;\r\n	for_each(numbers.begin(), numbers.end(),[&](int x) {count3 = count3 +(int) (x % 3 == 0); count13 = count13 +(int)( x % 13 == 0); });\r\n	cout << count3 << endl;\r\n	cout << count13 << endl;\r\n\r\n\r\n	//lambda可以访问作用域内任何变量\r\n	//[&]  让表达式可以按引用访问所有动态变量\r\n	//[=]  让表达式可以按值访问所有动态变量\r\n\r\n	//但是lambda表达式一般是用来代替函数符的\r\n \r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (170, 'C++ function包装器', 1, '##function包装器\r\n```\r\n#include<iostream>\r\n#include<functional>\r\nusing namespace std;\r\ntemplate<class T, class F>\r\n//template<class T>\r\n//T use_f(T v,function<T(T)>f)\r\n//cout<<use_f<double>(y,dub)<<endl;\r\nT use_f(T v, F f)\r\n{\r\n	static int count = 0;\r\n	count++;\r\n	cout << &count << endl;\r\n	return f(v);\r\n}\r\n\r\nclass Fp\r\n{\r\nprivate:\r\n	double z_;\r\npublic:\r\n	Fp(double z = 1.0) :z_(z)\r\n	{\r\n\r\n	}\r\n	double operator()(double p)\r\n	{\r\n		return z_ * p;\r\n	}\r\n};\r\n\r\nclass Fq\r\n{\r\nprivate:\r\n	double z_;\r\npublic:\r\n	Fq(double z = 1.0) :z_(z)\r\n	{\r\n\r\n	}\r\n	double operator()(double q)\r\n	{\r\n		return z_ + q;\r\n	}\r\n};\r\ndouble dub(double x)\r\n{\r\n	return 2.0*x;\r\n}\r\ndouble square(double x)\r\n{\r\n	return x * x;\r\n}\r\nint main()\r\n{\r\n	double y = 1.21;\r\n	function<double(double)>ef1 = dub;\r\n	function<double(double)>ef2 = square;\r\n	function<double(double)>ef3 = Fq(10.0);\r\n	function<double(double)>ef4 = Fp(10.0);\r\n	function<double(double)>ef5 = [](double u) {return u * u; };\r\n	function<double(double)>ef6 = [](double u) {return u + u / 2.0; };\r\n\r\n	typedef function<double(double)> fdd;\r\n	//用function提取多次实例化中相同的特征标，进行包装创建一个对象\r\n\r\n	cout << use_f(y, fdd(dub)) << endl;\r\n	cout << use_f(y, fdd(square)) << endl;\r\n	cout << use_f(y, ef3) << endl;\r\n	cout << use_f(y, ef4) << endl;\r\n	cout << use_f(y, ef5) << endl;\r\n	cout << use_f(y, ef6) << endl;\r\n\r\n\r\n	//这样use_f只被实例化一次\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (171, 'C++ 可变参数模板', 1, '##可变参数模板(递归方式展开模板参数包)\r\n```\r\n#include<iostream>\r\n#include<string>\r\nvoid show_list()\r\n{\r\n	//空函数\r\n}\r\ntemplate<class T>\r\nvoid show_list(const T& value)   //在前面再添加一个函数模板，当模板参数包递减到只有一个的时候将调用此函数，因为此函数不是递归函数，所以，递归函数将在此停止，不再走上面的空函数。\r\n{\r\n	std::cout << value << \'\\n\';\r\n}\r\n\r\ntemplate<class T,class...Args>   //第一个参数模板为参数包展开的第一个模板参数，第二个参数为参数包类型（class...type）\r\nvoid show_list( T value,Args... args) //包含一个模板参数包，递归方式展开模板参数包\r\n{\r\n	std::cout << value << \",\";\r\n	show_list(args...);   //模板参数包，一次只使用一个模板参数，进行递归，直到模板中没有参数\r\n}\r\n\r\nint main()\r\n{\r\n	int n = 14;\r\n	double x = 2.71828;\r\n	std::string mr = \"Mr.String objects!\";\r\n	show_list(n, x);\r\n	//show_list(x*x, \'!\', 7, mr);\r\n\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (172, 'C++ 类成员解除运算符', 1, '##类成员解除运算符\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nclass Example\r\n{\r\nprivate:\r\n	int feet;\r\n	int inches;\r\npublic:\r\n	Example();\r\n	Example(int ft);\r\n	~Example();\r\n	void show_in()const;\r\n	void show_ft()const;\r\n	void use_ptr()const;\r\n};\r\nExample::Example()\r\n{\r\n	feet = 0;\r\n	inches = 0;\r\n}\r\nExample::Example(int ft)\r\n{\r\n	feet = ft;\r\n	inches = 12 * feet;\r\n}\r\nExample::~Example()\r\n{\r\n\r\n}\r\nvoid Example::show_in()const\r\n{\r\n	cout << inches << \"inches\\n\";\r\n}\r\n\r\nvoid Example::show_ft()const\r\n{\r\n	cout << feet << \" feet\\n\";\r\n}\r\nvoid Example::use_ptr()const\r\n{\r\n	Example yard(3);\r\n	int Example::*pt;\r\n	pt = &Example::inches;  //指针指向类成员 inches\r\n	cout << \"Set pt to &Example::inches:\\n\";\r\n	cout << \"this->pt: \" << this->*pt << endl;  //inches;\r\n	cout << \"yard.*pt: \" << yard.*pt << endl;\r\n	pt = &Example::feet;  //指针指向类成员 feet\r\n	cout << \"Set pt to &Example::feet:\\n\";\r\n	cout << \"this->pt:\" << this->*pt << endl;\r\n	cout << \"yard.*pt:\" << yard.*pt << endl;\r\n	void (Example::*pf)()const;  \r\n	pf = &Example::show_in;   //指针指向类成员函数show_in\r\n	cout << \"Set pf to &Example::show_in:\\n\";\r\n	cout << \"Using(this->*pf)(): \";\r\n	(this->*pf)();\r\n	cout << \"Using(yard.*pf)(): \";\r\n	(yard.*pf)();\r\n}\r\nint main()\r\n{\r\n	Example car(15);\r\n	Example van(20);\r\n	Example garage;\r\n\r\n	cout << \"car.use_ptr()output：\\n\";\r\n	car.use_ptr();\r\n	cout << \"\\nvan.use_ptr()output: \\n\";\r\n	van.use_ptr();\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (173, 'C++ alignof运算符', 1, '##alignof运算符	\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nstruct things1\r\n{\r\n	double x;\r\n	char ch;\r\n	int a;\r\n	\r\n};\r\nstruct things2 \r\n{\r\n	int a;\r\n	double x;\r\n	char ch;\r\n};\r\nint main()\r\n{\r\n	things1 th1;\r\n	things2 th2;\r\n	cout << \"char aligment: \" << alignof(char) << endl;  //1的倍数\r\n	cout << \"int aligment:\" << alignof(int) << endl;     //4的倍数\r\n	cout << \"things1 alignment: \" << alignof(things1) << endl; //8的倍数\r\n	cout << \"things2 alignment: \" << alignof(things2) << endl;\r\n	cout << sizeof(things1) << endl;\r\n	cout << sizeof(things2) << endl;\r\n	//计算机系统可能限制数据在内存中的存储方式，例如，一个系统可能要求double值存储在编号为偶数的内存单元中，\r\n	//而另一个系统可能要求起始地址为8个整数倍。运算符alignof将类型作为参数，并返回一个整数，指出要求对齐的方式。\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (174, 'C++ 单向链表', 1, '##单向链表\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n	int info;\r\n	Node * next;\r\n	Node()\r\n	{\r\n\r\n	}\r\n	Node(int i)\r\n	{\r\n		info = i;\r\n		next = nullptr;\r\n	}\r\n	Node(int i, Node * n)\r\n	{\r\n		info = i;\r\n		next = n;\r\n	}\r\n};\r\n\r\nclass LinkList\r\n{\r\nprivate:\r\n	Node * head;\r\n	Node * tail;\r\npublic:\r\n	LinkList()\r\n	{\r\n		head = tail  = nullptr;\r\n	}\r\n\r\n	//头添加\r\n	void insertFromHead(const int info)\r\n	{\r\n		if (head == nullptr)\r\n		{\r\n			Node * temp = new Node(info);\r\n			head = temp;   //head指针指向temp节点\r\n			tail = head;\r\n		}\r\n		else\r\n		{\r\n			Node * temp = new Node(info);\r\n			temp->next = head;\r\n			head = temp;\r\n		}\r\n	}\r\n	//尾添加\r\n	void insertFromTail(const int info)\r\n	{\r\n		if (tail == nullptr)\r\n		{\r\n			Node * temp = new Node(info);\r\n			tail = temp;\r\n			head = tail;\r\n		}\r\n		else\r\n		{\r\n			Node * temp = new Node(info);\r\n			tail->next = temp;\r\n			tail = temp;\r\n		}\r\n                                                                       \r\n	}\r\n	//随机插入\r\n	void insertFromRandom(int pos,const int info)\r\n	{\r\n		int count = 0;\r\n		if (pos == 0)\r\n		{\r\n			Node * temp = new Node(info);\r\n			temp->next = head;\r\n			head = temp;\r\n		}\r\n		else if(pos == 1)\r\n		{\r\n			Node * temp = new Node(info);\r\n			Node * h = head->next;\r\n\r\n			head->next = temp;\r\n			temp->next = h;\r\n				\r\n		}\r\n		else\r\n		{\r\n			Node * temp = new Node(info);\r\n			Node * h = head;\r\n			while (1)\r\n			{\r\n				if(count==(pos-1))\r\n					break;\r\n				h = h->next;\r\n				count = count + 1;	\r\n			}\r\n			Node * h1 = h->next;\r\n			h->next = temp;\r\n			temp->next = h1;\r\n		}\r\n	}\r\n\r\n	void deleteFromHead()   //头删除\r\n	{\r\n		if (head == tail)\r\n		{\r\n			delete head;\r\n			head = tail = nullptr;\r\n		}\r\n		else\r\n		{\r\n			Node * h = head->next;\r\n			delete head;\r\n			head = h;\r\n		}\r\n\r\n	}\r\n\r\n	void deleteFromTail() //尾删除\r\n	{\r\n		if (head == tail)\r\n		{\r\n			delete tail;\r\n			head = tail = nullptr;\r\n		}\r\n		else\r\n		{\r\n			Node * h = head;\r\n			int count = 0;\r\n			while (h != tail)\r\n			{\r\n				h = h->next;\r\n				count++;\r\n			}\r\n			h = head;\r\n			for (int i = 0; i < count - 1; i++)\r\n			{\r\n				h = h->next;\r\n			}\r\n			delete tail;\r\n			tail = h;\r\n			tail->next = nullptr;   //注意这里要对next进行赋值，防止野指针；\r\n		}\r\n	}\r\n\r\n	void deleteFromRandom(int pos) //随机删除\r\n	{\r\n		if (head == tail)\r\n		{\r\n			delete head;\r\n			head = tail = nullptr;\r\n		}\r\n		else\r\n		{\r\n\r\n			if (pos == 0)\r\n			{\r\n				Node * h = head->next;\r\n				delete head;\r\n				head = h;\r\n			}\r\n			else\r\n			{\r\n				Node * h = head;\r\n				for (int i = 0; i < pos; i++)\r\n				{\r\n					h = h->next;    //找到指定位置\r\n				}\r\n				Node * hh = h->next;  //指定位置的后一个位置\r\n				Node * bh = head;\r\n\r\n				for (int i = 0; i < pos - 1; i++)\r\n				{\r\n					bh = h->next;     //找到指定位置的前一个位置\r\n				}\r\n\r\n				delete h;\r\n				bh->next = hh;\r\n			}\r\n		}\r\n\r\n	}\r\n	//遍历链表\r\n	void display()\r\n	{\r\n		while (head != nullptr)\r\n		{\r\n			cout << head->info << \",\";\r\n			head = head->next;\r\n		}\r\n	}\r\n\r\n};\r\nint main()\r\n{\r\n\r\n	LinkList link;\r\n\r\n	link.insertFromHead(0);\r\n	link.insertFromHead(1);\r\n	link.insertFromHead(2);\r\n	link.insertFromHead(3);\r\n	link.insertFromHead(4);\r\n\r\n	link.deleteFromRandom(1);\r\n	link.display();\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (175, 'C++ 双向链表', 1, '##双向链表\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass DLLNode\r\n{\r\npublic:\r\n	T info;\r\n	DLLNode * next;\r\n	DLLNode * prev;\r\n	DLLNode()\r\n	{\r\n		next = prev = nullptr;\r\n	}\r\n	DLLNode(T &t)\r\n	{\r\n		prev = nullptr;\r\n		next = nullptr;\r\n		info = t;\r\n	}\r\n	DLLNode(const T & el, DLLNode * n = nullptr, DLLNode * p = nullptr)\r\n	{\r\n		info = el;\r\n		next = n;\r\n		prev = p;\r\n	}\r\n};\r\n\r\ntemplate<class T>\r\nclass DoubleLinkList\r\n{\r\nprotected:\r\n	DLLNode<T> * head;\r\n	DLLNode<T> * tail;\r\n\r\npublic:\r\n	DoubleLinkList()\r\n	{\r\n		head = tail = 0;\r\n	}\r\n	void addToHead(const T& t);\r\n	void deleteFromTail();\r\n	void display();\r\n\r\n};\r\n\r\ntemplate<class T>\r\nvoid DoubleLinkList<T>::addToHead(const T&t)\r\n{\r\n	if ((head == nullptr)&&(tail==nullptr))\r\n	{\r\n		head = new DLLNode<T>(t);\r\n		tail = head;\r\n	}\r\n	else\r\n	{\r\n		DLLNode<T> * n1 = new DLLNode<T>(t);\r\n		n1->next = head;\r\n		head->prev = n1;\r\n		head = n1;\r\n	}\r\n}\r\n\r\ntemplate<class T>\r\nvoid DoubleLinkList<T>::deleteFromTail()\r\n{\r\n	if (head == tail)\r\n	{\r\n		if (head == nullptr)\r\n			head = tail = nullptr;\r\n		else\r\n		{\r\n			delete head;\r\n			head = tail = nullptr;\r\n		}\r\n	}\r\n	//空指针可以被释放，所以这里可以这么写\r\n	//if (head == tail)\r\n	//{\r\n	//	delete head;\r\n	//	head = tail = nullptr;\r\n	//}\r\n	else\r\n	{\r\n		DLLNode<T> * n1 = tail->prev;\r\n		delete tail;\r\n		n1->next = nullptr;\r\n		tail = n1;\r\n	}\r\n}\r\ntemplate<class T>\r\nvoid DoubleLinkList<T>::display()\r\n{\r\n	while (head!=nullptr)\r\n	{\r\n		cout << head->info << \",\";\r\n		head = head->next;\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	DoubleLinkList<int> li;\r\n	li.addToHead(1);\r\n	li.addToHead(2);\r\n	li.addToHead(3);\r\n	li.deleteFromTail();\r\n\r\n	li.display();\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n\r\n```', 0);
INSERT INTO `blog_course` VALUES (176, 'C++ 跳跃链表', 1, '##跳跃链表\r\n```\r\n#include<iostream>\r\n#include<ctime>       //time\r\n#include<climits>    //INT_MIN\r\n#include<cstdlib>   //rand\r\n\r\nusing namespace std;\r\nstruct Node\r\n{\r\n	int value;\r\n	Node * up;\r\n	Node * down;\r\n	Node * left;\r\n	Node * right;\r\n\r\n\r\n	Node(int val = INT_MIN) :value(val), up(nullptr), down(nullptr), left(nullptr), right(nullptr)\r\n	{\r\n		//对结构体进行默认设置\r\n	}\r\n};\r\nclass SkipList_Int\r\n{\r\nprivate:\r\n	Node * head;   //头节点\r\n	int lvl_num;   //当前链表的层数\r\n\r\n	bool randomVal();    //随机判断\r\n\r\npublic:\r\n	SkipList_Int() :lvl_num(1)   //初始化为1层\r\n	{\r\n		head = new Node();\r\n	}\r\n\r\n	void insert(int val); //插入元素\r\n\r\n	bool search(int val); //查询元素\r\n\r\n	void remove(int val); //删除元素\r\n};\r\n\r\nbool SkipList_Int::randomVal()\r\n{\r\n	srand(time(nullptr));  //用时间作为随机种子\r\n	if (rand() % 2 == 1)\r\n		return true;\r\n	return false;\r\n}\r\n\r\n\r\n//插入节点\r\n\r\nvoid SkipList_Int::insert(int val)\r\n{\r\n	//第一层插入\r\n	Node * cursor = head;    //将光标移到头节点\r\n	Node * new_node = nullptr;  //记录第一层插入的节点\r\n	while (cursor->down != nullptr)\r\n	{\r\n		cursor = cursor->down;  //将光标移到第一层的头节点\r\n	}\r\n\r\n	Node * cur_head = cursor;  //记录第一层的头节点\r\n\r\n	//开始插入节点。考虑一开始就存在节点的的情况\r\n	while (cursor->right != nullptr)  //插入元素，每一层的元素都是升序的\r\n	{\r\n		if (cursor->right->value > val&& new_node==nullptr)    //如果val小于值，那么将节点插入在此\r\n		{\r\n			new_node = new Node(val);  //对之前的节点进行赋值\r\n			Node * temp = cursor->right;\r\n			new_node->right = temp;  //插入的节点指向光标的下一个节点\r\n			temp->right = new_node;      //光标的下一个节点指向新节点\r\n		}\r\n		cursor = cursor->right;\r\n	}\r\n\r\n	//考虑到新节点大于所有以存在节点，或者没有节点时\r\n	if (new_node == nullptr)\r\n	{\r\n		new_node = new Node(val);\r\n		cursor->right = new_node;\r\n	}\r\n\r\n\r\n	//非第一层\r\n	int cur_lvl = 1;  //记录插入时当前所执行的层数\r\n	while (randomVal())    //第二层随机插入，二分之一概率插入\r\n	{\r\n		cur_lvl++;    //进入下一层，考虑链表是否存在下一层\r\n		if (lvl_num < cur_lvl)   //考虑是否需要新增加一层\r\n		{\r\n			lvl_num++;\r\n			Node * new_head = new Node();   //创建此层的头节点\r\n			new_head->down = head;          //此层的头节点指向第下层的头节点\r\n			head->up = new_head;            //下一层的头节点指向此层的头节点\r\n			head = new_head;                //将整个链表的头节点移到到此层\r\n		}\r\n\r\n		//开始插入节点，//考虑之前就存在节点的情况\r\n\r\n		cur_head = cur_head->up;  //将记录层数的节点上上移一层（注意：这里不一定是第二层）\r\n		cursor = cur_head;        //将光标移动到此层的头节点\r\n\r\n		Node * skip_node = nullptr;     //预插入节点\r\n\r\n		while (cursor->right != nullptr && skip_node==nullptr)  //此插入节点\r\n		{\r\n			if (cursor->right->value > val)\r\n			{\r\n				skip_node = new Node(val);\r\n				Node * temp = cursor->right;\r\n				cursor->right = skip_node;\r\n				skip_node->right = temp;\r\n			}\r\n			cursor = cursor->right;\r\n		}\r\n\r\n		//考虑第次没有比插入节点大的节点，或者是第二层本来为空\r\n		if (skip_node == nullptr)\r\n		{\r\n			skip_node = new Node(val);\r\n			cursor->right = skip_node;\r\n		}\r\n\r\n		//将两个节点进行连接\r\n		while (new_node->up != nullptr)  //将记录底层新节点的位置记录为最高层的节点；这样才能让相邻两层的节点进行连接\r\n		{\r\n			new_node = new_node->up;\r\n		}\r\n\r\n		skip_node->down = new_node;\r\n		new_node->up = skip_node;\r\n	}\r\n}\r\n\r\n//查找方法\r\nbool SkipList_Int::search(int val)\r\n{\r\n	\r\n	if (head == nullptr)  //考虑到链表为空的时候\r\n		return false;\r\n\r\n	Node * cursor = head;\r\n	cursor = head;\r\n	while (cursor->down != nullptr)  //从顶层向下依次查找\r\n	{\r\n		while (cursor->right != nullptr)  //从顶层循环寻找此层的元素\r\n		{\r\n			if (cursor->right->value >= val)  //当找到元素或者第一个目标元素大的元素的时候；跳出此循环，进入下一层\r\n				break;\r\n			cursor = cursor->right;\r\n		}\r\n		cursor = cursor->down;	\r\n	}\r\n\r\n	//当到达最低层的时候\r\n	while (cursor->right != nullptr)\r\n	{\r\n		if (cursor->right->value > val)\r\n			cursor = cursor->right;\r\n		else if (cursor->right->value == val)\r\n			return true;\r\n		else\r\n			return false;\r\n	}\r\n	return false;//如果程序执行到这里说明没有找到元素，则返回false\r\n}\r\n\r\n//删除方法\r\n\r\nvoid SkipList_Int::remove(int val)\r\n{\r\n	//由于每次插入时，链表的头节点都被移到最高一层，所以此时初始化光标时，此时光标在跳表的最上层\r\n	Node * cursor = head; //初始化光标\r\n	Node * pre_head = nullptr;   //上一行的头指针，删除行的时候使用\r\n\r\n	while (true)  //删除元素，即每一层的此元素都将被删除释放\r\n	{\r\n		Node * cur_head = cursor;  //记录当前行的头指针，因为经过遍历后光标会进行后移\r\n\r\n		//如果上一层没有元素了\r\n		if (pre_head != nullptr)   //如果pre_head不为空，说明上一行已经没有元素\r\n		{\r\n			cur_head->up = nullptr;     //此层头节点的上指针为空\r\n			pre_head->down = nullptr;   //解除上级的指针\r\n			delete pre_head;\r\n			pre_head = nullptr;         //再次将pre_head置为空指针\r\n			lvl_num--;                  //链表层数减一\r\n			head = cur_head;            //链表头指针下移，移到此层。\r\n		}\r\n\r\n\r\n		//在当前行进行查找删除\r\n		while (cursor != nullptr&&cursor->right != nullptr) //在当前行查找val\r\n		{\r\n			if (val == cursor->right->value)\r\n			{\r\n				Node * delptr = cursor->right;   //找到此层要释放的节点\r\n				cursor->right = cursor->right->right;  //删除节点后，光标指向下下个节点\r\n				delete delptr;   \r\n			}\r\n			cursor = cursor->right;\r\n		}\r\n\r\n		//考虑到释放掉此节点后，此行是否还有元素\r\n		if (cur_head->right == nullptr)  //判断当前行是否还存在其他元素，如果不存在则删除该行并将整个链表降维\r\n		{\r\n			pre_head = cur_head;  \r\n		}\r\n\r\n		//判断是否到达最底层\r\n		if (cur_head->down == nullptr)    //如果下一行为空，说明此行为跳表的最底层，则删除完毕。\r\n			break;\r\n		else\r\n			cursor = cur_head->down;       //如果下一行不为空，则将光标移动到下一行的头节点，循环再次删除同一元素的节点\r\n	}\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (177, 'C++ 栈--向量实现', 1, '##栈--向量实现\r\n```\r\n#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\ntemplate <class T,int capacity = 30>\r\nclass Stack\r\n{\r\nprivate:\r\n	vector<T> pool;    //设置一个动态数组\r\npublic:\r\n	Stack()\r\n	{\r\n		pool.reserve(capacity);   //为数组重新分配容量\r\n	}\r\n	void clear()\r\n	{\r\n		pool.clear();    //清楚栈\r\n	}\r\n	bool isEmpty()const\r\n	{\r\n		return pool.empty();  //判断栈内是否为空\r\n	}\r\n	T& topEL()    //读取栈中的第一个元素（满足先进后出）\r\n	{\r\n		return pool.back();   //返回数组的最后一个元素\r\n	}\r\n	T pop()                          \r\n	{\r\n		T el = pool.back();   //返回数组的最后一个元素（栈的第一个元素）\r\n		pool.pop_back();       //删除数组的最后一个元素（栈的第一个元素）：弹栈\r\n		return el;             //将删除的元素作为返回值\r\n	}\r\n	void push(const T &el)    //压栈（向栈中添加元素）\r\n	{\r\n		pool.push_back(el);   //数组尾添加\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	Stack<int> s;\r\n	s.push(2);\r\n	s.push(3);\r\n\r\n	cout << s.topEL() <<endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (178, 'C++ 栈--链表实现', 1, '##栈--链表实现\r\n```\r\n#include<iostream>\r\n#include<list>\r\n\r\ntemplate<class T>\r\nclass LStack\r\n{\r\nprivate:\r\n	list<T>li;\r\n\r\n	LStack()\r\n	{\r\n\r\n	}\r\n	void clear()\r\n	{\r\n		li.clear();\r\n	}\r\n	bool isEmpty()const\r\n	{\r\n		return li.empty();\r\n	}\r\n	T & topEL()\r\n	{\r\n		return li.back();\r\n	}\r\n	T pop()\r\n	{\r\n		T el = li.back();\r\n		li.pop_back();\r\n		return el;\r\n	}\r\n	void push(const T &el)\r\n	{\r\n		li.push_back(el);\r\n	}\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (179, 'C++ 队列--数组实现', 1, '##队列--数组实现\r\n```\r\n#include<iostream>\r\n\r\ntemplate<class T, int size = 100>\r\nclass ArrayQueue\r\n{\r\nprivate:\r\n	int first;\r\n	int last;\r\n	T storage[size];\r\npublic:\r\n	ArrayQueue()\r\n	{\r\n		first = last = 1;\r\n	}\r\n	void enqueue(T);    //在队列尾添加元素\r\n	T dequeue();        //删除队首元素\r\n	bool isFull()\r\n	{\r\n		return first == 0 && last == size - 1 || first == last + 1;\r\n	}\r\n	bool isEmpty()\r\n	{\r\n		return first == -1;\r\n	}\r\n};\r\ntemplate <class T, int size>\r\nvoid ArrayQueue<T, size>::enqueue(T el)\r\n{\r\n	if (!isFull())\r\n	{\r\n		if (last == size - 1 || last == -1)\r\n		{\r\n			storage[0] = el;\r\n			last = 0;\r\n			if (first == -1)\r\n				first = 0;\r\n		}\r\n\r\n		else storage[++last] = el;\r\n	}\r\n	else std::cout << \"Full queue.\\n\";\r\n}\r\n\r\ntemplate <class T, int size>\r\nT ArrayQueue<T, size>::dequeue()\r\n{\r\n	T tmp;\r\n	tmp = storage[first];\r\n	if (first == last)\r\n		last = first = -1;\r\n	else if (first == size - 1)\r\n		first = 0;\r\n	else\r\n		first++;\r\n	return tmp;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (180, 'C++ 队列--链表实现', 1, '##队列--链表实现\r\n```\r\n#include<iostream>\r\nusing namespace std;\r\n\r\ntemplate <class T>\r\nclass Queue\r\n{\r\nprivate:\r\n	list<T>lst;\r\npublic:\r\n	Queue()\r\n	{\r\n\r\n	}\r\n	void clear()   //清除队列\r\n	{\r\n		lst.clear();\r\n	}\r\n	bool isEmpty()const\r\n	{\r\n		return lst.empty();\r\n	}\r\n	T & front()\r\n	{\r\n		return lst.front();   //返回队首元素\r\n	}\r\n	T dequeue()    //删除队首元素\r\n	{\r\n		T el = lst.front();\r\n		lst.pop_front();\r\n		return el;\r\n	}\r\n	void enqueue(const T& el)   //删除队尾元素\r\n	{\r\n		lst.push_back(el);\r\n	}\r\n};\r\n```', 0);
INSERT INTO `blog_course` VALUES (181, 'C++ STL中的优先队列', 1, '##STL中的优先队列\r\n```\r\n#include<iostream>\r\n#include<queue>\r\n#include<functional>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	priority_queue<int> pq1;  //三个模板参数，其他两个默认为  vector<int>  less<int>  //默认为降序\r\n\r\n	priority_queue<int, vector<int>, greater<int>> pq2;\r\n\r\n	pq1.push(3);\r\n	pq1.push(1);\r\n	pq1.push(2);\r\n\r\n	pq2.push(3);\r\n	pq2.push(1);\r\n	pq2.push(2);\r\n\r\n	int a[] = { 4,6,5 };\r\n	priority_queue<int> pq3(a, a + 3); //使用数组的第一个元素到最后一个元素对 pq3进行初始化\r\n	while (!pq1.empty())\r\n	{\r\n		cout << pq1.top() << \' \';   //返回优先队列中优先级的最高元素\r\n		pq1.pop();         //删除队列优先级最高的元素\r\n	}\r\n	while (!pq2.empty())\r\n	{\r\n		cout << pq2.top() << \' \';\r\n		pq2.pop();\r\n	}\r\n	while (!pq3.empty())\r\n	{\r\n		cout << pq3.top() << \' \';\r\n		pq3.pop();\r\n	}\r\n\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (182, 'C++ 二叉树', 1, '##二叉树\r\n```\r\n#include<iostream>\r\n#include<queue>   //队列\r\n#include<stack>   //栈\r\n#include<vector>\r\nusing namespace std;\r\n\r\ntemplate <class T>\r\nclass Stack :public stack<T>   //栈\r\n{\r\npublic:\r\n	T deStack()   //弹栈\r\n	{\r\n		T temp = stack<T>::top();   //这里将对返回的元素重新分配空间\r\n		stack<T>::pop();  //弹出栈顶元素\r\n		return temp;\r\n	}\r\n	void enStack(const T & el)//压栈\r\n	{\r\n		push(el);\r\n	}\r\n};\r\n\r\ntemplate<class T>     //队列\r\nclass Queue :public queue<T>\r\n{\r\npublic :\r\n	T dequeue()\r\n	{\r\n		T tmp = queue<T>::front();\r\n		queue<T>::pop(); //删除第一个元素\r\n		return tmp;      //将删除的元素值返回,这里一定要返回节点\r\n	}\r\n	void enqueue(const T & el)\r\n	{\r\n		push(el);        //在队尾添加一个元素\r\n	}\r\n};\r\n\r\ntemplate<class T>   //节点类\r\nclass BSTNode\r\n{\r\npublic :\r\n	T el;                  //数据域\r\n	BSTNode<T> * left;     //左节点\r\n	BSTNode<T> * right;    //右节点\r\n\r\n	BSTNode()\r\n	{\r\n		left = right = nullptr;\r\n	}\r\n\r\n	BSTNode(const T & e, BSTNode<T> * l = nullptr, BSTNode<T> * r = nullptr)  //有参构造\r\n	{\r\n		el = e;\r\n		left = l;\r\n		right = r;\r\n	}\r\n};\r\n\r\ntemplate <class T>   //二叉树类\r\nclass BST\r\n{\r\nprotected:\r\n	BSTNode<T> * root;   //根节点\r\n\r\n	T * search(BSTNode<T> * ,const T &)const;\r\n	void preorder(BSTNode<T> *);\r\n	void inorder(BSTNode<T> *);\r\n	void postorder(BSTNode<T> *);\r\n	virtual void visit(BSTNode<T> * p)\r\n	{\r\n		cout << p->el << \' \';\r\n	}\r\n\r\npublic:\r\n	BST()\r\n	{\r\n		root = 0;\r\n	}\r\n	~BST()\r\n	{\r\n		clear();\r\n	}\r\n\r\n	void clear()\r\n	{\r\n		clear(root);\r\n		root = nullptr;\r\n	}\r\n\r\n	bool isEmpty()const\r\n	{\r\n		return root == 0;  //如果为真 则返回true\r\n	}\r\n\r\n	void preorder()\r\n	{\r\n		preorder(root);\r\n	}\r\n\r\n	void inorder()\r\n	{\r\n		inorder(root);\r\n	}\r\n	void postorder()\r\n	{\r\n		postorder(root);\r\n	}\r\n\r\n	T * search(const T & el)const\r\n	{\r\n		return search(root, el);\r\n	}\r\n\r\n	void breathFirst();\r\n	void iterativePreorder();\r\n	void iterativeInorder();\r\n	void iterativePostorder();\r\n	void MorrisInorder();\r\n	void insert(const T&);\r\n	void deleteByMerging(BSTNode<T> * &);\r\n	void finAndDeleteByMerging(const T &);\r\n	void deleteByCopying(BSTNode<T> * &);\r\n	void balance(T *, int, int);\r\n};\r\n\r\n//查找二叉树\r\ntemplate <class T>\r\nT * BST<T>::search(BSTNode<T> * p, const T &el)const \r\n{\r\n	while (p != nullptr)\r\n	{\r\n		if (el == p->el)\r\n			return &p->el;\r\n		else if (el < p->el)\r\n			p = p->left;\r\n		else\r\n			p = p->right;\r\n	}\r\n}\r\n//从上到下，从左到右的广度优先遍历实现\r\n//广度优先遍历：从最底层开始，向下逐层访问每个节点，每一层上，从左到右访问每一个节点。\r\n//树的遍历是将树线性化，每个节点只访问一次\r\ntemplate<class T>\r\nvoid BST<T> ::breathFirst()\r\n{\r\n	Queue<BSTNode<T> *>queue;   //创建一个队列\r\n	BSTNode<T> * p = root;\r\n	if (p != nullptr)\r\n	{\r\n		queue.enqueue(p);  //在队列尾部添加一个元素，即树的根节点\r\n		while (!queue.empty())  //队列为空结束循环\r\n		{\r\n			p = queue.dequeue();  //删除队首元素，并将队首元素返回给p指针\r\n			visit(p);             //输出队列的首元素\r\n			if (p->left != nullptr)   //先遍历左节点\r\n				queue.enqueue(p->left);\r\n			if (p->right != nullptr)\r\n				queue.enqueue(p->right);\r\n		}\r\n	}\r\n}\r\n\r\n//深度优先遍历\r\n\r\n//V：访问根节点\r\n//L：遍历左子树\r\n//R：遍历右子树\r\n\r\n\r\n//中序遍历LVR\r\n//左子树--节点--右子树\r\ntemplate<class T>\r\nvoid BST<T>::inorder(BSTNode<T> *P)\r\n{\r\n	if (P != nullptr)\r\n	{ \r\n		inorder(P->left);\r\n		visit(P);\r\n		inorder(P->right);\r\n	}\r\n}	\r\n\r\n//前序遍历VLR\r\n//节点--左子树--右子树\r\ntemplate<class T>\r\nvoid BST<T>::preorder(BSTNode<T> *p)\r\n{\r\n	if (p != nullptr)\r\n	{\r\n		visit(p);\r\n		preorder(p->left);\r\n		preorder(p->right);\r\n	}\r\n}\r\n\r\n//后序树遍历LRV\r\n//左子树--右子树--节点\r\ntemplate<class T>\r\nvoid BST<T>::postorder(BSTNode<T> *p)\r\n{\r\n	if (p!= nullptr)\r\n	{\r\n		postorder(p->left);\r\n		postorder(p->right);\r\n		visit(p);\r\n	}\r\n}\r\n\r\n//前序非递归遍历\r\ntemplate<class T>\r\nvoid BST<T>::iterativePreorder()\r\n{\r\n	Stack<BSTNode<T> *> travStack;   //使用栈对其进行遍历\r\n	BSTNode<T> * p = root;           //定义一个根节点\r\n	if (p != nullptr)\r\n	{\r\n		travStack.enStack(p);           //将根结点添加到栈顶\r\n		while (!travStack.empty())   //循环遍历，直到栈空\r\n		{\r\n			p = travStack.deStack();     //弹栈，再将节点元素返回给指针P；注意：此时p指向的是树的节点，并不是站内的，栈内此节点已经消失。而且弹栈并不是对其进行释放，而是将其拿出栈\r\n			visit(p);                //输出\r\n\r\n			//再次遍历根节点的左右子树\r\n			//先遍历左子树，再遍历右子树，但是由于是用栈来存储遍历，那么就应该先将右节点存储，再将左节点存储。（满足后进先出）\r\n\r\n			if (p->right != nullptr)\r\n				travStack.enStack(p->right);\r\n			if (p->left != nullptr)\r\n				travStack.enStack(p->left);\r\n		}\r\n	}\r\n}\r\n\r\n//前序非递归\r\n// template<class T>\r\n// void BST<T>::iterativePreorder(BSTNode<T> * root)\r\n// {\r\n// 	if (root == nullptr)\r\n// 		return result;\r\n// 	stack<BSTNode<T> *> s;  //栈中存储节点的指针\r\n// 	s.push(root);\r\n// 	while (!s.empty())  //栈不为空\r\n// 	{\r\n// 		BSTNode<T> * node = s.top();   //返回栈顶元素\r\n// 		s.pop(); //弹栈\r\n// 		visit(node);\r\n// 		result.push_back(node->el);  //将节点的值存储在向量中\r\n// 		if (node->right != nullptr)\r\n// 			s.push(node->right);\r\n// 		if (node->left != nullptr)\r\n// 			s.push(node->left);\r\n// 	}\r\n// }\r\n\r\n\r\n\r\n//后序树遍历的非递归实现\r\ntemplate<class T>\r\nvoid BST<T>::iterativePostorder()\r\n{\r\n\r\n	//注意：将元素放到容器内是再次申请空间，并将原有的元素复制一份到栈内，其内存地址是不同的\r\n	Stack<BSTNode<T> *> travStack;\r\n	BSTNode<T>* p = root;\r\n	BSTNode<T>* q = root;\r\n	while (p != nullptr)\r\n	{\r\n		for (p=root; p->left != nullptr; p = p->left)  //将左子树全都放入栈内\r\n			travStack.enStack(p);\r\n		while (p->right == nullptr||p->right == q)  //遍历栈的内容\r\n		{\r\n			visit(p);//输出p\r\n			q = p;\r\n 			//使用q记录节点被访问与否\r\n 			if (travStack.empty())\r\n 				return;\r\n 			p = travStack.deStack();   //弹栈，并将遍历的元素返回给P节点\r\n 			//此处P指针指向返回元素的地址，但是并不是原先栈内的地址；\r\n		}\r\n		travStack.deStack(p);\r\n		p = p->right;\r\n	}\r\n}\r\n\r\n//中序树遍历的非递归实现\r\ntemplate<class T>\r\nvoid BST<T>::iterativeInorder()\r\n{\r\n	Stack<BSTNode<T> *> travStack;\r\n	BSTNode<T> * p = root;\r\n	while (p != nullptr)\r\n	{\r\n		while (p != nullptr)\r\n		{\r\n			if (p->right)\r\n				travStack.deStack(p->right);\r\n			travStack.deStack(p);\r\n			p = p->left;\r\n		}\r\n		p = travStack.enStack();\r\n		while (!travStack.empty() && p->right == nullptr)\r\n		{\r\n			visit(p);\r\n			p = travStack.enStack();\r\n		}\r\n		visit(p);\r\n		if (!travStack.empty())\r\n			p = travStack.enStack();\r\n		else\r\n			p = nullptr;\r\n	}\r\n}\r\n\r\n//中序遍历的Morris算法实现\r\ntemplate<class T>\r\nvoid BST<T>::MorrisInorder()\r\n{\r\n	BSTNode<T> * p = root;\r\n	BSTNode<T> * temp;\r\n	while (p != nullptr)\r\n	{\r\n		if (p->left == nullptr)\r\n		{\r\n			visit(p);\r\n			p = p->right;\r\n		}\r\n		else\r\n		{\r\n			temp = p->left;\r\n			while (temp->right != nullptr&&temp->right != p)\r\n				temp = temp->right;\r\n			if (temp->right == nullptr)\r\n			{\r\n				temp->right = p;\r\n				p = p->left;\r\n			}\r\n			else\r\n			{\r\n				visit(p);\r\n				temp->right = nullptr;\r\n				p = p->right;\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\n//插入算法实现\r\ntemplate<class T>\r\nvoid BST<T>::insert(const T& el)\r\n{\r\n	BSTNode<T> * p = root;\r\n	BSTNode<T> * prev = nullptr;\r\n	while (p != nullptr)\r\n	{\r\n		prev = p;\r\n		if (el < p->el)\r\n			p = p->left;\r\n		else\r\n			p = p->right;\r\n	}\r\n	if (root == nullptr)\r\n		root = new BSTNode<T>(el);\r\n	else if (el < prev->el)\r\n		prev->left = new BSTNode<T>(el);\r\n	else\r\n		prev->right = new BSTNode<T>(el);\r\n}\r\n\r\n//合并删除算法实现\r\ntemplate <class T>\r\nvoid BST<T>::deleteByMerging(BSTNode<T> * & node)\r\n{\r\n	BSTNode<T> * temp = node;\r\n	if (!node != nullptr)\r\n	{\r\n		if (!node->right)\r\n			node = node->left;\r\n		else if (node->left == nullptr)\r\n			node = node->right;\r\n		else\r\n		{\r\n			temp = node->left;\r\n			while (temp->right != nullptr)\r\n				temp = temp->right;\r\n			temp->right = node->right;\r\n			temp = node;\r\n			node = node->left;\r\n		}\r\n		delete temp;\r\n	}\r\n}\r\n\r\ntemplate<class T>\r\nvoid BST<T>::finAndDeleteByMerging(const T & el)\r\n{\r\n	BSTNode<T> *node = root;\r\n	BSTNode<T> *prev = nullptr;\r\n	while (node != nullptr)\r\n	{\r\n		if(node->el == el)\r\n			break;\r\n		prev = node;\r\n		if (node->el < el)\r\n			node = node->right;\r\n		else\r\n			node = node->left;\r\n	}\r\n	if (node != nullptr&&node->el == el)\r\n	{\r\n		if (node == root)\r\n			deleteByMerging(root);\r\n		else if (prev->left == node)\r\n			deleteByMerging(prev->left);\r\n		else\r\n			deleteByMerging(prev->right);\r\n	}\r\n	else if (root != nullptr)\r\n		cout << \"值\" << el << \"不在树中\" << endl;\r\n	else\r\n		cout << \"此树是空的\" << endl;\r\n}\r\n\r\n//复制删除算法实现\r\ntemplate<class T>\r\nvoid BST<T>::deleteByCopying(BSTNode<T> * & node)\r\n{\r\n	BSTNode<T> * previous;\r\n	BSTNode<T> * temp = node;\r\n	if (node->right == nullptr)\r\n		node = node->left;\r\n	else if (node->left == nullptr)\r\n		node = node->right;\r\n	else\r\n	{\r\n		temp = node->left;\r\n		previous = node;++\r\n		while (temp->right != nullptr)\r\n		{\r\n			previous = temp;\r\n			temp = temp->right;\r\n		}\r\n		node->el = temp->el;\r\n		if (previous == node)\r\n			previous->left = temp->left;\r\n		else\r\n			previous->right = temp->left;\r\n	}\r\n	delete temp;\r\n}\r\n\r\n//树的平衡\r\ntemplate<class T>\r\nvoid BST<T>::balance(T *data, int first, int last)\r\n{\r\n	if (first <= last)\r\n	{\r\n		int middle = (first + last) / 2;\r\n		insert(data[middle]);\r\n		balance(data, first, middle - 1);\r\n		balance(data, middle + 1, last);\r\n	}\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (183, 'C++ （补）日期和时间', 1, '##日期和时间\r\n```\r\n#pragma warning(disable:4996)\r\n#include<iostream>\r\n#include<ctime>\r\nusing namespace std;\r\n//如果使用日期和时间相关的函数和结构，需要在C++程序中引用<ctime>头文件\r\n//有四个与时间相关的类型：\r\n//1.clock_t\r\n//2.time_t\r\n//3.size_t\r\n//4.tm\r\n//clock_t和size_t和time_t能把系统时间和日期表示为某种整数\r\n\r\n//结构类型tm把日期和时间以C结构的形式保存，\r\n//struct tm\r\n//{\r\n//	int tm_sec;   //秒，正常范围是0-59，单允许到61；\r\n//   	int tm_min;   //分，范围0-59；\r\n//	int tm_hour;  //小时，范围0-23；\r\n//	int tm_mday;  //一月中的第几天，范围1-31；\r\n//	int tm_mon;   //月，范围0-11\r\n//	int tm_year;  //年，1900-以后\r\n//	int tm_wday;  //一周中的第几天，范围0-6 （从星期日算起）\r\n//	int tm_yday;  //一年中的第几天，范围0-365（从1月1日算起）\r\n//	int tm_isdst; //夏令时；\r\n//};\r\n//C++中关于日期和时间的重要函数，这些函数都是C++标准库的组成部分，可以在C++标准库中查看\r\nint main()\r\n{\r\n	\r\n	time_t t1;\r\n    //函数原型 time_t time(time_t*time)//显示系统当前时间\r\n	cout << time(&t1) << endl;   \r\n\r\n	//函数原型  char*ctime(const time_t*time)//以字符串形式显示时间\r\n	cout << ctime(&t1) << endl;\r\n\r\n	//函数原型  clock_t clock(void)  //返回程序执行起的时间\r\n	cout << clock() << endl;\r\n\r\n	//函数原型  char*asctime(const struct tm*time)//返回time所指向结构中存储的信息\r\n	tm time;\r\n	time.tm_sec = 0;\r\n	time.tm_min = 50;\r\n	time.tm_hour = 12;\r\n	time.tm_mday = 25;\r\n	time.tm_mon = 2;\r\n	time.tm_year = 89;\r\n	time.tm_wday = 6;\r\n	cout << asctime(&time) << endl;\r\n\r\n	//函数原型 struct tm*gmtime(const time_t *time)//返回结构类型的指针\r\n	tm*p = gmtime(&t1);  //声明一个指针来接着这个地址\r\n	cout << p->tm_hour<< endl;\r\n	tm*p1 = localtime(&t1);\r\n	cout << p1->tm_hour << endl;\r\n\r\n	//函数原型 time_t mktime(struct tm*time)//返回日历时间，相当于time所指向结构中存储的时间\r\n	time_t t2 = mktime(&time);\r\n	cout << ctime(&t2) << endl;\r\n\r\n	//函数原型 double difftime(time_t time2,time_t time1)//返回time2和time1相差的秒数\r\n\r\n	//函数原型 size_t strftime(); //该函数可用于格式化日期和时间为指定的格式\r\n\r\n	//size_t strftime(char*str, size_t maxsize, const char*format, const struct tm*timeper);\r\n	char tmp[64];\r\n	strftime(tmp, sizeof(tmp), \"%Y-%m-%d\", p1);\r\n	cout << tmp << endl;\r\n\r\n	system(\"pause\");\r\n	return 0;\r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (184, 'C++ （补）随机数', 1, '##随机数\r\n```\r\n//随机生成器，有两个相关的函数，一个是rand(),该函数只返回一个伪随机数，生成随机数之前必须先调用srand()函数 \r\n#include<iostream>\r\n#include <ctime>\r\n#define random(x) (rand()%x)   //利用宏可以进行范围的取伪随机数\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int j;\r\n	int k;\r\n	srand(time(0));//设置种子\r\n	cout << time(0) << endl;//当前系统时间\r\n	for (int i = 0; i < 10; i++)\r\n	{\r\n		//生成实际的随机数\r\n		j = rand();\r\n	    cout << \"随机数：\" << j << endl;\r\n		//k = random(100);\r\n		//cout << k << endl;\r\n	}\r\n	system(\"pause\");\r\n	return 0; \r\n}\r\n```', 0);
INSERT INTO `blog_course` VALUES (185, 'Java 基础知识', 2, '[TOC]\r\n## 1. 面向对象和面向过程的区别\r\n\r\n### 面向过程\r\n\r\n**优点：** 性能比面向对象高。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发\r\n\r\n**缺点：** 没有面向对象易维护、易复用、易扩展\r\n\r\n### 面向对象\r\n\r\n**优点：** 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护\r\n\r\n**缺点：** 性能比面向过程低\r\n\r\n## 2. Java语言有哪些特点\r\n\r\n1. 简单易学；\r\n2. 面向对象（封装，继承，多态）；\r\n3. 平台无关性（ Java 虚拟机实现平台无关性）；\r\n4. 可靠性；\r\n5. 安全性；\r\n6. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；\r\n7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；\r\n8. 编译与解释并存；\r\n\r\n## 3. 关于JVM, JDK, JRE最详细通俗的解答\r\n\r\n### JVM\r\n\r\nJava虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。\r\n\r\n**什么是字节码?采用字节码的好处是什么?**\r\n\r\n> 在 Java 中，JVM可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。\r\n\r\n**Java 程序从源代码到运行一般有下面3步：**\r\n\r\n![Java程序运行过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png)\r\n\r\n我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。\r\n\r\n> HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。\r\n\r\n总结：Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM  实现是 Java 语言“一次编译，随处可以运行”的关键所在。 \r\n\r\n### JDK 和 JRE\r\n\r\nJDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。\r\n\r\nJRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。\r\n\r\n如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。\r\n\r\n## 4. Oracle JDK 和 OpenJDK 的对比\r\n\r\n可能在看这个问题之前很多人和我一样并没有接触和使用过  OpenJDK 。那么Oracle和OpenJDK之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。\r\n\r\n对于Java 7，没什么关键的地方。OpenJDK项目主要基于Sun捐赠的HotSpot源代码。此外，OpenJDK被选为Java 7的参考实现，由Oracle工程师维护。关于JVM，JDK，JRE和OpenJDK之间的区别，Oracle博客帖子在2012年有一个更详细的答案：\r\n\r\n> 问：OpenJDK存储库中的源代码与用于构建Oracle JDK的代码之间有什么区别？\r\n>\r\n> 答：非常接近 - 我们的Oracle JDK版本构建过程基于OpenJDK 7构建，只添加了几个部分，例如部署代码，其中包括Oracle的Java插件和Java WebStart的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源Oracle JDK的所有部分，除了我们考虑商业功能的部分。\r\n\r\n总结：\r\n\r\n1. Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；\r\n2. OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；\r\n3. Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；\r\n4. 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；\r\n5. Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；\r\n6. Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。\r\n\r\n## 5. Java和C++的区别?\r\n\r\n我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过C++，也要记下来！\r\n\r\n- 都是面向对象的语言，都支持封装、继承和多态\r\n- Java 不提供指针来直接访问内存，程序内存更加安全\r\n- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\r\n- Java 有自动内存管理机制，不需要程序员手动释放无用内存\r\n\r\n\r\n## 6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?\r\n\r\n一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。\r\n\r\n## 7. Java 应用程序与小程序之间有那些差别?\r\n\r\n简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。\r\n\r\n## 8. 字符型常量和字符串常量的区别?\r\n\r\n1. 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符\r\n2. 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)\r\n3. 占内存大小 字符常量只占2个字节; 字符串常量占若干个字节(至少一个字符结束标志) (**注意： char在Java中占两个字节**)\r\n\r\n> java编程思想第四版：2.2.2节\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg)\r\n\r\n## 9. 构造器 Constructor 是否可被 override?\r\n\r\n在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。\r\n\r\n## 10. 重载和重写的区别\r\n\r\n**重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　\r\n\r\n**重写：**   发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。\r\n\r\n## 11. Java 面向对象编程三大特性: 封装 继承 多态\r\n\r\n### 封装\r\n\r\n封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。\r\n\r\n\r\n### 继承\r\n继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。\r\n\r\n**关于继承如下 3 点请记住：**\r\n\r\n1. 子类拥有父类非 private 的属性和方法。\r\n2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\r\n3. 子类可以用自己的方式实现父类的方法。（以后介绍）。\r\n\r\n### 多态\r\n\r\n所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。\r\n\r\n在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。\r\n\r\n## 12. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?\r\n\r\n**可变性**\r\n　\r\n\r\n简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，`private　final　char　value[]`，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。\r\n\r\nStringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。\r\n\r\nAbstractStringBuilder.java\r\n\r\n```java\r\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\r\n    char[] value;\r\n    int count;\r\n    AbstractStringBuilder() {\r\n    }\r\n    AbstractStringBuilder(int capacity) {\r\n        value = new char[capacity];\r\n    }\r\n```\r\n\r\n\r\n**线程安全性**\r\n\r\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\r\n　　\r\n\r\n**性能**\r\n\r\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\r\n\r\n**对于三者使用的总结：** \r\n1. 操作少量的数据: 适用String\r\n2. 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder\r\n3. 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer\r\n\r\n## 13. 自动装箱与拆箱\r\n**装箱**：将基本类型用它们对应的引用类型包装起来；\r\n\r\n**拆箱**：将包装类型转换为基本数据类型；\r\n\r\n## 14. 在一个静态方法内调用一个非静态成员为什么是非法的?\r\n\r\n由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。\r\n\r\n## 15. 在 Java 中定义一个不做事且没有参数的构造方法的作用\r\n　Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。\r\n\r\n## 16. import java和javax有什么区别？\r\n\r\n刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。\r\n\r\n所以，实际上java和javax没有区别。这都是一个名字。\r\n\r\n## 17. 接口和抽象类的区别是什么？\r\n\r\n1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。\r\n2.  接口中的实例变量默认是 final 类型的，而抽象类中则不一定。\r\n3.  一个类可以实现多个接口，但最多只能实现一个抽象类。\r\n4.  一个类实现接口的话要实现接口的所有方法，而抽象类不一定。\r\n5.  接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。\r\n\r\n备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见issue:[https://github.com/Snailclimb/JavaGuide/issues/146](https://github.com/Snailclimb/JavaGuide/issues/146))\r\n\r\n## 18. 成员变量与局部变量的区别有那些？\r\n\r\n1. 从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。\r\n2. 从变量在内存中的存储方式来看:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\r\n3. 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。\r\n4. 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值），而局部变量则不会自动赋值。\r\n\r\n## 19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?\r\n\r\nnew运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）。\r\n\r\n## 20. 什么是方法的返回值?返回值在类的方法里的作用是什么?\r\n\r\n方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！\r\n\r\n## 21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?\r\n\r\n主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。\r\n\r\n## 22. 构造方法有哪些特性？\r\n\r\n1. 名字与类名相同。\r\n2. 没有返回值，但不能用void声明构造函数。\r\n3. 生成类的对象时自动执行，无需调用。\r\n\r\n## 23. 静态方法和实例方法有何不同\r\n\r\n1. 在外部调用静态方法时，可以使用\"类名.方法名\"的方式，也可以使用\"对象名.方法名\"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 \r\n\r\n2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。\r\n\r\n## 24. 对象的相等与指向他们的引用相等,两者有什么不同?\r\n\r\n对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。\r\n\r\n## 25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?\r\n\r\n帮助子类做初始化工作。\r\n\r\n## 26. == 与 equals(重要)\r\n\r\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。\r\n\r\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\r\n-  情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\r\n- 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。\r\n\r\n\r\n**举个例子：**\r\n\r\n```java\r\npublic class test1 {\r\n    public static void main(String[] args) {\r\n        String a = new String(\"ab\"); // a 为一个引用\r\n        String b = new String(\"ab\"); // b为另一个引用,对象的内容一样\r\n        String aa = \"ab\"; // 放在常量池中\r\n        String bb = \"ab\"; // 从常量池中查找\r\n        if (aa == bb) // true\r\n            System.out.println(\"aa==bb\");\r\n        if (a == b) // false，非同一对象\r\n            System.out.println(\"a==b\");\r\n        if (a.equals(b)) // true\r\n            System.out.println(\"aEQb\");\r\n        if (42 == 42.0) { // true\r\n            System.out.println(\"true\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**说明：**\r\n- String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。\r\n- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。\r\n\r\n\r\n\r\n##  27. hashCode 与 equals (重要)\r\n\r\n面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”\r\n\r\n### hashCode（）介绍\r\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。\r\n\r\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\r\n\r\n### 为什么要有 hashCode\r\n\r\n\r\n**我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：**\r\n\r\n当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\r\n\r\n\r\n\r\n### hashCode（）与equals（）的相关规定\r\n\r\n1. 如果两个对象相等，则hashcode一定也是相同的\r\n2. 两个对象相等,对两个对象分别调用equals方法都返回true\r\n3. 两个对象有相同的hashcode值，它们也不一定是相等的\r\n4. **因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**\r\n5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\r\n\r\n\r\n## 28. 为什么Java中只有值传递？\r\n\r\n [为什么Java中只有值传递？](https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%882018-8-7%EF%BC%89.md)\r\n\r\n\r\n## 29. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?\r\n\r\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \r\n\r\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\r\n\r\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\r\n线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\r\n\r\n## 30. 线程有哪些基本状态?\r\n\r\nJava 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。\r\n\r\n![Java线程的状态](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)\r\n\r\n线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）：\r\n\r\n![Java线程状态变迁](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png)\r\n\r\n\r\n\r\n由上图可以看出：\r\n\r\n线程创建之后它将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。\r\n\r\n> 操作系统隐藏 Java虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：[HowToDoInJava](https://howtodoinjava.com/)：[Java Thread Life Cycle and Thread States](https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/)），所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态 。\r\n\r\n![RUNNABLE-VS-RUNNING](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png)\r\n\r\n当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）**状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。线程在执行 Runnable 的` run() `方法之后将会进入到 **TERMINATED（终止）** 状态。\r\n\r\n## 31 关于 final 关键字的一些总结\r\n\r\nfinal关键字主要用在三个地方：变量、方法、类。\r\n\r\n1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。\r\n2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。\r\n3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。\r\n\r\n## 32 Java 中的异常处理\r\n\r\n### Java异常类层次结构图\r\n\r\n![Java异常类层次结构图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png)\r\n   在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 **Throwable类**。Throwable： 有两个重要的子类：**Exception（异常）** 和 **Error（错误）** ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。\r\n\r\n**Error（错误）:是程序无法处理的错误**，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。\r\n\r\n这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。\r\n\r\n**Exception（异常）:是程序本身可以处理的异常**。</font>Exception 类有一个重要的子类 **RuntimeException**。RuntimeException 异常由Java虚拟机抛出。**NullPointerException**（要访问的变量没有引用任何对象时，抛出该异常）、**ArithmeticException**（算术运算异常，一个整数除以0时，抛出该异常）和 **ArrayIndexOutOfBoundsException** （下标越界异常）。\r\n\r\n**注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。**\r\n\r\n### Throwable类常用方法\r\n\r\n- **public string getMessage()**:返回异常发生时的详细信息\r\n- **public string toString()**:返回异常发生时的简要描述\r\n- **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同\r\n- **public void printStackTrace()**:在控制台上打印Throwable对象封装的异常信息\r\n\r\n### 异常处理总结\r\n\r\n- **try 块：**用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。\r\n- **catch 块：**用于处理try捕获到的异常。\r\n- **finally 块：**无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。\r\n\r\n**在以下4种特殊情况下，finally块不会被执行：**\r\n\r\n1. 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行\r\n2. 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行\r\n3. 程序所在的线程死亡。\r\n4. 关闭CPU。\r\n\r\n下面这部分内容来自issue:<https://github.com/Snailclimb/JavaGuide/issues/190>。\r\n\r\n**关于返回值：**\r\n\r\n如果try语句里有return，返回的是try语句块中变量值。 \r\n详细执行过程如下：\r\n\r\n1. 如果有返回值，就把返回值保存到局部变量中；\r\n2. 执行jsr指令跳到finally语句里执行；\r\n3. 执行完finally语句后，返回之前保存在局部变量表里的值。\r\n4. 如果try，finally语句里均有return，忽略try的return，而使用finally的return.\r\n\r\n## 33 Java序列化中如果有些字段不想进行序列化，怎么办？\r\n\r\n对于不想进行序列化的变量，使用transient关键字修饰。\r\n\r\ntransient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。\r\n\r\n## 34 获取用键盘输入常用的的两种方法\r\n\r\n方法1：通过 Scanner\r\n\r\n```java\r\nScanner input = new Scanner(System.in);\r\nString s  = input.nextLine();\r\ninput.close();\r\n```\r\n\r\n方法2：通过 BufferedReader \r\n\r\n```java\r\nBufferedReader input = new BufferedReader(new InputStreamReader(System.in)); \r\nString s = input.readLine(); \r\n```\r\n\r\n## 参考\r\n\r\n- https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre\r\n- https://www.educba.com/oracle-vs-openjdk/\r\n- https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top\r\n', 0);
INSERT INTO `blog_course` VALUES (186, 'Java final,this,static,super', 2, '<!-- MarkdownTOC -->\r\n\r\n- [final,static,this,super 关键字总结](#finalstaticthissuper-关键字总结)\r\n  - [final 关键字](#final-关键字)\r\n  - [static 关键字](#static-关键字)\r\n  - [this 关键字](#this-关键字)\r\n  - [super 关键字](#super-关键字)\r\n  - [参考](#参考)\r\n- [static 关键字详解](#static-关键字详解)\r\n  - [static 关键字主要有以下四种使用场景](#static-关键字主要有以下四种使用场景)\r\n    - [修饰成员变量和成员方法\\(常用\\)](#修饰成员变量和成员方法常用)\r\n    - [静态代码块](#静态代码块)\r\n    - [静态内部类](#静态内部类)\r\n    - [静态导包](#静态导包)\r\n  - [补充内容](#补充内容)\r\n    - [静态方法与非静态方法](#静态方法与非静态方法)\r\n    - [static{}静态代码块与{}非静态代码块\\(构造代码块\\)](#static静态代码块与非静态代码块构造代码块)\r\n    - [参考](#参考-1)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n# final,static,this,super 关键字总结\r\n\r\n## final 关键字\r\n\r\n**final关键字主要用在三个地方：变量、方法、类。**\r\n\r\n1. **对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。**\r\n\r\n2. **当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。**\r\n\r\n3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。\r\n\r\n## static 关键字\r\n\r\n**static 关键字主要有以下四种使用场景：**\r\n\r\n1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名`    `类名.静态方法名()`\r\n2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.\r\n3. **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。\r\n4. **静态导包(用来导入类中的静态资源，1.5之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。\r\n\r\n## this 关键字\r\n\r\nthis关键字用于引用类的当前实例。 例如：\r\n\r\n```java\r\nclass Manager {\r\n    Employees[] employees;\r\n     \r\n    void manageEmployees() {\r\n        int totalEmp = this.employees.length;\r\n        System.out.println(\"Total employees: \" + totalEmp);\r\n        this.report();\r\n    }\r\n     \r\n    void report() { }\r\n}\r\n```\r\n\r\n在上面的示例中，this关键字用于两个地方：\r\n\r\n- this.employees.length：访问类Manager的当前实例的变量。\r\n- this.report（）：调用类Manager的当前实例的方法。\r\n\r\n此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。\r\n\r\n\r\n\r\n## super 关键字\r\n\r\nsuper关键字用于从子类访问父类的变量和方法。 例如：\r\n\r\n```java\r\npublic class Super {\r\n    protected int number;\r\n     \r\n    protected showNumber() {\r\n        System.out.println(\"number = \" + number);\r\n    }\r\n}\r\n \r\npublic class Sub extends Super {\r\n    void bar() {\r\n        super.number = 10;\r\n        super.showNumber();\r\n    }\r\n}\r\n```\r\n\r\n在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 `showNumber（）` 方法。\r\n\r\n**使用 this 和 super 要注意的问题：**\r\n\r\n- 在构造器中使用 `super（）` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。\r\n- this、super不能用在static方法中。\r\n\r\n**简单解释一下：**\r\n\r\n被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。\r\n\r\n## 参考\r\n\r\n- https://www.codejava.net/java-core/the-java-language/java-keywords\r\n- https://blog.csdn.net/u013393958/article/details/79881037\r\n\r\n# static 关键字详解\r\n\r\n## static 关键字主要有以下四种使用场景\r\n\r\n1. 修饰成员变量和成员方法\r\n2. 静态代码块\r\n3. 修饰类(只能修饰内部类)\r\n4. 静态导包(用来导入类中的静态资源，1.5之后的新特性)\r\n\r\n### 修饰成员变量和成员方法(常用)\r\n\r\n被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。\r\n\r\n方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。\r\n\r\n HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。\r\n\r\n\r\n\r\n调用格式：\r\n\r\n- 类名.静态变量名\r\n- 类名.静态方法名()\r\n\r\n如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。\r\n\r\n测试方法：\r\n\r\n```java\r\npublic class StaticBean {\r\n\r\n    String name;\r\n    静态变量\r\n    static int age;\r\n\r\n    public StaticBean(String name) {\r\n        this.name = name;\r\n    }\r\n    静态方法\r\n    static void SayHello() {\r\n        System.out.println(Hello i am java);\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return StaticBean{ +\r\n                name=\' + name + \'\'\' + age + age +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class StaticDemo {\r\n\r\n    public static void main(String[] args) {\r\n        StaticBean staticBean = new StaticBean(1);\r\n        StaticBean staticBean2 = new StaticBean(2);\r\n        StaticBean staticBean3 = new StaticBean(3);\r\n        StaticBean staticBean4 = new StaticBean(4);\r\n        StaticBean.age = 33;\r\n        StaticBean{name=\'1\'age33} StaticBean{name=\'2\'age33} StaticBean{name=\'3\'age33} StaticBean{name=\'4\'age33}\r\n        System.out.println(staticBean+ +staticBean2+ +staticBean3+ +staticBean4);\r\n        StaticBean.SayHello();Hello i am java\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n### 静态代码块\r\n\r\n静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次.\r\n\r\n静态代码块的格式是 \r\n\r\n```\r\nstatic {    \r\n语句体;   \r\n}\r\n```\r\n\r\n\r\n一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/88531075.jpg)\r\n\r\n静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问.\r\n\r\n\r\n### 静态内部类\r\n\r\n静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：\r\n\r\n1.  它的创建是不需要依赖外围类的创建。\r\n2.  它不能使用任何外围类的非static成员变量和方法。\r\n\r\n\r\nExample（静态内部类实现单例模式）\r\n\r\n```java\r\npublic class Singleton {\r\n    \r\n    声明为 private 避免调用默认构造方法创建对象\r\n    private Singleton() {\r\n    }\r\n    \r\n    声明为 private 表明静态内部该类只能在该 Singleton 类中被访问\r\n    private static class SingletonHolder {\r\n        private static final Singleton INSTANCE = new Singleton();\r\n    }\r\n\r\n    public static Singleton getUniqueInstance() {\r\n        return SingletonHolder.INSTANCE;\r\n    }\r\n}\r\n```\r\n\r\n当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance() `方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。\r\n\r\n这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。\r\n\r\n### 静态导包\r\n\r\n格式为：import static \r\n\r\n这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法\r\n\r\n```java\r\n\r\n\r\n  Math. --- 将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用\r\n  如果只想导入单一某个静态方法，只需要将换成对应的方法名即可\r\n \r\nimport static java.lang.Math.;\r\n\r\n  换成import static java.lang.Math.max;具有一样的效果\r\n \r\npublic class Demo {\r\n  public static void main(String[] args) {\r\n \r\n    int max = max(1,2);\r\n    System.out.println(max);\r\n  }\r\n}\r\n\r\n```\r\n\r\n\r\n##  补充内容\r\n\r\n### 静态方法与非静态方法\r\n\r\n静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。\r\n\r\nExample\r\n\r\n```java\r\nclass Foo {\r\n    int i;\r\n    public Foo(int i) { \r\n       this.i = i;\r\n    }\r\n\r\n    public static String method1() {\r\n       return An example string that doesn\'t depend on i (an instance variable);\r\n       \r\n    }\r\n\r\n    public int method2() {\r\n       return this.i + 1;  Depends on i\r\n    }\r\n\r\n}\r\n```\r\n你可以像这样调用静态方法：`Foo.method1（）`。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：`Foo bar = new Foo（1）;bar.method2（）;`\r\n\r\n总结：\r\n\r\n- 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 \r\n- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 \r\n\r\n### static{}静态代码块与{}非静态代码块(构造代码块)\r\n\r\n相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 \r\n\r\n不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 \r\n\r\n一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. \r\n\r\nExample\r\n\r\n```java\r\npublic class Test {\r\n    public Test() {\r\n        System.out.print(默认构造方法！--);\r\n    }\r\n\r\n     非静态代码块\r\n    {\r\n        System.out.print(非静态代码块！--);\r\n    }\r\n     静态代码块\r\n    static {\r\n        System.out.print(静态代码块！--);\r\n    }\r\n\r\n    public static void test() {\r\n        System.out.print(静态方法中的内容! --);\r\n        {\r\n            System.out.print(静态方法中的代码块！--);\r\n        }\r\n\r\n    }\r\n    public static void main(String[] args) {\r\n\r\n        Test test = new Test();   \r\n        Test.test();静态代码块！--静态方法中的内容! --静态方法中的代码块！--\r\n    }\r\n```\r\n\r\n当执行 `Test.test();` 时输出：\r\n\r\n```\r\n静态代码块！--静态方法中的内容! --静态方法中的代码块！--\r\n```\r\n\r\n当执行 `Test test = new Test();` 时输出：\r\n\r\n```\r\n静态代码块！--非静态代码块！--默认构造方法！--\r\n```\r\n\r\n\r\n非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 \r\n\r\n### 参考\r\n\r\n- httpsblog.csdn.netchen13579867831articledetails78995480\r\n- httpwww.cnblogs.comchenssyp3388487.html\r\n- httpwww.cnblogs.comQian123p5713440.html\r\n', 0);
INSERT INTO `blog_course` VALUES (187, 'Java IO与NIO', 2, '<!-- MarkdownTOC -->\r\n\r\n- [IO流学习总结](#IO流学习总结)\r\n- [NIO与AIO学习总结](#NIO与AIO学习总结)\r\n- [推荐阅读](#推荐阅读)\r\n\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n\r\n\r\n## IO流学习总结\r\n\r\n### [一　Java IO，硬骨头也能变软](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483981&idx=1&sn=6e5c682d76972c8d2cf271a85dcf09e2&chksm=fd98542ccaefdd3a70428e9549bc33e8165836855edaa748928d16c1ebde9648579d3acaac10#rd)\r\n\r\n**（1） 按操作方式分类结构图：**\r\n\r\n![按操作方式分类结构图：](https://user-gold-cdn.xitu.io/2018/5/16/16367d4fd1ce1b46?w=720&h=1080&f=jpeg&s=69522)\r\n\r\n\r\n**（2）按操作对象分类结构图**\r\n\r\n![按操作对象分类结构图](https://user-gold-cdn.xitu.io/2018/5/16/16367d673b0e268d?w=720&h=535&f=jpeg&s=46081)\r\n\r\n### [二　java IO体系的学习总结](https://blog.csdn.net/nightcurtis/article/details/51324105) \r\n1. **IO流的分类：**\r\n   - 按照流的流向分，可以分为输入流和输出流；\r\n   - 按照操作单元划分，可以划分为字节流和字符流；\r\n   - 按照流的角色划分为节点流和处理流。\r\n2. **流的原理浅析:**\r\n\r\n   java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。\r\n\r\n   - **InputStream/Reader**: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\r\n   - **OutputStream/Writer**: 所有输出流的基类，前者是字节输出流，后者是字符输出流。\r\n3. **常用的io流的用法** \r\n\r\n### [三　Java IO面试题](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483985&idx=1&sn=38531c2cee7b87f125df7aef41637014&chksm=fd985430caefdd26b0506aa84fc26251877eccba24fac73169a4d6bd1eb5e3fbdf3c3b940261#rd)\r\n\r\n## NIO与AIO学习总结\r\n\r\n\r\n### [一 Java NIO 概览](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483956&idx=1&sn=57692bc5b7c2c6dfb812489baadc29c9&chksm=fd985455caefdd4331d828d8e89b22f19b304aa87d6da73c5d8c66fcef16e4c0b448b1a6f791#rd)\r\n\r\n1.  **NIO简介**:\r\n\r\n    Java NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，不单纯是New。\r\n\r\n2.  **NIO的特性/NIO与IO区别:**\r\n    -   1)IO是面向流的，NIO是面向缓冲区的；\r\n    -   2)IO流是阻塞的，NIO流是不阻塞的;\r\n    -   3)NIO有选择器，而IO没有。\r\n3.  **读数据和写数据方式:**\r\n    - 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。\r\n\r\n    - 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。\r\n\r\n4.  **NIO核心组件简单介绍**\r\n    - **Channels**\r\n    - **Buffers**\r\n    - **Selectors**\r\n\r\n\r\n### [二 Java NIO 之 Buffer(缓冲区)](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483961&idx=1&sn=f67bef4c279e78043ff649b6b03fdcbc&chksm=fd985458caefdd4e3317ccbdb2d0a5a70a5024d3255eebf38183919ed9c25ade536017c0a6ba#rd)\r\n\r\n1. **Buffer(缓冲区)介绍:**\r\n   - Java NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels；\r\n   - Buffer本质上就是一块内存区；\r\n   - 一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。\r\n2. **Buffer的常见方法**\r\n    - Buffer clear()\r\n    - Buffer flip()\r\n    - Buffer rewind()\r\n    - Buffer position(int newPosition)\r\n3. **Buffer的使用方式/方法介绍:**\r\n    - 分配缓冲区（Allocating a Buffer）:\r\n    ```java\r\n    ByteBuffer buf = ByteBuffer.allocate(28);//以ByteBuffer为例子\r\n    ```\r\n    - 写入数据到缓冲区（Writing Data to a Buffer）\r\n    \r\n     **写数据到Buffer有两种方法：**\r\n      \r\n      1.从Channel中写数据到Buffer\r\n      ```java\r\n      int bytesRead = inChannel.read(buf); //read into buffer.\r\n      ```\r\n      2.通过put写数据：\r\n      ```java\r\n      buf.put(127);\r\n      ```\r\n\r\n4. **Buffer常用方法测试**\r\n     \r\n    说实话，NIO编程真的难，通过后面这个测试例子，你可能才能勉强理解前面说的Buffer方法的作用。\r\n\r\n\r\n### [三 Java NIO 之 Channel（通道）](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483966&idx=1&sn=d5cf18c69f5f9ec2aff149270422731f&chksm=fd98545fcaefdd49296e2c78000ce5da277435b90ba3c03b92b7cf54c6ccc71d61d13efbce63#rd)\r\n\r\n\r\n1.  **Channel（通道）介绍**\r\n     - 通常来说NIO中的所有IO都是从 Channel（通道） 开始的。 \r\n     - NIO Channel通道和流的区别：\r\n2. **FileChannel的使用**\r\n3. **SocketChannel和ServerSocketChannel的使用**\r\n4.  **️DatagramChannel的使用**\r\n5.  **Scatter / Gather**\r\n    - Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer).\r\n    - Gather: 将N个Buffer里面内容按照顺序发送到一个Channel.\r\n6. **通道之间的数据传输**\r\n   - 在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。\r\n   - transferFrom() :transferFrom方法把数据从通道源传输到FileChannel\r\n   - transferTo() :transferTo方法把FileChannel数据传输到另一个channel\r\n   \r\n\r\n### [四 Java NIO之Selector（选择器）](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483970&idx=1&sn=d5e2b133313b1d0f32872d54fbdf0aa7&chksm=fd985423caefdd354b587e57ce6cf5f5a7bec48b9ab7554f39a8d13af47660cae793956e0f46#rd)\r\n\r\n\r\n1. **Selector（选择器）介绍**\r\n   - Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。\r\n   - 使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。\r\n2. **Selector（选择器）的使用方法介绍**\r\n   - Selector的创建\r\n   ```java\r\n   Selector selector = Selector.open();\r\n   ```\r\n   - 注册Channel到Selector(Channel必须是非阻塞的)\r\n   ```java\r\n   channel.configureBlocking(false);\r\n   SelectionKey key = channel.register(selector, Selectionkey.OP_READ);\r\n   ```\r\n   -  SelectionKey介绍\r\n   \r\n      一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。\r\n   - 从Selector中选择channel(Selecting Channels via a Selector)\r\n   \r\n     选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.\r\n   - 停止选择的方法\r\n     \r\n     wakeup()方法 和close()方法。\r\n3.  **模板代码**\r\n\r\n    有了模板代码我们在编写程序时，大多数时间都是在模板代码中添加相应的业务代码。\r\n4. **客户端与服务端简单交互实例**\r\n\r\n\r\n\r\n### [五 Java NIO之拥抱Path和Files](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483976&idx=1&sn=2296c05fc1b840a64679e2ad7794c96d&chksm=fd985429caefdd3f48e2ee6fdd7b0f6fc419df90b3de46832b484d6d1ca4e74e7837689c8146&token=537240785&lang=zh_CN#rd)\r\n\r\n**一 文件I/O基石：Path：**\r\n- 创建一个Path\r\n- File和Path之间的转换，File和URI之间的转换\r\n- 获取Path的相关信息\r\n- 移除Path中的冗余项\r\n\r\n**二 拥抱Files类：**\r\n-  Files.exists() 检测文件路径是否存在\r\n-  Files.createFile() 创建文件\r\n-  Files.createDirectories()和Files.createDirectory()创建文件夹\r\n-  Files.delete()方法 可以删除一个文件或目录\r\n-  Files.copy()方法可以吧一个文件从一个地址复制到另一个位置\r\n-   获取文件属性\r\n-   遍历一个文件夹\r\n-   Files.walkFileTree()遍历整个目录\r\n\r\n### [六 NIO学习总结以及NIO新特性介绍](https://blog.csdn.net/a953713428/article/details/64907250)\r\n\r\n- **内存映射：**\r\n\r\n这个功能主要是为了提高大文件的读写速度而设计的。内存映射文件(memory-mappedfile)能让你创建和修改那些大到无法读入内存的文件。有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问了。将文件的一段区域映射到内存中，比传统的文件处理速度要快很多。内存映射文件它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。\r\n\r\n### [七 Java NIO AsynchronousFileChannel异步文件通](http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-asynchronousfilechannel.html)\r\n\r\nJava7中新增了AsynchronousFileChannel作为nio的一部分。AsynchronousFileChannel使得数据可以进行异步读写。\r\n\r\n### [八 高并发Java（8）：NIO和AIO](http://www.importnew.com/21341.html)\r\n\r\n\r\n\r\n## 推荐阅读\r\n\r\n### [在 Java 7 中体会 NIO.2 异步执行的快乐](https://www.ibm.com/developerworks/cn/java/j-lo-nio2/index.html)\r\n\r\n### [Java AIO总结与示例](https://blog.csdn.net/x_i_y_u_e/article/details/52223406)\r\nAIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。\r\n\r\n\r\n**欢迎关注我的微信公众号:\"Java面试通关手册\"（一个有温度的微信公众号，期待与你共同进步~~~坚持原创，分享美文，分享各种Java学习资源）：**\r\n', 0);
INSERT INTO `blog_course` VALUES (188, 'Java BIO-NIO-AIO', 2, '熟练掌握 BIO,NIO,AIO 的基本概念以及一些常见问题是你准备面试的过程中不可或缺的一部分，另外这些知识点也是你学习 Netty 的基础。\r\n\r\n<!-- MarkdownTOC -->\r\n\r\n- [BIO,NIO,AIO 总结](#BIO,NIO,AIO 总结)\r\n  - [1. BIO \\(Blocking I/O\\)](#1. BIO -Blocking I/O)\r\n    - [1.1 传统 BIO](#1.1 传统 BIO)\r\n    - [1.2 伪异步 IO](#1.2 伪异步 IO)\r\n    - [1.3 代码示例](#1.3 代码示例)\r\n    - [1.4 总结](#1.4 总结)\r\n  - [2. NIO \\(New I/O\\)](#2. NIO -New I/O)\r\n    - [2.1 NIO 简介](#2.1 NIO 简介)\r\n    - [2.2 NIO的特性/NIO与IO区别](#2.2 NIO的特性/NIO与IO区别)\r\n      - [1)Non-blocking IO（非阻塞IO）](#2.2.1 Non-blocking IO（非阻塞IO）)\r\n      - [2)Buffer\\(缓冲区\\)](#2.2.2Buffer(缓冲区)\r\n      - [3)Channel \\(通道\\)](#2.2.3(Channel (通道)\r\n      - [4)Selectors\\(选择器\\)](#2.2.4(Selectors (选择器)\r\n    - [2.3  NIO 读数据和写数据方式](#2.3  NIO 读数据和写数据方式)\r\n    - [2.4 NIO核心组件简单介绍](#2.4 NIO核心组件简单介绍)\r\n    - [2.5 代码示例](#2.5 代码示例)\r\n  - [3. AIO  \\(Asynchronous I/O\\)](#3. AIO (Asynchronous I/O)\r\n  - [参考](#参考)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n\r\n# BIO,NIO,AIO 总结\r\n\r\n Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。\r\n\r\n在讲 BIO,NIO,AIO 之前先来回顾一下这样几个概念：同步与异步，阻塞与非阻塞。\r\n\r\n**同步与异步**\r\n\r\n- **同步：** 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。\r\n- **异步：** 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。\r\n\r\n同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。\r\n\r\n**阻塞和非阻塞**\r\n\r\n- **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。\r\n- **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。\r\n\r\n举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（**同步阻塞**）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（**同步非阻塞**）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（**异步非阻塞**）。\r\n\r\n\r\n## 1. BIO -Blocking I/O\r\n\r\n同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。\r\n\r\n### 1.1 传统 BIO\r\n\r\nBIO通信（一请求一应答）模型图如下(图源网络，原出处不明)：\r\n\r\n![传统BIO通信模型图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2.png)\r\n\r\n采用 **BIO 通信模型** 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在`while(true)` 循环中服务端会调用 `accept()` 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。\r\n\r\n如果要让 **BIO 通信模型** 能够同时处理多个客户端请求，就必须使用多线程（主要原因是`socket.accept()`、`socket.read()`、`socket.write()` 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 **一请求一应答通信模型** 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 **线程池机制** 改善，线程池还可以让线程的创建和回收成本相对较低。使用`FixedThreadPool` 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节\"伪异步 BIO\"中会详细介绍到。\r\n\r\n**我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？**\r\n\r\n在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。\r\n\r\n### 1.2 伪异步 IO\r\n\r\n为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。\r\n\r\n伪异步IO模型图(图源网络，原出处不明)：\r\n\r\n![伪异步IO模型图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/3.png)\r\n\r\n采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。\r\n\r\n伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层任然是同步阻塞的BIO模型，因此无法从根本上解决问题。\r\n\r\n### 1.3 代码示例\r\n\r\n下面代码中演示了BIO通信（一请求一应答）模型。我们会在客户端创建多个线程依次连接服务端并向其发送\"当前时间+:hello world\"，服务端会为每个客户端线程创建一个线程来处理。代码示例出自闪电侠的博客，原地址如下：        \r\n\r\n[https://www.jianshu.com/p/a4e03835921a](https://www.jianshu.com/p/a4e03835921a)\r\n\r\n**客户端**\r\n\r\n```java\r\n/**\r\n * \r\n * @author 闪电侠\r\n * @date 2018年10月14日\r\n * @Description:客户端\r\n */\r\npublic class IOClient {\r\n\r\n  public static void main(String[] args) {\r\n    // TODO 创建多个线程，模拟多个客户端连接服务端\r\n    new Thread(() -> {\r\n      try {\r\n        Socket socket = new Socket(\"127.0.0.1\", 3333);\r\n        while (true) {\r\n          try {\r\n            socket.getOutputStream().write((new Date() + \": hello world\").getBytes());\r\n            Thread.sleep(2000);\r\n          } catch (Exception e) {\r\n          }\r\n        }\r\n      } catch (IOException e) {\r\n      }\r\n    }).start();\r\n\r\n  }\r\n\r\n}\r\n\r\n```\r\n\r\n**服务端**\r\n\r\n```java\r\n/**\r\n * @author 闪电侠\r\n * @date 2018年10月14日\r\n * @Description: 服务端\r\n */\r\npublic class IOServer {\r\n\r\n  public static void main(String[] args) throws IOException {\r\n    // TODO 服务端处理客户端连接请求\r\n    ServerSocket serverSocket = new ServerSocket(3333);\r\n\r\n    // 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理\r\n    new Thread(() -> {\r\n      while (true) {\r\n        try {\r\n          // 阻塞方法获取新的连接\r\n          Socket socket = serverSocket.accept();\r\n\r\n          // 每一个新的连接都创建一个线程，负责读取数据\r\n          new Thread(() -> {\r\n            try {\r\n              int len;\r\n              byte[] data = new byte[1024];\r\n              InputStream inputStream = socket.getInputStream();\r\n              // 按字节流方式读取数据\r\n              while ((len = inputStream.read(data)) != -1) {\r\n                System.out.println(new String(data, 0, len));\r\n              }\r\n            } catch (IOException e) {\r\n            }\r\n          }).start();\r\n\r\n        } catch (IOException e) {\r\n        }\r\n\r\n      }\r\n    }).start();\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n### 1.4 总结\r\n\r\n在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。\r\n\r\n\r\n\r\n## 2. NIO -New I/O\r\n\r\n### 2.1 NIO 简介\r\n\r\n NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。\r\n \r\nNIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。\r\n\r\n### 2.2 NIO的特性/NIO与IO区别\r\n\r\n如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。如果，你把这些都回答上了我觉得你对于 NIO 就有了更为深入一点的认识，面试官问到你这个问题，你也能很轻松的回答上来了。\r\n\r\n#### 2.2.1 Non-blocking IO（非阻塞IO）\r\n\r\n**IO流是阻塞的，NIO流是不阻塞的。**\r\n\r\nJava NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。\r\n\r\nJava IO的各种流是阻塞的。这意味着，当一个线程调用 `read()` 或  `write()` 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了\r\n\r\n#### 2.2.2Buffer(缓冲区\r\n\r\n**IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。**\r\n\r\nBuffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。\r\n\r\n在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。\r\n\r\n最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。\r\n\r\n#### 2.2.3(Channel (通道\r\n\r\nNIO 通过Channel（通道） 进行读写。\r\n\r\n通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。\r\n\r\n#### 2.2.4(Selectors (选择器\r\n\r\nNIO有选择器，而IO没有。\r\n\r\n选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。\r\n\r\n![一个单线程中Slector维护3个Channel的示意图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Slector.png)\r\n\r\n### 2.3  NIO 读数据和写数据方式\r\n通常来说NIO中的所有IO都是从 Channel（通道） 开始的。\r\n\r\n- 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。\r\n- 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。\r\n\r\n数据读取和写入操作图示：\r\n\r\n![NIO读写数据的方式](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/NIO读写数据的方式.png)\r\n\r\n\r\n### 2.4 NIO核心组件简单介绍\r\n\r\nNIO 包含下面几个核心的组件：\r\n\r\n- Channel(通道)\r\n- Buffer(缓冲区)\r\n- Selector(选择器)\r\n\r\n整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”。我们上面已经对这三个概念进行了基本的阐述，这里就不多做解释了。\r\n\r\n### 2.5 代码示例\r\n\r\n代码示例出自闪电侠的博客，原地址如下：        \r\n\r\n[https://www.jianshu.com/p/a4e03835921a](https://www.jianshu.com/p/a4e03835921a)\r\n\r\n客户端 IOClient.java 的代码不变，我们对服务端使用 NIO 进行改造。以下代码较多而且逻辑比较复杂，大家看看就好。\r\n\r\n```java\r\n/**\r\n * \r\n * @author 闪电侠\r\n * @date 2019年2月21日\r\n * @Description: NIO 改造后的服务端\r\n */\r\npublic class NIOServer {\r\n  public static void main(String[] args) throws IOException {\r\n    // 1. serverSelector负责轮询是否有新的连接，服务端监测到新的连接之后，不再创建一个新的线程，\r\n    // 而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等\r\n    Selector serverSelector = Selector.open();\r\n    // 2. clientSelector负责轮询连接是否有数据可读\r\n    Selector clientSelector = Selector.open();\r\n\r\n    new Thread(() -> {\r\n      try {\r\n        // 对应IO编程中服务端启动\r\n        ServerSocketChannel listenerChannel = ServerSocketChannel.open();\r\n        listenerChannel.socket().bind(new InetSocketAddress(3333));\r\n        listenerChannel.configureBlocking(false);\r\n        listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);\r\n\r\n        while (true) {\r\n          // 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms\r\n          if (serverSelector.select(1) > 0) {\r\n            Set<SelectionKey> set = serverSelector.selectedKeys();\r\n            Iterator<SelectionKey> keyIterator = set.iterator();\r\n\r\n            while (keyIterator.hasNext()) {\r\n              SelectionKey key = keyIterator.next();\r\n\r\n              if (key.isAcceptable()) {\r\n                try {\r\n                  // (1)\r\n                  // 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector\r\n                  SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\r\n                  clientChannel.configureBlocking(false);\r\n                  clientChannel.register(clientSelector, SelectionKey.OP_READ);\r\n                } finally {\r\n                  keyIterator.remove();\r\n                }\r\n              }\r\n\r\n            }\r\n          }\r\n        }\r\n      } catch (IOException ignored) {\r\n      }\r\n    }).start();\r\n    new Thread(() -> {\r\n      try {\r\n        while (true) {\r\n          // (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms\r\n          if (clientSelector.select(1) > 0) {\r\n            Set<SelectionKey> set = clientSelector.selectedKeys();\r\n            Iterator<SelectionKey> keyIterator = set.iterator();\r\n\r\n            while (keyIterator.hasNext()) {\r\n              SelectionKey key = keyIterator.next();\r\n\r\n              if (key.isReadable()) {\r\n                try {\r\n                  SocketChannel clientChannel = (SocketChannel) key.channel();\r\n                  ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\r\n                  // (3) 面向 Buffer\r\n                  clientChannel.read(byteBuffer);\r\n                  byteBuffer.flip();\r\n                  System.out.println(\r\n                      Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\r\n                } finally {\r\n                  keyIterator.remove();\r\n                  key.interestOps(SelectionKey.OP_READ);\r\n                }\r\n              }\r\n\r\n            }\r\n          }\r\n        }\r\n      } catch (IOException ignored) {\r\n      }\r\n    }).start();\r\n\r\n  }\r\n}\r\n```\r\n\r\n为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？从上面的代码中大家都可以看出来，是真的难用！除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：\r\n\r\n- JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%\r\n- 项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug\r\n\r\nNetty 的出现很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题。\r\n\r\n### 3. AIO (Asynchronous I/O\r\n\r\nAIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\r\n\r\nAIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释，推荐一篇文章：[《漫话：如何给女朋友解释什么是Linux的五种IO模型？》](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect) ）\r\n\r\n查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。\r\n\r\n## 参考\r\n\r\n- 《Netty 权威指南》第二版\r\n- https://zhuanlan.zhihu.com/p/23488863 (美团技术团队)\r\n', 0);
INSERT INTO `blog_course` VALUES (189, 'Java 集合框架', 2, '<!-- MarkdownTOC -->\r\n\r\n1. [List，Set,Map三者的区别及总结](#List，Set,Map三者的区别及总结)\r\n1. [Arraylist 与 LinkedList 区别](#Arraylist 与 LinkedList 区别)\r\n1. [ArrayList 与 Vector 区别（为什么要用Arraylist取代Vector呢？）](#ArrayList 与 Vector 区别)\r\n1. [HashMap 和 Hashtable 的区别](#HashMap 和 Hashtable 的区别)\r\n1. [HashSet 和 HashMap 区别](#>HashSet 和 HashMap 区别)\r\n1. [HashMap 和 ConcurrentHashMap 的区别](#HashMap 和 ConcurrentHashMap 的区别)\r\n1. [HashSet如何检查重复](#HashSet如何检查重复)\r\n1. [comparable 和 comparator的区别](#comparable 和 comparator的区别)\r\n	1. [Comparator定制排序](#Comparator定制排序)\r\n	1. [重写compareTo方法实现按年龄来排序](#重写compareTo方法实现按年龄来排序)\r\n1. [如何对Object的list排序？](#如何对Object的list排序)\r\n1. [如何实现数组与List的相互转换？](#如何实现数组与List的相互转换)\r\n1. [如何求ArrayList集合的交集 并集 差集 去重复并集](#如何求ArrayList集合的交集 并集 差集 去重复并集)\r\n1. [HashMap 的工作原理及代码实现](#HashMap 的工作原理及代码实现)\r\n1. [ConcurrentHashMap 的工作原理及代码实现](#ConcurrentHashMap 的工作原理及代码实现)\r\n1. [集合框架底层数据结构总结](#集合框架底层数据结构总结)\r\n	1. [- Collection](#- Collection)\r\n		1. [1. List](#1. List)\r\n		1. [2. Set](#2. Set)\r\n	1. [- Map](#- Map )\r\n1. [集合的选用](#集合的选用)\r\n1. [集合的常用方法](#集合的常用方法)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n## List，Set,Map三者的区别及总结\r\n- **List：对付顺序的好帮手**\r\n\r\n  List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象\r\n- **Set:注重独一无二的性质**\r\n  \r\n  不允许重复的集合。不会有多个元素引用相同的对象。\r\n\r\n- **Map:用Key来搜索的专家**\r\n  \r\n  使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。\r\n  \r\n\r\n## Arraylist 与 LinkedList 区别\r\nArraylist底层使用的是数组（存读数据效率高，插入删除特定位置效率低），LinkedList 底层使用的是双向链表数据结构（插入，删除效率特别高）（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别：）； 详细可阅读JDK1.7-LinkedList循环链表优化。学过数据结构这门课后我们就知道采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，都是近似O（1）而数组为近似O（n），因此当数据特别多，而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了，因为一般数据量都不会蛮大，Arraylist是使用最多的集合类。\r\n\r\n## ArrayList 与 Vector 区别\r\nVector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector\r\n，代码要在同步操作上耗费大量的时间。Arraylist不是同步的，所以在不需要同步时建议使用Arraylist。\r\n\r\n## HashMap 和 Hashtable 的区别\r\n1. HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰。\r\n\r\n2. 因为线程安全的问题，HashMap要比HashTable效率高一点，HashTable基本被淘汰。\r\n3. HashMap允许有null值的存在，而在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。\r\n\r\nHashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java5或以上的话，请使用ConcurrentHashMap吧\r\n\r\n## HashSet 和 HashMap 区别\r\n![HashSet 和 HashMap 区别](https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?w=896&h=363&f=jpeg&s=205536)\r\n\r\n## HashMap 和 ConcurrentHashMap 的区别\r\n[HashMap与ConcurrentHashMap的区别](https://blog.csdn.net/xuefeng0707/article/details/40834595)\r\n\r\n1. ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）\r\n2. HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。\r\n\r\n## HashSet如何检查重复\r\n当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）\r\n\r\n**hashCode（）与equals（）的相关规定：**\r\n1. 如果两个对象相等，则hashcode一定也是相同的\r\n2. 两个对象相等,对两个equals方法返回true\r\n3. 两个对象有相同的hashcode值，它们也不一定是相等的\r\n4. 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖\r\n5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。\r\n\r\n**==与equals的区别**\r\n\r\n1. ==是判断两个变量或实例是不是指向同一个内存空间    equals是判断两个变量或实例所指向的内存空间的值是不是相同\r\n2. ==是指对内存地址进行比较    equals()是对字符串的内容进行比较\r\n3. ==指引用是否相同    equals()指的是值是否相同\r\n\r\n## comparable 和 comparator的区别\r\n- comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序\r\n- comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序\r\n\r\n一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().\r\n\r\n### Comparator定制排序\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * TODO Collections类方法测试之排序\r\n * @author 寇爽\r\n * @date 2017年11月20日\r\n * @version 1.8\r\n */\r\npublic class CollectionsSort {\r\n\r\n	public static void main(String[] args) {\r\n\r\n		ArrayList<Integer> arrayList = new ArrayList<Integer>();\r\n		arrayList.add(-1);\r\n		arrayList.add(3);\r\n		arrayList.add(3);\r\n		arrayList.add(-5);\r\n		arrayList.add(7);\r\n		arrayList.add(4);\r\n		arrayList.add(-9);\r\n		arrayList.add(-7);\r\n		System.out.println(\"原始数组:\");\r\n		System.out.println(arrayList);\r\n		// void reverse(List list)：反转\r\n		Collections.reverse(arrayList);\r\n		System.out.println(\"Collections.reverse(arrayList):\");\r\n		System.out.println(arrayList);\r\n/*		\r\n		 * void rotate(List list, int distance),旋转。\r\n		 * 当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将\r\n		 * list的前distance个元素整体移到后面。\r\n		 \r\n		Collections.rotate(arrayList, 4);\r\n		System.out.println(\"Collections.rotate(arrayList, 4):\");\r\n		System.out.println(arrayList);*/\r\n		\r\n		// void sort(List list),按自然排序的升序排序\r\n		Collections.sort(arrayList);\r\n		System.out.println(\"Collections.sort(arrayList):\");\r\n		System.out.println(arrayList);\r\n\r\n		// void shuffle(List list),随机排序\r\n		Collections.shuffle(arrayList);\r\n		System.out.println(\"Collections.shuffle(arrayList):\");\r\n		System.out.println(arrayList);\r\n\r\n		// 定制排序的用法\r\n		Collections.sort(arrayList, new Comparator<Integer>() {\r\n\r\n			@Override\r\n			public int compare(Integer o1, Integer o2) {\r\n				return o2.compareTo(o1);\r\n			}\r\n		});\r\n		System.out.println(\"定制排序后：\");\r\n		System.out.println(arrayList);\r\n	}\r\n\r\n}\r\n\r\n```\r\n### 重写compareTo方法实现按年龄来排序\r\n```java\r\npackage map;\r\n\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\n\r\npublic class TreeMap2 {\r\n\r\n	public static void main(String[] args) {\r\n		// TODO Auto-generated method stub\r\n		TreeMap<Person, String> pdata = new TreeMap<Person, String>();\r\n		pdata.put(new Person(\"张三\", 30), \"zhangsan\");\r\n		pdata.put(new Person(\"李四\", 20), \"lisi\");\r\n		pdata.put(new Person(\"王五\", 10), \"wangwu\");\r\n		pdata.put(new Person(\"小红\", 5), \"xiaohong\");\r\n		// 得到key的值的同时得到key所对应的值\r\n		Set<Person> keys = pdata.keySet();\r\n		for (Person key : keys) {\r\n			System.out.println(key.getAge() + \"-\" + key.getName());\r\n\r\n		}\r\n	}\r\n}\r\n\r\n// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列\r\n// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他\r\n// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了\r\n\r\nclass Person implements Comparable<Person> {\r\n	private String name;\r\n	private int age;\r\n\r\n	public Person(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n\r\n	public String getName() {\r\n		return name;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n\r\n	/**\r\n	 * TODO重写compareTo方法实现按年龄来排序\r\n	 */\r\n	@Override\r\n	public int compareTo(Person o) {\r\n		// TODO Auto-generated method stub\r\n		if (this.age > o.getAge()) {\r\n			return 1;\r\n		} else if (this.age < o.getAge()) {\r\n			return -1;\r\n		}\r\n		return age;\r\n	}\r\n}\r\n```\r\n\r\n## 如何对Object的list排序\r\n-   对objects数组进行排序，我们可以用Arrays.sort()方法\r\n-   对objects的集合进行排序，需要使用Collections.sort()方法\r\n  \r\n\r\n## 如何实现数组与List的相互转换\r\nList转数组：toArray(arraylist.size()方法；数组转List:Arrays的asList(a)方法\r\n```java\r\nList<String> arrayList = new ArrayList<String>();\r\n		arrayList.add(\"s\");\r\n		arrayList.add(\"e\");\r\n		arrayList.add(\"n\");\r\n		/**\r\n		 * ArrayList转数组\r\n		 */\r\n		int size=arrayList.size();\r\n		String[] a = arrayList.toArray(new String[size]);\r\n		//输出第二个元素\r\n		System.out.println(a[1]);//结果：e\r\n		//输出整个数组\r\n		System.out.println(Arrays.toString(a));//结果：[s, e, n]\r\n		/**\r\n		 * 数组转list\r\n		 */\r\n		List<String> list=Arrays.asList(a);\r\n		/**\r\n		 * list转Arraylist\r\n		 */\r\n		List<String> arrayList2 = new ArrayList<String>();\r\n		arrayList2.addAll(list);\r\n		System.out.println(list);\r\n```\r\n## 如何求ArrayList集合的交集 并集 差集 去重复并集\r\n需要用到List接口中定义的几个方法：\r\n\r\n- addAll(Collection<? extends E> c) :按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾\r\n实例代码：\r\n- retainAll(Collection<?> c): 仅保留此列表中包含在指定集合中的元素。 \r\n- removeAll(Collection<?> c) :从此列表中删除指定集合中包含的所有元素。 \r\n```java\r\npackage list;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n *TODO 两个集合之间求交集 并集 差集 去重复并集\r\n * @author 寇爽\r\n * @date 2017年11月21日\r\n * @version 1.8\r\n */\r\npublic class MethodDemo {\r\n\r\n	public static void main(String[] args) {\r\n		// TODO Auto-generated method stub\r\n		List<Integer> list1 = new ArrayList<Integer>();\r\n		list1.add(1);\r\n		list1.add(2);\r\n		list1.add(3);\r\n		list1.add(4);\r\n\r\n		List<Integer> list2 = new ArrayList<Integer>();\r\n		list2.add(2);\r\n		list2.add(3);\r\n		list2.add(4);\r\n		list2.add(5);\r\n		// 并集\r\n		// list1.addAll(list2);\r\n		// 交集\r\n		//list1.retainAll(list2);\r\n		// 差集\r\n		// list1.removeAll(list2);\r\n		// 无重复并集\r\n		list2.removeAll(list1);\r\n		list1.addAll(list2);\r\n		for (Integer i : list1) {\r\n			System.out.println(i);\r\n		}\r\n	}\r\n\r\n}\r\n\r\n```\r\n\r\n## HashMap 的工作原理及代码实现\r\n\r\n[集合框架源码学习之HashMap(JDK1.8)](https://juejin.im/post/5ab0568b5188255580020e56)\r\n\r\n## ConcurrentHashMap 的工作原理及代码实现\r\n\r\n[ConcurrentHashMap实现原理及源码分析](http://www.cnblogs.com/chengxiao/p/6842045.html)\r\n\r\n\r\n## 集合框架底层数据结构总结\r\n### - Collection\r\n  \r\n####  1. List\r\n   - Arraylist：数组（查询快,增删慢   线程不安全,效率高  ）\r\n   - Vector：数组（查询快,增删慢 线程安全,效率低  ）\r\n   - LinkedList：链表（查询慢,增删快  线程不安全,效率高  ）\r\n\r\n####  2. Set\r\n  - HashSet（无序，唯一）:哈希表或者叫散列集(hash table)\r\n  - LinkedHashSet：链表和哈希表组成 。 由链表保证元素的排序 ， 由哈希表证元素的唯一性  \r\n  - TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树。)\r\n\r\n### - Map \r\n -  HashMap：基于哈希表的Map接口实现（哈希表对键进行散列，Map结构即映射表存放键值对）\r\n -  LinkedHashMap:HashMap  的基础上加上了链表数据结构\r\n -  HashTable:哈希表\r\n -  TreeMap:红黑树（自平衡的排序二叉树）\r\n \r\n\r\n## 集合的选用\r\n主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。\r\n\r\n2018/3/11更新\r\n## 集合的常用方法\r\n今天下午无意看见一道某大厂的面试题，面试题的内容就是问你某一个集合常见的方法有哪些。虽然平时也经常见到这些集合，但是猛一下让我想某一个集合的常用的方法难免会有遗漏或者与其他集合搞混，所以建议大家还是照着API文档把常见的那几个集合的常用方法看一看。\r\n\r\n会持续更新。。。\r\n\r\n**参考书籍：**\r\n\r\n《Head first java 》第二版 推荐阅读真心不错 （适合基础较差的）\r\n\r\n 《Java核心技术卷1》推荐阅读真心不错 （适合基础较好的）\r\n \r\n 《算法》第四版 （适合想对数据结构的Java实现感兴趣的）\r\n \r\n', 0);
INSERT INTO `blog_course` VALUES (190, 'Java Collections 工具类和 Arrays 工具类常见方法', 2, '<!-- TOC -->\r\n\r\n- [Collections 工具类和 Arrays 工具类常见方法](#Collections 工具类和 Arrays 工具类常见方法)\r\n    - [Collections](#Collections)\r\n        - [排序操作](#排序操作)\r\n        - [查找,替换操作](#查找,替换操作)\r\n        - [同步控制](#同步控制)\r\n    - [Arrays类的常见操作](#Arrays类的常见操作)\r\n        - [排序 : `sort()`](#排序: sort（）)\r\n        - [查找 : `binarySearch()`](#查找： binarySearch（）)\r\n        - [比较: `equals()`](#比较： equals（）)\r\n        - [填充 : `fill()`](#填充： fill（）)\r\n        - [转列表 `asList()`](#转列表： asList（）)\r\n        - [转字符串 `toString()`](#转字符串： toString（）)\r\n        - [复制 `copyOf()`](#复制： copyof（）)\r\n\r\n<!-- /TOC -->\r\n# Collections 工具类和 Arrays 工具类常见方法\r\n\r\n## Collections\r\n\r\nCollections 工具类常用方法:\r\n\r\n1. 排序\r\n2. 查找,替换操作\r\n3. 同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)\r\n\r\n###  排序操作\r\n\r\n```java\r\nvoid reverse(List list)//反转\r\nvoid shuffle(List list)//随机排序\r\nvoid sort(List list)//按自然排序的升序排序\r\nvoid sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑\r\nvoid swap(List list, int i , int j)//交换两个索引位置的元素\r\nvoid rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。\r\n```\r\n\r\n**示例代码:**\r\n\r\n```java\r\n     ArrayList<Integer> arrayList = new ArrayList<Integer>();\r\n		arrayList.add(-1);\r\n		arrayList.add(3);\r\n		arrayList.add(3);\r\n		arrayList.add(-5);\r\n		arrayList.add(7);\r\n		arrayList.add(4);\r\n		arrayList.add(-9);\r\n		arrayList.add(-7);\r\n		System.out.println(\"原始数组:\");\r\n		System.out.println(arrayList);\r\n		// void reverse(List list)：反转\r\n		Collections.reverse(arrayList);\r\n		System.out.println(\"Collections.reverse(arrayList):\");\r\n		System.out.println(arrayList);\r\n		\r\n		 \r\n		Collections.rotate(arrayList, 4);\r\n		System.out.println(\"Collections.rotate(arrayList, 4):\");\r\n		System.out.println(arrayList);\r\n		\r\n		// void sort(List list),按自然排序的升序排序\r\n		Collections.sort(arrayList);\r\n		System.out.println(\"Collections.sort(arrayList):\");\r\n		System.out.println(arrayList);\r\n\r\n		// void shuffle(List list),随机排序\r\n		Collections.shuffle(arrayList);\r\n		System.out.println(\"Collections.shuffle(arrayList):\");\r\n		System.out.println(arrayList);\r\n		\r\n		// void swap(List list, int i , int j),交换两个索引位置的元素\r\n		Collections.swap(arrayList, 2, 5);\r\n		System.out.println(\"Collections.swap(arrayList, 2, 5):\");\r\n		System.out.println(arrayList);\r\n\r\n		// 定制排序的用法\r\n		Collections.sort(arrayList, new Comparator<Integer>() {\r\n\r\n			@Override\r\n			public int compare(Integer o1, Integer o2) {\r\n				return o2.compareTo(o1);\r\n			}\r\n		});\r\n		System.out.println(\"定制排序后：\");\r\n		System.out.println(arrayList);\r\n```\r\n\r\n### 查找,替换操作\r\n\r\n```java\r\nint binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的\r\nint max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)\r\nint max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)\r\nvoid fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。 \r\nint frequency(Collection c, Object o)//统计元素出现次数\r\nint indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).\r\nboolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素\r\n```\r\n\r\n**示例代码：**\r\n\r\n```java\r\n		ArrayList<Integer> arrayList = new ArrayList<Integer>();\r\n		arrayList.add(-1);\r\n		arrayList.add(3);\r\n		arrayList.add(3);\r\n		arrayList.add(-5);\r\n		arrayList.add(7);\r\n		arrayList.add(4);\r\n		arrayList.add(-9);\r\n		arrayList.add(-7);\r\n		ArrayList<Integer> arrayList2 = new ArrayList<Integer>();\r\n		arrayList2.add(-3);\r\n		arrayList2.add(-5);\r\n		arrayList2.add(7);\r\n		System.out.println(\"原始数组:\");\r\n		System.out.println(arrayList);\r\n\r\n		System.out.println(\"Collections.max(arrayList):\");\r\n		System.out.println(Collections.max(arrayList));\r\n\r\n		System.out.println(\"Collections.min(arrayList):\");\r\n		System.out.println(Collections.min(arrayList));\r\n\r\n		System.out.println(\"Collections.replaceAll(arrayList, 3, -3):\");\r\n		Collections.replaceAll(arrayList, 3, -3);\r\n		System.out.println(arrayList);\r\n\r\n		System.out.println(\"Collections.frequency(arrayList, -3):\");\r\n		System.out.println(Collections.frequency(arrayList, -3));\r\n\r\n		System.out.println(\"Collections.indexOfSubList(arrayList, arrayList2):\");\r\n		System.out.println(Collections.indexOfSubList(arrayList, arrayList2));\r\n\r\n		System.out.println(\"Collections.binarySearch(arrayList, 7):\");\r\n		// 对List进行二分查找，返回索引，List必须是有序的\r\n		Collections.sort(arrayList);\r\n		System.out.println(Collections.binarySearch(arrayList, 7));\r\n```\r\n\r\n### 同步控制\r\n\r\nCollectons提供了多个`synchronizedXxx()`方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。\r\n\r\n我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。\r\n\r\n**最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。**\r\n\r\n方法如下：\r\n\r\n```java\r\nsynchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。\r\nsynchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。 \r\nsynchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。\r\nsynchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。 \r\n```\r\n\r\n### Collections还可以设置不可变集合，提供了如下三类方法：\r\n\r\n```java\r\nemptyXxx(): 返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。\r\nsingletonXxx(): 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。\r\nunmodifiableXxx(): 返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。\r\n上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。\r\n```\r\n\r\n**示例代码：**\r\n\r\n```java\r\n        ArrayList<Integer> arrayList = new ArrayList<Integer>();\r\n        arrayList.add(-1);\r\n        arrayList.add(3);\r\n        arrayList.add(3);\r\n        arrayList.add(-5);\r\n        arrayList.add(7);\r\n        arrayList.add(4);\r\n        arrayList.add(-9);\r\n        arrayList.add(-7);\r\n        HashSet<Integer> integers1 = new HashSet<>();\r\n        integers1.add(1);\r\n        integers1.add(3);\r\n        integers1.add(2);\r\n        Map scores = new HashMap();\r\n        scores.put(\"语文\" , 80);\r\n        scores.put(\"Java\" , 82);\r\n\r\n        //Collections.emptyXXX();创建一个空的、不可改变的XXX对象\r\n        List<Object> list = Collections.emptyList();\r\n        System.out.println(list);//[]\r\n        Set<Object> objects = Collections.emptySet();\r\n        System.out.println(objects);//[]\r\n        Map<Object, Object> objectObjectMap = Collections.emptyMap();\r\n        System.out.println(objectObjectMap);//{}\r\n\r\n        //Collections.singletonXXX();\r\n        List<ArrayList<Integer>> arrayLists = Collections.singletonList(arrayList);\r\n        System.out.println(arrayLists);//[[-1, 3, 3, -5, 7, 4, -9, -7]]\r\n        //创建一个只有一个元素，且不可改变的Set对象\r\n        Set<ArrayList<Integer>> singleton = Collections.singleton(arrayList);\r\n        System.out.println(singleton);//[[-1, 3, 3, -5, 7, 4, -9, -7]]\r\n        Map<String, String> nihao = Collections.singletonMap(\"1\", \"nihao\");\r\n        System.out.println(nihao);//{1=nihao}\r\n\r\n        //unmodifiableXXX();创建普通XXX对象对应的不可变版本\r\n        List<Integer> integers = Collections.unmodifiableList(arrayList);\r\n        System.out.println(integers);//[-1, 3, 3, -5, 7, 4, -9, -7]\r\n        Set<Integer> integers2 = Collections.unmodifiableSet(integers1);\r\n        System.out.println(integers2);//[1, 2, 3]\r\n        Map<Object, Object> objectObjectMap2 = Collections.unmodifiableMap(scores);\r\n        System.out.println(objectObjectMap2);//{Java=82, 语文=80}\r\n\r\n        //添加出现异常：java.lang.UnsupportedOperationException\r\n//        list.add(1);\r\n//        arrayLists.add(arrayList);\r\n//        integers.add(1);\r\n```\r\n\r\n## Arrays类的常见操作\r\n1. 排序 : `sort()`\r\n2. 查找 : `binarySearch()`\r\n3. 比较: `equals()`\r\n4. 填充 : `fill()`\r\n5. 转列表:  `asList()`\r\n6. 转字符串 : `toString()`\r\n7. 复制 ：`copyOf()`\r\n\r\n### 排序: sort（）\r\n\r\n```java\r\n		// *************排序 sort****************\r\n		int a[] = { 1, 3, 2, 7, 6, 5, 4, 9 };\r\n		// sort(int[] a)方法按照数字顺序排列指定的数组。\r\n		Arrays.sort(a);\r\n		System.out.println(\"Arrays.sort(a):\");\r\n		for (int i : a) {\r\n			System.out.print(i);\r\n		}\r\n		// 换行\r\n		System.out.println();\r\n\r\n		// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围\r\n		int b[] = { 1, 3, 2, 7, 6, 5, 4, 9 };\r\n		Arrays.sort(b, 2, 6);\r\n		System.out.println(\"Arrays.sort(b, 2, 6):\");\r\n		for (int i : b) {\r\n			System.out.print(i);\r\n		}\r\n		// 换行\r\n		System.out.println();\r\n\r\n		int c[] = { 1, 3, 2, 7, 6, 5, 4, 9 };\r\n		// parallelSort(int[] a) 按照数字顺序排列指定的数组。同sort方法一样也有按范围的排序\r\n		Arrays.parallelSort(c);\r\n		System.out.println(\"Arrays.parallelSort(c)：\");\r\n		for (int i : c) {\r\n			System.out.print(i);\r\n		}\r\n		// 换行\r\n		System.out.println();\r\n\r\n		// parallelSort给字符数组排序，sort也可以\r\n		char d[] = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\r\n		Arrays.parallelSort(d);\r\n		System.out.println(\"Arrays.parallelSort(d)：\");\r\n		for (char d2 : d) {\r\n			System.out.print(d2);\r\n		}\r\n		// 换行\r\n		System.out.println();\r\n\r\n```\r\n\r\n在做算法面试题的时候，我们还可能会经常遇到对字符串排序的情况,`Arrays.sort()` 对每个字符串的特定位置进行比较，然后按照升序排序。\r\n\r\n```java\r\nString[] strs = { \"abcdehg\", \"abcdefg\", \"abcdeag\" };\r\nArrays.sort(strs);\r\nSystem.out.println(Arrays.toString(strs));//[abcdeag, abcdefg, abcdehg]\r\n```\r\n\r\n### 查找： binarySearch（）\r\n\r\n```java\r\n		// *************查找 binarySearch()****************\r\n		char[] e = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\r\n		System.out.println(\"Arrays.binarySearch(e, \'c\')：\");\r\n		int s = Arrays.binarySearch(e, \'c\');\r\n		System.out.println(\"字符c在数组的位置：\" + s);\r\n```\r\n\r\n### 比较： equals（）\r\n\r\n```java\r\n	// *************比较 equals****************\r\n        char[] e = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\r\n		char[] f = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\r\n		/*\r\n		 * 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。\r\n		 */\r\n		// 输出true\r\n		System.out.println(\"Arrays.equals(e, f):\" + Arrays.equals(e, f));\r\n```\r\n\r\n### 填充： fill（）\r\n\r\n```java\r\n		// *************填充fill(批量初始化)****************\r\n		int[] g = { 1, 2, 3, 3, 3, 3, 6, 6, 6 };\r\n		// 数组中所有元素重新分配值\r\n		Arrays.fill(g, 3);\r\n		System.out.println(\"Arrays.fill(g, 3)：\");\r\n		// 输出结果：333333333\r\n		for (int i : g) {\r\n			System.out.print(i);\r\n		}\r\n		// 换行\r\n		System.out.println();\r\n\r\n		int[] h = { 1, 2, 3, 3, 3, 3, 6, 6, 6, };\r\n		// 数组中指定范围元素重新分配值\r\n		Arrays.fill(h, 0, 2, 9);\r\n		System.out.println(\"Arrays.fill(h, 0, 2, 9);：\");\r\n		// 输出结果：993333666\r\n		for (int i : h) {\r\n			System.out.print(i);\r\n		}\r\n```\r\n\r\n### 转列表： asList（）\r\n\r\n```java\r\n		// *************转列表 asList()****************\r\n		/*\r\n		 * 返回由指定数组支持的固定大小的列表。\r\n		 * （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。\r\n		 * 返回的列表是可序列化的，并实现RandomAccess 。\r\n		 * 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：\r\n		 */\r\n		List<String> stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\r\n		System.out.println(stooges);\r\n```\r\n\r\n### 转字符串： toString（）\r\n\r\n```java\r\n        // *************转字符串 toString()****************\r\n        /*\r\n         * 返回指定数组的内容的字符串表示形式。\r\n         */\r\n        char[] k = { \'a\', \'f\', \'b\', \'c\', \'e\', \'A\', \'C\', \'B\' };\r\n        System.out.println(Arrays.toString(k));// [a, f, b, c, e, A, C, B]\r\n```\r\n\r\n### 复制： copyOf（）\r\n\r\n```java\r\n		// *************复制 copy****************\r\n		// copyOf 方法实现数组复制,h为数组，6为复制的长度\r\n        int[] h = { 1, 2, 3, 3, 3, 3, 6, 6, 6, };\r\n		int i[] = Arrays.copyOf(h, 6);\r\n		System.out.println(\"Arrays.copyOf(h, 6);：\");\r\n		// 输出结果：123333\r\n		for (int j : i) {\r\n			System.out.print(j);\r\n		}\r\n		// 换行\r\n		System.out.println();\r\n		// copyOfRange将指定数组的指定范围复制到新数组中\r\n		int j[] = Arrays.copyOfRange(h, 6, 11);\r\n		System.out.println(\"Arrays.copyOfRange(h, 6, 11)：\");\r\n		// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)\r\n		for (int j2 : j) {\r\n			System.out.print(j2);\r\n		}\r\n		// 换行\r\n		System.out.println();\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (191, 'Java ArrayList-Grow', 2, '\r\n## 一 先从 ArrayList 的构造函数说起\r\n\r\n**ArrayList有三种方式来初始化，构造方法源码如下：**\r\n\r\n```java\r\n   /**\r\n     * 默认初始容量大小\r\n     */\r\n    private static final int DEFAULT_CAPACITY = 10;\r\n    \r\n\r\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\r\n\r\n    /**\r\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\r\n     */\r\n    public ArrayList() {\r\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\r\n    }\r\n    \r\n    /**\r\n     * 带初始容量参数的构造函数。（用户自己指定容量）\r\n     */\r\n    public ArrayList(int initialCapacity) {\r\n        if (initialCapacity > 0) {//初始容量大于0\r\n            //创建initialCapacity大小的数组\r\n            this.elementData = new Object[initialCapacity];\r\n        } else if (initialCapacity == 0) {//初始容量等于0\r\n            //创建空数组\r\n            this.elementData = EMPTY_ELEMENTDATA;\r\n        } else {//初始容量小于0，抛出异常\r\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\r\n                                               initialCapacity);\r\n        }\r\n    }\r\n\r\n\r\n   /**\r\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\r\n    *如果指定的集合为null，throws NullPointerException。 \r\n    */\r\n     public ArrayList(Collection<? extends E> c) {\r\n        elementData = c.toArray();\r\n        if ((size = elementData.length) != 0) {\r\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\r\n            if (elementData.getClass() != Object[].class)\r\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\r\n        } else {\r\n            // replace with empty array.\r\n            this.elementData = EMPTY_ELEMENTDATA;\r\n        }\r\n    }\r\n\r\n```\r\n\r\n细心的同学一定会发现 ：**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。** 下面在我们分析 ArrayList 扩容时会讲到这一点内容！\r\n\r\n## 二 一步一步分析 ArrayList 扩容机制\r\n\r\n这里以无参构造函数创建的 ArrayList 为例分析\r\n\r\n### 1. 先来看 add（） 方法\r\n\r\n```java\r\n    /**\r\n     * 将指定的元素追加到此列表的末尾。 \r\n     */\r\n    public boolean add(E e) {\r\n   //添加元素之前，先调用ensureCapacityInternal方法\r\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\r\n        elementData[size++] = e;\r\n        return true;\r\n    }\r\n```\r\n### 2. 再来看看 ensureCapacityInternal() 方法\r\n\r\n可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\r\n\r\n```java\r\n   //得到最小扩容量\r\n    private void ensureCapacityInternal(int minCapacity) {\r\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\r\n              // 获取默认的容量和传入参数的较大值\r\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\r\n        }\r\n\r\n        ensureExplicitCapacity(minCapacity);\r\n    }\r\n```\r\n**当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。**\r\n\r\n### 3. ensureExplicitCapacity()方法 \r\n\r\n如果调用 `ensureCapacityInternal()` 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！\r\n\r\n```java\r\n  //判断是否需要扩容\r\n    private void ensureExplicitCapacity(int minCapacity) {\r\n        modCount++;\r\n\r\n        // overflow-conscious code\r\n        if (minCapacity - elementData.length > 0)\r\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\r\n            grow(minCapacity);\r\n    }\r\n\r\n```\r\n\r\n我们来仔细分析一下：\r\n\r\n- 当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为10。此时，`minCapacity - elementData.length > 0 `成立，所以会进入 `grow(minCapacity)` 方法。\r\n- 当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0 ` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\r\n- 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。\r\n\r\n直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。\r\n\r\n### 4. grow() 方法\r\n\r\n```java\r\n    /**\r\n     * 要分配的最大数组大小\r\n     */\r\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\r\n\r\n    /**\r\n     * ArrayList扩容的核心方法。\r\n     */\r\n    private void grow(int minCapacity) {\r\n        // oldCapacity为旧容量，newCapacity为新容量\r\n        int oldCapacity = elementData.length;\r\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\r\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\r\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\r\n        if (newCapacity - minCapacity < 0)\r\n            newCapacity = minCapacity;\r\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\r\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\r\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n            newCapacity = hugeCapacity(minCapacity);\r\n        // minCapacity is usually close to size, so this is a win:\r\n        elementData = Arrays.copyOf(elementData, newCapacity);\r\n    }\r\n```\r\n\r\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）**  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码\r\n\r\n>   \">>\"（移位运算符）：>>1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　\r\n\r\n**我们再来通过例子探究一下`grow()` 方法 ：**\r\n\r\n- 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 `hugeCapacity` 方法。数组容量为10，add方法中 return true,size增为1。\r\n- 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。\r\n- 以此类推······\r\n\r\n**这里补充一点比较重要，但是容易被忽视掉的知识点：**\r\n\r\n- java 中的 `length `属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\r\n- java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.\r\n- java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\r\n\r\n### 5. hugeCapacity()方法。\r\n\r\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 \r\n\r\n\r\n```java\r\n    private static int hugeCapacity(int minCapacity) {\r\n        if (minCapacity < 0) // overflow\r\n            throw new OutOfMemoryError();\r\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\r\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\r\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\r\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\r\n        return (minCapacity > MAX_ARRAY_SIZE) ?\r\n            Integer.MAX_VALUE :\r\n            MAX_ARRAY_SIZE;\r\n    }\r\n```\r\n\r\n\r\n\r\n## 三 System.arraycopy() 和 Arrays.copyOf()方法\r\n\r\n\r\n阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法！\r\n\r\n\r\n### 3.1 System.arraycopy() 方法\r\n\r\n```java\r\n    /**\r\n     * 在此列表中的指定位置插入指定的元素。 \r\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\r\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\r\n     */\r\n    public void add(int index, E element) {\r\n        rangeCheckForAdd(index);\r\n\r\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n        //arraycopy()方法实现数组自己复制自己\r\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\r\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\r\n        elementData[index] = element;\r\n        size++;\r\n    }\r\n```\r\n\r\n我们写一个简单的方法测试以下：\r\n\r\n```java\r\npublic class ArraycopyTest {\r\n\r\n	public static void main(String[] args) {\r\n		// TODO Auto-generated method stub\r\n		int[] a = new int[10];\r\n		a[0] = 0;\r\n		a[1] = 1;\r\n		a[2] = 2;\r\n		a[3] = 3;\r\n		System.arraycopy(a, 2, a, 3, 3);\r\n		a[2]=99;\r\n		for (int i = 0; i < a.length; i++) {\r\n			System.out.println(a[i]);\r\n		}\r\n	}\r\n\r\n}\r\n```\r\n\r\n结果：\r\n\r\n```\r\n0 1 99 2 3 0 0 0 0 0 \r\n```\r\n\r\n### 3.2 Arrays.copyOf()方法\r\n\r\n```java\r\n   /**\r\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 \r\n     */\r\n    public Object[] toArray() {\r\n    //elementData：要复制的数组；size：要复制的长度\r\n        return Arrays.copyOf(elementData, size);\r\n    }\r\n```\r\n\r\n个人觉得使用 `Arrays.copyOf()`方法主要是为了给原有数组扩容，测试代码如下：\r\n\r\n```java\r\npublic class ArrayscopyOfTest {\r\n\r\n	public static void main(String[] args) {\r\n		int[] a = new int[3];\r\n		a[0] = 0;\r\n		a[1] = 1;\r\n		a[2] = 2;\r\n		int[] b = Arrays.copyOf(a, 10);\r\n		System.out.println(\"b.length\"+b.length);\r\n	}\r\n}\r\n```\r\n\r\n结果：\r\n\r\n```\r\n10\r\n```\r\n\r\n\r\n### 3.3 两者联系和区别\r\n\r\n**联系：**\r\n\r\n看两者源代码可以发现 copyOf() 内部实际调用了 `System.arraycopy()` 方法 \r\n\r\n**区别：**\r\n\r\n`arraycopy()` 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 `copyOf()` 是系统自动在内部新建一个数组，并返回该数组。\r\n\r\n\r\n\r\n## 四 ensureCapacity()方法\r\nArrayList 源码中有一个 `ensureCapacity()` 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\r\n\r\n```java\r\n    /**\r\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\r\n     *\r\n     * @param   minCapacity   所需的最小容量\r\n     */\r\n    public void ensureCapacity(int minCapacity) {\r\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\r\n            // any size if not default element table\r\n            ? 0\r\n            // larger than default for default empty table. It\'s already\r\n            // supposed to be at default size.\r\n            : DEFAULT_CAPACITY;\r\n\r\n        if (minCapacity > minExpand) {\r\n            ensureExplicitCapacity(minCapacity);\r\n        }\r\n    }\r\n\r\n```\r\n\r\n**最好在 add 大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数**\r\n\r\n我们通过下面的代码实际测试以下这个方法的效果：\r\n\r\n```java\r\npublic class EnsureCapacityTest {\r\n	public static void main(String[] args) {\r\n		ArrayList<Object> list = new ArrayList<Object>();\r\n		final int N = 10000000;\r\n		long startTime = System.currentTimeMillis();\r\n		for (int i = 0; i < N; i++) {\r\n			list.add(i);\r\n		}\r\n		long endTime = System.currentTimeMillis();\r\n		System.out.println(\"使用ensureCapacity方法前：\"+(endTime - startTime));\r\n\r\n		list = new ArrayList<Object>();\r\n		long startTime1 = System.currentTimeMillis();\r\n		list.ensureCapacity(N);\r\n		for (int i = 0; i < N; i++) {\r\n			list.add(i);\r\n		}\r\n		long endTime1 = System.currentTimeMillis();\r\n		System.out.println(\"使用ensureCapacity方法后：\"+(endTime1 - startTime1));\r\n	}\r\n}\r\n```\r\n\r\n运行结果：\r\n\r\n```\r\n使用ensureCapacity方法前：4637\r\n使用ensureCapacity方法后：241\r\n\r\n```\r\n\r\n通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用`ensureCapacity()` 方法，以减少增量重新分配的次数\r\n', 0);
INSERT INTO `blog_course` VALUES (192, 'Java ArrayList', 2, '<!-- MarkdownTOC -->\r\n\r\n- [ArrayList简介](#ArrayList简介)\r\n- [ArrayList核心源码](#ArrayList核心源码)\r\n- [ArrayList源码分析](#ArrayList源码分析)\r\n    - [System.arraycopy\\(\\)和Arrays.copyOf\\(\\)方法](#System.arraycopy（）和Arrays.copyOf（）方法)\r\n        - [两者联系与区别](#两者联系与区别)\r\n    - [ArrayList核心扩容技术](#ArrayList 核心扩容技术)\r\n    - [内部类](#内部类)\r\n- [ArrayList经典Demo](#ArrayList经典Demo)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n\r\n### ArrayList简介\r\n　　ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用`ensureCapacity`操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。\r\n    \r\n   它继承于 **AbstractList**，实现了 **List**, **RandomAccess**, **Cloneable**, **java.io.Serializable** 这些接口。\r\n    \r\n   在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为**O（n）**,求表长以及增加元素，取第 i   元素的时间复杂度为**O（1）**\r\n\r\n　  ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\r\n\r\n　　ArrayList 实现了**RandomAccess 接口**， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持**快速随机访问**的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\r\n\r\n　　ArrayList 实现了**Cloneable 接口**，即覆盖了函数 clone()，**能被克隆**。\r\n\r\n　　ArrayList 实现**java.io.Serializable 接口**，这意味着ArrayList**支持序列化**，**能通过序列化去传输**。\r\n\r\n　　和 Vector 不同，**ArrayList 中的操作不是线程安全的**！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者  CopyOnWriteArrayList。\r\n### ArrayList核心源码\r\n\r\n```java\r\npackage java.util;\r\n\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Predicate;\r\nimport java.util.function.UnaryOperator;\r\n\r\n\r\npublic class ArrayList<E> extends AbstractList<E>\r\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\r\n{\r\n    private static final long serialVersionUID = 8683452581122892189L;\r\n\r\n    /**\r\n     * 默认初始容量大小\r\n     */\r\n    private static final int DEFAULT_CAPACITY = 10;\r\n\r\n    /**\r\n     * 空数组（用于空实例）。\r\n     */\r\n    private static final Object[] EMPTY_ELEMENTDATA = {};\r\n\r\n     //用于默认大小空实例的共享空数组实例。\r\n      //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\r\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\r\n\r\n    /**\r\n     * 保存ArrayList数据的数组\r\n     */\r\n    transient Object[] elementData; // non-private to simplify nested class access\r\n\r\n    /**\r\n     * ArrayList 所包含的元素个数\r\n     */\r\n    private int size;\r\n\r\n    /**\r\n     * 带初始容量参数的构造函数。（用户自己指定容量）\r\n     */\r\n    public ArrayList(int initialCapacity) {\r\n        if (initialCapacity > 0) {\r\n            //创建initialCapacity大小的数组\r\n            this.elementData = new Object[initialCapacity];\r\n        } else if (initialCapacity == 0) {\r\n            //创建空数组\r\n            this.elementData = EMPTY_ELEMENTDATA;\r\n        } else {\r\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\r\n                                               initialCapacity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\r\n     */\r\n    public ArrayList() {\r\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\r\n    }\r\n\r\n    /**\r\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\r\n     */\r\n    public ArrayList(Collection<? extends E> c) {\r\n        //\r\n        elementData = c.toArray();\r\n        //如果指定集合元素个数不为0\r\n        if ((size = elementData.length) != 0) {\r\n            // c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，\r\n            //这里用到了反射里面的getClass()方法\r\n            if (elementData.getClass() != Object[].class)\r\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\r\n        } else {\r\n            // 用空数组代替\r\n            this.elementData = EMPTY_ELEMENTDATA;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 \r\n     */\r\n    public void trimToSize() {\r\n        modCount++;\r\n        if (size < elementData.length) {\r\n            elementData = (size == 0)\r\n              ? EMPTY_ELEMENTDATA\r\n              : Arrays.copyOf(elementData, size);\r\n        }\r\n    }\r\n//下面是ArrayList的扩容机制\r\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\r\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\r\n    /**\r\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\r\n     * @param   minCapacity   所需的最小容量\r\n     */\r\n    public void ensureCapacity(int minCapacity) {\r\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\r\n            // any size if not default element table\r\n            ? 0\r\n            // larger than default for default empty table. It\'s already\r\n            // supposed to be at default size.\r\n            : DEFAULT_CAPACITY;\r\n\r\n        if (minCapacity > minExpand) {\r\n            ensureExplicitCapacity(minCapacity);\r\n        }\r\n    }\r\n   //得到最小扩容量\r\n    private void ensureCapacityInternal(int minCapacity) {\r\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\r\n              // 获取默认的容量和传入参数的较大值\r\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\r\n        }\r\n\r\n        ensureExplicitCapacity(minCapacity);\r\n    }\r\n  //判断是否需要扩容\r\n    private void ensureExplicitCapacity(int minCapacity) {\r\n        modCount++;\r\n\r\n        // overflow-conscious code\r\n        if (minCapacity - elementData.length > 0)\r\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\r\n            grow(minCapacity);\r\n    }\r\n\r\n    /**\r\n     * 要分配的最大数组大小\r\n     */\r\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\r\n\r\n    /**\r\n     * ArrayList扩容的核心方法。\r\n     */\r\n    private void grow(int minCapacity) {\r\n        // oldCapacity为旧容量，newCapacity为新容量\r\n        int oldCapacity = elementData.length;\r\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\r\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\r\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\r\n        if (newCapacity - minCapacity < 0)\r\n            newCapacity = minCapacity;\r\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\r\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\r\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\r\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n            newCapacity = hugeCapacity(minCapacity);\r\n        // minCapacity is usually close to size, so this is a win:\r\n        elementData = Arrays.copyOf(elementData, newCapacity);\r\n    }\r\n    //比较minCapacity和 MAX_ARRAY_SIZE\r\n    private static int hugeCapacity(int minCapacity) {\r\n        if (minCapacity < 0) // overflow\r\n            throw new OutOfMemoryError();\r\n        return (minCapacity > MAX_ARRAY_SIZE) ?\r\n            Integer.MAX_VALUE :\r\n            MAX_ARRAY_SIZE;\r\n    }\r\n\r\n    /**\r\n     *返回此列表中的元素数。 \r\n     */\r\n    public int size() {\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * 如果此列表不包含元素，则返回 true 。\r\n     */\r\n    public boolean isEmpty() {\r\n        //注意=和==的区别\r\n        return size == 0;\r\n    }\r\n\r\n    /**\r\n     * 如果此列表包含指定的元素，则返回true 。\r\n     */\r\n    public boolean contains(Object o) {\r\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \r\n        return indexOf(o) >= 0;\r\n    }\r\n\r\n    /**\r\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \r\n     */\r\n    public int indexOf(Object o) {\r\n        if (o == null) {\r\n            for (int i = 0; i < size; i++)\r\n                if (elementData[i]==null)\r\n                    return i;\r\n        } else {\r\n            for (int i = 0; i < size; i++)\r\n                //equals()方法比较\r\n                if (o.equals(elementData[i]))\r\n                    return i;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\r\n     */\r\n    public int lastIndexOf(Object o) {\r\n        if (o == null) {\r\n            for (int i = size-1; i >= 0; i--)\r\n                if (elementData[i]==null)\r\n                    return i;\r\n        } else {\r\n            for (int i = size-1; i >= 0; i--)\r\n                if (o.equals(elementData[i]))\r\n                    return i;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） \r\n     */\r\n    public Object clone() {\r\n        try {\r\n            ArrayList<?> v = (ArrayList<?>) super.clone();\r\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\r\n            v.elementData = Arrays.copyOf(elementData, size);\r\n            v.modCount = 0;\r\n            return v;\r\n        } catch (CloneNotSupportedException e) {\r\n            // 这不应该发生，因为我们是可以克隆的\r\n            throw new InternalError(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \r\n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\r\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\r\n     */\r\n    public Object[] toArray() {\r\n        return Arrays.copyOf(elementData, size);\r\n    }\r\n\r\n    /**\r\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; \r\n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 \r\n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 \r\n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\r\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） \r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public <T> T[] toArray(T[] a) {\r\n        if (a.length < size)\r\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\r\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\r\n            //调用System提供的arraycopy()方法实现数组之间的复制\r\n        System.arraycopy(elementData, 0, a, 0, size);\r\n        if (a.length > size)\r\n            a[size] = null;\r\n        return a;\r\n    }\r\n\r\n    // Positional Access Operations\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    E elementData(int index) {\r\n        return (E) elementData[index];\r\n    }\r\n\r\n    /**\r\n     * 返回此列表中指定位置的元素。\r\n     */\r\n    public E get(int index) {\r\n        rangeCheck(index);\r\n\r\n        return elementData(index);\r\n    }\r\n\r\n    /**\r\n     * 用指定的元素替换此列表中指定位置的元素。 \r\n     */\r\n    public E set(int index, E element) {\r\n        //对index进行界限检查\r\n        rangeCheck(index);\r\n\r\n        E oldValue = elementData(index);\r\n        elementData[index] = element;\r\n        //返回原来在这个位置的元素\r\n        return oldValue;\r\n    }\r\n\r\n    /**\r\n     * 将指定的元素追加到此列表的末尾。 \r\n     */\r\n    public boolean add(E e) {\r\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\r\n        elementData[size++] = e;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 在此列表中的指定位置插入指定的元素。 \r\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\r\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\r\n     */\r\n    public void add(int index, E element) {\r\n        rangeCheckForAdd(index);\r\n\r\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\r\n        System.arraycopy(elementData, index, elementData, index + 1,\r\n                         size - index);\r\n        elementData[index] = element;\r\n        size++;\r\n    }\r\n\r\n    /**\r\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 \r\n     */\r\n    public E remove(int index) {\r\n        rangeCheck(index);\r\n\r\n        modCount++;\r\n        E oldValue = elementData(index);\r\n\r\n        int numMoved = size - index - 1;\r\n        if (numMoved > 0)\r\n            System.arraycopy(elementData, index+1, elementData, index,\r\n                             numMoved);\r\n        elementData[--size] = null; // clear to let GC do its work\r\n      //从列表中删除的元素 \r\n        return oldValue;\r\n    }\r\n\r\n    /**\r\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\r\n     *返回true，如果此列表包含指定的元素\r\n     */\r\n    public boolean remove(Object o) {\r\n        if (o == null) {\r\n            for (int index = 0; index < size; index++)\r\n                if (elementData[index] == null) {\r\n                    fastRemove(index);\r\n                    return true;\r\n                }\r\n        } else {\r\n            for (int index = 0; index < size; index++)\r\n                if (o.equals(elementData[index])) {\r\n                    fastRemove(index);\r\n                    return true;\r\n                }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     * Private remove method that skips bounds checking and does not\r\n     * return the value removed.\r\n     */\r\n    private void fastRemove(int index) {\r\n        modCount++;\r\n        int numMoved = size - index - 1;\r\n        if (numMoved > 0)\r\n            System.arraycopy(elementData, index+1, elementData, index,\r\n                             numMoved);\r\n        elementData[--size] = null; // clear to let GC do its work\r\n    }\r\n\r\n    /**\r\n     * 从列表中删除所有元素。 \r\n     */\r\n    public void clear() {\r\n        modCount++;\r\n\r\n        // 把数组中所有的元素的值设为null\r\n        for (int i = 0; i < size; i++)\r\n            elementData[i] = null;\r\n\r\n        size = 0;\r\n    }\r\n\r\n    /**\r\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\r\n     */\r\n    public boolean addAll(Collection<? extends E> c) {\r\n        Object[] a = c.toArray();\r\n        int numNew = a.length;\r\n        ensureCapacityInternal(size + numNew);  // Increments modCount\r\n        System.arraycopy(a, 0, elementData, size, numNew);\r\n        size += numNew;\r\n        return numNew != 0;\r\n    }\r\n\r\n    /**\r\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\r\n     */\r\n    public boolean addAll(int index, Collection<? extends E> c) {\r\n        rangeCheckForAdd(index);\r\n\r\n        Object[] a = c.toArray();\r\n        int numNew = a.length;\r\n        ensureCapacityInternal(size + numNew);  // Increments modCount\r\n\r\n        int numMoved = size - index;\r\n        if (numMoved > 0)\r\n            System.arraycopy(elementData, index, elementData, index + numNew,\r\n                             numMoved);\r\n\r\n        System.arraycopy(a, 0, elementData, index, numNew);\r\n        size += numNew;\r\n        return numNew != 0;\r\n    }\r\n\r\n    /**\r\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\r\n     *将任何后续元素移动到左侧（减少其索引）。\r\n     */\r\n    protected void removeRange(int fromIndex, int toIndex) {\r\n        modCount++;\r\n        int numMoved = size - toIndex;\r\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\r\n                         numMoved);\r\n\r\n        // clear to let GC do its work\r\n        int newSize = size - (toIndex-fromIndex);\r\n        for (int i = newSize; i < size; i++) {\r\n            elementData[i] = null;\r\n        }\r\n        size = newSize;\r\n    }\r\n\r\n    /**\r\n     * 检查给定的索引是否在范围内。\r\n     */\r\n    private void rangeCheck(int index) {\r\n        if (index >= size)\r\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\r\n    }\r\n\r\n    /**\r\n     * add和addAll使用的rangeCheck的一个版本\r\n     */\r\n    private void rangeCheckForAdd(int index) {\r\n        if (index > size || index < 0)\r\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\r\n    }\r\n\r\n    /**\r\n     * 返回IndexOutOfBoundsException细节信息\r\n     */\r\n    private String outOfBoundsMsg(int index) {\r\n        return \"Index: \"+index+\", Size: \"+size;\r\n    }\r\n\r\n    /**\r\n     * 从此列表中删除指定集合中包含的所有元素。 \r\n     */\r\n    public boolean removeAll(Collection<?> c) {\r\n        Objects.requireNonNull(c);\r\n        //如果此列表被修改则返回true\r\n        return batchRemove(c, false);\r\n    }\r\n\r\n    /**\r\n     * 仅保留此列表中包含在指定集合中的元素。\r\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 \r\n     */\r\n    public boolean retainAll(Collection<?> c) {\r\n        Objects.requireNonNull(c);\r\n        return batchRemove(c, true);\r\n    }\r\n\r\n\r\n    /**\r\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\r\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 \r\n     *返回的列表迭代器是fail-fast 。 \r\n     */\r\n    public ListIterator<E> listIterator(int index) {\r\n        if (index < 0 || index > size)\r\n            throw new IndexOutOfBoundsException(\"Index: \"+index);\r\n        return new ListItr(index);\r\n    }\r\n\r\n    /**\r\n     *返回列表中的列表迭代器（按适当的顺序）。 \r\n     *返回的列表迭代器是fail-fast 。\r\n     */\r\n    public ListIterator<E> listIterator() {\r\n        return new ListItr(0);\r\n    }\r\n\r\n    /**\r\n     *以正确的顺序返回该列表中的元素的迭代器。 \r\n     *返回的迭代器是fail-fast 。 \r\n     */\r\n    public Iterator<E> iterator() {\r\n        return new Itr();\r\n    }\r\n\r\n  \r\n```\r\n### ArrayList源码分析\r\n####  System.arraycopy（）和Arrays.copyOf（）方法\r\n　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:\r\n```java \r\n    /**\r\n     * 在此列表中的指定位置插入指定的元素。 \r\n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\r\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\r\n     */\r\n    public void add(int index, E element) {\r\n        rangeCheckForAdd(index);\r\n\r\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\r\n        //arraycopy()方法实现数组自己复制自己\r\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\r\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\r\n        elementData[index] = element;\r\n        size++;\r\n    }\r\n```\r\n又如toArray()方法中用到了copyOf()方法\r\n```java\r\n\r\n    /**\r\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \r\n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\r\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\r\n     */\r\n    public Object[] toArray() {\r\n    //elementData：要复制的数组；size：要复制的长度\r\n        return Arrays.copyOf(elementData, size);\r\n    }\r\n```\r\n##### 两者联系与区别\r\n**联系：**\r\n看两者源代码可以发现`copyOf()`内部调用了`System.arraycopy()`方法\r\n**区别：**\r\n1. arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\r\n2. copyOf()是系统自动在内部新建一个数组，并返回该数组。\r\n#### ArrayList 核心扩容技术\r\n```java\r\n//下面是ArrayList的扩容机制\r\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\r\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\r\n    /**\r\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\r\n     * @param   minCapacity   所需的最小容量\r\n     */\r\n    public void ensureCapacity(int minCapacity) {\r\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\r\n            // any size if not default element table\r\n            ? 0\r\n            // larger than default for default empty table. It\'s already\r\n            // supposed to be at default size.\r\n            : DEFAULT_CAPACITY;\r\n\r\n        if (minCapacity > minExpand) {\r\n            ensureExplicitCapacity(minCapacity);\r\n        }\r\n    }\r\n   //得到最小扩容量\r\n    private void ensureCapacityInternal(int minCapacity) {\r\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\r\n              // 获取默认的容量和传入参数的较大值\r\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\r\n        }\r\n\r\n        ensureExplicitCapacity(minCapacity);\r\n    }\r\n  //判断是否需要扩容,上面两个方法都要调用\r\n    private void ensureExplicitCapacity(int minCapacity) {\r\n        modCount++;\r\n\r\n        // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。\r\n        //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1\r\n        if (minCapacity - elementData.length > 0)\r\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\r\n            grow(minCapacity);\r\n    }\r\n\r\n```\r\n```java\r\n    /**\r\n     * ArrayList扩容的核心方法。\r\n     */\r\n    private void grow(int minCapacity) {\r\n       //elementData为保存ArrayList数据的数组\r\n       ///elementData.length求数组长度elementData.size是求数组中的元素个数\r\n        // oldCapacity为旧容量，newCapacity为新容量\r\n        int oldCapacity = elementData.length;\r\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\r\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\r\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\r\n        if (newCapacity - minCapacity < 0)\r\n            newCapacity = minCapacity;\r\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\r\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\r\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\r\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n            newCapacity = hugeCapacity(minCapacity);\r\n        // minCapacity is usually close to size, so this is a win:\r\n        elementData = Arrays.copyOf(elementData, newCapacity);\r\n    }\r\n    \r\n```\r\n　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：**移位运算符**\r\n　　**简介**：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\"><<(左移)</font>、<font color=\"red\">>>(带符号右移)</font>和<font color=\"red\">>>>(无符号右移)</font>。\r\n　　**作用**：**对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源**\r\n　　比如这里：int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。\r\n\r\n**另外需要注意的是：**\r\n\r\n1. java 中的**length 属性**是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\r\n\r\n2. java 中的**length()方法**是针对字  符串String说的,如果想看这个字符串的长度则用到 length()这个方法.\r\n\r\n3. .java 中的**size()方法**是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\r\n\r\n\r\n#### 内部类\r\n```java\r\n    (1)private class Itr implements Iterator<E>  \r\n    (2)private class ListItr extends Itr implements ListIterator<E>  \r\n    (3)private class SubList extends AbstractList<E> implements RandomAccess  \r\n    (4)static final class ArrayListSpliterator<E> implements Spliterator<E>  \r\n```\r\n　　ArrayList有四个内部类，其中的**Itr是实现了Iterator接口**，同时重写了里面的**hasNext()**，**next()**，**remove()**等方法；其中的**ListItr**继承**Itr**，实现了**ListIterator接口**，同时重写了**hasPrevious()**，**nextIndex()**，**previousIndex()**，**previous()**，**set(E e)**，**add(E e)**等方法，所以这也可以看出了 **Iterator和ListIterator的区别:**ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。\r\n### ArrayList经典Demo\r\n\r\n```java\r\npackage list;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\npublic class ArrayListDemo {\r\n\r\n    public static void main(String[] srgs){\r\n         ArrayList<Integer> arrayList = new ArrayList<Integer>();\r\n\r\n         System.out.printf(\"Before add:arrayList.size() = %d\\n\",arrayList.size());\r\n\r\n         arrayList.add(1);\r\n         arrayList.add(3);\r\n         arrayList.add(5);\r\n         arrayList.add(7);\r\n         arrayList.add(9);\r\n         System.out.printf(\"After add:arrayList.size() = %d\\n\",arrayList.size());\r\n\r\n         System.out.println(\"Printing elements of arrayList\");\r\n         // 三种遍历方式打印元素\r\n         // 第一种：通过迭代器遍历\r\n         System.out.print(\"通过迭代器遍历:\");\r\n         Iterator<Integer> it = arrayList.iterator();\r\n         while(it.hasNext()){\r\n             System.out.print(it.next() + \" \");\r\n         }\r\n         System.out.println();\r\n\r\n         // 第二种：通过索引值遍历\r\n         System.out.print(\"通过索引值遍历:\");\r\n         for(int i = 0; i < arrayList.size(); i++){\r\n             System.out.print(arrayList.get(i) + \" \");\r\n         }\r\n         System.out.println();\r\n\r\n         // 第三种：for循环遍历\r\n         System.out.print(\"for循环遍历:\");\r\n         for(Integer number : arrayList){\r\n             System.out.print(number + \" \");\r\n         }\r\n\r\n         // toArray用法\r\n         // 第一种方式(最常用)\r\n         Integer[] integer = arrayList.toArray(new Integer[0]);\r\n\r\n         // 第二种方式(容易理解)\r\n         Integer[] integer1 = new Integer[arrayList.size()];\r\n         arrayList.toArray(integer1);\r\n\r\n         // 抛出异常，java不支持向下转型\r\n         //Integer[] integer2 = new Integer[arrayList.size()];\r\n         //integer2 = arrayList.toArray();\r\n         System.out.println();\r\n\r\n         // 在指定位置添加元素\r\n         arrayList.add(2,2);\r\n         // 删除指定位置上的元素\r\n         arrayList.remove(2);    \r\n         // 删除指定元素\r\n         arrayList.remove((Object)3);\r\n         // 判断arrayList是否包含5\r\n         System.out.println(\"ArrayList contains 5 is: \" + arrayList.contains(5));\r\n\r\n         // 清空ArrayList\r\n         arrayList.clear();\r\n         // 判断ArrayList是否为空\r\n         System.out.println(\"ArrayList is empty: \" + arrayList.isEmpty());\r\n    }\r\n}\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (193, 'Java LinkedList', 2, '\r\n<!-- MarkdownTOC -->\r\n\r\n- [简介](#简介)\r\n- [内部结构分析](#内部结构分析)\r\n- [LinkedList源码分析](#源码分析)\r\n    - [构造方法](#构造方法)\r\n    - [添加（add）方法](#add方法)\r\n    - [根据位置取数据的方法](#根据位置取数据的方法)\r\n    - [根据对象得到索引的方法](#根据对象得到索引的方法)\r\n    - [检查链表是否包含某对象的方法](#检查链表是否包含某对象的方法)\r\n    - [删除（remove/pop）方法](#删除方法)\r\n- [LinkedList类常用方法测试](#LinkedList类常用方法测试)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n## 简介\r\n\r\nLinkedList是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。\r\nLinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;\r\nLinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法：\r\n```java\r\nList list=Collections.synchronizedList(new LinkedList(...));\r\n```\r\n## 内部结构分析\r\n\r\n**如下图所示：**\r\n![LinkedList内部结构](https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&h=481&f=jpeg&s=18502)\r\n看完了图之后，我们再看LinkedList类中的一个<font color=\"red\">**内部私有类Node**</font>就很好理解了：\r\n```java\r\nprivate static class Node<E> {\r\n        E item;//节点值\r\n        Node<E> next;//后继节点\r\n        Node<E> prev;//前驱节点\r\n\r\n        Node(Node<E> prev, E element, Node<E> next) {\r\n            this.item = element;\r\n            this.next = next;\r\n            this.prev = prev;\r\n        }\r\n    }\r\n```\r\n这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。\r\n\r\n## 源码分析\r\n### 构造方法\r\n**空构造方法：**\r\n```java\r\n    public LinkedList() {\r\n    }\r\n```\r\n**用已有的集合创建链表的构造方法：**\r\n```java\r\n    public LinkedList(Collection<? extends E> c) {\r\n        this();\r\n        addAll(c);\r\n    }\r\n```\r\n### add方法\r\n**add(E e)** 方法：将元素添加到链表尾部\r\n```java\r\npublic boolean add(E e) {\r\n        linkLast(e);//这里就只调用了这一个方法\r\n        return true;\r\n    }\r\n```\r\n\r\n```java\r\n   /**\r\n     * 链接使e作为最后一个元素。\r\n     */\r\n    void linkLast(E e) {\r\n        final Node<E> l = last;\r\n        final Node<E> newNode = new Node<>(l, e, null);\r\n        last = newNode;//新建节点\r\n        if (l == null)\r\n            first = newNode;\r\n        else\r\n            l.next = newNode;//指向后继元素也就是指向下一个元素\r\n        size++;\r\n        modCount++;\r\n    }\r\n```\r\n**add(int index,E e)**：在指定位置添加元素\r\n```java\r\npublic void add(int index, E element) {\r\n        checkPositionIndex(index); //检查索引是否处于[0-size]之间\r\n\r\n        if (index == size)//添加在链表尾部\r\n            linkLast(element);\r\n        else//添加在链表中间\r\n            linkBefore(element, node(index));\r\n    }\r\n```\r\n<font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\r\n\r\n**addAll(Collection  c )：将集合插入到链表尾部**\r\n\r\n```java\r\npublic boolean addAll(Collection<? extends E> c) {\r\n        return addAll(size, c);\r\n    }\r\n```\r\n**addAll(int index, Collection c)：** 将集合从指定位置开始插入\r\n```java\r\npublic boolean addAll(int index, Collection<? extends E> c) {\r\n        //1:检查index范围是否在size之内\r\n        checkPositionIndex(index);\r\n\r\n        //2:toArray()方法把集合的数据存到对象数组中\r\n        Object[] a = c.toArray();\r\n        int numNew = a.length;\r\n        if (numNew == 0)\r\n            return false;\r\n\r\n        //3：得到插入位置的前驱节点和后继节点\r\n        Node<E> pred, succ;\r\n        //如果插入位置为尾部，前驱节点为last，后继节点为null\r\n        if (index == size) {\r\n            succ = null;\r\n            pred = last;\r\n        }\r\n        //否则，调用node()方法得到后继节点，再得到前驱节点\r\n        else {\r\n            succ = node(index);\r\n            pred = succ.prev;\r\n        }\r\n\r\n        // 4：遍历数据将数据插入\r\n        for (Object o : a) {\r\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\r\n            //创建新节点\r\n            Node<E> newNode = new Node<>(pred, e, null);\r\n            //如果插入位置在链表头部\r\n            if (pred == null)\r\n                first = newNode;\r\n            else\r\n                pred.next = newNode;\r\n            pred = newNode;\r\n        }\r\n\r\n        //如果插入位置在尾部，重置last节点\r\n        if (succ == null) {\r\n            last = pred;\r\n        }\r\n        //否则，将插入的链表与先前链表连接起来\r\n        else {\r\n            pred.next = succ;\r\n            succ.prev = pred;\r\n        }\r\n\r\n        size += numNew;\r\n        modCount++;\r\n        return true;\r\n    }    \r\n```\r\n上面可以看出addAll方法通常包括下面四个步骤：\r\n1. 检查index范围是否在size之内\r\n2. toArray()方法把集合的数据存到对象数组中\r\n3. 得到插入位置的前驱和后继节点\r\n4. 遍历数据，将数据插入到指定位置\r\n\r\n**addFirst(E e)：** 将元素添加到链表头部\r\n```java\r\n public void addFirst(E e) {\r\n        linkFirst(e);\r\n    }\r\n```\r\n```java\r\nprivate void linkFirst(E e) {\r\n        final Node<E> f = first;\r\n        final Node<E> newNode = new Node<>(null, e, f);//新建节点，以头节点为后继节点\r\n        first = newNode;\r\n        //如果链表为空，last节点也指向该节点\r\n        if (f == null)\r\n            last = newNode;\r\n        //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素\r\n        else\r\n            f.prev = newNode;\r\n        size++;\r\n        modCount++;\r\n    }\r\n```\r\n**addLast(E e)：** 将元素添加到链表尾部，与 **add(E e)** 方法一样\r\n```java\r\npublic void addLast(E e) {\r\n        linkLast(e);\r\n    }\r\n```\r\n### 根据位置取数据的方法\r\n**get(int index)：** 根据指定索引返回数据\r\n```java\r\npublic E get(int index) {\r\n        //检查index范围是否在size之内\r\n        checkElementIndex(index);\r\n        //调用Node(index)去找到index对应的node然后返回它的值\r\n        return node(index).item;\r\n    }\r\n```\r\n**获取头节点（index=0）数据方法:**\r\n```java\r\npublic E getFirst() {\r\n        final Node<E> f = first;\r\n        if (f == null)\r\n            throw new NoSuchElementException();\r\n        return f.item;\r\n    }\r\npublic E element() {\r\n        return getFirst();\r\n    }\r\npublic E peek() {\r\n        final Node<E> f = first;\r\n        return (f == null) ? null : f.item;\r\n    }\r\n\r\npublic E peekFirst() {\r\n        final Node<E> f = first;\r\n        return (f == null) ? null : f.item;\r\n     }\r\n```\r\n**区别：**\r\ngetFirst(),element(),peek(),peekFirst()\r\n这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中**getFirst()** 和**element()** 方法将会在链表为空时，抛出异常\r\n\r\nelement()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException  \r\n**获取尾节点（index=-1）数据方法:**\r\n```java\r\n public E getLast() {\r\n        final Node<E> l = last;\r\n        if (l == null)\r\n            throw new NoSuchElementException();\r\n        return l.item;\r\n    }\r\n public E peekLast() {\r\n        final Node<E> l = last;\r\n        return (l == null) ? null : l.item;\r\n    }\r\n```\r\n**两者区别：**\r\n**getLast()** 方法在链表为空时，会抛出**NoSuchElementException**，而**peekLast()** 则不会，只是会返回 **null**。\r\n### 根据对象得到索引的方法\r\n**int indexOf(Object o)：** 从头遍历找\r\n```java\r\npublic int indexOf(Object o) {\r\n        int index = 0;\r\n        if (o == null) {\r\n            //从头遍历\r\n            for (Node<E> x = first; x != null; x = x.next) {\r\n                if (x.item == null)\r\n                    return index;\r\n                index++;\r\n            }\r\n        } else {\r\n            //从头遍历\r\n            for (Node<E> x = first; x != null; x = x.next) {\r\n                if (o.equals(x.item))\r\n                    return index;\r\n                index++;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n```\r\n**int lastIndexOf(Object o)：** 从尾遍历找\r\n```java\r\npublic int lastIndexOf(Object o) {\r\n        int index = size;\r\n        if (o == null) {\r\n            //从尾遍历\r\n            for (Node<E> x = last; x != null; x = x.prev) {\r\n                index--;\r\n                if (x.item == null)\r\n                    return index;\r\n            }\r\n        } else {\r\n            //从尾遍历\r\n            for (Node<E> x = last; x != null; x = x.prev) {\r\n                index--;\r\n                if (o.equals(x.item))\r\n                    return index;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n```\r\n### 检查链表是否包含某对象的方法\r\n**contains(Object o)：** 检查对象o是否存在于链表中\r\n```java\r\n public boolean contains(Object o) {\r\n        return indexOf(o) != -1;\r\n    }\r\n```\r\n### 删除方法\r\n**remove()** ,**removeFirst(),pop():** 删除头节点\r\n```\r\npublic E pop() {\r\n        return removeFirst();\r\n    }\r\npublic E remove() {\r\n        return removeFirst();\r\n    }\r\npublic E removeFirst() {\r\n        final Node<E> f = first;\r\n        if (f == null)\r\n            throw new NoSuchElementException();\r\n        return unlinkFirst(f);\r\n    }\r\n```\r\n**removeLast(),pollLast():** 删除尾节点\r\n```java\r\npublic E removeLast() {\r\n        final Node<E> l = last;\r\n        if (l == null)\r\n            throw new NoSuchElementException();\r\n        return unlinkLast(l);\r\n    }\r\npublic E pollLast() {\r\n        final Node<E> l = last;\r\n        return (l == null) ? null : unlinkLast(l);\r\n    }\r\n```\r\n**区别：** removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。\r\n\r\n**remove(Object o):** 删除指定元素\r\n```java\r\npublic boolean remove(Object o) {\r\n        //如果删除对象为null\r\n        if (o == null) {\r\n            //从头开始遍历\r\n            for (Node<E> x = first; x != null; x = x.next) {\r\n                //找到元素\r\n                if (x.item == null) {\r\n                   //从链表中移除找到的元素\r\n                    unlink(x);\r\n                    return true;\r\n                }\r\n            }\r\n        } else {\r\n            //从头开始遍历\r\n            for (Node<E> x = first; x != null; x = x.next) {\r\n                //找到元素\r\n                if (o.equals(x.item)) {\r\n                    //从链表中移除找到的元素\r\n                    unlink(x);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n```\r\n当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。\r\n\r\nunlink(Node<E> x) 方法：\r\n```java\r\nE unlink(Node<E> x) {\r\n        // assert x != null;\r\n        final E element = x.item;\r\n        final Node<E> next = x.next;//得到后继节点\r\n        final Node<E> prev = x.prev;//得到前驱节点\r\n\r\n        //删除前驱指针\r\n        if (prev == null) {\r\n            first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点\r\n        } else {\r\n            prev.next = next;//将前驱节点的后继节点指向后继节点\r\n            x.prev = null;\r\n        }\r\n\r\n        //删除后继指针\r\n        if (next == null) {\r\n            last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\r\n        } else {\r\n            next.prev = prev;\r\n            x.next = null;\r\n        }\r\n\r\n        x.item = null;\r\n        size--;\r\n        modCount++;\r\n        return element;\r\n    }\r\n```\r\n**remove(int index)**：删除指定位置的元素\r\n```java\r\npublic E remove(int index) {\r\n        //检查index范围\r\n        checkElementIndex(index);\r\n        //将节点删除\r\n        return unlink(node(index));\r\n    }\r\n```\r\n## LinkedList类常用方法测试\r\n```java\r\npackage list;\r\n\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\n\r\npublic class LinkedListDemo {\r\n    public static void main(String[] srgs) {\r\n        //创建存放int类型的linkedList\r\n        LinkedList<Integer> linkedList = new LinkedList<>();\r\n        /************************** linkedList的基本操作 ************************/\r\n        linkedList.addFirst(0); // 添加元素到列表开头\r\n        linkedList.add(1); // 在列表结尾添加元素\r\n        linkedList.add(2, 2); // 在指定位置添加元素\r\n        linkedList.addLast(3); // 添加元素到列表结尾\r\n        \r\n        System.out.println(\"LinkedList（直接输出的）: \" + linkedList);\r\n\r\n        System.out.println(\"getFirst()获得第一个元素: \" + linkedList.getFirst()); // 返回此列表的第一个元素\r\n        System.out.println(\"getLast()获得第最后一个元素: \" + linkedList.getLast()); // 返回此列表的最后一个元素\r\n        System.out.println(\"removeFirst()删除第一个元素并返回: \" + linkedList.removeFirst()); // 移除并返回此列表的第一个元素\r\n        System.out.println(\"removeLast()删除最后一个元素并返回: \" + linkedList.removeLast()); // 移除并返回此列表的最后一个元素\r\n        System.out.println(\"After remove:\" + linkedList);\r\n        System.out.println(\"contains()方法判断列表是否包含1这个元素:\" + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true\r\n        System.out.println(\"该linkedList的大小 : \" + linkedList.size()); // 返回此列表的元素个数\r\n\r\n        /************************** 位置访问操作 ************************/\r\n        System.out.println(\"-----------------------------------------\");\r\n        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素\r\n        System.out.println(\"After set(1, 3):\" + linkedList);\r\n        System.out.println(\"get(1)获得指定位置（这里为1）的元素: \" + linkedList.get(1)); // 返回此列表中指定位置处的元素\r\n\r\n        /************************** Search操作 ************************/\r\n        System.out.println(\"-----------------------------------------\");\r\n        linkedList.add(3);\r\n        System.out.println(\"indexOf(3): \" + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引\r\n        System.out.println(\"lastIndexOf(3): \" + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引\r\n\r\n        /************************** Queue操作 ************************/\r\n        System.out.println(\"-----------------------------------------\");\r\n        System.out.println(\"peek(): \" + linkedList.peek()); // 获取但不移除此列表的头\r\n        System.out.println(\"element(): \" + linkedList.element()); // 获取但不移除此列表的头\r\n        linkedList.poll(); // 获取并移除此列表的头\r\n        System.out.println(\"After poll():\" + linkedList);\r\n        linkedList.remove();\r\n        System.out.println(\"After remove():\" + linkedList); // 获取并移除此列表的头\r\n        linkedList.offer(4);\r\n        System.out.println(\"After offer(4):\" + linkedList); // 将指定元素添加到此列表的末尾\r\n\r\n        /************************** Deque操作 ************************/\r\n        System.out.println(\"-----------------------------------------\");\r\n        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素\r\n        System.out.println(\"After offerFirst(2):\" + linkedList);\r\n        linkedList.offerLast(5); // 在此列表末尾插入指定的元素\r\n        System.out.println(\"After offerLast(5):\" + linkedList);\r\n        System.out.println(\"peekFirst(): \" + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素\r\n        System.out.println(\"peekLast(): \" + linkedList.peekLast()); // 获取但不移除此列表的第一个元素\r\n        linkedList.pollFirst(); // 获取并移除此列表的第一个元素\r\n        System.out.println(\"After pollFirst():\" + linkedList);\r\n        linkedList.pollLast(); // 获取并移除此列表的最后一个元素\r\n        System.out.println(\"After pollLast():\" + linkedList);\r\n        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）\r\n        System.out.println(\"After push(2):\" + linkedList);\r\n        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）\r\n        System.out.println(\"After pop():\" + linkedList);\r\n        linkedList.add(3);\r\n        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）\r\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\r\n        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）\r\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\r\n\r\n        /************************** 遍历操作 ************************/\r\n        System.out.println(\"-----------------------------------------\");\r\n        linkedList.clear();\r\n        for (int i = 0; i < 100000; i++) {\r\n            linkedList.add(i);\r\n        }\r\n        // 迭代器遍历\r\n        long start = System.currentTimeMillis();\r\n        Iterator<Integer> iterator = linkedList.iterator();\r\n        while (iterator.hasNext()) {\r\n            iterator.next();\r\n        }\r\n        long end = System.currentTimeMillis();\r\n        System.out.println(\"Iterator：\" + (end - start) + \" ms\");\r\n\r\n        // 顺序遍历(随机遍历)\r\n        start = System.currentTimeMillis();\r\n        for (int i = 0; i < linkedList.size(); i++) {\r\n            linkedList.get(i);\r\n        }\r\n        end = System.currentTimeMillis();\r\n        System.out.println(\"for：\" + (end - start) + \" ms\");\r\n\r\n        // 另一种for循环遍历\r\n        start = System.currentTimeMillis();\r\n        for (Integer i : linkedList)\r\n            ;\r\n        end = System.currentTimeMillis();\r\n        System.out.println(\"for2：\" + (end - start) + \" ms\");\r\n\r\n        // 通过pollFirst()或pollLast()来遍历LinkedList\r\n        LinkedList<Integer> temp1 = new LinkedList<>();\r\n        temp1.addAll(linkedList);\r\n        start = System.currentTimeMillis();\r\n        while (temp1.size() != 0) {\r\n            temp1.pollFirst();\r\n        }\r\n        end = System.currentTimeMillis();\r\n        System.out.println(\"pollFirst()或pollLast()：\" + (end - start) + \" ms\");\r\n\r\n        // 通过removeFirst()或removeLast()来遍历LinkedList\r\n        LinkedList<Integer> temp2 = new LinkedList<>();\r\n        temp2.addAll(linkedList);\r\n        start = System.currentTimeMillis();\r\n        while (temp2.size() != 0) {\r\n            temp2.removeFirst();\r\n        }\r\n        end = System.currentTimeMillis();\r\n        System.out.println(\"removeFirst()或removeLast()：\" + (end - start) + \" ms\");\r\n    }\r\n}\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (194, 'Java HashMap', 2, '<!-- MarkdownTOC -->\r\n\r\n- [HashMap 简介](#HashMap 简介)\r\n- [底层数据结构分析](#底层数据结构分析)\r\n  - [JDK1.8之前](#JDK1.8之前)\r\n  - [JDK1.8之后](#JDK1.8之后)\r\n- [HashMap源码分析](#HashMap源码分析)\r\n  - [构造方法](#构造方法)\r\n  - [put方法](#put方法)\r\n  - [get方法](#get方法)\r\n  - [resize方法](#resize方法)\r\n- [HashMap常用方法测试](#HashMap常用方法测试)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n> 感谢 [changfubai](https://github.com/changfubai) 对本文的改进做出的贡献！\r\n\r\n## HashMap 简介\r\nHashMap 主要用来存放键值对，它基于哈希表的Map接口实现</font>，是常用的Java集合之一。 \r\n\r\nJDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。\r\n\r\n## 底层数据结构分析\r\n### JDK1.8之前\r\nJDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。**HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**\r\n\r\n**所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。**\r\n\r\n**JDK 1.8 HashMap 的 hash 方法源码:**\r\n\r\nJDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\r\n\r\n  ```java\r\n      static final int hash(Object key) {\r\n        int h;\r\n        // key.hashCode()：返回散列值也就是hashcode\r\n        // ^ ：按位异或\r\n        // >>>:无符号右移，忽略符号位，空位都以0补齐\r\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\r\n    }\r\n  ```\r\n对比一下 JDK1.7的 HashMap 的 hash 方法源码.\r\n\r\n```java\r\nstatic int hash(int h) {\r\n    // This function ensures that hashCodes that differ only by\r\n    // constant multiples at each bit position have a bounded\r\n    // number of collisions (approximately 8 at default load factor).\r\n\r\n    h ^= (h >>> 20) ^ (h >>> 12);\r\n    return h ^ (h >>> 7) ^ (h >>> 4);\r\n}\r\n```\r\n\r\n相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\r\n\r\n所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\r\n\r\n![jdk1.8之前的内部结构](https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&h=427&f=png&s=10991)\r\n\r\n### JDK1.8之后\r\n相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\r\n\r\n![JDK1.8之后的HashMap底层数据结构](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg)\r\n\r\n**类的属性：**\r\n```java\r\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {\r\n    // 序列号\r\n    private static final long serialVersionUID = 362498820763181265L;    \r\n    // 默认的初始容量是16\r\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   \r\n    // 最大容量\r\n    static final int MAXIMUM_CAPACITY = 1 << 30; \r\n    // 默认的填充因子\r\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\r\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\r\n    static final int TREEIFY_THRESHOLD = 8; \r\n    // 当桶(bucket)上的结点数小于这个值时树转链表\r\n    static final int UNTREEIFY_THRESHOLD = 6;\r\n    // 桶中结构转化为红黑树对应的table的最小大小\r\n    static final int MIN_TREEIFY_CAPACITY = 64;\r\n    // 存储元素的数组，总是2的幂次倍\r\n    transient Node<k,v>[] table; \r\n    // 存放具体元素的集\r\n    transient Set<map.entry<k,v>> entrySet;\r\n    // 存放元素的个数，注意这个不等于数组的长度。\r\n    transient int size;\r\n    // 每次扩容和更改map结构的计数器\r\n    transient int modCount;   \r\n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\r\n    int threshold;\r\n    // 加载因子\r\n    final float loadFactor;\r\n}\r\n```\r\n- **loadFactor加载因子**\r\n\r\n  loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。\r\n\r\n  **loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值**。 \r\n  \r\n  给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\r\n\r\n- **threshold**\r\n\r\n  **threshold = capacity * loadFactor**，**当Size>=threshold**的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 **衡量数组是否需要扩增的一个标准**。\r\n\r\n**Node节点类源码:**\r\n\r\n```java\r\n// 继承自 Map.Entry<K,V>\r\nstatic class Node<K,V> implements Map.Entry<K,V> {\r\n       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较\r\n       final K key;//键\r\n       V value;//值\r\n       // 指向下一个节点\r\n       Node<K,V> next;\r\n       Node(int hash, K key, V value, Node<K,V> next) {\r\n            this.hash = hash;\r\n            this.key = key;\r\n            this.value = value;\r\n            this.next = next;\r\n        }\r\n        public final K getKey()        { return key; }\r\n        public final V getValue()      { return value; }\r\n        public final String toString() { return key + \"=\" + value; }\r\n        // 重写hashCode()方法\r\n        public final int hashCode() {\r\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\r\n        }\r\n\r\n        public final V setValue(V newValue) {\r\n            V oldValue = value;\r\n            value = newValue;\r\n            return oldValue;\r\n        }\r\n        // 重写 equals() 方法\r\n        public final boolean equals(Object o) {\r\n            if (o == this)\r\n                return true;\r\n            if (o instanceof Map.Entry) {\r\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\r\n                if (Objects.equals(key, e.getKey()) &&\r\n                    Objects.equals(value, e.getValue()))\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n}\r\n```\r\n**树节点类源码:**\r\n```java\r\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\r\n        TreeNode<K,V> parent;  // 父\r\n        TreeNode<K,V> left;    // 左\r\n        TreeNode<K,V> right;   // 右\r\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\r\n        boolean red;           // 判断颜色\r\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\r\n            super(hash, key, val, next);\r\n        }\r\n        // 返回根节点\r\n        final TreeNode<K,V> root() {\r\n            for (TreeNode<K,V> r = this, p;;) {\r\n                if ((p = r.parent) == null)\r\n                    return r;\r\n                r = p;\r\n       }\r\n```\r\n## HashMap源码分析\r\n### 构造方法\r\n![四个构造方法](https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&h=90&f=jpeg&s=26744)\r\n```java\r\n    // 默认构造函数。\r\n    public HashMap() {\r\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted\r\n     }\r\n     \r\n     // 包含另一个“Map”的构造函数\r\n     public HashMap(Map<? extends K, ? extends V> m) {\r\n         this.loadFactor = DEFAULT_LOAD_FACTOR;\r\n         putMapEntries(m, false);//下面会分析到这个方法\r\n     }\r\n     \r\n     // 指定“容量大小”的构造函数\r\n     public HashMap(int initialCapacity) {\r\n         this(initialCapacity, DEFAULT_LOAD_FACTOR);\r\n     }\r\n     \r\n     // 指定“容量大小”和“加载因子”的构造函数\r\n     public HashMap(int initialCapacity, float loadFactor) {\r\n         if (initialCapacity < 0)\r\n             throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);\r\n         if (initialCapacity > MAXIMUM_CAPACITY)\r\n             initialCapacity = MAXIMUM_CAPACITY;\r\n         if (loadFactor <= 0 || Float.isNaN(loadFactor))\r\n             throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);\r\n         this.loadFactor = loadFactor;\r\n         this.threshold = tableSizeFor(initialCapacity);\r\n     }\r\n```\r\n\r\n**putMapEntries方法：**\r\n\r\n```java\r\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\r\n    int s = m.size();\r\n    if (s > 0) {\r\n        // 判断table是否已经初始化\r\n        if (table == null) { // pre-size\r\n            // 未初始化，s为m的实际元素个数\r\n            float ft = ((float)s / loadFactor) + 1.0F;\r\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\r\n                    (int)ft : MAXIMUM_CAPACITY);\r\n            // 计算得到的t大于阈值，则初始化阈值\r\n            if (t > threshold)\r\n                threshold = tableSizeFor(t);\r\n        }\r\n        // 已初始化，并且m元素个数大于阈值，进行扩容处理\r\n        else if (s > threshold)\r\n            resize();\r\n        // 将m中的所有元素添加至HashMap中\r\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\r\n            K key = e.getKey();\r\n            V value = e.getValue();\r\n            putVal(hash(key), key, value, false, evict);\r\n        }\r\n    }\r\n}\r\n```\r\n### put方法\r\nHashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。\r\n\r\n**对putVal方法添加元素的分析如下：**\r\n\r\n- ①如果定位到的数组位置没有元素 就直接插入。\r\n- ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`将元素添加进入。如果不是就遍历链表插入。\r\n\r\n\r\n\r\n![put方法](https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&h=679&f=png&s=54486)\r\n\r\n```java\r\npublic V put(K key, V value) {\r\n    return putVal(hash(key), key, value, false, true);\r\n}\r\n\r\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\r\n                   boolean evict) {\r\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\r\n    // table未初始化或者长度为0，进行扩容\r\n    if ((tab = table) == null || (n = tab.length) == 0)\r\n        n = (tab = resize()).length;\r\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\r\n    if ((p = tab[i = (n - 1) & hash]) == null)\r\n        tab[i] = newNode(hash, key, value, null);\r\n    // 桶中已经存在元素\r\n    else {\r\n        Node<K,V> e; K k;\r\n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\r\n        if (p.hash == hash &&\r\n            ((k = p.key) == key || (key != null && key.equals(k))))\r\n                // 将第一个元素赋值给e，用e来记录\r\n                e = p;\r\n        // hash值不相等，即key不相等；为红黑树结点\r\n        else if (p instanceof TreeNode)\r\n            // 放入树中\r\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\r\n        // 为链表结点\r\n        else {\r\n            // 在链表最末插入结点\r\n            for (int binCount = 0; ; ++binCount) {\r\n                // 到达链表的尾部\r\n                if ((e = p.next) == null) {\r\n                    // 在尾部插入新结点\r\n                    p.next = newNode(hash, key, value, null);\r\n                    // 结点数量达到阈值，转化为红黑树\r\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\r\n                        treeifyBin(tab, hash);\r\n                    // 跳出循环\r\n                    break;\r\n                }\r\n                // 判断链表中结点的key值与插入的元素的key值是否相等\r\n                if (e.hash == hash &&\r\n                    ((k = e.key) == key || (key != null && key.equals(k))))\r\n                    // 相等，跳出循环\r\n                    break;\r\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\r\n                p = e;\r\n            }\r\n        }\r\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\r\n        if (e != null) { \r\n            // 记录e的value\r\n            V oldValue = e.value;\r\n            // onlyIfAbsent为false或者旧值为null\r\n            if (!onlyIfAbsent || oldValue == null)\r\n                //用新值替换旧值\r\n                e.value = value;\r\n            // 访问后回调\r\n            afterNodeAccess(e);\r\n            // 返回旧值\r\n            return oldValue;\r\n        }\r\n    }\r\n    // 结构性修改\r\n    ++modCount;\r\n    // 实际大小大于阈值则扩容\r\n    if (++size > threshold)\r\n        resize();\r\n    // 插入后回调\r\n    afterNodeInsertion(evict);\r\n    return null;\r\n} \r\n```\r\n\r\n**我们再来对比一下 JDK1.7 put方法的代码**\r\n\r\n**对于put方法的分析如下：**\r\n\r\n- ①如果定位到的数组位置没有元素 就直接插入。\r\n- ②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。\r\n\r\n```java\r\npublic V put(K key, V value)\r\n    if (table == EMPTY_TABLE) { \r\n    inflateTable(threshold); \r\n}  \r\n    if (key == null)\r\n        return putForNullKey(value);\r\n    int hash = hash(key);\r\n    int i = indexFor(hash, table.length);\r\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) { // 先遍历\r\n        Object k;\r\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\r\n            V oldValue = e.value;\r\n            e.value = value;\r\n            e.recordAccess(this);\r\n            return oldValue; \r\n        }\r\n    }\r\n\r\n    modCount++;\r\n    addEntry(hash, key, value, i);  // 再插入\r\n    return null;\r\n}\r\n```\r\n\r\n\r\n\r\n### get方法\r\n```java\r\npublic V get(Object key) {\r\n    Node<K,V> e;\r\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\r\n}\r\n\r\nfinal Node<K,V> getNode(int hash, Object key) {\r\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\r\n    if ((tab = table) != null && (n = tab.length) > 0 &&\r\n        (first = tab[(n - 1) & hash]) != null) {\r\n        // 数组元素相等\r\n        if (first.hash == hash && // always check first node\r\n            ((k = first.key) == key || (key != null && key.equals(k))))\r\n            return first;\r\n        // 桶中不止一个节点\r\n        if ((e = first.next) != null) {\r\n            // 在树中get\r\n            if (first instanceof TreeNode)\r\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\r\n            // 在链表中get\r\n            do {\r\n                if (e.hash == hash &&\r\n                    ((k = e.key) == key || (key != null && key.equals(k))))\r\n                    return e;\r\n            } while ((e = e.next) != null);\r\n        }\r\n    }\r\n    return null;\r\n}\r\n```\r\n### resize方法\r\n进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。\r\n```java\r\nfinal Node<K,V>[] resize() {\r\n    Node<K,V>[] oldTab = table;\r\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\r\n    int oldThr = threshold;\r\n    int newCap, newThr = 0;\r\n    if (oldCap > 0) {\r\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\r\n        if (oldCap >= MAXIMUM_CAPACITY) {\r\n            threshold = Integer.MAX_VALUE;\r\n            return oldTab;\r\n        }\r\n        // 没超过最大值，就扩充为原来的2倍\r\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\r\n            newThr = oldThr << 1; // double threshold\r\n    }\r\n    else if (oldThr > 0) // initial capacity was placed in threshold\r\n        newCap = oldThr;\r\n    else { \r\n        // signifies using defaults\r\n        newCap = DEFAULT_INITIAL_CAPACITY;\r\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\r\n    }\r\n    // 计算新的resize上限\r\n    if (newThr == 0) {\r\n        float ft = (float)newCap * loadFactor;\r\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\r\n    }\r\n    threshold = newThr;\r\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\r\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\r\n    table = newTab;\r\n    if (oldTab != null) {\r\n        // 把每个bucket都移动到新的buckets中\r\n        for (int j = 0; j < oldCap; ++j) {\r\n            Node<K,V> e;\r\n            if ((e = oldTab[j]) != null) {\r\n                oldTab[j] = null;\r\n                if (e.next == null)\r\n                    newTab[e.hash & (newCap - 1)] = e;\r\n                else if (e instanceof TreeNode)\r\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\r\n                else { \r\n                    Node<K,V> loHead = null, loTail = null;\r\n                    Node<K,V> hiHead = null, hiTail = null;\r\n                    Node<K,V> next;\r\n                    do {\r\n                        next = e.next;\r\n                        // 原索引\r\n                        if ((e.hash & oldCap) == 0) {\r\n                            if (loTail == null)\r\n                                loHead = e;\r\n                            else\r\n                                loTail.next = e;\r\n                            loTail = e;\r\n                        }\r\n                        // 原索引+oldCap\r\n                        else {\r\n                            if (hiTail == null)\r\n                                hiHead = e;\r\n                            else\r\n                                hiTail.next = e;\r\n                            hiTail = e;\r\n                        }\r\n                    } while ((e = next) != null);\r\n                    // 原索引放到bucket里\r\n                    if (loTail != null) {\r\n                        loTail.next = null;\r\n                        newTab[j] = loHead;\r\n                    }\r\n                    // 原索引+oldCap放到bucket里\r\n                    if (hiTail != null) {\r\n                        hiTail.next = null;\r\n                        newTab[j + oldCap] = hiHead;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return newTab;\r\n}\r\n```\r\n## HashMap常用方法测试\r\n```java\r\npackage map;\r\n\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Set;\r\n\r\npublic class HashMapDemo {\r\n\r\n    public static void main(String[] args) {\r\n        HashMap<String, String> map = new HashMap<String, String>();\r\n        // 键不能重复，值可以重复\r\n        map.put(\"san\", \"张三\");\r\n        map.put(\"si\", \"李四\");\r\n        map.put(\"wu\", \"王五\");\r\n        map.put(\"wang\", \"老王\");\r\n        map.put(\"wang\", \"老王2\");// 老王被覆盖\r\n        map.put(\"lao\", \"老王\");\r\n        System.out.println(\"-------直接输出hashmap:-------\");\r\n        System.out.println(map);\r\n        /**\r\n         * 遍历HashMap\r\n         */\r\n        // 1.获取Map中的所有键\r\n        System.out.println(\"-------foreach获取Map中所有的键:------\");\r\n        Set<String> keys = map.keySet();\r\n        for (String key : keys) {\r\n            System.out.print(key+\"  \");\r\n        }\r\n        System.out.println();//换行\r\n        // 2.获取Map中所有值\r\n        System.out.println(\"-------foreach获取Map中所有的值:------\");\r\n        Collection<String> values = map.values();\r\n        for (String value : values) {\r\n            System.out.print(value+\"  \");\r\n        }\r\n        System.out.println();//换行\r\n        // 3.得到key的值的同时得到key所对应的值\r\n        System.out.println(\"-------得到key的值的同时得到key所对应的值:-------\");\r\n        Set<String> keys2 = map.keySet();\r\n        for (String key : keys2) {\r\n            System.out.print(key + \"：\" + map.get(key)+\"   \");\r\n\r\n        }\r\n        /**\r\n         * 另外一种不常用的遍历方式\r\n         */\r\n        // 当我调用put(key,value)方法的时候，首先会把key和value封装到\r\n        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取\r\n        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来\r\n        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了\r\n        Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();\r\n        for (java.util.Map.Entry<String, String> entry : entrys) {\r\n            System.out.println(entry.getKey() + \"--\" + entry.getValue());\r\n        }\r\n        \r\n        /**\r\n         * HashMap其他常用方法\r\n         */\r\n        System.out.println(\"after map.size()：\"+map.size());\r\n        System.out.println(\"after map.isEmpty()：\"+map.isEmpty());\r\n        System.out.println(map.remove(\"san\"));\r\n        System.out.println(\"after map.remove()：\"+map);\r\n        System.out.println(\"after map.get(si)：\"+map.get(\"si\"));\r\n        System.out.println(\"after map.containsKey(si)：\"+map.containsKey(\"si\"));\r\n        System.out.println(\"after containsValue(李四)：\"+map.containsValue(\"李四\"));\r\n        System.out.println(map.replace(\"si\", \"李四2\"));\r\n        System.out.println(\"after map.replace(si, 李四2):\"+map);\r\n    }\r\n\r\n}\r\n\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (195, 'Java 集合面试题总结', 2, '\r\n\r\n<!-- MarkdownTOC -->\r\n\r\n- [Arraylist 与 LinkedList 异同](#Arraylist 与 LinkedList 异同)\r\n  - [补充：数据结构基础之双向链表](#补充：数据结构基础之双向链表)\r\n- [ArrayList 与 Vector 区别](#ArrayList 与 Vector 区别)\r\n- [HashMap的底层实现](#HashMap的底层实现)\r\n  - [JDK1.8之前](#JDK1.8之前)\r\n  - [JDK1.8之后](#JDK1.8之后)\r\n- [HashMap 和 Hashtable 的区别](#HashMap 和 Hashtable 的区别)\r\n- [HashMap 的长度为什么是2的幂次方](#HashMap 的长度为什么是2的幂次方)\r\n- [HashMap 多线程操作导致死循环问题](#HashMap 多线程操作导致死循环问题)\r\n- [HashSet 和 HashMap 区别](#HashSet 和 HashMap 区别)\r\n- [ConcurrentHashMap 和 Hashtable 的区别](#ConcurrentHashMap 和 Hashtable 的区别)\r\n- [ConcurrentHashMap线程安全的具体实现方式/底层具体实现](#ConcurrentHashMap线程安全的具体实现方式/底层具体实现)\r\n  - [JDK1.7（上面有示意图）](#JDK1.7（上面有示意图）)\r\n  - [JDK1.8 （上面有示意图）](#JDK1.8 （上面有示意图）)\r\n- [集合框架底层数据结构总结](#集合框架底层数据结构总结)\r\n  - [Collection](#Collection)\r\n    - [1. List](#1. List)\r\n    - [2. Set](#2. Set)\r\n  - [Map](#Map)\r\n  - [推荐阅读：](#推荐阅读：)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n## Arraylist 与 LinkedList 异同\r\n\r\n- **1. 是否保证线程安全：** ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\r\n- **2. 底层数据结构：** Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别：）； 详细可阅读[JDK1.7-LinkedList循环链表优化](https://www.cnblogs.com/xingele0917/p/3696593.html)\r\n-  **3. 插入和删除是否受元素位置的影响：** ① **ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行`add(E e)  `方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element) `）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② **LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。**\r\n- **4. 是否支持快速随机访问：** LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index) `方法)。\r\n- **5. 内存空间占用：** ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。 \r\n- **6.补充内容:RandomAccess接口**\r\n\r\n```java\r\npublic interface RandomAccess {\r\n}\r\n```\r\n\r\n查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。\r\n\r\n在binarySearch（）方法中，它要判断传入的list 是否RamdomAccess的实例，如果是，调用indexedBinarySearch（）方法，如果不是，那么调用iteratorBinarySearch（）方法\r\n\r\n```java\r\n    public static <T>\r\n    int binarySearch(List<? extends Comparable<? super T>> list, T key) {\r\n        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\r\n            return Collections.indexedBinarySearch(list, key);\r\n        else\r\n            return Collections.iteratorBinarySearch(list, key);\r\n    }\r\n\r\n```\r\nArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！\r\n\r\n\r\n**下面再总结一下 list 的遍历方式选择：**\r\n\r\n- 实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,\r\n- 未实现RandomAccess接口的ist， 优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环\r\n\r\n\r\n### 补充：数据结构基础之双向链表\r\n\r\n双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表，如下图所示，同时下图也是LinkedList 底层使用的是双向循环链表数据结构。\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-21/88766727.jpg)\r\n\r\n\r\n## ArrayList 与 Vector 区别\r\n\r\n Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。\r\n\r\nArraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。\r\n\r\n\r\n## HashMap的底层实现\r\n\r\n### JDK1.8之前\r\n\r\nJDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。**HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**\r\n\r\n**所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。**\r\n\r\n**JDK 1.8 HashMap 的 hash 方法源码:**\r\n\r\nJDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\r\n\r\n  ```java\r\n      static final int hash(Object key) {\r\n        int h;\r\n        // key.hashCode()：返回散列值也就是hashcode\r\n        // ^ ：按位异或\r\n        // >>>:无符号右移，忽略符号位，空位都以0补齐\r\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\r\n    }\r\n  ```\r\n对比一下 JDK1.7的 HashMap 的 hash 方法源码.\r\n\r\n```java\r\nstatic int hash(int h) {\r\n    // This function ensures that hashCodes that differ only by\r\n    // constant multiples at each bit position have a bounded\r\n    // number of collisions (approximately 8 at default load factor).\r\n\r\n    h ^= (h >>> 20) ^ (h >>> 12);\r\n    return h ^ (h >>> 7) ^ (h >>> 4);\r\n}\r\n```\r\n\r\n相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\r\n\r\n所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\r\n\r\n\r\n\r\n![jdk1.8之前的内部结构](https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&h=427&f=png&s=10991)\r\n\r\n\r\n### JDK1.8之后\r\n相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\r\n\r\n![JDK1.8之后的HashMap底层数据结构](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg)\r\n\r\n>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\r\n\r\n**推荐阅读：**\r\n\r\n- 《Java 8系列之重新认识HashMap》 ：[https://zhuanlan.zhihu.com/p/21673805](https://zhuanlan.zhihu.com/p/21673805)\r\n\r\n## HashMap 和 Hashtable 的区别\r\n\r\n1.  **线程是否安全：** HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过  `synchronized`  修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；\r\n2. **效率：** 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；\r\n3. **对Null key 和Null value的支持：** HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\r\n4. **初始容量大小和每次扩充容量大小的不同 ：**   ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。\r\n5. **底层数据结构：** JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\r\n\r\n**HasMap 中带有初始容量的构造函数：**\r\n\r\n```java\r\n    public HashMap(int initialCapacity, float loadFactor) {\r\n        if (initialCapacity < 0)\r\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\r\n                                               initialCapacity);\r\n        if (initialCapacity > MAXIMUM_CAPACITY)\r\n            initialCapacity = MAXIMUM_CAPACITY;\r\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\r\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\r\n                                               loadFactor);\r\n        this.loadFactor = loadFactor;\r\n        this.threshold = tableSizeFor(initialCapacity);\r\n    }\r\n     public HashMap(int initialCapacity) {\r\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\r\n    }\r\n```\r\n\r\n下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。\r\n\r\n```java\r\n    /**\r\n     * Returns a power of two size for the given target capacity.\r\n     */\r\n    static final int tableSizeFor(int cap) {\r\n        int n = cap - 1;\r\n        n |= n >>> 1;\r\n        n |= n >>> 2;\r\n        n |= n >>> 4;\r\n        n |= n >>> 8;\r\n        n |= n >>> 16;\r\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\r\n    }\r\n```\r\n\r\n## HashMap 的长度为什么是2的幂次方\r\n\r\n为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ `(n - 1) & hash` ”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。\r\n\r\n**这个算法应该如何设计呢？**\r\n\r\n我们首先可能会想到采用%取余的操作来实现。但是，重点来了：**“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。**\r\n\r\n## HashMap 多线程操作导致死循环问题\r\n\r\n在多线程下，进行 put 操作会导致 HashMap 死循环，原因在于 HashMap 的扩容 resize()方法。由于扩容是新建一个数组，复制原数据到数组。由于数组下标挂有链表，所以需要复制链表，但是多线程操作有可能导致环形链表。复制链表过程如下:  \r\n以下模拟2个线程同时扩容。假设，当前 HashMap 的空间为2（临界值为1），hashcode 分别为 0 和 1，在散列地址 0 处有元素 A 和 B，这时候要添加元素 C，C 经过 hash 运算，得到散列地址为 1，这时候由于超过了临界值，空间不够，需要调用 resize 方法进行扩容，那么在多线程条件下，会出现条件竞争，模拟过程如下：\r\n\r\n 线程一：读取到当前的 HashMap 情况，在准备扩容时，线程二介入\r\n\r\n![](https://note.youdao.com/yws/public/resource/e4cec65883d9fdc24effba57dcfa5241/xmlnote/41aed567e3419e1314bfbf689e3255a2/192)\r\n\r\n线程二：读取 HashMap，进行扩容\r\n\r\n![](https://note.youdao.com/yws/public/resource/e4cec65883d9fdc24effba57dcfa5241/xmlnote/f44624419c0a49686fb12aa37527ee65/191)\r\n\r\n线程一：继续执行\r\n\r\n![](https://note.youdao.com/yws/public/resource/e4cec65883d9fdc24effba57dcfa5241/xmlnote/79424b2bf4a89902a9e85c64600268e4/193)\r\n \r\n这个过程为，先将 A 复制到新的 hash 表中，然后接着复制 B 到链头（A 的前边：B.next=A），本来 B.next=null，到此也就结束了（跟线程二一样的过程），但是，由于线程二扩容的原因，将 B.next=A，所以，这里继续复制A，让 A.next=B，由此，环形链表出现：B.next=A; A.next=B \r\n\r\n**注意：jdk1.8已经解决了死循环的问题。**详细信息请阅读[jdk1.8 hashmap多线程put不会造成死循环](https://blog.csdn.net/qq_27007251/article/details/71403647)\r\n\r\n\r\n## HashSet 和 HashMap 区别\r\n\r\n如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。）\r\n\r\n![HashSet 和 HashMap 区别](https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?w=896&h=363&f=jpeg&s=205536)\r\n\r\n## ConcurrentHashMap 和 Hashtable 的区别\r\n\r\nConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\r\n\r\n- **底层数据结构：** JDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\r\n- **实现线程安全的方式（重要）：** ① **在JDK1.7的时候，ConcurrentHashMap（分段锁）** 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 **到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）**  整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **Hashtable(同一把锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\r\n\r\n**两者的对比图：** \r\n\r\n图片来源：http://www.cnblogs.com/chengxiao/p/6842045.html\r\n\r\nHashTable:\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/50656681.jpg)\r\n\r\nJDK1.7的ConcurrentHashMap：\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/33120488.jpg)\r\nJDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点\r\nNode: 链表节点）：\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/97739220.jpg)\r\n\r\n## ConcurrentHashMap线程安全的具体实现方式/底层具体实现\r\n\r\n### JDK1.7（上面有示意图）\r\n\r\n首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\r\n\r\n**ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成**。\r\n\r\nSegment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。\r\n\r\n```java\r\nstatic class Segment<K,V> extends ReentrantLock implements Serializable {\r\n}\r\n```\r\n\r\n一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry  数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。\r\n\r\n### JDK1.8 （上面有示意图）\r\n\r\nConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。\r\n\r\nsynchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。\r\n\r\n\r\n\r\n## 集合框架底层数据结构总结\r\n###  Collection\r\n  \r\n####  1. List\r\n   - **Arraylist：** Object数组\r\n   - **Vector：** Object数组\r\n   - **LinkedList：** 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)\r\n   详细可阅读[JDK1.7-LinkedList循环链表优化](https://www.cnblogs.com/xingele0917/p/3696593.html)\r\n\r\n####  2. Set\r\n  - **HashSet（无序，唯一）:**  基于 HashMap 实现的，底层采用 HashMap 来保存元素\r\n  - **LinkedHashSet：** LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。\r\n  - **TreeSet（有序，唯一）：** 红黑树(自平衡的排序二叉树。)\r\n\r\n###  Map \r\n -  **HashMap：** JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间\r\n -  **LinkedHashMap:** LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：[《LinkedHashMap 源码详细分析（JDK1.8）》](https://www.imooc.com/article/22931)\r\n -  **HashTable:** 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的\r\n -  **TreeMap:** 红黑树（自平衡的排序二叉树）\r\n \r\n\r\n\r\n\r\n### 推荐阅读：\r\n\r\n- [jdk1.8中ConcurrentHashMap的实现原理](https://blog.csdn.net/fjse51/article/details/55260493)\r\n- [HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！](https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/) \r\n- [HASHMAP、HASHTABLE、CONCURRENTHASHMAP的原理与区别](http://www.yuanrengu.com/index.php/2017-01-17.html)\r\n- [ConcurrentHashMap实现原理及源码分析](https://www.cnblogs.com/chengxiao/p/6842045.html)\r\n- [java-并发-ConcurrentHashMap高并发机制-jdk1.8](https://blog.csdn.net/jianghuxiaojin/article/details/52006118#commentBox)\r\n', 0);
INSERT INTO `blog_course` VALUES (196, 'Java 多线程', 2, '> ## 多线程系列文章\r\n下列文章，我都更新在了我的博客专栏：[Java并发编程指南](https://blog.csdn.net/column/details/20860.html)。\r\n\r\n1. [Java多线程学习（一）Java多线程入门](http://blog.csdn.net/qq_34337272/article/details/79640870)\r\n2. [Java多线程学习（二）synchronized关键字（1）](http://blog.csdn.net/qq_34337272/article/details/79655194)\r\n3.  [Java多线程学习（二）synchronized关键字（2）](http://blog.csdn.net/qq_34337272/article/details/79670775)\r\n4. [Java多线程学习（三）volatile关键字](http://blog.csdn.net/qq_34337272/article/details/79680771)\r\n5. [Java多线程学习（四）等待/通知（wait/notify）机制](http://blog.csdn.net/qq_34337272/article/details/79690279)\r\n\r\n6. [Java多线程学习（五）线程间通信知识点补充](http://blog.csdn.net/qq_34337272/article/details/79694226)\r\n7. [Java多线程学习（六）Lock锁的使用](http://blog.csdn.net/qq_34337272/article/details/79714196)\r\n8. [Java多线程学习（七）并发编程中一些问题](https://blog.csdn.net/qq_34337272/article/details/79844051)\r\n9. [Java多线程学习（八）线程池与Executor 框架](https://blog.csdn.net/qq_34337272/article/details/79959271)\r\n\r\n\r\n> ## 多线程系列文章重要知识点与思维导图\r\n\r\n###  Java多线程学习（一）Java多线程入门\r\n![](https://user-gold-cdn.xitu.io/2018/8/4/16504e0cb6bac32e?w=758&h=772&f=jpeg&s=247210)\r\n\r\n###  Java多线程学习（二）synchronized关键字（1）\r\n![](https://user-gold-cdn.xitu.io/2018/8/4/16504e245ceb3ea9?w=1028&h=490&f=jpeg&s=203811)\r\n\r\n注意：**可重入锁的概念**。\r\n\r\n   另外要注意：**synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁。** 如果多个线程访问的是同一个对象，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法，那么其他线程只能呈等待状态。如果多个线程访问的是多个对象则不一定，因为多个对象会产生多个锁。\r\n\r\n###  Java多线程学习（二）synchronized关键字（2）\r\n\r\n![思维导图](https://user-gold-cdn.xitu.io/2018/8/4/16504e3d98213324?w=1448&h=439&f=jpeg&s=245012)\r\n\r\n   **注意：**\r\n\r\n   - 其他线程执行对象中**synchronized同步方法**（上一节我们介绍过，需要回顾的可以看上一节的文章）和**synchronized(this)代码块**时呈现同步效果;\r\n   - **如果两个线程使用了同一个“对象监视器”（synchronized(object)）,运行结果同步，否则不同步**.\r\n\r\n   **synchronized关键字加到static静态方法**和**synchronized(class)代码块**上都是是给**Class类**上锁，而**synchronized关键字加到非static静态方法**上是给**对象**上锁。\r\n\r\n   数据类型String的常量池属性:**在Jvm中具有String常量池缓存的功能**\r\n\r\n###  Java多线程学习（三）volatile关键字\r\n\r\n![volatile关键字](https://user-gold-cdn.xitu.io/2018/8/4/16504e4ab69d8d58)\r\n   **注意：**\r\n\r\n   **synchronized关键字**和**volatile关键字**比较\r\n\r\n### Java多线程学习（四）等待/通知（wait/notify）机制\r\n\r\n![本节思维导图](https://user-gold-cdn.xitu.io/2018/3/25/1625d2a9188ec021?w=1254&h=452&f=jpeg&s=229471)\r\n\r\n### Java多线程学习（五）线程间通信知识点补充\r\n\r\n![本节思维导图](https://user-gold-cdn.xitu.io/2018/8/4/16504e618d6886c5?w=1146&h=427&f=jpeg&s=220573)\r\n   **注意：** ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。\r\n\r\n###  Java多线程学习（六）Lock锁的使用\r\n\r\n   ![本节思维导图](https://user-gold-cdn.xitu.io/2018/3/27/1626755a8e9a8774?w=1197&h=571&f=jpeg&s=258439)\r\n\r\n### Java多线程学习（七）并发编程中一些问题\r\n\r\n![思维导图](https://user-gold-cdn.xitu.io/2018/4/7/162a01b71ebc4842?w=1067&h=517&f=png&s=36857)\r\n\r\n### Java多线程学习（八）线程池与Executor 框架\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-14/86510659.jpg)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (197, 'Java synchronized', 2, '\r\n\r\n![Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/%E4%BA%8C%20%20Synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E3%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%81JDK1.6%20%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%20%E5%92%8CReenTrantLock%20%E7%9A%84%E5%AF%B9%E6%AF%94.png)\r\n\r\n###  synchronized关键字最主要的三种使用方式的总结\r\n\r\n- **修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁**\r\n- **修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁** 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。\r\n- **修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。** 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！\r\n\r\n下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。\r\n\r\n面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”\r\n\r\n\r\n\r\n**双重校验锁实现对象单例（线程安全）**\r\n\r\n```java\r\npublic class Singleton {\r\n\r\n    private volatile static Singleton uniqueInstance;\r\n\r\n    private Singleton() {\r\n    }\r\n\r\n    public static Singleton getUniqueInstance() {\r\n       //先判断对象是否已经实例过，没有实例化过才进入加锁代码\r\n        if (uniqueInstance == null) {\r\n            //类对象加锁\r\n            synchronized (Singleton.class) {\r\n                if (uniqueInstance == null) {\r\n                    uniqueInstance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return uniqueInstance;\r\n    }\r\n}\r\n```\r\n另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。\r\n\r\nuniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\r\n\r\n1. 为 uniqueInstance 分配内存空间\r\n2. 初始化 uniqueInstance\r\n3. 将 uniqueInstance 指向分配的内存地址\r\n\r\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\r\n\r\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\r\n\r\n\r\n###synchronized 关键字底层原理总结\r\n\r\n\r\n\r\n**synchronized 关键字底层原理属于 JVM 层面。**\r\n\r\n**① synchronized 同步语句块的情况**\r\n\r\n```java\r\npublic class SynchronizedDemo {\r\n	public void method() {\r\n		synchronized (this) {\r\n			System.out.println(\"synchronized 代码块\");\r\n		}\r\n	}\r\n}\r\n\r\n```\r\n\r\n通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 `javac SynchronizedDemo.java` 命令生成编译后的 .class 文件，然后执行`javap -c -s -v -l SynchronizedDemo.class`。\r\n\r\n![synchronized 关键字原理](https://images.gitbook.cn/abc37c80-d21d-11e8-aab3-09d30029e0d5)\r\n\r\n从上面我们可以看出：\r\n\r\n**synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。** 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。\r\n\r\n**② synchronized 修饰方法的的情况**\r\n\r\n```java\r\npublic class SynchronizedDemo2 {\r\n	public synchronized void method() {\r\n		System.out.println(\"synchronized 方法\");\r\n	}\r\n}\r\n\r\n```\r\n\r\n![synchronized 关键字原理](https://images.gitbook.cn/7d407bf0-d21e-11e8-b2d6-1188c7e0dd7e)\r\n\r\nsynchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\r\n\r\n\r\n在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。\r\n\r\n\r\n###  JDK1.6 之后的底层优化\r\n\r\nJDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。\r\n\r\n锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\r\n\r\n**①偏向锁**\r\n\r\n**引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉**。\r\n\r\n偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。\r\n\r\n但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。\r\n\r\n**② 轻量级锁**\r\n\r\n倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。**轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。** 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。\r\n\r\n**轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！**\r\n\r\n**③  自旋锁和自适应自旋**\r\n\r\n轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。\r\n\r\n互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。\r\n\r\n**一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。** 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。**为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋**。\r\n\r\n百度百科对自旋锁的解释：\r\n\r\n> 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，\"自旋\"一词就是因此而得名。\r\n\r\n自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过`--XX:+UseSpinning`参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。**自旋次数的默认值是10次，用户可以修改`--XX:PreBlockSpin`来更改**。\r\n\r\n另外,**在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了**。\r\n\r\n**④ 锁消除**\r\n\r\n锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。\r\n\r\n**⑤ 锁粗化**\r\n\r\n原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。\r\n\r\n大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。\r\n\r\n###  Synchronized 和 ReenTrantLock 的对比\r\n\r\n\r\n**① 两者都是可重入锁**\r\n\r\n两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\r\n\r\n**② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API**\r\n\r\nsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。\r\n\r\n**③ ReenTrantLock 比 synchronized 增加了一些高级功能**\r\n\r\n相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：**①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）**\r\n\r\n- **ReenTrantLock提供了一种能够中断等待锁的线程的机制**，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\r\n- **ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。** ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。\r\n- synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），**线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”** ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。\r\n\r\n如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。\r\n\r\n**④ 性能已不是选择标准**\r\n\r\n在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。**JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作**。\r\n', 0);
INSERT INTO `blog_course` VALUES (198, 'Java 多线程面试', 2, '\r\n\r\n\r\n# 一 面试中关于 synchronized 关键字的 5 连击\r\n\r\n### 1.1 说一说自己对于 synchronized 关键字的了解\r\n\r\nsynchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\r\n\r\n另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。\r\n\r\n\r\n### 1.2 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗\r\n\r\n**synchronized关键字最主要的三种使用方式：**\r\n\r\n- **修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁**\r\n- **修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁** 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。\r\n- **修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。** 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！\r\n\r\n下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。\r\n\r\n面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”\r\n\r\n\r\n\r\n**双重校验锁实现对象单例（线程安全）**\r\n\r\n```java\r\npublic class Singleton {\r\n\r\n    private volatile static Singleton uniqueInstance;\r\n\r\n    private Singleton() {\r\n    }\r\n\r\n    public static Singleton getUniqueInstance() {\r\n       //先判断对象是否已经实例过，没有实例化过才进入加锁代码\r\n        if (uniqueInstance == null) {\r\n            //类对象加锁\r\n            synchronized (Singleton.class) {\r\n                if (uniqueInstance == null) {\r\n                    uniqueInstance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return uniqueInstance;\r\n    }\r\n}\r\n```\r\n另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。\r\n\r\nuniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\r\n\r\n1. 为 uniqueInstance 分配内存空间\r\n2. 初始化 uniqueInstance\r\n3. 将 uniqueInstance 指向分配的内存地址\r\n\r\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\r\n\r\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\r\n\r\n### 1.3 讲一下 synchronized 关键字的底层原理\r\n\r\n**synchronized 关键字底层原理属于 JVM 层面。**\r\n\r\n**① synchronized 同步语句块的情况**\r\n\r\n```java\r\npublic class SynchronizedDemo {\r\n	public void method() {\r\n		synchronized (this) {\r\n			System.out.println(\"synchronized 代码块\");\r\n		}\r\n	}\r\n}\r\n\r\n```\r\n\r\n通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 `javac SynchronizedDemo.java` 命令生成编译后的 .class 文件，然后执行`javap -c -s -v -l SynchronizedDemo.class`。\r\n\r\n![synchronized 关键字原理](https://user-gold-cdn.xitu.io/2018/10/26/166add616a292bcf?w=917&h=633&f=png&s=21863)\r\n\r\n从上面我们可以看出：\r\n\r\n**synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。** 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。\r\n\r\n**② synchronized 修饰方法的的情况**\r\n\r\n```java\r\npublic class SynchronizedDemo2 {\r\n	public synchronized void method() {\r\n		System.out.println(\"synchronized 方法\");\r\n	}\r\n}\r\n\r\n```\r\n\r\n![synchronized 关键字原理](https://user-gold-cdn.xitu.io/2018/10/26/166add6169fc206d?w=875&h=421&f=png&s=16114)\r\n\r\nsynchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\r\n\r\n\r\n### 1.4 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗\r\n\r\nJDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。\r\n\r\n锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\r\n\r\n关于这几种优化的详细信息可以查看：[synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484539&idx=1&sn=3500cdcd5188bdc253fb19a1bfa805e6&chksm=fd98521acaefdb0c5167247a1fa903a1a53bb4e050b558da574f894f9feda5378ec9d0fa1ac7&token=1604028915&lang=zh_CN#rd)\r\n\r\n### 1.5 谈谈 synchronized和ReenTrantLock 的区别\r\n\r\n\r\n**① 两者都是可重入锁**\r\n\r\n两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\r\n\r\n**② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API**\r\n\r\nsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。\r\n\r\n**③ ReenTrantLock 比 synchronized 增加了一些高级功能**\r\n\r\n相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：**①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）**\r\n\r\n- **ReenTrantLock提供了一种能够中断等待锁的线程的机制**，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\r\n- **ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。** ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。\r\n- synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），**线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”** ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。\r\n\r\n如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。\r\n\r\n**④ 性能已不是选择标准**\r\n\r\n# 二 面试中关于线程池的 4 连击\r\n\r\n### 2.1 讲一下Java内存模型\r\n\r\n\r\n在 JDK1.2 之前，Java的内存模型实现总是从<font color=\"red\">**主存**（即共享内存）读取变量</font>，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<font color=\"red\">**本地内存**</font>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<font color=\"red\">**数据的不一致**</font>。\r\n\r\n![数据的不一致](https://user-gold-cdn.xitu.io/2018/10/30/166c46ede4423ba2?w=273&h=166&f=jpeg&s=7268)\r\n\r\n要解决这个问题，就需要把变量声明为<font color=\"red\"> **volatile**</font>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。\r\n\r\n说白了，<font color=\"red\"> **volatile**</font> 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。\r\n\r\n![volatile关键字的可见性](https://user-gold-cdn.xitu.io/2018/10/30/166c46ede4b9f501?w=474&h=238&f=jpeg&s=9942)\r\n\r\n\r\n### 2.2 说说 synchronized 关键字和 volatile 关键字的区别\r\n\r\n synchronized关键字和volatile关键字比较\r\n\r\n- **volatile关键字**是线程同步的**轻量级实现**，所以**volatile性能肯定比synchronized关键字要好**。但是**volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块**。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，**实际开发中使用 synchronized 关键字的场景还是更多一些**。\r\n- **多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞**\r\n- **volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。**\r\n- **volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。**\r\n\r\n\r\n# 三 面试中关于 线程池的 2 连击\r\n\r\n\r\n### 3.1 为什么要用线程池？\r\n\r\n线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 \r\n\r\n这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处：\r\n\r\n- **降低资源消耗。** 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\r\n- **提高响应速度。** 当任务到达时，任务可以不需要的等到线程创建就能立即执行。\r\n- **提高线程的可管理性。** 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\r\n\r\n\r\n### 3.2 实现Runnable接口和Callable接口的区别\r\n\r\n如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。\r\n\r\n  **备注：** 工具类`Executors`可以实现`Runnable`对象和`Callable`对象之间的相互转换。（`Executors.callable（Runnable task）`或`Executors.callable（Runnable task，Object resule）`）。\r\n\r\n### 3.3 执行execute()方法和submit()方法的区别是什么呢？\r\n\r\n  1)**`execute()` 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；**\r\n  \r\n  2)**submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功**，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 `get（long timeout，TimeUnit unit）`方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\r\n  \r\n\r\n### 3.4 如何创建线程池\r\n\r\n《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险\r\n\r\n> Executors 返回线程池对象的弊端如下：\r\n> \r\n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\r\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\r\n\r\n**方式一：通过构造方法实现**\r\n![通过构造方法实现](https://user-gold-cdn.xitu.io/2018/10/30/166c4a5baac923e9?w=925&h=158&f=jpeg&s=29190)\r\n**方式二：通过Executor 框架的工具类Executors来实现**\r\n我们可以创建三种类型的ThreadPoolExecutor：\r\n\r\n- **FixedThreadPool** ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。\r\n- **SingleThreadExecutor：** 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。\r\n- **CachedThreadPool：** 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。\r\n\r\n对应Executors工具类中的方法如图所示：\r\n![通过Executor 框架的工具类Executors来实现](https://user-gold-cdn.xitu.io/2018/10/30/166c4a5baa9ca5e9?w=645&h=222&f=jpeg&s=31710)\r\n\r\n\r\n# 四  面试中关于 Atomic 原子类的 4 连击\r\n\r\n### 4.1 介绍一下Atomic 原子类\r\n\r\nAtomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。\r\n\r\n所以，所谓原子类说简单点就是具有原子/原子操作特征的类。\r\n\r\n\r\n并发包 `java.util.concurrent` 的原子类都存放在`java.util.concurrent.atomic`下,如下图所示。\r\n\r\n![ JUC 原子类概览](https://user-gold-cdn.xitu.io/2018/10/30/166c4ac08d4c5547?w=317&h=367&f=png&s=13267)\r\n\r\n### 4.2 JUC 包中的原子类是哪4类?\r\n\r\n**基本类型** \r\n\r\n使用原子的方式更新基本类型\r\n\r\n- AtomicInteger：整形原子类\r\n- AtomicLong：长整型原子类\r\n-  AtomicBoolean ：布尔型原子类\r\n\r\n**数组类型**\r\n\r\n使用原子的方式更新数组里的某个元素\r\n\r\n\r\n- AtomicIntegerArray：整形数组原子类\r\n- AtomicLongArray：长整形数组原子类\r\n- AtomicReferenceArray ：引用类型数组原子类\r\n\r\n**引用类型**\r\n\r\n- AtomicReference：引用类型原子类\r\n- AtomicStampedRerence：原子更新引用类型里的字段原子类\r\n- AtomicMarkableReference ：原子更新带有标记位的引用类型\r\n\r\n**对象的属性修改类型**\r\n\r\n- AtomicIntegerFieldUpdater:原子更新整形字段的更新器\r\n- AtomicLongFieldUpdater：原子更新长整形字段的更新器\r\n- AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\r\n\r\n\r\n### 4.3 讲讲 AtomicInteger 的使用\r\n\r\n **AtomicInteger 类常用方法**\r\n \r\n```java\r\npublic final int get() //获取当前的值\r\npublic final int getAndSet(int newValue)//获取当前的值，并设置新的值\r\npublic final int getAndIncrement()//获取当前的值，并自增\r\npublic final int getAndDecrement() //获取当前的值，并自减\r\npublic final int getAndAdd(int delta) //获取当前的值，并加上预期的值\r\nboolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）\r\npublic final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。\r\n```\r\n\r\n **AtomicInteger 类的使用示例**\r\n\r\n使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。\r\n```java\r\nclass AtomicIntegerTest {\r\n        private AtomicInteger count = new AtomicInteger();\r\n      //使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。\r\n        public void increment() {\r\n                  count.incrementAndGet();\r\n        }\r\n     \r\n       public int getCount() {\r\n                return count.get();\r\n        }\r\n}\r\n\r\n```\r\n\r\n### 4.4 能不能给我简单介绍一下 AtomicInteger 类的原理\r\n\r\nAtomicInteger 线程安全原理简单分析\r\n\r\nAtomicInteger 类的部分源码：\r\n\r\n```java\r\n    // setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）\r\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\r\n    private static final long valueOffset;\r\n\r\n    static {\r\n        try {\r\n            valueOffset = unsafe.objectFieldOffset\r\n                (AtomicInteger.class.getDeclaredField(\"value\"));\r\n        } catch (Exception ex) { throw new Error(ex); }\r\n    }\r\n\r\n    private volatile int value;\r\n``` \r\n\r\nAtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\r\n\r\nCAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。\r\n\r\n关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：[JUC 中的 Atomic 原子类总结](https://mp.weixin.qq.com/s/joa-yOiTrYF67bElj8xqvg)\r\n\r\n# 五  AQS\r\n\r\n### 5.1 AQS 介绍\r\n\r\nAQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。\r\n\r\n![enter image description here](https://user-gold-cdn.xitu.io/2018/10/30/166c4bb575d4a690?w=317&h=338&f=png&s=14122)\r\n\r\nAQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。\r\n\r\n### 5.2 AQS 原理分析\r\n\r\nAQS 原理这部分参考了部分博客，在5.2节末尾放了链接。\r\n\r\n> 在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要假如自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。\r\n\r\n下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。\r\n\r\n#### 5.2.1 AQS 原理概览\r\n\r\n\r\n\r\n**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**\r\n\r\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。\r\n\r\n看个AQS(AbstractQueuedSynchronizer)原理图：\r\n\r\n\r\n![enter image description here](https://user-gold-cdn.xitu.io/2018/10/30/166c4bbe4a9c5ae7?w=852&h=401&f=png&s=21797)\r\n\r\nAQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。\r\n\r\n```java\r\nprivate volatile int state;//共享变量，使用volatile修饰保证线程可见性\r\n```\r\n\r\n状态信息通过procted类型的getState，setState，compareAndSetState进行操作\r\n\r\n```java\r\n\r\n//返回同步状态的当前值\r\nprotected final int getState() {  \r\n        return state;\r\n}\r\n // 设置同步状态的值\r\nprotected final void setState(int newState) { \r\n        state = newState;\r\n}\r\n//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\r\nprotected final boolean compareAndSetState(int expect, int update) {\r\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\r\n}\r\n```\r\n\r\n#### 5.2.2 AQS 对资源的共享方式\r\n\r\n**AQS定义两种资源共享方式**\r\n\r\n- **Exclusive**（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：\r\n    - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\r\n    - 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\r\n-  **Share**（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\r\n\r\nReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。\r\n\r\n不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。\r\n\r\n#### 5.2.3 AQS底层使用了模板方法模式\r\n\r\n同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\r\n\r\n1. 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）\r\n2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\r\n\r\n这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。\r\n\r\n**AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：**\r\n\r\n```java\r\nisHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。\r\ntryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。\r\ntryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。\r\ntryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\r\ntryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。\r\n\r\n```\r\n\r\n默认情况下，每个方法都抛出 `UnsupportedOperationException`。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 \r\n\r\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\r\n\r\n再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。\r\n\r\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。\r\n\r\n推荐两篇 AQS 原理和相关源码分析的文章：\r\n\r\n- http://www.cnblogs.com/waterystone/p/4920797.html\r\n- https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html\r\n\r\n### 5.3 AQS 组件总结\r\n\r\n- **Semaphore(信号量)-允许多个线程同时访问：** synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。\r\n- **CountDownLatch （倒计时器）：** CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。\r\n- **CyclicBarrier(循环栅栏)：** CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\r\n\r\n关于AQS这部分的更多内容可以查看我的这篇文章:[并发编程面试必备：AQS 原理以及 AQS 同步组件总结](https://mp.weixin.qq.com/s/joa-yOiTrYF67bElj8xqvg)\r\n\r\n# Reference\r\n\r\n- 《深入理解 Java 虚拟机》\r\n- 《实战 Java 高并发程序设计》\r\n- 《Java并发编程的艺术》\r\n- http://www.cnblogs.com/waterystone/p/4920797.html\r\n- https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html\r\n', 0);
INSERT INTO `blog_course` VALUES (199, 'Java 虚拟机(JVM)', 2, '\r\n下面是按jvm虚拟机知识点分章节总结的一些jvm学习与面试相关的一些东西。一般作为Java程序员在面试的时候一般会问的大多就是**Java内存区域、虚拟机垃圾算法、虚拟垃圾收集器、JVM内存管理**这些问题了。这些内容参考周的《深入理解Java虚拟机》中第二章和第三章就足够了对应下面的[深入理解虚拟机之Java内存区域：](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU4NDQ4MzU5OA%3D%3D%26mid%3D2247483910%26idx%3D1%26sn%3D246f39051a85fc312577499691fba89f%26chksm%3Dfd985467caefdd71f9a7c275952be34484b14f9e092723c19bd4ef557c324169ed084f868bdb%23rd)和[深入理解虚拟机之垃圾回收](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU4NDQ4MzU5OA%3D%3D%26mid%3D2247483914%26idx%3D1%26sn%3D9aa157d4a1570962c39783cdeec7e539%26chksm%3Dfd98546bcaefdd7d9f61cd356e5584e56b64e234c3a403ed93cb6d4dde07a505e3000fd0c427%23rd)这两篇文章。\r\n\r\n\r\n> ### 常见面试题\r\n\r\n[深入理解虚拟机之Java内存区域](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484960&idx=1&sn=ff3739fe849030178346bef28a4556c3&chksm=cea249ebf9d5c0fdbde7c86155d0d7ac8925153742aff472bcb79e5e9d400534a855bad38375&token=1082669959&lang=zh_CN#rd)\r\n\r\n1. 介绍下Java内存区域（运行时数据区）。\r\n\r\n2. 对象的访问定位的两种方式。\r\n\r\n\r\n[深入理解虚拟机之垃圾回收](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484959&idx=1&sn=9ac740edba59981b7c89482043776280&chksm=cea249d4f9d5c0c21703382510a47d4bb387932bd814ac891fd214b92cead5d2cf0ee2dff797&token=1082669959&lang=zh_CN#rd)\r\n\r\n1. 如何判断对象是否死亡（两种方法）。\r\n\r\n2. 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。\r\n\r\n3. 垃圾收集有哪些算法，各自的特点？\r\n\r\n4. HotSpot为什么要分为新生代和老年代？\r\n\r\n5. 常见的垃圾回收器有那些？\r\n\r\n6. 介绍一下CMS,G1收集器。\r\n\r\n7. Minor Gc和Full GC 有什么不同呢？\r\n\r\n\r\n\r\n [虚拟机性能监控和故障处理工具](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484957&idx=1&sn=713ed6003d23ef883ded14cb43e9ebb7&chksm=cea249d6f9d5c0c0ce0854a03f0d02fcacc8a46e29c2fd4f085a375b00e1cd1b632937a9895e&token=1082669959&lang=zh_CN#rd)\r\n\r\n1. JVM调优的常见命令行工具有哪些？\r\n\r\n [深入理解虚拟机之类文件结构](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484956&idx=1&sn=05f46ccacacdbce7c43de594d3fe93db&chksm=cea249d7f9d5c0c1ef6d29b0fbbf0701acd28490deb0974ae71b4d23ae793bec0b0993a4c829&token=1082669959&lang=zh_CN#rd)\r\n\r\n1. 简单介绍一下Class类文件结构（常量池主要存放的是那两大常量？Class文件的继承关系是如何确定的？字段表、方法表、属性表主要包含那些信息？）\r\n\r\n[深入理解虚拟机之虚拟机字节码执行引擎](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484952&idx=1&sn=d0ec9443600dc5b2a81782b7ae0691d5&chksm=cea249d3f9d5c0c50642f1829fd6fe9e35d155bbbb6718611330c7c46c7158279275b533181e&token=1082669959&lang=zh_CN#rd)\r\n\r\n1. 简单说说类加载过程，里面执行了哪些操作？\r\n\r\n2. 对类加载器有了解吗？\r\n\r\n3. 什么是双亲委派模型？\r\n\r\n4. 双亲委派模型的工作过程以及使用它的好处。\r\n\r\n\r\n\r\n\r\n\r\n> ### 推荐阅读\r\n\r\n [《深入理解 Java 内存模型》读书笔记](http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/) （非常不错的文章）\r\n [全面理解Java内存模型(JMM)及volatile关键字 ](https://blog.csdn.net/javazejian/article/details/72772461)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (200, 'Java 内存', 2, '\r\n<!-- TOC -->\r\n\r\n- [写在前面(常见面试题)](#写在前面（常见面试题）)\r\n    - [基本问题](#基本问题)\r\n    - [拓展问题](#拓展问题)\r\n- [一 概述](#一 概述)\r\n- [二 运行时数据区域](#二 运行时数据区域)\r\n    - [2.1 程序计数器](#2.1 程序计数器)\r\n    - [2.2 Java 虚拟机栈](#2.2 Java 虚拟机栈)\r\n    - [2.3 本地方法栈](#2.3 本地方法栈)\r\n    - [2.4 堆](#2.4 堆)\r\n    - [2.5 方法区](#2.5 方法区)\r\n    - [2.6 运行时常量池](#2.6 运行时常量池)\r\n    - [2.7 直接内存](#2.7 直接内存)\r\n- [三 HotSpot 虚拟机对象探秘](#三 HotSpot 虚拟机对象探秘)\r\n    - [3.1 对象的创建](#3.1 对象的创建)\r\n    - [3.2 对象的内存布局](#3.2 对象的内存布局)\r\n    - [3.3 对象的访问定位](#3.3 对象的访问定位)\r\n- [四 重点内容补充](#四 重点内容补充)\r\n    - [String 类和常量池](#String 类和常量池)\r\n    - [String s1 = new String(\"abc\");这句话创建了几个对象？](#这句话创建了几个对象)\r\n    - [8种基本类型的包装类和常量池](#8种基本类型的包装类和常量池)\r\n- [参考](#参考)\r\n\r\n<!-- /TOC -->\r\n## 写在前面（常见面试题）\r\n\r\n### 基本问题\r\n\r\n- **介绍下 Java 内存区域（运行时数据区）**\r\n- **Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）**\r\n- **对象的访问定位的两种方式（句柄和直接指针两种方式）**\r\n\r\n### 拓展问题\r\n\r\n- **String类和常量池**\r\n- **8种基本类型的包装类和常量池**\r\n\r\n\r\n## 一 概述\r\n\r\n对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。\r\n\r\n\r\n## 二 运行时数据区域\r\nJava 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。\r\n\r\n**JDK 1.8之前：**\r\n\r\n<div align=\"center\">  \r\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM运行时数据区域.png\" width=\"600px\"/>\r\n</div>\r\n**JDK 1.8 ：**\r\n\r\n<div align=\"center\">  \r\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3Java运行时数据区域JDK1.8.png\" width=\"600px\"/>\r\n</div>\r\n\r\n**线程私有的：**\r\n\r\n- 程序计数器\r\n- 虚拟机栈\r\n- 本地方法栈\r\n\r\n**线程共享的：**\r\n\r\n- 堆\r\n- 方法区\r\n- 直接内存(非运行时数据区的一部分)\r\n\r\n\r\n### 2.1 程序计数器\r\n程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**\r\n\r\n另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**\r\n\r\n**从上面的介绍中我们知道程序计数器主要有两个作用：**\r\n\r\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\r\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\r\n\r\n**注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**\r\n\r\n### 2.2 Java 虚拟机栈\r\n\r\n**与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**\r\n\r\n**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）\r\n\r\n**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\r\n\r\n**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**\r\n\r\n- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。\r\n- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。\r\n\r\nJava 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。\r\n\r\n**扩展：那么方法/函数如何调用？**\r\n\r\nJava 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。\r\n\r\nJava方法有两种返回方式：\r\n\r\n1. return 语句。\r\n2. 抛出异常。\r\n\r\n不管哪种返回方式都会导致栈帧被弹出。\r\n\r\n### 2.3 本地方法栈\r\n\r\n和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\r\n\r\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\r\n\r\n方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。\r\n\r\n### 2.4 堆\r\nJava 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**\r\n\r\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**\r\n\r\n<div align=\"center\">  \r\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png\" width=\"400px\"/>\r\n</div>\r\n\r\n上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\r\n\r\n### 2.5 方法区\r\n\r\n方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。\r\n\r\n方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。\r\n\r\n#### 方法区和永久代的关系\r\n\r\n> 《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。  **方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。\r\n\r\n#### 常用参数\r\n\r\nJDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\r\n\r\n```java\r\n-XX:PermSize=N //方法区(永久代)初始大小\r\n-XX:MaxPermSize=N //方法区(永久代)最大大小,超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen\r\n```\r\n\r\n相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**\r\n\r\nJDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。\r\n\r\n下面是一些常用参数：\r\n\r\n```java\r\n-XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）\r\n-XX:MaxMetaspaceSize=N //设置Metaspace的最大大小\r\n```\r\n\r\n与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\r\n\r\n#### 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?\r\n\r\n整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。\r\n\r\n当然这只是其中一个原因，还有很多底层的原因，这里就不提了。\r\n\r\n### 2.6 运行时常量池\r\n\r\n运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）\r\n\r\n既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。\r\n\r\n**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。** \r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/26038433.jpg)\r\n——图片来源：https://blog.csdn.net/wangbiao007/article/details/78545189\r\n\r\n\r\n### 2.7 直接内存\r\n\r\n**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**\r\n\r\nJDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。\r\n\r\n本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。\r\n\r\n\r\n## 三 HotSpot 虚拟机对象探秘\r\n通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。\r\n\r\n### 3.1 对象的创建\r\n下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。\r\n![Java对象的创建过程](https://user-gold-cdn.xitu.io/2018/8/22/16561e59a4135869?w=950&h=279&f=png&s=28529)\r\n\r\n**①类加载检查：** 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\r\n\r\n**②分配内存：** 在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。\r\n\r\n\r\n**内存分配的两种方式：（补充内容，需要掌握）**\r\n\r\n选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是\"标记-清除\"，还是\"标记-整理\"（也称作\"标记-压缩\"），值得注意的是，复制算法内存也是规整的\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/8/22/16561e59a40a2c3d?w=1426&h=333&f=png&s=26346)\r\n\r\n**内存分配并发问题（补充内容，需要掌握）**\r\n\r\n在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：\r\n\r\n- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**\r\n- **TLAB：** 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配\r\n\r\n\r\n\r\n**③初始化零值：** 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\r\n\r\n**④设置对象头：** 初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\r\n\r\n\r\n**⑤执行 init 方法：** 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\r\n\r\n\r\n### 3.2 对象的内存布局\r\n\r\n在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：**对象头**、**实例数据**和**对齐填充**。\r\n\r\n**Hotspot虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的自身运行时数据**（哈希码、GC分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。\r\n\r\n**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。\r\n\r\n**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\r\n\r\n### 3.3 对象的访问定位\r\n建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：\r\n\r\n1. **句柄：** 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；\r\n![使用句柄](https://user-gold-cdn.xitu.io/2018/4/27/16306b9573968946?w=786&h=362&f=png&s=109201)\r\n\r\n2. **直接指针：**  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。\r\n\r\n![使用直接指针](https://user-gold-cdn.xitu.io/2018/4/27/16306ba3a41b6b65?w=766&h=353&f=png&s=99172)\r\n\r\n**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**\r\n\r\n\r\n\r\n\r\n## 四 重点内容补充\r\n\r\n### String 类和常量池\r\n\r\n**1 String 对象的两种创建方式：**\r\n\r\n```java\r\n     String str1 = \"abcd\";\r\n     String str2 = new String(\"abcd\");\r\n     System.out.println(str1==str2);//false\r\n```\r\n\r\n这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。\r\n![](https://user-gold-cdn.xitu.io/2018/8/22/16561e59a59c0873?w=698&h=355&f=png&s=10449)\r\n记住：只要使用new方法，便需要创建新的对象。\r\n\r\n\r\n\r\n**2 String 类型的常量池比较特殊。它的主要使用方法有两种：**\r\n\r\n- 直接使用双引号声明出来的 String 对象会直接存储在常量池中。\r\n- 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。\r\n\r\n```java\r\n	      String s1 = new String(\"计算机\");\r\n	      String s2 = s1.intern();\r\n	      String s3 = \"计算机\";\r\n	      System.out.println(s2);//计算机\r\n	      System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，\r\n	      System.out.println(s3 == s2);//true，因为两个都是常量池中的String对象\r\n```\r\n**3 String 字符串拼接**\r\n```java\r\n		  String str1 = \"str\";\r\n		  String str2 = \"ing\";\r\n		  \r\n		  String str3 = \"str\" + \"ing\";//常量池中的对象\r\n		  String str4 = str1 + str2; //在堆上创建的新的对象	  \r\n		  String str5 = \"string\";//常量池中的对象\r\n		  System.out.println(str3 == str4);//false\r\n		  System.out.println(str3 == str5);//true\r\n		  System.out.println(str4 == str5);//false\r\n```\r\n![](https://user-gold-cdn.xitu.io/2018/8/22/16561e59a4d13f92?w=593&h=603&f=png&s=22265)\r\n\r\n尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。\r\n### 这句话创建了几个对象\r\n`String s1 = new String（\"abc\"）;`\r\n**创建了两个对象。**\r\n\r\n**验证：**\r\n\r\n```java\r\n		String s1 = new String(\"abc\");// 堆内存的地址值\r\n		String s2 = \"abc\";\r\n		System.out.println(s1 == s2);// 输出false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。\r\n		System.out.println(s1.equals(s2));// 输出true\r\n```\r\n\r\n**结果：**\r\n\r\n```\r\nfalse\r\ntrue\r\n```\r\n\r\n**解释：**\r\n\r\n先有字符串\"abc\"放入常量池，然后 new 了一份字符串\"abc\"放入Java堆(字符串常量\"abc\"在编译期就已经确定放入常量池，而 Java 堆上的\"abc\"是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的\"abc\"。 \r\n\r\n### 8种基本类型的包装类和常量池\r\n\r\n- **Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。**\r\n- **两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**\r\n\r\n```java\r\n		Integer i1 = 33;\r\n		Integer i2 = 33;\r\n		System.out.println(i1 == i2);// 输出true\r\n		Integer i11 = 333;\r\n		Integer i22 = 333;\r\n		System.out.println(i11 == i22);// 输出false\r\n		Double i3 = 1.2;\r\n		Double i4 = 1.2;\r\n		System.out.println(i3 == i4);// 输出false\r\n```\r\n\r\n**Integer 缓存源代码：** \r\n\r\n```java\r\n/**\r\n*此方法将始终缓存-128到127（包括端点）范围内的值，并可以缓存此范围之外的其他值。\r\n*/\r\n    public static Integer valueOf(int i) {\r\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\r\n            return IntegerCache.cache[i + (-IntegerCache.low)];\r\n        return new Integer(i);\r\n    }\r\n\r\n```\r\n\r\n**应用场景：**\r\n1. Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。\r\n2.  Integer i1 = new Integer(40);这种情况下会创建新的对象。\r\n\r\n```java\r\n  Integer i1 = 40;\r\n  Integer i2 = new Integer(40);\r\n  System.out.println(i1==i2);//输出false\r\n```\r\n**Integer比较更丰富的一个例子:**\r\n\r\n```java\r\n  Integer i1 = 40;\r\n  Integer i2 = 40;\r\n  Integer i3 = 0;\r\n  Integer i4 = new Integer(40);\r\n  Integer i5 = new Integer(40);\r\n  Integer i6 = new Integer(0);\r\n  \r\n  System.out.println(\"i1=i2   \" + (i1 == i2));\r\n  System.out.println(\"i1=i2+i3   \" + (i1 == i2 + i3));\r\n  System.out.println(\"i1=i4   \" + (i1 == i4));\r\n  System.out.println(\"i4=i5   \" + (i4 == i5));\r\n  System.out.println(\"i4=i5+i6   \" + (i4 == i5 + i6));   \r\n  System.out.println(\"40=i5+i6   \" + (40 == i5 + i6));     \r\n```\r\n\r\n结果：\r\n\r\n```\r\ni1=i2   true\r\ni1=i2+i3   true\r\ni1=i4   false\r\ni4=i5   false\r\ni4=i5+i6   true\r\n40=i5+i6   true\r\n```\r\n\r\n解释：\r\n\r\n语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。\r\n\r\n## 参考\r\n\r\n- 《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版》\r\n- 《实战java虚拟机》\r\n- <https://docs.oracle.com/javase/specs/index.html>\r\n- <http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/>\r\n- <https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou>\r\n- <https://stackoverflow.com/questions/9095748/method-area-and-permgen>\r\n\r\n\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (201, 'Java 垃圾回收', 2, '\r\n上文回顾：[《可能是把Java内存区域讲的最清楚的一篇文章》](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd)\r\n## 写在前面\r\n\r\n### 本节常见面试题：\r\n\r\n问题答案在文中都有提到\r\n\r\n- 如何判断对象是否死亡（两种方法）。\r\n- 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。\r\n- 如何判断一个常量是废弃常量\r\n- 如何判断一个类是无用的类\r\n- 垃圾收集有哪些算法，各自的特点？\r\n- HotSpot为什么要分为新生代和老年代？\r\n- 常见的垃圾回收器有那些？\r\n- 介绍一下CMS,G1收集器。\r\n- Minor Gc和Full GC 有什么不同呢？\r\n\r\n### 本文导火索\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/29176325.jpg)\r\n\r\n当需要排查各种 内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。\r\n\r\n\r\n\r\n## 1  揭开JVM内存分配与回收的神秘面纱\r\n\r\nJava 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。\r\n\r\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**\r\n\r\n**堆空间的基本结构：**\r\n\r\n<div align=\"center\">  \r\n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png\" width=\"400px\"/>\r\n</div>\r\n\r\n上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\r\n\r\n\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/89294547.jpg)\r\n\r\n### 1.1 对象优先在eden区分配\r\n\r\n目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\r\n\r\n大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC.下面我们来进行实际测试以下。\r\n\r\n在测试之前我们先来看看 **Minor GC和Full GC 有什么不同呢？**\r\n\r\n- **新生代GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。\r\n- **老年代GC（Major GC/Full GC）**:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。\r\n\r\n**测试：**\r\n\r\n```java\r\npublic class GCTest {\r\n\r\n	public static void main(String[] args) {\r\n		byte[] allocation1, allocation2;\r\n		allocation1 = new byte[30900*1024];\r\n		//allocation2 = new byte[900*1024];\r\n	}\r\n}\r\n```\r\n通过以下方式运行：\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/25178350.jpg)\r\n\r\n添加的参数：`-XX:+PrintGCDetails`\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/10317146.jpg)\r\n\r\n运行结果(红色字体描述有误，应该是对应于JDK1.7的永久代)：\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28954286.jpg)\r\n\r\n从上图我们可以看出eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用2000多k内存）。假如我们再为allocation2分配内存会出现什么情况呢？\r\n\r\n```java\r\nallocation2 = new byte[900*1024];\r\n```\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28128785.jpg)\r\n\r\n**简单解释一下为什么会出现这种情况：** 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.GC期间虚拟机又发现allocation1无法存入Survivor空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。可以执行如下代码验证：\r\n\r\n```java\r\npublic class GCTest {\r\n\r\n	public static void main(String[] args) {\r\n		byte[] allocation1, allocation2,allocation3,allocation4,allocation5;\r\n		allocation1 = new byte[32000*1024];\r\n		allocation2 = new byte[1000*1024];\r\n		allocation3 = new byte[1000*1024];\r\n		allocation4 = new byte[1000*1024];\r\n		allocation5 = new byte[1000*1024];\r\n	}\r\n}\r\n\r\n```\r\n\r\n\r\n### 1.2 大对象直接进入老年代\r\n大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\r\n\r\n**为什么要这样呢？**\r\n\r\n为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。\r\n\r\n### 1.3 长期存活的对象将进入老年代\r\n既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。\r\n\r\n如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\r\n\r\n### 1.4 动态对象年龄判定\r\n\r\n为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。\r\n\r\n\r\n## 2 对象已经死亡？\r\n\r\n堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/11034259.jpg)\r\n\r\n### 2.1 引用计数法\r\n\r\n给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。\r\n\r\n**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。\r\n\r\n```java\r\npublic class ReferenceCountingGc {\r\n    Object instance = null;\r\n	public static void main(String[] args) {\r\n		ReferenceCountingGc objA = new ReferenceCountingGc();\r\n		ReferenceCountingGc objB = new ReferenceCountingGc();\r\n		objA.instance = objB;\r\n		objB.instance = objA;\r\n		objA = null;\r\n		objB = null;\r\n\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n### 2.2 可达性分析算法\r\n\r\n这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\r\n\r\n![可达性分析算法](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/72762049.jpg)\r\n\r\n\r\n### 2.3 再谈引用\r\n\r\n无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。\r\n\r\nJDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\r\n\r\nJDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\r\n\r\n\r\n\r\n**1．强引用**\r\n\r\n以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\r\n\r\n**2．软引用（SoftReference）**\r\n\r\n如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\r\n\r\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。\r\n\r\n**3．弱引用（WeakReference）**\r\n\r\n如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 \r\n\r\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\r\n\r\n**4．虚引用（PhantomReference）**\r\n\r\n\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\r\n\r\n**虚引用主要用来跟踪对象被垃圾回收的活动**。\r\n\r\n**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 \r\n\r\n特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。\r\n\r\n### 2.4 不可达的对象并非“非死不可”\r\n\r\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\r\n\r\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\r\n\r\n### 2.5 如何判断一个常量是废弃常量\r\n\r\n运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？\r\n\r\n假如在常量池中存在字符串 \"abc\"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 \"abc\" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\"abc\" 就会被系统清理出常量池。\r\n\r\n注意：我们在 [可能是把Java内存区域讲的最清楚的一篇文章](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd) 也讲了JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。\r\n\r\n### 2.6 如何判断一个类是无用的类\r\n\r\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\r\n\r\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 **“无用的类”** ：\r\n\r\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\r\n- 加载该类的 ClassLoader 已经被回收。\r\n- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\r\n\r\n虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\r\n\r\n\r\n## 3 垃圾收集算法\r\n\r\n![垃圾收集算法](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/1142723.jpg)\r\n\r\n### 3.1 标记-清除算法\r\n\r\n算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：\r\n\r\n1. **效率问题**\r\n2. **空间问题（标记清除后会产生大量不连续的碎片）**\r\n\r\n![标记-清除算法](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/63707281.jpg)\r\n\r\n### 3.2 复制算法\r\n\r\n为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\r\n\r\n![复制算法](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/90984624.jpg)\r\n\r\n### 3.3 标记-整理算法\r\n根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\r\n\r\n![标记-整理算法](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/94057049.jpg)\r\n\r\n### 3.4 分代收集算法\r\n\r\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\r\n\r\n**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**\r\n\r\n**延伸面试问题：** HotSpot为什么要分为新生代和老年代？\r\n\r\n根据上面的对分代收集算法的介绍回答。\r\n\r\n## 4 垃圾收集器\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/41460955.jpg)\r\n\r\n**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**\r\n\r\n虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为知道现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，**我们能做的就是根据具体应用场景选择适合自己的垃圾收集器**。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。\r\n\r\n\r\n### 4.1 Serial收集器\r\nSerial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **\"Stop The World\"** ），直到它收集结束。\r\n\r\n **新生代采用复制算法，老年代采用标记-整理算法。**\r\n![ Serial收集器](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/46873026.jpg)\r\n\r\n虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\r\n\r\n但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。\r\n\r\n\r\n\r\n### 4.2 ParNew收集器\r\n**ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。**\r\n\r\n **新生代采用复制算法，老年代采用标记-整理算法。**\r\n![ParNew收集器](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg)\r\n\r\n它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\r\n\r\n**并行和并发概念补充：**\r\n\r\n- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\r\n\r\n- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。\r\n\r\n\r\n### 4.3 Parallel Scavenge收集器\r\n\r\nParallel Scavenge 收集器类似于ParNew 收集器。 **那么它有什么特别之处呢？**\r\n\r\n```\r\n-XX:+UseParallelGC \r\n\r\n    使用Parallel收集器+ 老年代串行\r\n\r\n-XX:+UseParallelOldGC\r\n\r\n    使用Parallel收集器+ 老年代并行\r\n\r\n```\r\n\r\n**Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。** Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\r\n\r\n **新生代采用复制算法，老年代采用标记-整理算法。**\r\n![ParNew收集器](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg)\r\n\r\n\r\n### 4.4.Serial Old收集器\r\n**Serial收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。\r\n\r\n### 4.5 Parallel Old收集器\r\n **Parallel Scavenge收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。\r\n\r\n### 4.6 CMS收集器\r\n\r\n**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。**\r\n\r\n**CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**\r\n\r\n从名字中的**Mark Sweep**这两个词可以看出，CMS收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\r\n\r\n- **初始标记：** 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；\r\n- **并发标记：** 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\r\n- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\r\n- **并发清除：** 开启用户线程，同时GC线程开始对为标记的区域做清扫。\r\n\r\n![CMS垃圾收集器](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/82825079.jpg)\r\n\r\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：\r\n\r\n- **对CPU资源敏感；**\r\n- **无法处理浮动垃圾；**\r\n- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**\r\n\r\n### 4.7 G1收集器\r\n\r\n\r\n**G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.**\r\n\r\n被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：\r\n\r\n- **并行与并发**：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。\r\n- **分代收集**：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。\r\n- **空间整合**：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。\r\n- **可预测的停顿**：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。\r\n\r\n\r\nG1收集器的运作大致分为以下几个步骤：\r\n\r\n- **初始标记**\r\n- **并发标记**\r\n- **最终标记**\r\n- **筛选回收**\r\n\r\n\r\n**G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\r\n\r\n\r\n\r\n\r\n\r\n参考：\r\n\r\n- 《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版》\r\n- https://my.oschina.net/hosee/blog/644618\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (202, 'Java AQS', 2, '\r\n**目录：**\r\n<!-- MarkdownTOC -->\r\n\r\n- [1 AQS 简单介绍](#1 AQS 简单介绍)\r\n- [2 AQS 原理](#2 AQS 原理)\r\n  - [2.1 AQS 原理概览](#2.1 AQS 原理概览)\r\n  - [2.2 AQS 对资源的共享方式](#2.2 AQS 对资源的共享方式)\r\n  - [2.3 AQS底层使用了模板方法模式](#2.3 AQS底层使用了模板方法模式)\r\n- [3 Semaphore\\(信号量\\)-允许多个线程同时访问](#3 Semaphore（信号量-允许多个线程同时访问）)\r\n- [4 CountDownLatch （倒计时器）](#4 CountDownLatch （倒计时器）)\r\n  - [4.1 CountDownLatch 的三种典型用法](#4.1 CountDownLatch 的三种典型用法)\r\n  - [4.2 CountDownLatch 的使用示例](#4.2 CountDownLatch 的使用示例)\r\n  - [4.3 CountDownLatch 的不足](#4.3 CountDownLatch 的不足)\r\n  - [4.4 CountDownLatch相常见面试题：](#4.4 CountDownLatch相常见面试题:)\r\n- [5 CyclicBarrier\\(循环栅栏\\)](#5 CyclicBarrier（循环栅栏）)\r\n  - [5.1 CyclicBarrier 的应用场景](#5.1 CyclicBarrier 的应用场景)\r\n  - [5.2 CyclicBarrier 的使用示例](#5.2 CyclicBarrier 的使用示例)\r\n  - [5.3 CyclicBarrier和CountDownLatch的区别](#5.3 CyclicBarrier和CountDownLatch的区别)\r\n- [6 ReentrantLock 和 ReentrantReadWriteLock](#6 ReentrantLock 和 ReentrantReadWriteLock)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n> 常见问题：AQS原理？;CountDownLatch和CyclicBarrier了解吗,两者的区别是什么？用过Semaphore吗？\r\n\r\n**本节思维导图：**\r\n\r\n![并发编程面试必备：AQS 原理以及 AQS 同步组件总结](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-31/61115865.jpg)\r\n\r\n\r\n### 1 AQS 简单介绍\r\nAQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。\r\n\r\n![enter image description here](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/AQS.png)\r\n\r\nAQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。\r\n\r\n### 2 AQS 原理\r\n\r\n> 在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。\r\n\r\n下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。\r\n\r\n#### 2.1 AQS 原理概览\r\n\r\n**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**\r\n\r\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。\r\n\r\n看个AQS(AbstractQueuedSynchronizer)原理图：\r\n\r\n\r\n![enter image description here](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/CLH.png)\r\n\r\nAQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。\r\n\r\n```java\r\nprivate volatile int state;//共享变量，使用volatile修饰保证线程可见性\r\n```\r\n\r\n状态信息通过protected类型的getState，setState，compareAndSetState进行操作\r\n\r\n```java\r\n\r\n//返回同步状态的当前值\r\nprotected final int getState() {  \r\n        return state;\r\n}\r\n // 设置同步状态的值\r\nprotected final void setState(int newState) { \r\n        state = newState;\r\n}\r\n//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\r\nprotected final boolean compareAndSetState(int expect, int update) {\r\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\r\n}\r\n```\r\n\r\n#### 2.2 AQS 对资源的共享方式\r\n\r\n**AQS定义两种资源共享方式**\r\n\r\n- **Exclusive**（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：\r\n    - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\r\n    - 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\r\n-  **Share**（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\r\n\r\nReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。\r\n\r\n不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层已经帮我们实现好了。\r\n\r\n#### 2.3 AQS底层使用了模板方法模式\r\n\r\n同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\r\n\r\n1. 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）\r\n2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\r\n\r\n这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。\r\n\r\n> 模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票`buyTicket()`->安检`securityCheck()`->乘坐某某工具回家`ride()`->到达目的地`arrive()`。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了`ride()`方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 `ride()`方法。\r\n\r\n**AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：**\r\n\r\n```java\r\nisHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。\r\ntryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。\r\ntryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。\r\ntryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\r\ntryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。\r\n\r\n```\r\n\r\n默认情况下，每个方法都抛出 `UnsupportedOperationException`。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 \r\n\r\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\r\n\r\n再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。\r\n\r\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。\r\n\r\n推荐两篇 AQS 原理和相关源码分析的文章：\r\n\r\n- http://www.cnblogs.com/waterystone/p/4920797.html\r\n- https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html\r\n\r\n\r\n\r\n### 3 Semaphore（信号量-允许多个线程同时访问）\r\n\r\n**synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。**示例代码如下：\r\n\r\n```java\r\n/**\r\n * \r\n * @author Snailclimb\r\n * @date 2018年9月30日\r\n * @Description: 需要一次性拿一个许可的情况\r\n */\r\npublic class SemaphoreExample1 {\r\n  // 请求的数量\r\n  private static final int threadCount = 550;\r\n\r\n  public static void main(String[] args) throws InterruptedException {\r\n    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）\r\n    ExecutorService threadPool = Executors.newFixedThreadPool(300);\r\n    // 一次只能允许执行的线程数量。\r\n    final Semaphore semaphore = new Semaphore(20);\r\n\r\n    for (int i = 0; i < threadCount; i++) {\r\n      final int threadnum = i;\r\n      threadPool.execute(() -> {// Lambda 表达式的运用\r\n        try {\r\n          semaphore.acquire();// 获取一个许可，所以可运行线程数量为20/1=20\r\n          test(threadnum);\r\n          semaphore.release();// 释放一个许可\r\n        } catch (InterruptedException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        }\r\n\r\n      });\r\n    }\r\n    threadPool.shutdown();\r\n    System.out.println(\"finish\");\r\n  }\r\n\r\n  public static void test(int threadnum) throws InterruptedException {\r\n    Thread.sleep(1000);// 模拟请求的耗时操作\r\n    System.out.println(\"threadnum:\" + threadnum);\r\n    Thread.sleep(1000);// 模拟请求的耗时操作\r\n  }\r\n}\r\n```\r\n\r\n执行 `acquire` 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 `release` 方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。 Semaphore经常用于限制获取某种资源的线程数量。\r\n\r\n当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：\r\n\r\n```java\r\n          semaphore.acquire(5);// 获取5个许可，所以可运行线程数量为20/5=4\r\n          test(threadnum);\r\n          semaphore.release(5);// 获取5个许可，所以可运行线程数量为20/5=4\r\n```\r\n\r\n除了 `acquire`方法之外，另一个比较常用的与之对应的方法是`tryAcquire`方法，该方法如果获取不到许可就立即返回false。\r\n\r\n\r\nSemaphore 有两种模式，公平模式和非公平模式。\r\n\r\n- **公平模式：** 调用acquire的顺序就是获取许可证的顺序，遵循FIFO；\r\n- **非公平模式：** 抢占式的。\r\n\r\n**Semaphore 对应的两个构造方法如下：**\r\n\r\n```java\r\n   public Semaphore(int permits) {\r\n        sync = new NonfairSync(permits);\r\n    }\r\n\r\n    public Semaphore(int permits, boolean fair) {\r\n        sync = fair ? new FairSync(permits) : new NonfairSync(permits);\r\n    }\r\n```\r\n**这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。** \r\n\r\n由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下面这篇文章：\r\n\r\n- https://blog.csdn.net/qq_19431333/article/details/70212663\r\n\r\n### 4 CountDownLatch （倒计时器）\r\n\r\nCountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。在Java并发中，countdownlatch的概念是一个常见的面试题，所以一定要确保你很好的理解了它。\r\n\r\n#### 4.1 CountDownLatch 的三种典型用法\r\n\r\n①某一线程在开始运行前等待n个线程执行完毕。将 CountDownLatch 的计数器初始化为n ：`new CountDownLatch(n) `，每当一个任务线程执行完毕，就将计数器减1 `countdownlatch.countDown()`，当计数器的值变为0时，在`CountDownLatch上 await()` 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。\r\n\r\n②实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 `CountDownLatch` 对象，将其计数器初始化为 1 ：`new CountDownLatch(1) `，多个线程在开始执行任务前首先 `coundownlatch.await()`，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。\r\n\r\n③死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。\r\n\r\n#### 4.2 CountDownLatch 的使用示例\r\n\r\n```java\r\n/**\r\n * \r\n * @author SnailClimb\r\n * @date 2018年10月1日\r\n * @Description: CountDownLatch 使用方法示例\r\n */\r\npublic class CountDownLatchExample1 {\r\n  // 请求的数量\r\n  private static final int threadCount = 550;\r\n\r\n  public static void main(String[] args) throws InterruptedException {\r\n    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）\r\n    ExecutorService threadPool = Executors.newFixedThreadPool(300);\r\n    final CountDownLatch countDownLatch = new CountDownLatch(threadCount);\r\n    for (int i = 0; i < threadCount; i++) {\r\n      final int threadnum = i;\r\n      threadPool.execute(() -> {// Lambda 表达式的运用\r\n        try {\r\n          test(threadnum);\r\n        } catch (InterruptedException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        } finally {\r\n          countDownLatch.countDown();// 表示一个请求已经被完成\r\n        }\r\n\r\n      });\r\n    }\r\n    countDownLatch.await();\r\n    threadPool.shutdown();\r\n    System.out.println(\"finish\");\r\n  }\r\n\r\n  public static void test(int threadnum) throws InterruptedException {\r\n    Thread.sleep(1000);// 模拟请求的耗时操作\r\n    System.out.println(\"threadnum:\" + threadnum);\r\n    Thread.sleep(1000);// 模拟请求的耗时操作\r\n  }\r\n}\r\n\r\n```\r\n上面的代码中，我们定义了请求的数量为550，当这550个请求被处理完成之后，才会执行`System.out.println(\"finish\");`。\r\n\r\n与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。\r\n\r\n其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。\r\n\r\n#### 4.3 CountDownLatch 的不足\r\n\r\nCountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。\r\n\r\n#### 4.4 CountDownLatch相常见面试题:\r\n\r\n解释一下CountDownLatch概念？\r\n\r\nCountDownLatch 和CyclicBarrier的不同之处？\r\n\r\n给出一些CountDownLatch使用的例子？\r\n\r\nCountDownLatch 类中主要的方法？\r\n\r\n### 5 CyclicBarrier（循环栅栏）\r\n\r\nCyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。\r\n\r\nCyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 `CyclicBarrier(int parties)`，其参数表示屏障拦截的线程数量，每个线程调用`await`方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\r\n\r\n#### 5.1 CyclicBarrier 的应用场景\r\n\r\nCyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。\r\n\r\n#### 5.2 CyclicBarrier 的使用示例\r\n\r\n示例1：\r\n\r\n```java\r\n/**\r\n * \r\n * @author Snailclimb\r\n * @date 2018年10月1日\r\n * @Description: 测试 CyclicBarrier 类中带参数的 await() 方法\r\n */\r\npublic class CyclicBarrierExample2 {\r\n  // 请求的数量\r\n  private static final int threadCount = 550;\r\n  // 需要同步的线程数量\r\n  private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5);\r\n\r\n  public static void main(String[] args) throws InterruptedException {\r\n    // 创建线程池\r\n    ExecutorService threadPool = Executors.newFixedThreadPool(10);\r\n\r\n    for (int i = 0; i < threadCount; i++) {\r\n      final int threadNum = i;\r\n      Thread.sleep(1000);\r\n      threadPool.execute(() -> {\r\n        try {\r\n          test(threadNum);\r\n        } catch (InterruptedException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        } catch (BrokenBarrierException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        }\r\n      });\r\n    }\r\n    threadPool.shutdown();\r\n  }\r\n\r\n  public static void test(int threadnum) throws InterruptedException, BrokenBarrierException {\r\n    System.out.println(\"threadnum:\" + threadnum + \"is ready\");\r\n    try {\r\n      /**等待60秒，保证子线程完全执行结束*/  \r\n      cyclicBarrier.await(60, TimeUnit.SECONDS);\r\n    } catch (Exception e) {\r\n      System.out.println(\"-----CyclicBarrierException------\");\r\n    }\r\n    System.out.println(\"threadnum:\" + threadnum + \"is finish\");\r\n  }\r\n\r\n}\r\n```\r\n\r\n运行结果，如下：\r\n\r\n```\r\nthreadnum:0is ready\r\nthreadnum:1is ready\r\nthreadnum:2is ready\r\nthreadnum:3is ready\r\nthreadnum:4is ready\r\nthreadnum:4is finish\r\nthreadnum:0is finish\r\nthreadnum:1is finish\r\nthreadnum:2is finish\r\nthreadnum:3is finish\r\nthreadnum:5is ready\r\nthreadnum:6is ready\r\nthreadnum:7is ready\r\nthreadnum:8is ready\r\nthreadnum:9is ready\r\nthreadnum:9is finish\r\nthreadnum:5is finish\r\nthreadnum:8is finish\r\nthreadnum:7is finish\r\nthreadnum:6is finish\r\n......\r\n```\r\n可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， `await`方法之后的方法才被执行。 \r\n\r\n另外，CyclicBarrier还提供一个更高级的构造函数`CyclicBarrier(int parties, Runnable barrierAction)`，用于在线程到达屏障时，优先执行`barrierAction`，方便处理更复杂的业务场景。示例代码如下：\r\n\r\n```java\r\n/**\r\n * \r\n * @author SnailClimb\r\n * @date 2018年10月1日\r\n * @Description: 新建 CyclicBarrier 的时候指定一个 Runnable\r\n */\r\npublic class CyclicBarrierExample3 {\r\n  // 请求的数量\r\n  private static final int threadCount = 550;\r\n  // 需要同步的线程数量\r\n  private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -> {\r\n    System.out.println(\"------当线程数达到之后，优先执行------\");\r\n  });\r\n\r\n  public static void main(String[] args) throws InterruptedException {\r\n    // 创建线程池\r\n    ExecutorService threadPool = Executors.newFixedThreadPool(10);\r\n\r\n    for (int i = 0; i < threadCount; i++) {\r\n      final int threadNum = i;\r\n      Thread.sleep(1000);\r\n      threadPool.execute(() -> {\r\n        try {\r\n          test(threadNum);\r\n        } catch (InterruptedException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        } catch (BrokenBarrierException e) {\r\n          // TODO Auto-generated catch block\r\n          e.printStackTrace();\r\n        }\r\n      });\r\n    }\r\n    threadPool.shutdown();\r\n  }\r\n\r\n  public static void test(int threadnum) throws InterruptedException, BrokenBarrierException {\r\n    System.out.println(\"threadnum:\" + threadnum + \"is ready\");\r\n    cyclicBarrier.await();\r\n    System.out.println(\"threadnum:\" + threadnum + \"is finish\");\r\n  }\r\n\r\n}\r\n```\r\n\r\n运行结果，如下：\r\n\r\n```\r\nthreadnum:0is ready\r\nthreadnum:1is ready\r\nthreadnum:2is ready\r\nthreadnum:3is ready\r\nthreadnum:4is ready\r\n------当线程数达到之后，优先执行------\r\nthreadnum:4is finish\r\nthreadnum:0is finish\r\nthreadnum:2is finish\r\nthreadnum:1is finish\r\nthreadnum:3is finish\r\nthreadnum:5is ready\r\nthreadnum:6is ready\r\nthreadnum:7is ready\r\nthreadnum:8is ready\r\nthreadnum:9is ready\r\n------当线程数达到之后，优先执行------\r\nthreadnum:9is finish\r\nthreadnum:5is finish\r\nthreadnum:6is finish\r\nthreadnum:8is finish\r\nthreadnum:7is finish\r\n......\r\n```\r\n#### 5.3 CyclicBarrier和CountDownLatch的区别\r\n\r\nCountDownLatch是计数器，只能使用一次，而CyclicBarrier的计数器提供reset功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从jdk作者设计的目的来看，javadoc是这么描述它们的：\r\n\r\n> CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；)\r\n> CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)\r\n\r\n对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。\r\n\r\nCountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。\r\n\r\n![CyclicBarrier和CountDownLatch的区别](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/AQS333.png)\r\n\r\nCyclicBarrier和CountDownLatch的区别这部分内容参考了如下两篇文章：\r\n\r\n- https://blog.csdn.net/u010185262/article/details/54692886\r\n- https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0\r\n\r\n### 6 ReentrantLock 和 ReentrantReadWriteLock\r\n\r\nReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。\r\n\r\n由于篇幅问题，关于 ReentrantLock 和 ReentrantReadWriteLock 详细内容可以查看我的这篇原创文章。\r\n\r\n- [ReentrantLock 和 ReentrantReadWriteLock](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483745&idx=2&sn=6778ee954a19816310df54ef9a3c2f8a&chksm=fd985700caefde16b9970f5e093b0c140d3121fb3a8458b11871e5e9723c5fd1b5a961fd2228&token=1829606453&lang=zh_CN#rd)\r\n', 0);
INSERT INTO `blog_course` VALUES (203, 'Java Atomic', 2, '> 个人觉得这一节掌握基本的使用即可！\r\n\r\n**本节思维导图:**\r\n\r\n![](https://user-gold-cdn.xitu.io/2018/10/30/166c58b785368234?w=1200&h=657&f=png&s=49615)\r\n\r\n### 1 Atomic 原子类介绍\r\n\r\nAtomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。\r\n\r\n所以，所谓原子类说简单点就是具有原子/原子操作特征的类。\r\n\r\n并发包 `java.util.concurrent` 的原子类都存放在`java.util.concurrent.atomic`下,如下图所示。\r\n\r\n![ JUC 原子类概览](https://user-gold-cdn.xitu.io/2018/10/30/166c4ac08d4c5547?w=317&h=367&f=png&s=13267)\r\n\r\n根据操作的数据类型，可以将JUC包中的原子类分为4类\r\n\r\n**基本类型** \r\n\r\n使用原子的方式更新基本类型\r\n\r\n- AtomicInteger：整型原子类\r\n- AtomicLong：长整型原子类\r\n-  AtomicBoolean ：布尔型原子类\r\n\r\n**数组类型**\r\n\r\n使用原子的方式更新数组里的某个元素\r\n\r\n\r\n- AtomicIntegerArray：整型数组原子类\r\n- AtomicLongArray：长整型数组原子类\r\n- AtomicReferenceArray ：引用类型数组原子类\r\n\r\n**引用类型**\r\n\r\n- AtomicReference：引用类型原子类\r\n- AtomicStampedRerence：原子更新引用类型里的字段原子类\r\n- AtomicMarkableReference ：原子更新带有标记位的引用类型\r\n\r\n**对象的属性修改类型**\r\n\r\n- AtomicIntegerFieldUpdater:原子更新整型字段的更新器\r\n- AtomicLongFieldUpdater：原子更新长整型字段的更新器\r\n- AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\r\n\r\n下面我们来详细介绍一下这些原子类。\r\n\r\n### 2 基本类型原子类\r\n\r\n#### 2.1 基本类型原子类介绍\r\n\r\n使用原子的方式更新基本类型\r\n\r\n- AtomicInteger：整型原子类\r\n- AtomicLong：长整型原子类\r\n-  AtomicBoolean ：布尔型原子类\r\n\r\n上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。\r\n\r\n **AtomicInteger 类常用方法**\r\n \r\n```java\r\npublic final int get() //获取当前的值\r\npublic final int getAndSet(int newValue)//获取当前的值，并设置新的值\r\npublic final int getAndIncrement()//获取当前的值，并自增\r\npublic final int getAndDecrement() //获取当前的值，并自减\r\npublic final int getAndAdd(int delta) //获取当前的值，并加上预期的值\r\nboolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）\r\npublic final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。\r\n```\r\n\r\n#### 2.2 AtomicInteger 常见方法使用\r\n\r\n```java\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\n\r\npublic class AtomicIntegerTest {\r\n\r\n	public static void main(String[] args) {\r\n		// TODO Auto-generated method stub\r\n		int temvalue = 0;\r\n		AtomicInteger i = new AtomicInteger(0);\r\n		temvalue = i.getAndSet(3);\r\n		System.out.println(\"temvalue:\" + temvalue + \";  i:\" + i);//temvalue:0;  i:3\r\n		temvalue = i.getAndIncrement();\r\n		System.out.println(\"temvalue:\" + temvalue + \";  i:\" + i);//temvalue:3;  i:4\r\n		temvalue = i.getAndAdd(5);\r\n		System.out.println(\"temvalue:\" + temvalue + \";  i:\" + i);//temvalue:4;  i:9\r\n	}\r\n\r\n}\r\n```\r\n\r\n#### 2.3 基本数据类型原子类的优势\r\n\r\n通过一个简单例子带大家看一下基本数据类型原子类的优势\r\n\r\n**①多线程环境不使用原子类保证线程安全（基本数据类型）**\r\n\r\n```java\r\nclass Test {\r\n        private volatile int count = 0;\r\n        //若要线程安全执行执行count++，需要加锁\r\n        public synchronized void increment() {\r\n                  count++; \r\n        }\r\n\r\n        public int getCount() {\r\n                  return count;\r\n        }\r\n}\r\n```\r\n**②多线程环境使用原子类保证线程安全（基本数据类型）**\r\n\r\n```java\r\nclass Test2 {\r\n        private AtomicInteger count = new AtomicInteger();\r\n\r\n        public void increment() {\r\n                  count.incrementAndGet();\r\n        }\r\n      //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。\r\n       public int getCount() {\r\n                return count.get();\r\n        }\r\n}\r\n\r\n```\r\n#### 2.4 AtomicInteger 线程安全原理简单分析\r\n\r\nAtomicInteger 类的部分源码：\r\n\r\n```java\r\n    // setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）\r\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\r\n    private static final long valueOffset;\r\n\r\n    static {\r\n        try {\r\n            valueOffset = unsafe.objectFieldOffset\r\n                (AtomicInteger.class.getDeclaredField(\"value\"));\r\n        } catch (Exception ex) { throw new Error(ex); }\r\n    }\r\n\r\n    private volatile int value;\r\n```\r\n\r\nAtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\r\n\r\nCAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。\r\n\r\n\r\n### 3 数组类型原子类\r\n\r\n#### 3.1 数组类型原子类介绍\r\n\r\n使用原子的方式更新数组里的某个元素\r\n\r\n\r\n- AtomicIntegerArray：整形数组原子类\r\n- AtomicLongArray：长整形数组原子类\r\n- AtomicReferenceArray ：引用类型数组原子类\r\n\r\n上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。\r\n\r\n**AtomicIntegerArray 类常用方法**\r\n\r\n```java\r\npublic final int get(int i) //获取 index=i 位置元素的值\r\npublic final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue\r\npublic final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增\r\npublic final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减\r\npublic final int getAndAdd(int delta) //获取 index=i 位置元素的值，并加上预期的值\r\nboolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）\r\npublic final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。\r\n```\r\n#### 3.2 AtomicIntegerArray 常见方法使用\r\n\r\n```java\r\n\r\nimport java.util.concurrent.atomic.AtomicIntegerArray;\r\n\r\npublic class AtomicIntegerArrayTest {\r\n\r\n	public static void main(String[] args) {\r\n		// TODO Auto-generated method stub\r\n		int temvalue = 0;\r\n		int[] nums = { 1, 2, 3, 4, 5, 6 };\r\n		AtomicIntegerArray i = new AtomicIntegerArray(nums);\r\n		for (int j = 0; j < nums.length; j++) {\r\n			System.out.println(i.get(j));\r\n		}\r\n		temvalue = i.getAndSet(0, 2);\r\n		System.out.println(\"temvalue:\" + temvalue + \";  i:\" + i);\r\n		temvalue = i.getAndIncrement(0);\r\n		System.out.println(\"temvalue:\" + temvalue + \";  i:\" + i);\r\n		temvalue = i.getAndAdd(0, 5);\r\n		System.out.println(\"temvalue:\" + temvalue + \";  i:\" + i);\r\n	}\r\n\r\n}\r\n```\r\n\r\n### 4 引用类型原子类\r\n\r\n#### 4.1  引用类型原子类介绍\r\n\r\n基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。\r\n\r\n- AtomicReference：引用类型原子类\r\n- AtomicStampedRerence：原子更新引用类型里的字段原子类\r\n- AtomicMarkableReference ：原子更新带有标记位的引用类型\r\n\r\n上面三个类提供的方法几乎相同，所以我们这里以 AtomicReference 为例子来介绍。\r\n\r\n#### 4.2 AtomicReference 类使用示例\r\n\r\n```java\r\nimport java.util.concurrent.atomic.AtomicReference;\r\n\r\npublic class AtomicReferenceTest {\r\n\r\n	public static void main(String[] args) {\r\n		AtomicReference<Person> ar = new AtomicReference<Person>();\r\n		Person person = new Person(\"SnailClimb\", 22);\r\n		ar.set(person);\r\n		Person updatePerson = new Person(\"Daisy\", 20);\r\n		ar.compareAndSet(person, updatePerson);\r\n\r\n		System.out.println(ar.get().getName());\r\n		System.out.println(ar.get().getAge());\r\n	}\r\n}\r\n\r\nclass Person {\r\n	private String name;\r\n	private int age;\r\n\r\n	public Person(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n\r\n	public String getName() {\r\n		return name;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n\r\n}\r\n```\r\n上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下：\r\n\r\n```\r\nDaisy\r\n20\r\n```\r\n\r\n\r\n### 5 对象的属性修改类型原子类\r\n\r\n#### 5.1 对象的属性修改类型原子类介绍\r\n\r\n如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。\r\n\r\n- AtomicIntegerFieldUpdater:原子更新整形字段的更新器\r\n- AtomicLongFieldUpdater：原子更新长整形字段的更新器\r\n- AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\r\n\r\n要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。\r\n\r\n上面三个类提供的方法几乎相同，所以我们这里以 `AtomicIntegerFieldUpdater`为例子来介绍。\r\n\r\n#### 5.2 AtomicIntegerFieldUpdater 类使用示例\r\n\r\n```java\r\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\r\n\r\npublic class AtomicIntegerFieldUpdaterTest {\r\n	public static void main(String[] args) {\r\n		AtomicIntegerFieldUpdater<User> a = AtomicIntegerFieldUpdater.newUpdater(User.class, \"age\");\r\n\r\n		User user = new User(\"Java\", 22);\r\n		System.out.println(a.getAndIncrement(user));// 22\r\n		System.out.println(a.get(user));// 23\r\n	}\r\n}\r\n\r\nclass User {\r\n	private String name;\r\n	public volatile int age;\r\n\r\n	public User(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n\r\n	public String getName() {\r\n		return name;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n\r\n}\r\n```\r\n\r\n输出结果：\r\n\r\n```\r\n22\r\n23\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (204, 'Java 并发编程基础知识', 2, '# Java 并发基础知识\r\n\r\nJava 并发的基础知识，可能会在笔试中遇到，技术面试中也可能以并发知识环节提问的第一个问题出现。比如面试官可能会问你：“谈谈自己对于进程和线程的理解，两者的区别是什么？”\r\n\r\n**本节思维导图：**\r\n\r\n![Java 并发基础知识](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-26/51390272.jpg)\r\n\r\n## 一 进程和线程\r\n\r\n进程和线程的对比这一知识点由于过于基础，所以在面试中很少碰到，但是极有可能会在笔试题中碰到。\r\n\r\n常见的提问形式是这样的：**“什么是线程和进程?，请简要描述线程与进程的关系、区别及优缺点？ ”**。\r\n\r\n### 1.1. 何为进程?\r\n\r\n进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。\r\n\r\n在Java中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。\r\n\r\n如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe文件的运行）。\r\n\r\n![进程](https://images.gitbook.cn/a0929b60-d133-11e8-88a4-5328c5b70145)\r\n\r\n### 1.2 何为线程?\r\n\r\n线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\r\n\r\nJava 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。\r\n\r\n```java\r\npublic class MultiThread {\r\n	public static void main(String[] args) {\r\n		// 获取Java线程管理MXBean\r\n	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\r\n		// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息\r\n		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\r\n		// 遍历线程信息，仅打印线程ID和线程名称信息\r\n		for (ThreadInfo threadInfo : threadInfos) {\r\n			System.out.println(\"[\" + threadInfo.getThreadId() + \"] \" + threadInfo.getThreadName());\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行main方法即可）：\r\n\r\n```\r\n[5] Attach Listener //添加事件\r\n[4] Signal Dispatcher // 分发处理给JVM信号的线程\r\n[3] Finalizer //调用对象finalize方法的线程\r\n[2] Reference Handler //清除reference线程\r\n[1] main //main线程,程序入口\r\n```\r\n\r\n从上面的输出内容可以看出：**一个 Java 程序的运行是 main 线程和多个其他线程同时运行**。\r\n\r\n### 1.3 从 JVM 角度说进程和线程之间的关系（重要） 	\r\n\r\n#### 1.3.1 图解进程和线程的关系\r\n\r\n下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。如果你对  Java 内存区域(运行时数据区)这部分知识不太了解的话可以阅读一下我的这篇文章：[《可能是把Java内存区域讲的最清楚的一篇文章》](https://github.com/Snailclimb/JavaGuide/blob/master/Java相关/可能是把Java内存区域讲的最清楚的一篇文章.md)\r\n\r\n![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM运行时数据区域.png)\r\n\r\n从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区**资源，但是每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。\r\n\r\n下面来思考这样一个问题：为什么**程序计数器**、**虚拟机栈**和**本地方法栈**是线程私有的呢？为什么堆和方法区是线程共享的呢？\r\n\r\n#### 1.3.2 程序计数器为什么是私有的?\r\n\r\n程序计数器主要有下面两个作用：\r\n\r\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\r\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\r\n\r\n需要注意的是，如果执行的是native方法，那么程序计数器记录的是undefined地址，只有执行的是Java代码时程序计数器记录的才是下一条指令的地址。\r\n\r\n所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。\r\n\r\n#### 1.3.3 虚拟机栈和本地方法栈为什么是私有的?\r\n\r\n- **虚拟机栈：**每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\r\n- **本地方法栈：**和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\r\n\r\n所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。\r\n\r\n#### 1.3.4 一句话简单了解堆和方法区\r\n\r\n堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象(所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\r\n\r\n## 二 多线程并发编程\r\n\r\n### 2.1 并发与并行\r\n\r\n- **并发：** 同一时间段，多个任务都在执行(单位时间内不一定同时执行)；\r\n- **并行：**单位时间内，多个任务同时执行。\r\n\r\n### 2.1 多线程并发编程详解\r\n\r\n单CPU时代多个任务共享一个CPU，某一特定时刻只能有一个任务被执行，CPU会分配时间片给当前要执行的任务。当一个任务占用CPU时，其他任务就会被挂起。当占用CPU的任务的时间片用完后，才会由 CPU 选择下一个需要执行的任务。所以说，在单核CPU时代，多线程编程没有太大意义，反而会因为线程间频繁的上下文切换而带来额外开销。\r\n\r\n但现在 CPU 一般都是多核，如果这个CPU是多核的话，那么进程中的不同线程可以使用不同核心，实现了真正意义上的并行运行。**那为什么我们不直接叫做多线程并行编程呢？**\r\n\r\n**这是因为多线程在实际开发使用中，线程的个数往往多于CPU的个数，所以一般都称多线程并发编程而不是多线程并行编程。`**\r\n\r\n### 2.2 为什么要多线程并发编程?\r\n\r\n- **从计算机底层来说：**线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。\r\n\r\n- **从当代互联网发展趋势来说：**现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。\r\n\r\n## 三 线程的创建与运行\r\n\r\n前两种实际上很少使用，一般都是用线程池的方式比较多一点。\r\n\r\n### 3.1 继承 Thread 类的方式\r\n\r\n\r\n```java\r\npublic class MyThread extends Thread {\r\n	@Override\r\n	public void run() {\r\n		super.run();\r\n		System.out.println(\"MyThread\");\r\n	}\r\n}\r\n```\r\nRun.java\r\n\r\n```java\r\npublic class Run {\r\n\r\n	public static void main(String[] args) {\r\n		MyThread mythread = new MyThread();\r\n		mythread.start();\r\n		System.out.println(\"运行结束\");\r\n	}\r\n\r\n}\r\n\r\n```\r\n运行结果：\r\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\r\n\r\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\r\n\r\n### 3.2 实现Runnable接口的方式\r\n\r\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\r\n\r\nMyRunnable.java\r\n\r\n```java\r\npublic class MyRunnable implements Runnable {\r\n	@Override\r\n	public void run() {\r\n		System.out.println(\"MyRunnable\");\r\n	}\r\n}\r\n```\r\n\r\nRun.java\r\n\r\n```java\r\npublic class Run {\r\n\r\n	public static void main(String[] args) {\r\n		Runnable runnable=new MyRunnable();\r\n		Thread thread=new Thread(runnable);\r\n		thread.start();\r\n		System.out.println(\"运行结束！\");\r\n	}\r\n\r\n}\r\n```\r\n运行结果：\r\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\r\n\r\n### 3.3 使用线程池的方式\r\n\r\n使用线程池的方式也是最推荐的一种方式，另外，《阿里巴巴Java开发手册》在第一章第六节并发处理这一部分也强调到“线程资源必须通过线程池提供，不允许在应用中自行显示创建线程”。这里就不给大家演示代码了，线程池这一节会详细介绍到这部分内容。\r\n\r\n## 四 线程的生命周期和状态\r\n\r\nJava 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。\r\n\r\n![Java线程的状态](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)\r\n\r\n线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）：\r\n\r\n![Java线程状态变迁](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png)\r\n\r\n\r\n\r\n由上图可以看出：\r\n\r\n线程创建之后它将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。\r\n\r\n> 操作系统隐藏 Java虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：[HowToDoInJava](https://howtodoinjava.com/)：[Java Thread Life Cycle and Thread States](https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/)），所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态 。\r\n\r\n![RUNNABLE-VS-RUNNING](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png)\r\n\r\n当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）**状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。线程在执行 Runnable 的` run() `方法之后将会进入到 **TERMINATED（终止）** 状态。\r\n\r\n## 五 线程优先级\r\n\r\n**理论上**来说系统会根据优先级来决定首先使哪个线程进入运行状态。当 CPU 比较闲的时候，设置线程优先级几乎不会有任何作用，而且很多操作系统压根不会不会理会你设置的线程优先级，所以不要让业务过度依赖于线程的优先级。\r\n\r\n另外，**线程优先级具有继承特性**比如A线程启动B线程，则B线程的优先级和A是一样的。**线程优先级还具有随机性** 也就是说线程优先级高的不一定每一次都先执行完。\r\n\r\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**1** 到**10** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\r\n\r\n**一般情况下，不会对线程设定优先级别，更不会让某些业务严重地依赖线程的优先级别，比如权重，借助优先级设定某个任务的权重，这种方式是不可取的，一般定义线程的时候使用默认的优先级就好了。**\r\n\r\n**相关方法：**\r\n\r\n```java\r\npublic final void setPriority(int newPriority) //为线程设定优先级\r\npublic final int getPriority() //获取线程的优先级\r\n```\r\n**设置线程优先级方法源码：**\r\n\r\n```java\r\n    public final void setPriority(int newPriority) {\r\n        ThreadGroup g;\r\n        checkAccess();\r\n        //线程游戏优先级不能小于1也不能大于10，否则会抛出异常\r\n        if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        //如果指定的线程优先级大于该线程所在线程组的最大优先级，那么该线程的优先级将设为线程组的最大优先级\r\n        if((g = getThreadGroup()) != null) {\r\n            if (newPriority > g.getMaxPriority()) {\r\n                newPriority = g.getMaxPriority();\r\n            }\r\n            setPriority0(priority = newPriority);\r\n        }\r\n    }\r\n\r\n```\r\n\r\n## 六 守护线程和用户线程\r\n\r\n**守护线程和用户线程简介:**\r\n\r\n- **用户(User)线程：**运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\r\n- **守护(Daemon)线程：**运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作.\r\n\r\nmain 函数所在的线程就是一个用户线程啊，main函数启动的同时在JVM内部同时还启动了好多守护线程，比如垃圾回收线程。\r\n\r\n**那么守护线程和用户线程有什么区别呢？**\r\n\r\n比较明显的区别之一是用户线程结束，JVM退出，不管这个时候有没有守护线程运行。而守护线程不会影响 JVM 的退出。\r\n\r\n**注意事项：**\r\n\r\n1.  `setDaemon(true)`必须在`start（）`方法前执行，否则会抛出 `IllegalThreadStateException` 异常\r\n2.  在守护线程中产生的新线程也是守护线程\r\n3.  不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\r\n4.  守护(Daemon)线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作，所以守护(Daemon)线程中的finally语句块可能无法被执行。\r\n\r\n\r\n\r\n## 参考\r\n\r\n- 《Java并发编程之美》\r\n- 《Java并发编程的艺术》\r\n- https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/', 0);
INSERT INTO `blog_course` VALUES (205, 'Java 并发容器总结', 2, '\r\n<!-- MarkdownTOC -->\r\n\r\n- [一 JDK 提供的并发容器总结](#一 JDK 提供的并发容器总结)\r\n- [二 ConcurrentHashMap](#二 ConcurrentHashMap)\r\n- [三 CopyOnWriteArrayList](#三 CopyOnWriteArrayList)\r\n  - [3.1 CopyOnWriteArrayList 简介](#3.1 CopyOnWriteArrayList 简介)\r\n  - [3.2 CopyOnWriteArrayList 是如何做到的？](#3.2 CopyOnWriteArrayList 是如何做到的？)\r\n  - [3.3 CopyOnWriteArrayList 读取和写入源码简单分析](#3.3 CopyOnWriteArrayList 读取和写入源码简单分析)\r\n    - [3.3.1 CopyOnWriteArrayList 读取操作的实现](#3.3.1 CopyOnWriteArrayList 读取操作的实现)\r\n    - [3.3.2 CopyOnWriteArrayList 写入操作的实现](#3.3.2 CopyOnWriteArrayList 写入操作的实现)\r\n- [四 ConcurrentLinkedQueue](#四 ConcurrentLinkedQueue)\r\n- [五 BlockingQueue](#五 BlockingQueue)\r\n  - [5.1 BlockingQueue 简单介绍](#5.1 BlockingQueue 简单介绍)\r\n  - [5.2 ArrayBlockingQueue](#5.2 ArrayBlockingQueue)\r\n  - [5.3 LinkedBlockingQueue](#5.3 LinkedBlockingQueue)\r\n  - [5.4 PriorityBlockingQueue](#5.4 PriorityBlockingQueue)\r\n- [六 ConcurrentSkipListMap](#六 ConcurrentSkipListMap)\r\n- [七 参考](#七 参考)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n##  一 JDK 提供的并发容器总结\r\n\r\nJDK提供的这些容器大部分在 `java.util.concurrent` 包中。\r\n\r\n\r\n- **ConcurrentHashMap:** 线程安全的HashMap\r\n- **CopyOnWriteArrayList:** 线程安全的List，在读多写少的场合性能非常好，远远好于Vector.\r\n- **ConcurrentLinkedQueue:** 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。\r\n- **BlockingQueue:** 这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。\r\n- **ConcurrentSkipListMap:** 跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。\r\n\r\n## 二 ConcurrentHashMap\r\n\r\n我们知道 HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 `Collections.synchronizedMap()` 方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。\r\n\r\n所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。\r\n\r\n关于 ConcurrentHashMap 相关问题，我在 [《这几道Java集合框架面试题几乎必问》](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.md) 这篇文章中已经提到过。下面梳理一下关于 ConcurrentHashMap 比较重要的问题：\r\n\r\n- [ConcurrentHashMap 和 Hashtable 的区别](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/%E8%BF%99%E5%87%A0%E9%81%93Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98%E5%87%A0%E4%B9%8E%E5%BF%85%E9%97%AE.md#concurrenthashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB)\r\n- [ConcurrentHashMap线程安全的具体实现方式/底层具体实现](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/%E8%BF%99%E5%87%A0%E9%81%93Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98%E5%87%A0%E4%B9%8E%E5%BF%85%E9%97%AE.md#concurrenthashmap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0)\r\n\r\n\r\n\r\n## 三 CopyOnWriteArrayList\r\n\r\n### 3.1 CopyOnWriteArrayList 简介\r\n\r\n```java\r\npublic class CopyOnWriteArrayList<E>\r\nextends Object\r\nimplements List<E>, RandomAccess, Cloneable, Serializable\r\n```\r\n\r\n在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问List的内部数据，毕竟读取操作是安全的。\r\n\r\n这和我们之前在多线程章节讲过 `ReentrantReadWriteLock` 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。JDK中提供了 `CopyOnWriteArrayList` 类比相比于在读写锁的思想又更进一步。为了将读取的性能发挥到极致，`CopyOnWriteArrayList` 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。**那它是怎么做的呢？**\r\n\r\n### 3.2 CopyOnWriteArrayList 是如何做到的？\r\n\r\n `CopyOnWriteArrayList` 类的所有可变操作（add，set等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。\r\n\r\n从 `CopyOnWriteArrayList` 的名字就能看出`CopyOnWriteArrayList` 是满足`CopyOnWrite` 的ArrayList，所谓`CopyOnWrite` 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。\r\n\r\n### 3.3 CopyOnWriteArrayList 读取和写入源码简单分析\r\n\r\n#### 3.3.1 CopyOnWriteArrayList 读取操作的实现\r\n\r\n读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。\r\n\r\n```java\r\n    /** The array, accessed only via getArray/setArray. */\r\n    private transient volatile Object[] array;\r\n    public E get(int index) {\r\n        return get(getArray(), index);\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    private E get(Object[] a, int index) {\r\n        return (E) a[index];\r\n    }\r\n    final Object[] getArray() {\r\n        return array;\r\n    }\r\n\r\n```\r\n\r\n#### 3.3.2 CopyOnWriteArrayList 写入操作的实现\r\n\r\nCopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。\r\n\r\n```java\r\n    /**\r\n     * Appends the specified element to the end of this list.\r\n     *\r\n     * @param e element to be appended to this list\r\n     * @return {@code true} (as specified by {@link Collection#add})\r\n     */\r\n    public boolean add(E e) {\r\n        final ReentrantLock lock = this.lock;\r\n        lock.lock();//加锁\r\n        try {\r\n            Object[] elements = getArray();\r\n            int len = elements.length;\r\n            Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝新数组\r\n            newElements[len] = e;\r\n            setArray(newElements);\r\n            return true;\r\n        } finally {\r\n            lock.unlock();//释放锁\r\n        }\r\n    }\r\n```\r\n\r\n## 四 ConcurrentLinkedQueue\r\n\r\nJava提供的线程安全的 Queue 可以分为**阻塞队列**和**非阻塞队列**，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 **阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。**\r\n\r\n从名字可以看出，`ConcurrentLinkedQueue`这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。\r\n\r\nConcurrentLinkedQueue 内部代码我们就不分析了，大家知道ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。\r\n\r\nConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。\r\n\r\n##  五 BlockingQueue\r\n\r\n### 5.1 BlockingQueue 简单介绍\r\n\r\n上面我们己经提到了 ConcurrentLinkedQueue 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——BlockingQueue。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。\r\n\r\nBlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 的相关实现类：\r\n\r\n![BlockingQueue 的实现类](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/51622268.jpg)\r\n\r\n**下面主要介绍一下:ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue，这三个 BlockingQueue 的实现类。**\r\n\r\n### 5.2 ArrayBlockingQueue\r\n\r\n**ArrayBlockingQueue** 是 BlockingQueue 接口的有界队列实现类，底层采用**数组**来实现。ArrayBlockingQueue一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。\r\n\r\nArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：\r\n\r\n```java\r\nprivate static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10,true);\r\n```\r\n\r\n### 5.3 LinkedBlockingQueue\r\n\r\n**LinkedBlockingQueue** 底层基于**单向链表**实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足FIFO的特性，与ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE。\r\n\r\n**相关构造方法:**\r\n\r\n```java\r\n    /**\r\n     *某种意义上的无界队列\r\n     * Creates a {@code LinkedBlockingQueue} with a capacity of\r\n     * {@link Integer#MAX_VALUE}.\r\n     */\r\n    public LinkedBlockingQueue() {\r\n        this(Integer.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     *有界队列\r\n     * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.\r\n     *\r\n     * @param capacity the capacity of this queue\r\n     * @throws IllegalArgumentException if {@code capacity} is not greater\r\n     *         than zero\r\n     */\r\n    public LinkedBlockingQueue(int capacity) {\r\n        if (capacity <= 0) throw new IllegalArgumentException();\r\n        this.capacity = capacity;\r\n        last = head = new Node<E>(null);\r\n    }\r\n```\r\n\r\n### 5.4 PriorityBlockingQueue\r\n\r\n**PriorityBlockingQueue** 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 `compareTo()` 方法来指定元素排序规则，或者初始化时通过构造器参数 `Comparator` 来指定排序规则。\r\n\r\nPriorityBlockingQueue 并发控制采用的是 **ReentrantLock**，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，**如果空间不够的话会自动扩容**）。\r\n\r\n简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\r\n\r\n**推荐文章：**\r\n\r\n《解读 Java 并发队列 BlockingQueue》\r\n\r\n[https://javadoop.com/post/java-concurrent-queue](https://javadoop.com/post/java-concurrent-queue)\r\n\r\n## 六 ConcurrentSkipListMap\r\n\r\n下面这部分内容参考了极客时间专栏[《数据结构与算法之美》](https://time.geekbang.org/column/intro/126?code=zl3GYeAsRI4rEJIBNu5B/km7LSZsPDlGWQEpAYw5Vu0=&utm_term=SPoster)以及《实战Java高并发程序设计》。\r\n\r\n**为了引出ConcurrentSkipListMap，先带着大家简单理解一下跳表。**\r\n\r\n对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 **O(logn)** 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。\r\n\r\n跳表的本质是同时维护了多个链表，并且链表是分层的，\r\n\r\n![2级索引跳表](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/93666217.jpg)\r\n\r\n最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。\r\n\r\n跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素18。\r\n\r\n![在跳表中查找元素18](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/32005738.jpg)\r\n\r\n查找18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。\r\n\r\n从上面很容易看出，**跳表是一种利用空间换时间的算法。**\r\n\r\n使用跳表实现Map 和使用哈希算法实现Map的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是ConcurrentSkipListMap。\r\n\r\n\r\n\r\n## 七 参考\r\n\r\n- 《实战Java高并发程序设计》\r\n- https://javadoop.com/post/java-concurrent-queue\r\n- https://juejin.im/post/5aeebd02518825672f19c546\r\n', 0);
INSERT INTO `blog_course` VALUES (206, 'Java 8Tutorial', 2, '随着 Java 8 的普及度越来越高，很多人都提到面试中关于Java 8 也是非常常问的知识点。应各位要求和需要，我打算对这部分知识做一个总结。本来准备自己总结的，后面看到Github 上有一个相关的仓库，地址：\r\n[https://github.com/winterbe/java8-tutorial](https://github.com/winterbe/java8-tutorial)。这个仓库是英文的，我对其进行了翻译并添加和修改了部分内容，下面是正文了。\r\n\r\n<!-- MarkdownTOC -->\r\n\r\n- [Java 8 Tutorial](#Java 8 Tutorial)\r\n    - [接口的默认方法\\(Default Methods for Interfaces\\)](#接口的默认方法（Default Methods for Interfaces）)\r\n    - [Lambda表达式\\(Lambda expressions\\)](#Lambda表达式（Lambda expressions）)\r\n    - [函数式接口\\(Functional Interfaces\\)](#函数式接口（Functional Interfaces）)\r\n    - [方法和构造函数引用\\(Method and Constructor References\\)](#方法和构造函数引用（Method and Constructor References）)\r\n    - [Lamda 表达式作用域\\(Lambda Scopes\\)](#Lamda 表达式作用域（Lambda Scopes）)\r\n      - [访问局部变量](#访问局部变量)\r\n      - [访问字段和静态变量](#访问字段和静态变量)\r\n      - [访问默认接口方法](#访问默认接口方法)\r\n    - [内置函数式接口\\(Built-in Functional Interfaces\\)](#内置函数式接口（Built-in Functional Interfaces）)\r\n      - [Predicates](#Predicates)\r\n      - [Functions](#Functions)\r\n      - [Suppliers](#Suppliers)\r\n      - [Consumers](#Consumers)\r\n      - [Comparators](#Comparators)\r\n    - [Optionals](#Optionals)\r\n    - [Streams\\(流\\)](#Streams（流）)\r\n      - [Filter\\(过滤\\)](#Filter（过滤）)\r\n      - [Sorted\\(排序\\)](#Sorted（排序）)\r\n      - [Map\\(映射\\)](#Map（映射）)\r\n      - [Match\\(匹配\\)](#Match（匹配）)\r\n      - [Count\\(计数\\)](#Count（计数）)\r\n      - [Reduce\\(规约\\)](#Reduce（规约）)\r\n  - [Parallel Streams\\(并行流\\)](#Parallel Streams（并行流）)\r\n    - [Sequential Sort\\(串行排序\\)](#Sequential Sort（串行排序）)\r\n    - [Parallel Sort\\(并行排序\\)](#Parallel Sort（并行排序）)\r\n  - [Maps](#Maps)\r\n  - [Data API\\(日期相关API\\)](#Data API日期相关API)\r\n    - [Clock](#clock)\r\n    - [Timezones\\(时区\\)](#Timezones（时区）)\r\n    - [LocalTime\\(本地时间\\)](#LocalTime（本地时间）)\r\n    - [LocalDate\\(本地日期\\)](#LocalDate（本地日期）)\r\n    - [LocalDateTime\\(本地日期时间\\)](#LocalDateTime（本地日期时间）)\r\n  - [Annotations\\(注解\\)](#Annotations（注解）)\r\n  - [Whete to go from here?](#Whete to go from here?)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n\r\n# Java 8 Tutorial \r\n\r\n欢迎阅读我对Java 8的介绍。本教程将逐步指导您完成所有新语言功能。 在简短的代码示例的基础上，您将学习如何使用默认接口方法，lambda表达式，方法引用和可重复注释。 在本文的最后，您将熟悉最新的 API 更改，如流，函数式接口(Functional Interfaces)，Map 类的扩展和新的 Date API。 没有大段枯燥的文字，只有一堆注释的代码片段。\r\n\r\n\r\n### 接口的默认方法（Default Methods for Interfaces）\r\n\r\nJava 8使我们能够通过使用 `default` 关键字向接口添加非抽象方法实现。 此功能也称为[虚拟扩展方法](http://stackoverflow.com/a/24102730)。\r\n\r\n第一个例子：\r\n\r\n```java\r\ninterface Formula{\r\n\r\n    double calculate(int a);\r\n\r\n    default double sqrt(int a) {\r\n        return Math.sqrt(a);\r\n    }\r\n\r\n}\r\n```\r\n\r\nFormula 接口中除了抽象方法计算接口公式还定义了默认方法 `sqrt`。 实现该接口的类只需要实现抽象方法 `calculate`。 默认方法`sqrt` 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。\r\n\r\n```java\r\npublic class Main {\r\n\r\n  public static void main(String[] args) {\r\n    // TODO 通过匿名内部类方式访问接口\r\n    Formula formula = new Formula() {\r\n        @Override\r\n        public double calculate(int a) {\r\n            return sqrt(a * 100);\r\n        }\r\n    };\r\n\r\n    System.out.println(formula.calculate(100));     // 100.0\r\n    System.out.println(formula.sqrt(16));           // 4.0\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 `sqrt(a * 100)`。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。\r\n\r\n**译者注：** 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。\r\n\r\n### Lambda表达式（Lambda expressions）\r\n\r\n首先看看在老版本的Java中是如何排列字符串的：\r\n\r\n```java\r\nList<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\r\n\r\nCollections.sort(names, new Comparator<String>() {\r\n    @Override\r\n    public int compare(String a, String b) {\r\n        return b.compareTo(a);\r\n    }\r\n});\r\n```\r\n\r\n只需要给静态方法` Collections.sort` 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 `sort` 方法。\r\n\r\n在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：\r\n\r\n```java\r\nCollections.sort(names, (String a, String b) -> {\r\n    return b.compareTo(a);\r\n});\r\n```\r\n\r\n可以看出，代码变得更段且更具有可读性，但是实际上还可以写得更短：\r\n\r\n```java\r\nCollections.sort(names, (String a, String b) -> b.compareTo(a));\r\n```\r\n\r\n对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：\r\n\r\n```java\r\nnames.sort((a, b) -> b.compareTo(a));\r\n```\r\n\r\nList 类本身就有一个 `sort` 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。\r\n\r\n### 函数式接口（Functional Interfaces）\r\n\r\n**译者注：** 原文对这部分解释不太清楚，故做了修改！\r\n\r\nJava 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。**“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。** 像这样的接口，可以被隐式转换为lambda表达式。`java.lang.Runnable` 与 `java.util.concurrent.Callable` 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解`@FunctionalInterface`,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用`@FunctionalInterface` 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示\r\n![](http://10.0.75.1:9528/write/get_image?fileName=20190402113106_@FunctionalInterface.png)\r\n示例：\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Converter<F, T> {\r\n  T convert(F from);\r\n}\r\n```\r\n\r\n```java\r\n    // TODO 将数字字符串转换为整数类型\r\n    Converter<String, Integer> converter = (from) -> Integer.valueOf(from);\r\n    Integer converted = converter.convert(\"123\");\r\n    System.out.println(converted.getClass()); //class java.lang.Integer\r\n```\r\n\r\n**译者注：** 大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。\r\n\r\n### 方法和构造函数引用（Method and Constructor References）\r\n\r\n前一节中的代码还可以通过静态方法引用来表示：\r\n\r\n```java\r\n    Converter<String, Integer> converter = Integer::valueOf;\r\n    Integer converted = converter.convert(\"123\");\r\n    System.out.println(converted.getClass());   //class java.lang.Integer\r\n```\r\nJava 8允许您通过`::`关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法：\r\n\r\n```java\r\nclass Something {\r\n    String startsWith(String s) {\r\n        return String.valueOf(s.charAt(0));\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nSomething something = new Something();\r\nConverter<String, String> converter = something::startsWith;\r\nString converted = converter.convert(\"Java\");\r\nSystem.out.println(converted);    // \"J\"\r\n```\r\n\r\n接下来看看构造函数是如何使用`::`关键字来引用的，首先我们定义一个包含多个构造函数的简单类：\r\n\r\n```java\r\nclass Person {\r\n    String firstName;\r\n    String lastName;\r\n\r\n    Person() {}\r\n\r\n    Person(String firstName, String lastName) {\r\n        this.firstName = firstName;\r\n        this.lastName = lastName;\r\n    }\r\n}\r\n```\r\n接下来我们指定一个用来创建Person对象的对象工厂接口：\r\n\r\n```java\r\ninterface PersonFactory<P extends Person> {\r\n    P create(String firstName, String lastName);\r\n}\r\n```\r\n\r\n这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：\r\n\r\n```java\r\nPersonFactory<Person> personFactory = Person::new;\r\nPerson person = personFactory.create(\"Peter\", \"Parker\");\r\n```\r\n我们只需要使用 `Person::new` 来获取Person类构造函数的引用，Java编译器会自动根据`PersonFactory.create`方法的参数类型来选择合适的构造函数。\r\n\r\n### Lamda 表达式作用域（Lambda Scopes）\r\n\r\n#### 访问局部变量\r\n\r\n我们可以直接在 lambda 表达式中访问外部的局部变量：\r\n\r\n```java\r\nfinal int num = 1;\r\nConverter<Integer, String> stringConverter =\r\n        (from) -> String.valueOf(from + num);\r\n\r\nstringConverter.convert(2);     // 3\r\n```\r\n\r\n但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：\r\n\r\n```java\r\nint num = 1;\r\nConverter<Integer, String> stringConverter =\r\n        (from) -> String.valueOf(from + num);\r\n\r\nstringConverter.convert(2);     // 3\r\n```\r\n\r\n不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：\r\n\r\n```java\r\nint num = 1;\r\nConverter<Integer, String> stringConverter =\r\n        (from) -> String.valueOf(from + num);\r\nnum = 3;//在lambda表达式中试图修改num同样是不允许的。\r\n```\r\n\r\n#### 访问字段和静态变量\r\n\r\n与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。\r\n\r\n```java\r\nclass Lambda4 {\r\n    static int outerStaticNum;\r\n    int outerNum;\r\n\r\n    void testScopes() {\r\n        Converter<Integer, String> stringConverter1 = (from) -> {\r\n            outerNum = 23;\r\n            return String.valueOf(from);\r\n        };\r\n\r\n        Converter<Integer, String> stringConverter2 = (from) -> {\r\n            outerStaticNum = 72;\r\n            return String.valueOf(from);\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n#### 访问默认接口方法\r\n\r\n还记得第一节中的 formula 示例吗？ `Formula` 接口定义了一个默认方法`sqrt`，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。\r\n\r\n无法从 lambda 表达式中访问默认方法,故以下代码无法编译：\r\n\r\n```java\r\nFormula formula = (a) -> sqrt(a * 100);\r\n```\r\n\r\n### 内置函数式接口（Built-in Functional Interfaces）\r\n\r\nJDK 1.8 API包含许多内置函数式接口。 其中一些借口在老版本的 Java 中是比较常见的比如： `Comparator` 或`Runnable`，这些接口都增加了`@FunctionalInterface`注解以便能用在 lambda 表达式上。\r\n\r\n但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 [Google Guava](https://code.google.com/p/guava-libraries/) 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。\r\n\r\n#### Predicates\r\n\r\nPredicate 接口是只有一个参数的返回布尔类型值的 **断言型** 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）：\r\n\r\n**译者注：** Predicate 接口源码如下\r\n\r\n```java\r\npackage java.util.function;\r\nimport java.util.Objects;\r\n\r\n@FunctionalInterface\r\npublic interface Predicate<T> {\r\n    \r\n    // 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.\r\n    boolean test(T t);\r\n\r\n    //and方法与关系型运算符\"&&\"相似，两边都成立才返回true\r\n    default Predicate<T> and(Predicate<? super T> other) {\r\n        Objects.requireNonNull(other);\r\n        return (t) -> test(t) && other.test(t);\r\n    }\r\n    // 与关系运算符\"!\"相似，对判断进行取反\r\n    default Predicate<T> negate() {\r\n        return (t) -> !test(t);\r\n    }\r\n    //or方法与关系型运算符\"||\"相似，两边只要有一个成立就返回true\r\n    default Predicate<T> or(Predicate<? super T> other) {\r\n        Objects.requireNonNull(other);\r\n        return (t) -> test(t) || other.test(t);\r\n    }\r\n   // 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).\r\n    static <T> Predicate<T> isEqual(Object targetRef) {\r\n        return (null == targetRef)\r\n                ? Objects::isNull\r\n                : object -> targetRef.equals(object);\r\n    }\r\n```\r\n\r\n示例：\r\n\r\n```java\r\nPredicate<String> predicate = (s) -> s.length() > 0;\r\n\r\npredicate.test(\"foo\");              // true\r\npredicate.negate().test(\"foo\");     // false\r\n\r\nPredicate<Boolean> nonNull = Objects::nonNull;\r\nPredicate<Boolean> isNull = Objects::isNull;\r\n\r\nPredicate<String> isEmpty = String::isEmpty;\r\nPredicate<String> isNotEmpty = isEmpty.negate();\r\n```\r\n\r\n#### Functions\r\n\r\nFunction 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）：\r\n\r\n**译者注：** Function  接口源码如下\r\n\r\n```java\r\n\r\npackage java.util.function;\r\n \r\nimport java.util.Objects;\r\n \r\n@FunctionalInterface\r\npublic interface Function<T, R> {\r\n    \r\n    //将Function对象应用到输入的参数上，然后返回计算结果。\r\n    R apply(T t);\r\n    //将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。\r\n    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {\r\n        Objects.requireNonNull(before);\r\n        return (V v) -> apply(before.apply(v));\r\n    }\r\n    // \r\n    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {\r\n        Objects.requireNonNull(after);\r\n        return (T t) -> after.apply(apply(t));\r\n    }\r\n \r\n    static <T> Function<T, T> identity() {\r\n        return t -> t;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n```java\r\nFunction<String, Integer> toInteger = Integer::valueOf;\r\nFunction<String, String> backToString = toInteger.andThen(String::valueOf);\r\nbackToString.apply(\"123\");     // \"123\"\r\n```\r\n\r\n#### Suppliers\r\n\r\nSupplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。\r\n\r\n```java\r\nSupplier<Person> personSupplier = Person::new;\r\npersonSupplier.get();   // new Person\r\n```\r\n\r\n#### Consumers\r\n\r\nConsumer 接口表示要对单个输入参数执行的操作。\r\n\r\n```java\r\nConsumer<Person> greeter = (p) -> System.out.println(\"Hello, \" + p.firstName);\r\ngreeter.accept(new Person(\"Luke\", \"Skywalker\"));\r\n```\r\n\r\n#### Comparators\r\n\r\nComparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：\r\n\r\n```java\r\nComparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);\r\n\r\nPerson p1 = new Person(\"John\", \"Doe\");\r\nPerson p2 = new Person(\"Alice\", \"Wonderland\");\r\n\r\ncomparator.compare(p1, p2);             // > 0\r\ncomparator.reversed().compare(p1, p2);  // < 0\r\n```\r\n\r\n## Optionals\r\n\r\nOptionals不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下Optionals的工作原理。\r\n\r\nOptional 是一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。\r\n\r\n译者注：示例中每个方法的作用已经添加。\r\n\r\n```java\r\n//of（）：为非null的值创建一个Optional\r\nOptional<String> optional = Optional.of(\"bam\");\r\n// isPresent（）： 如果值存在返回true，否则返回false\r\noptional.isPresent();           // true\r\n//get()：如果Optional有值则将其返回，否则抛出NoSuchElementException\r\noptional.get();                 // \"bam\"\r\n//orElse（）：如果有值则将其返回，否则返回指定的其它值\r\noptional.orElse(\"fallback\");    // \"bam\"\r\n//ifPresent（）：如果Optional实例有值则为其调用consumer，否则不做处理\r\noptional.ifPresent((s) -> System.out.println(s.charAt(0)));     // \"b\"\r\n```\r\n\r\n推荐阅读：[[Java8]如何正确使用Optional](https://blog.kaaass.net/archives/764)\r\n\r\n## Streams（流）\r\n\r\n`java.util.Stream` 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如` java.util.Collection` 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。\r\n\r\n首先看看Stream是怎么用，首先创建实例代码的用到的数据List：\r\n\r\n```java\r\nList<String> stringCollection = new ArrayList<>();\r\nstringCollection.add(\"ddd2\");\r\nstringCollection.add(\"aaa2\");\r\nstringCollection.add(\"bbb1\");\r\nstringCollection.add(\"aaa1\");\r\nstringCollection.add(\"bbb3\");\r\nstringCollection.add(\"ccc\");\r\nstringCollection.add(\"bbb2\");\r\nstringCollection.add(\"ddd1\");\r\n```\r\n\r\nJava 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：\r\n\r\n### Filter（过滤）\r\n\r\n过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于**中间操作**，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。\r\n\r\n```java\r\n        // 测试 Filter(过滤)\r\n        stringList\r\n                .stream()\r\n                .filter((s) -> s.startsWith(\"a\"))\r\n                .forEach(System.out::println);//aaa2 aaa1\r\n```\r\n\r\nforEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。\r\n\r\n### Sorted（排序）\r\n\r\n排序是一个 **中间操作**，返回的是排序好后的 Stream。**如果你不指定一个自定义的 Comparator 则会使用默认排序。**\r\n\r\n```java\r\n        // 测试 Sort (排序)\r\n        stringList\r\n                .stream()\r\n                .sorted()\r\n                .filter((s) -> s.startsWith(\"a\"))\r\n                .forEach(System.out::println);// aaa1 aaa2\r\n```\r\n\r\n需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：\r\n\r\n```java\r\n    System.out.println(stringList);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1\r\n```\r\n\r\n### Map（映射）\r\n\r\n中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。\r\n\r\n下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。\r\n\r\n```java\r\n        // 测试 Map 操作\r\n        stringList\r\n                .stream()\r\n                .map(String::toUpperCase)\r\n                .sorted((a, b) -> b.compareTo(a))\r\n                .forEach(System.out::println);// \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\"\r\n```\r\n\r\n\r\n\r\n### Match（匹配）\r\n\r\nStream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 **最终操作** ，并返回一个 boolean 类型的值。\r\n\r\n```java\r\n        // 测试 Match (匹配)操作\r\n        boolean anyStartsWithA =\r\n                stringList\r\n                        .stream()\r\n                        .anyMatch((s) -> s.startsWith(\"a\"));\r\n        System.out.println(anyStartsWithA);      // true\r\n\r\n        boolean allStartsWithA =\r\n                stringList\r\n                        .stream()\r\n                        .allMatch((s) -> s.startsWith(\"a\"));\r\n\r\n        System.out.println(allStartsWithA);      // false\r\n\r\n        boolean noneStartsWithZ =\r\n                stringList\r\n                        .stream()\r\n                        .noneMatch((s) -> s.startsWith(\"z\"));\r\n\r\n        System.out.println(noneStartsWithZ);      // true\r\n```\r\n\r\n\r\n\r\n### Count（计数）\r\n\r\n计数是一个 **最终操作**，返回Stream中元素的个数，**返回值类型是 long**。\r\n\r\n```java\r\n      //测试 Count (计数)操作\r\n        long startsWithB =\r\n                stringList\r\n                        .stream()\r\n                        .filter((s) -> s.startsWith(\"b\"))\r\n                        .count();\r\n        System.out.println(startsWithB);    // 3\r\n```\r\n\r\n### Reduce（规约）\r\n\r\n这是一个 **最终操作** ，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：\r\n\r\n```java\r\n        //测试 Reduce (规约)操作\r\n        Optional<String> reduced =\r\n                stringList\r\n                        .stream()\r\n                        .sorted()\r\n                        .reduce((s1, s2) -> s1 + \"#\" + s2);\r\n\r\n        reduced.ifPresent(System.out::println);//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\r\n```\r\n\r\n\r\n\r\n**译者注：** 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于`Integer sum = integers.reduce(0, (a, b) -> a+b);`也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。\r\n\r\n```java\r\n// 字符串连接，concat = \"ABCD\"\r\nString concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat); \r\n// 求最小值，minValue = -3.0\r\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); \r\n// 求和，sumValue = 10, 有起始值\r\nint sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);\r\n// 求和，sumValue = 10, 无起始值\r\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\r\n// 过滤，字符串连接，concat = \"ace\"\r\nconcat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").\r\n filter(x -> x.compareTo(\"Z\") > 0).\r\n reduce(\"\", String::concat);\r\n```\r\n\r\n上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： [IBM：Java 8 中的 Streams API 详解](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html) \r\n\r\n## Parallel Streams（并行流）\r\n\r\n前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。\r\n\r\n下面的例子展示了是如何通过并行Stream来提升性能：\r\n\r\n首先我们创建一个没有重复元素的大表：\r\n\r\n```java\r\nint max = 1000000;\r\nList<String> values = new ArrayList<>(max);\r\nfor (int i = 0; i < max; i++) {\r\n    UUID uuid = UUID.randomUUID();\r\n    values.add(uuid.toString());\r\n}\r\n```\r\n\r\n我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。\r\n\r\n### Sequential Sort（串行排序）\r\n\r\n```java\r\n//串行排序\r\nlong t0 = System.nanoTime();\r\nlong count = values.stream().sorted().count();\r\nSystem.out.println(count);\r\n\r\nlong t1 = System.nanoTime();\r\n\r\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\r\nSystem.out.println(String.format(\"sequential sort took: %d ms\", millis));\r\n```\r\n\r\n```\r\n1000000\r\nsequential sort took: 709 ms//串行排序所用的时间\r\n```\r\n\r\n### Parallel Sort（并行排序）\r\n\r\n```java\r\n//并行排序\r\nlong t0 = System.nanoTime();\r\n\r\nlong count = values.parallelStream().sorted().count();\r\nSystem.out.println(count);\r\n\r\nlong t1 = System.nanoTime();\r\n\r\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\r\nSystem.out.println(String.format(\"parallel sort took: %d ms\", millis));\r\n\r\n```\r\n\r\n```java\r\n1000000\r\nparallel sort took: 475 ms//串行排序所用的时间\r\n```\r\n\r\n上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 `stream()` 改为`parallelStream()`。\r\n\r\n## Maps\r\n\r\n前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 `stream（）`方法，但是你可以在键，值上创建专门的流或者通过 `map.keySet().stream()`,`map.values().stream()`和`map.entrySet().stream()`。\r\n\r\n此外,Maps 支持各种新的和有用的方法来执行常见任务。\r\n\r\n```java\r\nMap<Integer, String> map = new HashMap<>();\r\n\r\nfor (int i = 0; i < 10; i++) {\r\n    map.putIfAbsent(i, \"val\" + i);\r\n}\r\n\r\nmap.forEach((id, val) -> System.out.println(val));//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9\r\n```\r\n\r\n`putIfAbsent` 阻止我们在null检查时写入额外的代码;`forEach`接受一个 consumer 来对 map 中的每个元素操作。\r\n\r\n此示例显示如何使用函数在 map 上计算代码：\r\n\r\n```java\r\nmap.computeIfPresent(3, (num, val) -> val + num);\r\nmap.get(3);             // val33\r\n\r\nmap.computeIfPresent(9, (num, val) -> null);\r\nmap.containsKey(9);     // false\r\n\r\nmap.computeIfAbsent(23, num -> \"val\" + num);\r\nmap.containsKey(23);    // true\r\n\r\nmap.computeIfAbsent(3, num -> \"bam\");\r\nmap.get(3);             // val33\r\n```\r\n\r\n接下来展示如何在Map里删除一个键值全都匹配的项：\r\n\r\n```java\r\nmap.remove(3, \"val3\");\r\nmap.get(3);             // val33\r\nmap.remove(3, \"val33\");\r\nmap.get(3);             // null\r\n```\r\n\r\n另外一个有用的方法：\r\n\r\n```java\r\nmap.getOrDefault(42, \"not found\");  // not found\r\n```\r\n\r\n对Map的元素做合并也变得很容易了：\r\n\r\n```java\r\nmap.merge(9, \"val9\", (value, newValue) -> value.concat(newValue));\r\nmap.get(9);             // val9\r\nmap.merge(9, \"concat\", (value, newValue) -> value.concat(newValue));\r\nmap.get(9);             // val9concat\r\n```\r\n\r\nMerge 做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。\r\n\r\n## Data API（日期相关API）\r\n\r\nJava 8在 `java.time` 包下包含一个全新的日期和时间API。新的Date API与Joda-Time库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。\r\n\r\n**译者注(总结)：**\r\n\r\n- Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 `System.currentTimeMillis()` 来获取当前的微秒数。某一个特定的时间点也可以使用 `Instant` 类来表示，`Instant` 类也可以用来创建旧版本的`java.util.Date` 对象。\r\n\r\n- 在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类`ZoneId`（在`java.time`包中）表示一个区域标识符。 它有一个名为`getAvailableZoneIds`的静态方法，它返回所有区域标识符。\r\n\r\n- jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。\r\n\r\n  \r\n\r\n### Clock\r\n\r\nClock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 `System.currentTimeMillis()` 来获取当前的微秒数。某一个特定的时间点也可以使用 `Instant` 类来表示，`Instant` 类也可以用来创建旧版本的`java.util.Date` 对象。\r\n\r\n```java\r\nClock clock = Clock.systemDefaultZone();\r\nlong millis = clock.millis();\r\nSystem.out.println(millis);//1552379579043\r\nInstant instant = clock.instant();\r\nSystem.out.println(instant);\r\nDate legacyDate = Date.from(instant); //2019-03-12T08:46:42.588Z\r\nSystem.out.println(legacyDate);//Tue Mar 12 16:32:59 CST 2019\r\n```\r\n\r\n### Timezones（时区）\r\n\r\n在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类`ZoneId`（在`java.time`包中）表示一个区域标识符。 它有一个名为`getAvailableZoneIds`的静态方法，它返回所有区域标识符。\r\n\r\n```java\r\n//输出所有区域标识符\r\nSystem.out.println(ZoneId.getAvailableZoneIds());\r\n\r\nZoneId zone1 = ZoneId.of(\"Europe/Berlin\");\r\nZoneId zone2 = ZoneId.of(\"Brazil/East\");\r\nSystem.out.println(zone1.getRules());// ZoneRules[currentStandardOffset=+01:00]\r\nSystem.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=-03:00]\r\n```\r\n\r\n### LocalTime（本地时间）\r\n\r\nLocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：\r\n\r\n```java\r\nLocalTime now1 = LocalTime.now(zone1);\r\nLocalTime now2 = LocalTime.now(zone2);\r\nSystem.out.println(now1.isBefore(now2));  // false\r\n\r\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\r\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\r\n\r\nSystem.out.println(hoursBetween);       // -3\r\nSystem.out.println(minutesBetween);     // -239\r\n```\r\n\r\nLocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串.\r\n\r\n```java\r\nLocalTime late = LocalTime.of(23, 59, 59);\r\nSystem.out.println(late);       // 23:59:59\r\nDateTimeFormatter germanFormatter =\r\n    DateTimeFormatter\r\n        .ofLocalizedTime(FormatStyle.SHORT)\r\n        .withLocale(Locale.GERMAN);\r\n\r\nLocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);\r\nSystem.out.println(leetTime);   // 13:37\r\n```\r\n\r\n### LocalDate（本地日期）\r\n\r\nLocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。\r\n\r\n```java\r\nLocalDate today = LocalDate.now();//获取现在的日期\r\nSystem.out.println(\"今天的日期: \"+today);//2019-03-12\r\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\r\nSystem.out.println(\"明天的日期: \"+tomorrow);//2019-03-13\r\nLocalDate yesterday = tomorrow.minusDays(2);\r\nSystem.out.println(\"昨天的日期: \"+yesterday);//2019-03-11\r\nLocalDate independenceDay = LocalDate.of(2019, Month.MARCH, 12);\r\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\r\nSystem.out.println(\"今天是周几:\"+dayOfWeek);//TUESDAY\r\n```\r\n\r\n从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用  `DateTimeFormatter` 解析字符串的例子：\r\n\r\n```java\r\n    String str1 = \"2014==04==12 01时06分09秒\";\r\n        // 根据需要解析的日期、时间字符串定义解析所用的格式器\r\n        DateTimeFormatter fomatter1 = DateTimeFormatter\r\n                .ofPattern(\"yyyy==MM==dd HH时mm分ss秒\");\r\n\r\n        LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1);\r\n        System.out.println(dt1); // 输出 2014-04-12T01:06:09\r\n\r\n        String str2 = \"2014$$$四月$$$13 20小时\";\r\n        DateTimeFormatter fomatter2 = DateTimeFormatter\r\n                .ofPattern(\"yyy$$$MMM$$$dd HH小时\");\r\n        LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2);\r\n        System.out.println(dt2); // 输出 2014-04-13T20:00\r\n\r\n```\r\n\r\n再来看一个使用 `DateTimeFormatter` 格式化日期的示例\r\n\r\n```java\r\nLocalDateTime rightNow=LocalDateTime.now();\r\nString date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);\r\nSystem.out.println(date);//2019-03-12T16:26:48.29\r\nDateTimeFormatter formatter=DateTimeFormatter.ofPattern(\"YYYY-MM-dd HH:mm:ss\");\r\nSystem.out.println(formatter.format(rightNow));//2019-03-12 16:26:48\r\n```\r\n\r\n### LocalDateTime（本地日期时间）\r\n\r\nLocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。\r\n\r\n```java\r\nLocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\r\n\r\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\r\nSystem.out.println(dayOfWeek);      // WEDNESDAY\r\n\r\nMonth month = sylvester.getMonth();\r\nSystem.out.println(month);          // DECEMBER\r\n\r\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\r\nSystem.out.println(minuteOfDay);    // 1439\r\n```\r\n\r\n只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的`java.util.Date`。\r\n\r\n```java\r\nInstant instant = sylvester\r\n        .atZone(ZoneId.systemDefault())\r\n        .toInstant();\r\n\r\nDate legacyDate = Date.from(instant);\r\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\r\n```\r\n\r\n格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：\r\n\r\n```java\r\nDateTimeFormatter formatter =\r\n    DateTimeFormatter\r\n        .ofPattern(\"MMM dd, yyyy - HH:mm\");\r\nLocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);\r\nString string = formatter.format(parsed);\r\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\r\n```\r\n\r\n和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。\r\n关于时间日期格式的详细信息在[这里](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)。\r\n\r\n## Annotations（注解）\r\n\r\n在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。\r\n首先定义一个包装类Hints注解用来放置一组具体的Hint注解：\r\n\r\n```java\r\n@interface Hints {\r\n    Hint[] value();\r\n}\r\n@Repeatable(Hints.class)\r\n@interface Hint {\r\n    String value();\r\n}\r\n```\r\n\r\nJava 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下`@Repeatable`即可。\r\n\r\n例 1: 使用包装类当容器来存多个注解（老方法）\r\n\r\n```java\r\n@Hints({@Hint(\"hint1\"), @Hint(\"hint2\")})\r\nclass Person {}\r\n```\r\n\r\n例 2：使用多重注解（新方法）\r\n\r\n```java\r\n@Hint(\"hint1\")\r\n@Hint(\"hint2\")\r\nclass Person {}\r\n```\r\n\r\n第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：\r\n\r\n```java\r\nHint hint = Person.class.getAnnotation(Hint.class);\r\nSystem.out.println(hint);                   // null\r\nHints hints1 = Person.class.getAnnotation(Hints.class);\r\nSystem.out.println(hints1.value().length);  // 2\r\n\r\nHint[] hints2 = Person.class.getAnnotationsByType(Hint.class);\r\nSystem.out.println(hints2.length);          // 2\r\n```\r\n\r\n即便我们没有在 `Person`类上定义 `@Hints`注解，我们还是可以通过 `getAnnotation(Hints.class) `来获取 `@Hints`注解，更加方便的方法是使用 `getAnnotationsByType` 可以直接获取到所有的`@Hint`注解。\r\n另外Java 8的注解还增加到两种新的target上了：\r\n\r\n```java\r\n@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\r\n@interface MyAnnotation {}\r\n```\r\n\r\n\r\n\r\n## Whete to go from here?\r\n\r\n关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如`Arrays.parallelSort`, `StampedLock`和`CompletableFuture`等等。\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (207, 'Java 8接口规范-静态，默认方法', 2, 'JDK8接口规范\r\n===\r\n在JDK8中引入了lambda表达式，出现了函数式接口的概念，为了在扩展接口时保持向前兼容性(比如泛型也是为了保持兼容性而失去了在一些别的语言泛型拥有的功能)，Java接口规范发生了一些改变。。\r\n---\r\n## 1.JDK8以前的接口规范\r\n- JDK8以前接口可以定义的变量和方法\r\n   - 所有变量(Field)不论是否<i>显式</i> 的声明为```public static final```，它实际上都是```public static final```的。\r\n   - 所有方法(Method)不论是否<i>显示</i> 的声明为```public abstract```，它实际上都是```public abstract```的。\r\n```java\r\npublic interface AInterfaceBeforeJDK8 {\r\n    int FIELD = 0;\r\n    void simpleMethod();\r\n}\r\n```\r\n以上接口信息反编译以后可以看到字节码信息里Filed是public static final的，而方法是public abstract的，即是你没有显示的去声明它。\r\n```java\r\n{\r\n    public static final int FIELD;\r\n    descriptor: I\r\n    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL\r\n    ConstantValue: int 0\r\n\r\n  public abstract void simpleMethod();\r\n    descriptor: ()V\r\n    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT\r\n}\r\n```\r\n## 2.JDK8之后的接口规范\r\n- JDK8之后接口可以定义的变量和方法\r\n  - 变量(Field)仍然必须是 ```java public static final```的\r\n  - 方法(Method)除了可以是public abstract之外，还可以是public static或者是default(相当于仅public修饰的实例方法)的。\r\n从以上改变不难看出，修改接口的规范主要是为了能在扩展接口时保持向前兼容。\r\n<br>下面是一个JDK8之后的接口例子\r\n```java\r\npublic interface AInterfaceInJDK8 {\r\n    int simpleFiled = 0;\r\n    static int staticField = 1;\r\n\r\n    public static void main(String[] args) {\r\n    }\r\n    static void staticMethod(){}\r\n\r\n    default void defaultMethod(){}\r\n\r\n    void simpleMethod() throws IOException;\r\n\r\n}\r\n```\r\n进行反编译(去除了一些没用信息)\r\n```java\r\n{\r\n  public static final int simpleFiled;\r\n    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL\r\n\r\n  public static final int staticField;\r\n    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL\r\n\r\n  public static void main(java.lang.String[]);\r\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\r\n    \r\n  public static void staticMethod();\r\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\r\n\r\n  public void defaultMethod();\r\n    flags: (0x0001) ACC_PUBLIC\r\n\r\n  public abstract void simpleMethod() throws java.io.IOException;\r\n    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT\r\n    Exceptions:\r\n      throws java.io.IOException\r\n}\r\n```\r\n可以看到 default关键字修饰的方法是像实例方法一样定义的，所以我们来定义一个只有default的方法并且实现一下试一试。\r\n```java\r\ninterface Default {\r\n    default int defaultMethod() {\r\n        return 4396;\r\n    }\r\n}\r\n\r\npublic class DefaultMethod implements Default {\r\n    public static void main(String[] args) {\r\n        DefaultMethod defaultMethod = new DefaultMethod();\r\n        System.out.println(defaultMethod.defaultMethod());\r\n        //compile error : Non-static method \'defaultMethod()\' cannot be referenced from a static context\r\n        //! DefaultMethod.defaultMethod();\r\n    }\r\n}\r\n```\r\n可以看到default方法确实像实例方法一样，必须有实例对象才能调用，并且子类在实现接口时，可以不用实现default方法，也可以覆盖该方法。\r\n这有点像子类继承父类实例方法。\r\n<br>\r\n接口静态方法就像是类静态方法，唯一的区别是**接口静态方法只能通过接口名调用，而类静态方法既可以通过类名调用也可以通过实例调用**\r\n```java\r\ninterface Static {\r\n    static int staticMethod() {\r\n        return 4396;\r\n    }\r\n}\r\n ... main(String...args)\r\n    //!compile error: Static method may be invoked on containing interface class only\r\n    //!aInstanceOfStatic.staticMethod();\r\n ...\r\n```\r\n另一个问题是多继承问题，大家知道Java中类是不支持多继承的，但是接口是多继承和多实现(implements后跟多个接口)的，\r\n那么如果一个接口继承另一个接口，两个接口都有同名的default方法会怎么样呢？答案是会像类继承一样覆写(@Override)，以下代码在IDE中可以顺利编译\r\n```java\r\ninterface Default {\r\n    default int defaultMethod() {\r\n        return 4396;\r\n    }\r\n}\r\ninterface Default2 extends Default {\r\n    @Override\r\n    default int defaultMethod() {\r\n        return 9527;\r\n    }\r\n}\r\npublic class DefaultMethod implements Default,Default2 {\r\n    public static void main(String[] args) {\r\n        DefaultMethod defaultMethod = new DefaultMethod();\r\n        System.out.println(defaultMethod.defaultMethod());\r\n    }\r\n}\r\n\r\n输出 : 9527\r\n```\r\n出现上面的情况时，会优先找继承树上近的方法，类似于“短路优先”。\r\n<br>\r\n那么如果一个类实现了两个没有继承关系的接口，且这两个接口有同名方法的话会怎么样呢？IDE会要求你重写这个冲突的方法，让你自己选择去执行哪个方法，因为IDE它\r\n还没智能到你不告诉它，它就知道你想执行哪个方法。可以通过```java 接口名.super```指针来访问接口中定义的实例(default)方法。\r\n```java\r\ninterface Default {\r\n    default int defaultMethod() {\r\n        return 4396;\r\n    }\r\n}\r\n\r\ninterface Default2 {\r\n    default int defaultMethod() {\r\n        return 9527;\r\n    }\r\n}\r\n//如果不重写\r\n//compile error : defaults.DefaultMethod inherits unrelated defaults for defaultMethod() from types defaults.Default and defaults.Default2\r\npublic class DefaultMethod implements Default,Default2 {\r\n@Override\r\n    public int defaultMethod() {\r\n        System.out.println(Default.super.defaultMethod());\r\n        System.out.println(Default2.super.defaultMethod());\r\n        return 996;\r\n    }\r\n    public static void main(String[] args) {\r\n        DefaultMethod defaultMethod = new DefaultMethod();\r\n        System.out.println(defaultMethod.defaultMethod());\r\n    }\r\n}\r\n\r\n运行输出 : \r\n4396\r\n9527\r\n996\r\n```\r\n', 0);
INSERT INTO `blog_course` VALUES (208, 'Java 8Lambda表达式', 2, 'JDK8--Lambda表达式\r\n===\r\n## 1.什么是Lambda表达式\r\n**Lambda表达式实质上是一个可传递的代码块，Lambda又称为闭包或者匿名函数，是函数式编程语法，让方法可以像普通参数一样传递**\r\n\r\n## 2.Lambda表达式语法\r\n```(参数列表) -> {执行代码块}```\r\n<br>参数列表可以为空```()->{}```\r\n<br>可以加类型声明比如```(String para1, int para2) -> {return para1 + para2;}```我们可以看到，lambda同样可以有返回值.\r\n<br>在编译器可以推断出类型的时候，可以将类型声明省略，比如```(para1, para2) -> {return para1 + para2;}```\r\n<br>(lambda有点像动态类型语言语法。lambda在字节码层面是用invokedynamic实现的，而这条指令就是为了让JVM更好的支持运行在其上的动态类型语言)\r\n\r\n## 3.函数式接口\r\n在了解Lambda表达式之前，有必要先了解什么是函数式接口```(@FunctionalInterface)```<br>\r\n**函数式接口指的是有且只有一个抽象(abstract)方法的接口**<br>\r\n当需要一个函数式接口的对象时，就可以用Lambda表达式来实现，举个常用的例子:\r\n<br>\r\n```java\r\n  Thread thread = new Thread(() -> {\r\n      System.out.println(\"This is JDK8\'s Lambda!\");\r\n  });\r\n```\r\n这段代码和函数式接口有啥关系？我们回忆一下，Thread类的构造函数里是不是有一个以Runnable接口为参数的？\r\n```java\r\npublic Thread(Runnable target) {...}\r\n\r\n/**\r\n * Runnable Interface\r\n */\r\n@FunctionalInterface\r\npublic interface Runnable {  \r\n    public abstract void run();\r\n}\r\n```\r\n到这里大家可能已经明白了，**Lambda表达式相当于一个匿名类或者说是一个匿名方法**。上面Thread的例子相当于\r\n```java\r\n  Thread thread = new Thread(new Runnable() {\r\n      @Override\r\n      public void run() {\r\n          System.out.println(\"Anonymous class\");\r\n      }\r\n  });\r\n```\r\n也就是说，上面的lambda表达式相当于实现了这个run()方法，然后当做参数传入(个人感觉可以这么理解,lambda表达式就是一个函数，只不过它的返回值、参数列表都\r\n由编译器帮我们推断，因此可以减少很多代码量)。\r\n<br>Lambda也可以这样用 :\r\n```java\r\n  Runnable runnable = () -> {...};\r\n```\r\n其实这和上面的用法没有什么本质上的区别。\r\n<br>至此大家应该明白什么是函数式接口以及函数式接口和lambda表达式之间的关系了。在JDK8中修改了接口的规范，\r\n目的是为了在给接口添加新的功能时保持向前兼容(个人理解)，比如一个已经定义了的函数式接口，某天我们想给它添加新功能，那么就不能保持向前兼容了，\r\n因为在旧的接口规范下，添加新功能必定会破坏这个函数式接口[(JDK8中接口规范)]()\r\n<br>\r\n除了上面说的Runnable接口之外，JDK中已经存在了很多函数式接口\r\n比如(当然不止这些):\r\n- ```java.util.concurrent.Callable```\r\n- ```java.util.Comparator```\r\n- ```java.io.FileFilter```\r\n<br>**关于JDK中的预定义的函数式接口**\r\n\r\n- JDK在```java.util.function```下预定义了很多函数式接口\r\n  - ```Function<T, R> {R apply(T t);}``` 接受一个T对象，然后返回一个R对象，就像普通的函数。\r\n  - ```Consumer<T> {void accept(T t);}``` 消费者 接受一个T对象，没有返回值。\r\n  - ```Predicate<T> {boolean test(T t);}``` 判断，接受一个T对象，返回一个布尔值。\r\n  - ```Supplier<T> {T get();} 提供者(工厂)``` 返回一个T对象。\r\n  - 其他的跟上面的相似，大家可以看一下function包下的具体接口。\r\n## 4.变量作用域\r\n```java\r\npublic class VaraibleHide {\r\n    @FunctionalInterface\r\n    interface IInner {\r\n        void printInt(int x);\r\n    }\r\n    public static void main(String[] args) {\r\n        int x = 20;\r\n        IInner inner = new IInner() {\r\n            int x = 10;\r\n            @Override\r\n            public void printInt(int x) {\r\n                System.out.println(x);\r\n            }\r\n        };\r\n        inner.printInt(30);\r\n        \r\n        inner = (s) -> {\r\n            //Variable used in lambda expression should be final or effectively final\r\n            //!int x = 10;\r\n            //!x= 50; error\r\n            System.out.print(x);\r\n        };\r\n        inner.printInt(30);\r\n    }\r\n}\r\n输出 :\r\n30\r\n20\r\n```\r\n对于lambda表达式```java inner = (s) -> {System.out.print(x);};```,变量x并不是在lambda表达式中定义的，像这样并不是在lambda中定义或者通过lambda的参数列表()获取的变量成为自由变量，它是被lambda表达式捕获的。\r\n<br>lambda表达式和内部类一样，对外部自由变量捕获时，外部自由变量必须为final或者是最终变量(effectively final)的，也就是说这个变量初始化后就不能为它赋新值，\r\n同时lambda不像内部类/匿名类，lambda表达式与外围嵌套块有着相同的作用域，因此对变量命名的有关规则对lambda同样适用。大家阅读上面的代码对这些概念应该\r\n不难理解。\r\n## 5.方法引用\r\n**只需要提供方法的名字，具体的调用过程由Lambda和函数式接口来确定，这样的方法调用成为方法引用。**\r\n<br>下面的例子会打印list中的每个元素:\r\n```java\r\nList<Integer> list = new ArrayList<>();\r\n        for (int i = 0; i < 10; ++i) {\r\n            list.add(i);\r\n        }\r\n        list.forEach(System.out::println);\r\n```\r\n其中```System.out::println```这个就是一个方法引用，等价于Lambda表达式 ```(para)->{System.out.println(para);}```\r\n<br>我们看一下List#forEach方法 ```default void forEach(Consumer<? super T> action)```可以看到它的参数是一个Consumer接口，该接口是一个函数式接口\r\n```java\r\n@FunctionalInterface\r\npublic interface Consumer<T> {\r\n    void accept(T t);\r\n```\r\n大家能发现这个函数接口的方法和```System.out::println```有什么相似的么？没错，它们有着相似的参数列表和返回值。\r\n<br>我们自己定义一个方法，看看能不能像标准输出的打印函数一样被调用\r\n```java\r\npublic class MethodReference {\r\n    public static void main(String[] args) {\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i = 0; i < 10; ++i) {\r\n            list.add(i);\r\n        }\r\n        list.forEach(MethodReference::myPrint);\r\n    }\r\n\r\n    static void myPrint(int i) {\r\n        System.out.print(i + \", \");\r\n    }\r\n}\r\n\r\n输出: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \r\n```\r\n可以看到，我们自己定义的方法也可以当做方法引用。\r\n<br>到这里大家多少对方法引用有了一定的了解，我们再来说一下方法引用的形式。\r\n- 方法引用\r\n  - 类名::静态方法名\r\n  - 类名::实例方法名\r\n  - 类名::new (构造方法引用)\r\n  - 实例名::实例方法名\r\n可以看出，方法引用是通过(方法归属名)::(方法名)来调用的。通过上面的例子已经讲解了一个`类名::静态方法名`的使用方法了，下面再依次介绍其余的几种\r\n方法引用的使用方法。<br>\r\n**类名::实例方法名**<br>\r\n先来看一段代码\r\n```java\r\n  String[] strings = new String[10];\r\n  Arrays.sort(strings, String::compareToIgnoreCase);\r\n```\r\n**上面的String::compareToIgnoreCase等价于(x, y) -> {return x.compareToIgnoreCase(y);}**<br>\r\n我们看一下`Arrays#sort`方法`public static <T> void sort(T[] a, Comparator<? super T> c)`,\r\n可以看到第二个参数是一个Comparator接口，该接口也是一个函数式接口，其中的抽象方法是`int compare(T o1, T o2);`，再看一下\r\n`String#compareToIgnoreCase`方法,`public int compareToIgnoreCase(String str)`，这个方法好像和上面讲方法引用中`类名::静态方法名`不大一样啊，它\r\n的参数列表和函数式接口的参数列表不一样啊，虽然它的返回值一样？\r\n<br>是的，确实不一样但是别忘了，String类的这个方法是个实例方法，而不是静态方法，也就是说，这个方法是需要有一个接收者的。所谓接收者就是\r\ninstance.method(x)中的instance，\r\n它是某个类的实例，有的朋友可能已经明白了。上面函数式接口的`compare(T o1, T o2)`中的第一个参数作为了实例方法的接收者，而第二个参数作为了实例方法的\r\n参数。我们再举一个自己实现的例子:\r\n```java\r\npublic class MethodReference {\r\n    static Random random = new Random(47);\r\n    public static void main(String[] args) {\r\n        MethodReference[] methodReferences = new MethodReference[10];\r\n        Arrays.sort(methodReferences, MethodReference::myCompare);\r\n    }\r\n    int myCompare(MethodReference o) {\r\n        return random.nextInt(2) - 1;\r\n    }\r\n}\r\n```\r\n上面的例子可以在IDE里通过编译，大家有兴趣的可以模仿上面的例子自己写一个程序，打印出排序后的结果。\r\n<br>**构造器引用**<br>\r\n构造器引用仍然需要与特定的函数式接口配合使用，并不能像下面这样直接使用。IDE会提示String不是一个函数式接口\r\n```java\r\n  //compile error : String is not a functional interface\r\n  String str = String::new;\r\n```\r\n下面是一个使用构造器引用的例子，可以看出构造器引用可以和这种工厂型的函数式接口一起使用的。\r\n```java\r\n  interface IFunctional<T> {\r\n    T func();\r\n}\r\n\r\npublic class ConstructorReference {\r\n\r\n    public ConstructorReference() {\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Supplier<ConstructorReference> supplier0 = () -> new ConstructorReference();\r\n        Supplier<ConstructorReference> supplier1 = ConstructorReference::new;\r\n        IFunctional<ConstructorReference> functional = () -> new ConstructorReference();\r\n        IFunctional<ConstructorReference> functional1 = ConstructorReference::new;\r\n    }\r\n}\r\n```\r\n下面是一个JDK官方的例子\r\n```java\r\n  public static <T, SOURCE extends Collection<T>, DEST extends Collection<T>>\r\n    DEST transferElements(\r\n        SOURCE sourceCollection,\r\n        Supplier<DEST> collectionFactory) {\r\n\r\n        DEST result = collectionFactory.get();\r\n        for (T t : sourceCollection) {\r\n            result.add(t);\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    ...\r\n    \r\n    Set<Person> rosterSet = transferElements(\r\n            roster, HashSet::new);\r\n```\r\n\r\n**实例::实例方法**\r\n<br>\r\n其实开始那个例子就是一个实例::实例方法的引用\r\n```java\r\nList<Integer> list = new ArrayList<>();\r\n        for (int i = 0; i < 10; ++i) {\r\n            list.add(i);\r\n        }\r\n        list.forEach(System.out::println);\r\n```\r\n其中System.out就是一个实例，println是一个实例方法。相信不用再给大家做解释了。\r\n## 总结\r\nLambda表达式是JDK8引入Java的函数式编程语法，使用Lambda需要直接或者间接的与函数式接口配合，在开发中使用Lambda可以减少代码量，\r\n但是并不是说必须要使用Lambda(虽然它是一个很酷的东西)。有些情况下使用Lambda会使代码的可读性急剧下降，并且也节省不了多少代码，\r\n所以在实际开发中还是需要仔细斟酌是否要使用Lambda。和Lambda相似的还有JDK10中加入的var类型推断，同样对于这个特性需要斟酌使用。\r\n', 0);
INSERT INTO `blog_course` VALUES (209, 'Java 8Stream', 2, 'Stream API 旨在让编码更高效率、干净、简洁。\r\n\r\n### 从迭代器到Stream操作\r\n\r\n当使用 `Stream` 时，我们一般会通过三个阶段建立一个流水线：\r\n\r\n1. 创建一个 `Stream`；\r\n2. 进行一个或多个中间操作;\r\n3. 使用终止操作产生一个结果,`Stream` 就不会再被使用了。\r\n\r\n**案例1：统计 List 中的单词长度大于6的个数**\r\n\r\n```java\r\n/**\r\n* 案例1：统计 List 中的单词长度大于6的个数\r\n*/\r\nArrayList<String> wordsList = new ArrayList<String>();\r\nwordsList.add(\"Charles\");\r\nwordsList.add(\"Vincent\");\r\nwordsList.add(\"William\");\r\nwordsList.add(\"Joseph\");\r\nwordsList.add(\"Henry\");\r\nwordsList.add(\"Bill\");\r\nwordsList.add(\"Joan\");\r\nwordsList.add(\"Linda\");\r\nint count = 0;\r\n```\r\nJava8之前我们通常用迭代方法来完成上面的需求：\r\n\r\n```java\r\n//迭代（Java8之前的常用方法）\r\n//迭代不好的地方：1. 代码多；2 很难被并行运算。\r\nfor (String word : wordsList) {\r\n    if (word.length() > 6) {\r\n        count++;\r\n    }\r\n}\r\nSystem.out.println(count);//3\r\n```\r\nJava8之前我们使用 `Stream` 一行代码就能解决了，而且可以瞬间转换为并行执行的效果：\r\n\r\n```java\r\n//Stream\r\n//将stream()改为parallelStream()就可以瞬间将代码编程并行执行的效果\r\nlong count2=wordsList.stream()\r\n    .filter(w->w.length()>6)\r\n    .count();\r\nlong count3=wordsList.parallelStream()\r\n    .filter(w->w.length()>6)\r\n    .count();\r\nSystem.out.println(count2);\r\nSystem.out.println(count3);\r\n```\r\n\r\n### distinct()\r\n\r\n去除 List 中重复的 String\r\n\r\n```java\r\nList<String> list = list.stream()\r\n    .distinct()\r\n    .collect(Collectors.toList());\r\n```\r\n\r\n### map\r\n\r\nmap 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：\r\n\r\n```java\r\nList<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);\r\n// 获取 List 中每个元素对应的平方数并去重\r\nList<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());\r\nSystem.out.println(squaresList.toString());//[9, 4, 49, 25]\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (210, 'Java 8改进的类型推断', 2, '## 　　　　　　　　　　　　　改进的类型推断\r\n### 1.什么是类型推断\r\n类型推断就像它的字面意思一样，编译器根据<b><i>你显示声明的已知的信息</i></b> 推断出你没有显示声明的类型，这就是类型推断。\r\n看过《Java编程思想 第四版》的朋友可能还记得里面讲解泛型一章的时候，里面很多例子是下面这样的:\r\n```java\r\n  Map<String, Object> map = new Map<String, Object>();\r\n```\r\n而我们平常写的都是这样的:\r\n```java\r\n  Map<String, Object> map = new Map<>();\r\n```\r\n这就是类型推断，《Java编程思想 第四版》这本书出书的时候最新的JDK只有1.6(JDK7推出的类型推断)，在Java编程思想里Bruce Eckel大叔还提到过这个问题\r\n(可能JDK的官方人员看了Bruce Eckel大叔的Thinking in Java才加的类型推断，☺)，在JDK7中推出了上面这样的类型推断，可以减少一些无用的代码。\r\n(Java编程思想到现在还只有第四版，是不是因为Bruce Eckel大叔觉得Java新推出的语言特性“然并卵”呢？/滑稽)\r\n<br>\r\n在JDK7中，类型推断只有上面例子的那样的能力，即只有在使用**赋值语句**时才能自动推断出泛型参数信息(即<>里的信息)，下面的官方文档里的例子在JDK7里会编译\r\n错误\r\n```java\r\n  List<String> stringList = new ArrayList<>();\r\n  stringList.add(\"A\");\r\n  //error : addAll(java.util.Collection<? extends java.lang.String>)in List cannot be applied to (java.util.List<java.lang.Object>)\r\n  stringList.addAll(Arrays.asList());  \r\n```\r\n但是上面的代码在JDK8里可以通过，也就说，JDK8里，类型推断不仅可以用于赋值语句，而且可以根据代码中上下文里的信息推断出更多的信息，因此我们需要些的代码\r\n会更少。加强的类型推断还有一个就是用于Lambda表达式了。\r\n<br>\r\n大家其实不必细究类型推断，在日常使用中IDE会自动判断，当IDE自己无法推断出足够的信息时，就需要我们额外做一下工作，比如在<>里添加更多的类型信息，\r\n相信随着Java的进化，这些便利的功能会越来越强大。\r\n\r\n<!-- --------------------------------------------------- 改进的类型推断结束------------------------------------------------- -->\r\n', 0);
INSERT INTO `blog_course` VALUES (211, 'Java 8通过反射获得方法的参数信息', 2, '## 　　　　　　　　　　　　　通过反射获得方法的参数信息\r\nJDK8之前 .class文件是不会存储方法参数信息的，因此也就无法通过反射获取该信息(想想反射获取类信息的入口是什么？当然就是Class类了)。即是是在JDK11里\r\n也不会默认生成这些信息，可以通过在javac加上-parameters参数来让javac生成这些信息(javac就是java编译器，可以把java文件编译成.class文件)。生成额外\r\n的信息(运行时非必须信息)会消耗内存并且有可能公布敏感信息(某些方法参数比如password，JDK文档里这么说的)，并且确实很多信息javac并不会为我们生成，比如\r\nLocalVariableTable，javac就不会默认生成，需要你加上 -g:vars来强制让编译器生成，同样的，方法参数信息也需要加上\r\n-parameters来让javac为你在.class文件中生成这些信息，否则运行时反射是无法获取到这些信息的。在讲解Java语言层面的方法之前，先看一下javac加上该\r\n参数和不加生成的信息有什么区别(不感兴趣想直接看运行代码的可以跳过这段)。下面是随便写的一个类。\r\n```java\r\npublic class ByteCodeParameters {\r\n    public String simpleMethod(String canUGetMyName, Object yesICan) {\r\n        return \"9527\";\r\n    }\r\n}\r\n```\r\n先来不加参数编译和反编译一下这个类javac ByteCodeParameters.java , javap -v ByteCodeParameters:\r\n```java\r\n  //只截取了部分信息\r\n  public java.lang.String simpleMethod(java.lang.String, java.lang.Object);\r\n    descriptor: (Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/String;\r\n    flags: (0x0001) ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=3, args_size=3\r\n         0: ldc           #2                  // String 9527\r\n         2: areturn\r\n      LineNumberTable:\r\n        line 5: 0\r\n  //这个方法的描述到这里就结束了\r\n```\r\n接下来我们加上参数javac -parameters ByteCodeParameters.java 再来看反编译的信息:\r\n```java\r\n public java.lang.String simpleMethod(java.lang.String, java.lang.Object);\r\n    descriptor: (Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/String;\r\n    flags: (0x0001) ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=3, args_size=3\r\n         0: ldc           #2                  // String 9527\r\n         2: areturn\r\n      LineNumberTable:\r\n        line 8: 0\r\n    MethodParameters:\r\n      Name                           Flags\r\n      canUGetMyName\r\n      yesICan\r\n```\r\n可以看到.class文件里多了一个MethodParameters信息，这就是参数的名字，可以看到默认是不保存的。\r\n<br>下面看一下在Intelj Idea里运行的这个例子，我们试一下通过反射获取方法名 :\r\n```java\r\npublic class ByteCodeParameters {\r\n    public String simpleMethod(String canUGetMyName, Object yesICan) {\r\n        return \"9527\";\r\n    }\r\n\r\n    public static void main(String[] args) throws NoSuchMethodException {\r\n        Class<?> clazz = ByteCodeParameters.class;\r\n        Method simple = clazz.getDeclaredMethod(\"simpleMethod\", String.class, Object.class);\r\n        Parameter[] parameters = simple.getParameters();\r\n        for (Parameter p : parameters) {\r\n            System.out.println(p.getName());\r\n        }\r\n    }\r\n}\r\n输出 :\r\narg0\r\narg1\r\n```\r\n？？？说好的方法名呢？？？？别急，哈哈。前面说了，默认是不生成参数名信息的，因此我们需要做一些配置，我们找到IDEA的settings里的Java Compiler选项，在\r\nAdditional command line parameters:一行加上-parameters(Eclipse 也是找到Java Compiler选中Stoer information about method parameters)，或者自\r\n己编译一个.class文件放在IDEA的out下，然后再来运行 :\r\n```java\r\n输出 :\r\ncanUGetMyName\r\nyesICan\r\n```\r\n这样我们就通过反射获取到参数信息了。想要了解更多的同学可以自己研究一下 [官方文档]\r\n(https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html)\r\n<br>\r\n## 总结与补充\r\n在JDK8之后，可以通过-parameters参数来让编译器生成参数信息然后在运行时通过反射获取方法参数信息，其实在SpringFramework\r\n里面也有一个LocalVariableTableParameterNameDiscoverer对象可以获取方法参数名信息，有兴趣的同学可以自行百度(这个类在打印日志时可能会比较有用吧，个人感觉)。\r\n', 0);
INSERT INTO `blog_course` VALUES (212, 'Java 8特性总结', 2, 'JDK8新特性总结\r\n======\r\n总结了部分JDK8新特性，另外一些新特性可以通过Oracle的官方文档查看，毕竟是官方文档，各种新特性都会介绍，有兴趣的可以去看。<br>\r\n[Oracle官方文档:What\'s New in JDK8](https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html)\r\n-----\r\n- [Java语言特性](#JavaProgrammingLanguage)\r\n  - [Lambda表达式是一个新的语言特性，已经在JDK8中加入。它是一个可以传递的代码块，你也可以把它们当做方法参数。\r\n  Lambda表达式允许您更紧凑地创建单虚方法接口（称为功能接口）的实例。](#LambdaExpressions)\r\n  \r\n  - [方法引用为已经存在的具名方法提供易于阅读的Lambda表达式](#MethodReferences)\r\n  \r\n  - [默认方法允许将新功能添加到库的接口，并确保与为这些接口的旧版本编写的代码的二进制兼容性。](#DefaultMethods)\r\n  \r\n  - [改进的类型推断。](#ImprovedTypeInference)\r\n      \r\n  - [方法参数反射(通过反射获得方法参数信息)](#MethodParameterReflection)  \r\n  \r\n- [流(stream)](#stream)\r\n  - [新java.util.stream包中的类提供Stream API以支持对元素流的功能样式操作。流(stream)和I/O里的流不是同一个概念\r\n     ，使用stream API可以更方便的操作集合。]()\r\n  \r\n- [国际化]()\r\n   - 待办\r\n- 待办\r\n___ \r\n<!-- ---------------------------------------------------Lambda表达式-------------------------------------------------------- -->\r\n<!-- 标题与跳转-->\r\n<span id=\"JavaProgrammingLanguage\"></span> \r\n<span id=\"LambdaExpressions\"></span>\r\n<!-- 标题与跳转结束-->\r\n<!-- 正文-->\r\n\r\n## 　　　　　　　　　　　　　Lambda表达式\r\n### 1.什么是Lambda表达式\r\n**Lambda表达式实质上是一个可传递的代码块，Lambda又称为闭包或者匿名函数，是函数式编程语法，让方法可以像普通参数一样传递**\r\n\r\n### 2.Lambda表达式语法\r\n```(参数列表) -> {执行代码块}```\r\n<br>参数列表可以为空```()->{}```\r\n<br>可以加类型声明比如```(String para1, int para2) -> {return para1 + para2;}```我们可以看到，lambda同样可以有返回值.\r\n<br>在编译器可以推断出类型的时候，可以将类型声明省略，比如```(para1, para2) -> {return para1 + para2;}```\r\n<br>(lambda有点像动态类型语言语法。lambda在字节码层面是用invokedynamic实现的，而这条指令就是为了让JVM更好的支持运行在其上的动态类型语言)\r\n\r\n### 3.函数式接口\r\n在了解Lambda表达式之前，有必要先了解什么是函数式接口```(@FunctionalInterface)```<br>\r\n**函数式接口指的是有且只有一个抽象(abstract)方法的接口**<br>\r\n当需要一个函数式接口的对象时，就可以用Lambda表达式来实现，举个常用的例子:\r\n<br>\r\n```java\r\n  Thread thread = new Thread(() -> {\r\n      System.out.println(\"This is JDK8\'s Lambda!\");\r\n  });\r\n```\r\n这段代码和函数式接口有啥关系？我们回忆一下，Thread类的构造函数里是不是有一个以Runnable接口为参数的？\r\n```java\r\npublic Thread(Runnable target) {...}\r\n\r\n/**\r\n * Runnable Interface\r\n */\r\n@FunctionalInterface\r\npublic interface Runnable {  \r\n    public abstract void run();\r\n}\r\n```\r\n到这里大家可能已经明白了，**Lambda表达式相当于一个匿名类或者说是一个匿名方法**。上面Thread的例子相当于\r\n```java\r\n  Thread thread = new Thread(new Runnable() {\r\n      @Override\r\n      public void run() {\r\n          System.out.println(\"Anonymous class\");\r\n      }\r\n  });\r\n```\r\n也就是说，上面的lambda表达式相当于实现了这个run()方法，然后当做参数传入(个人感觉可以这么理解,lambda表达式就是一个函数，只不过它的返回值、参数列表都\r\n由编译器帮我们推断，因此可以减少很多代码量)。\r\n<br>Lambda也可以这样用 :\r\n```java\r\n  Runnable runnable = () -> {...};\r\n```\r\n其实这和上面的用法没有什么本质上的区别。\r\n<br>至此大家应该明白什么是函数式接口以及函数式接口和lambda表达式之间的关系了。在JDK8中修改了接口的规范，\r\n目的是为了在给接口添加新的功能时保持向前兼容(个人理解)，比如一个已经定义了的函数式接口，某天我们想给它添加新功能，那么就不能保持向前兼容了，\r\n因为在旧的接口规范下，添加新功能必定会破坏这个函数式接口[(JDK8中接口规范)]()\r\n<br>\r\n除了上面说的Runnable接口之外，JDK中已经存在了很多函数式接口\r\n比如(当然不止这些):\r\n- ```java.util.concurrent.Callable```\r\n- ```java.util.Comparator```\r\n- ```java.io.FileFilter```\r\n<br>**关于JDK中的预定义的函数式接口**\r\n\r\n- JDK在```java.util.function```下预定义了很多函数式接口\r\n  - ```Function<T, R> {R apply(T t);}``` 接受一个T对象，然后返回一个R对象，就像普通的函数。\r\n  - ```Consumer<T> {void accept(T t);}``` 消费者 接受一个T对象，没有返回值。\r\n  - ```Predicate<T> {boolean test(T t);}``` 判断，接受一个T对象，返回一个布尔值。\r\n  - ```Supplier<T> {T get();} 提供者(工厂)``` 返回一个T对象。\r\n  - 其他的跟上面的相似，大家可以看一下function包下的具体接口。\r\n### 4.变量作用域\r\n```java\r\npublic class VaraibleHide {\r\n    @FunctionalInterface\r\n    interface IInner {\r\n        void printInt(int x);\r\n    }\r\n    public static void main(String[] args) {\r\n        int x = 20;\r\n        IInner inner = new IInner() {\r\n            int x = 10;\r\n            @Override\r\n            public void printInt(int x) {\r\n                System.out.println(x);\r\n            }\r\n        };\r\n        inner.printInt(30);\r\n        \r\n        inner = (s) -> {\r\n            //Variable used in lambda expression should be final or effectively final\r\n            //!int x = 10;\r\n            //!x= 50; error\r\n            System.out.print(x);\r\n        };\r\n        inner.printInt(30);\r\n    }\r\n}\r\n输出 :\r\n30\r\n20\r\n```\r\n对于lambda表达式```java inner = (s) -> {System.out.print(x);};```,变量x并不是在lambda表达式中定义的，像这样并不是在lambda中定义或者通过lambda\r\n的参数列表()获取的变量成为自由变量，它是被lambda表达式捕获的。\r\n<br>lambda表达式和内部类一样，对外部自由变量捕获时，外部自由变量必须为final或者是最终变量(effectively final)的，也就是说这个变量初始化后就不能为它赋新值，同时lambda不像内部类/匿名类，lambda表达式与外围嵌套块有着相同的作用域，因此对变量命名的有关规则对lambda同样适用。大家阅读上面的代码对这些概念应该不难理解。\r\n<span id=\"MethodReferences\"></span>\r\n### 5.方法引用\r\n**只需要提供方法的名字，具体的调用过程由Lambda和函数式接口来确定，这样的方法调用成为方法引用。**\r\n<br>下面的例子会打印list中的每个元素:\r\n```java\r\nList<Integer> list = new ArrayList<>();\r\n        for (int i = 0; i < 10; ++i) {\r\n            list.add(i);\r\n        }\r\n        list.forEach(System.out::println);\r\n```\r\n其中```System.out::println```这个就是一个方法引用，等价于Lambda表达式 ```(para)->{System.out.println(para);}```\r\n<br>我们看一下List#forEach方法 ```default void forEach(Consumer<? super T> action)```可以看到它的参数是一个Consumer接口，该接口是一个函数式接口\r\n```java\r\n@FunctionalInterface\r\npublic interface Consumer<T> {\r\n    void accept(T t);\r\n```\r\n大家能发现这个函数接口的方法和```System.out::println```有什么相似的么？没错，它们有着相似的参数列表和返回值。\r\n<br>我们自己定义一个方法，看看能不能像标准输出的打印函数一样被调用\r\n```java\r\npublic class MethodReference {\r\n    public static void main(String[] args) {\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i = 0; i < 10; ++i) {\r\n            list.add(i);\r\n        }\r\n        list.forEach(MethodReference::myPrint);\r\n    }\r\n\r\n    static void myPrint(int i) {\r\n        System.out.print(i + \", \");\r\n    }\r\n}\r\n\r\n输出: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \r\n```\r\n可以看到，我们自己定义的方法也可以当做方法引用。\r\n<br>到这里大家多少对方法引用有了一定的了解，我们再来说一下方法引用的形式。\r\n- 方法引用\r\n  - 类名::静态方法名\r\n  - 类名::实例方法名\r\n  - 类名::new (构造方法引用)\r\n  - 实例名::实例方法名\r\n可以看出，方法引用是通过(方法归属名)::(方法名)来调用的。通过上面的例子已经讲解了一个`类名::静态方法名`的使用方法了，下面再依次介绍其余的几种\r\n方法引用的使用方法。<br>\r\n**类名::实例方法名**<br>\r\n先来看一段代码\r\n```java\r\n  String[] strings = new String[10];\r\n  Arrays.sort(strings, String::compareToIgnoreCase);\r\n```\r\n**上面的String::compareToIgnoreCase等价于(x, y) -> {return x.compareToIgnoreCase(y);}**<br>\r\n我们看一下`Arrays#sort`方法`public static <T> void sort(T[] a, Comparator<? super T> c)`,\r\n可以看到第二个参数是一个Comparator接口，该接口也是一个函数式接口，其中的抽象方法是`int compare(T o1, T o2);`，再看一下\r\n`String#compareToIgnoreCase`方法,`public int compareToIgnoreCase(String str)`，这个方法好像和上面讲方法引用中`类名::静态方法名`不大一样啊，它\r\n的参数列表和函数式接口的参数列表不一样啊，虽然它的返回值一样？\r\n<br>是的，确实不一样但是别忘了，String类的这个方法是个实例方法，而不是静态方法，也就是说，这个方法是需要有一个接收者的。所谓接收者就是\r\ninstance.method(x)中的instance，\r\n它是某个类的实例，有的朋友可能已经明白了。上面函数式接口的`compare(T o1, T o2)`中的第一个参数作为了实例方法的接收者，而第二个参数作为了实例方法的\r\n参数。我们再举一个自己实现的例子:\r\n```java\r\npublic class MethodReference {\r\n    static Random random = new Random(47);\r\n    public static void main(String[] args) {\r\n        MethodReference[] methodReferences = new MethodReference[10];\r\n        Arrays.sort(methodReferences, MethodReference::myCompare);\r\n    }\r\n    int myCompare(MethodReference o) {\r\n        return random.nextInt(2) - 1;\r\n    }\r\n}\r\n```\r\n上面的例子可以在IDE里通过编译，大家有兴趣的可以模仿上面的例子自己写一个程序，打印出排序后的结果。\r\n<br>**构造器引用**<br>\r\n构造器引用仍然需要与特定的函数式接口配合使用，并不能像下面这样直接使用。IDE会提示String不是一个函数式接口\r\n```java\r\n  //compile error : String is not a functional interface\r\n  String str = String::new;\r\n```\r\n下面是一个使用构造器引用的例子，可以看出构造器引用可以和这种工厂型的函数式接口一起使用的。\r\n```java\r\n  interface IFunctional<T> {\r\n    T func();\r\n}\r\n\r\npublic class ConstructorReference {\r\n\r\n    public ConstructorReference() {\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Supplier<ConstructorReference> supplier0 = () -> new ConstructorReference();\r\n        Supplier<ConstructorReference> supplier1 = ConstructorReference::new;\r\n        IFunctional<ConstructorReference> functional = () -> new ConstructorReference();\r\n        IFunctional<ConstructorReference> functional1 = ConstructorReference::new;\r\n    }\r\n}\r\n```\r\n下面是一个JDK官方的例子\r\n```java\r\n  public static <T, SOURCE extends Collection<T>, DEST extends Collection<T>>\r\n    DEST transferElements(\r\n        SOURCE sourceCollection,\r\n        Supplier<DEST> collectionFactory) {\r\n\r\n        DEST result = collectionFactory.get();\r\n        for (T t : sourceCollection) {\r\n            result.add(t);\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    ...\r\n    \r\n    Set<Person> rosterSet = transferElements(\r\n            roster, HashSet::new);\r\n```\r\n\r\n**实例::实例方法**\r\n<br>\r\n其实开始那个例子就是一个实例::实例方法的引用\r\n```java\r\nList<Integer> list = new ArrayList<>();\r\n        for (int i = 0; i < 10; ++i) {\r\n            list.add(i);\r\n        }\r\n        list.forEach(System.out::println);\r\n```\r\n其中System.out就是一个实例，println是一个实例方法。相信不用再给大家做解释了。\r\n### 总结\r\nLambda表达式是JDK8引入Java的函数式编程语法，使用Lambda需要直接或者间接的与函数式接口配合，在开发中使用Lambda可以减少代码量，\r\n但是并不是说必须要使用Lambda(虽然它是一个很酷的东西)。有些情况下使用Lambda会使代码的可读性急剧下降，并且也节省不了多少代码，\r\n所以在实际开发中还是需要仔细斟酌是否要使用Lambda。和Lambda相似的还有JDK10中加入的var类型推断，同样对于这个特性需要斟酌使用。\r\n\r\n<!-- ---------------------------------------------------Lambda表达式结束---------------------------------------------------- -->\r\n___\r\n<!-- ---------------------------------------------------接口默认方法-------------------------------------------------------- -->\r\n<span id=\"DefaultMethods\"></span>\r\n## 　　　　　　　　　　　　　JDK8接口规范\r\n### 在JDK8中引入了lambda表达式，出现了函数式接口的概念，为了在扩展接口时保持向前兼容性(JDK8之前扩展接口会使得实现了该接口的类必须实现添加的方法，否则会报错。为了保持兼容性而做出妥协的特性还有泛型，泛型也是为了保持兼容性而失去了在一些别的语言泛型拥有的功能)，Java接口规范发生了一些改变。\r\n### 1.JDK8以前的接口规范\r\n- JDK8以前接口可以定义的变量和方法\r\n   - 所有变量(Field)不论是否<i>显式</i> 的声明为```public static final```，它实际上都是```public static final```的。\r\n   - 所有方法(Method)不论是否<i>显示</i> 的声明为```public abstract```，它实际上都是```public abstract```的。\r\n```java\r\npublic interface AInterfaceBeforeJDK8 {\r\n    int FIELD = 0;\r\n    void simpleMethod();\r\n}\r\n```\r\n以上接口信息反编译以后可以看到字节码信息里Filed是public static final的，而方法是public abstract的，即是你没有显示的去声明它。\r\n```java\r\n{\r\n    public static final int FIELD;\r\n    descriptor: I\r\n    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL\r\n    ConstantValue: int 0\r\n\r\n  public abstract void simpleMethod();\r\n    descriptor: ()V\r\n    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT\r\n}\r\n```\r\n### 2.JDK8之后的接口规范\r\n- JDK8之后接口可以定义的变量和方法\r\n  - 变量(Field)仍然必须是 ```java public static final```的\r\n  - 方法(Method)除了可以是public abstract之外，还可以是public static或者是default(相当于仅public修饰的实例方法)的。\r\n从以上改变不难看出，修改接口的规范主要是为了能在扩展接口时保持向前兼容。\r\n<br>下面是一个JDK8之后的接口例子\r\n```java\r\npublic interface AInterfaceInJDK8 {\r\n    int simpleFiled = 0;\r\n    static int staticField = 1;\r\n\r\n    public static void main(String[] args) {\r\n    }\r\n    static void staticMethod(){}\r\n\r\n    default void defaultMethod(){}\r\n\r\n    void simpleMethod() throws IOException;\r\n\r\n}\r\n```\r\n进行反编译(去除了一些没用信息)\r\n```java\r\n{\r\n  public static final int simpleFiled;\r\n    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL\r\n\r\n  public static final int staticField;\r\n    flags: (0x0019) ACC_PUBLIC, ACC_STATIC, ACC_FINAL\r\n\r\n  public static void main(java.lang.String[]);\r\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\r\n    \r\n  public static void staticMethod();\r\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\r\n\r\n  public void defaultMethod();\r\n    flags: (0x0001) ACC_PUBLIC\r\n\r\n  public abstract void simpleMethod() throws java.io.IOException;\r\n    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT\r\n    Exceptions:\r\n      throws java.io.IOException\r\n}\r\n```\r\n可以看到 default关键字修饰的方法是像实例方法(就是普通类中定义的普通方法)一样定义的，所以我们来定义一个只有default方法的接口并且实现一下这个接口试一\r\n试。\r\n```java\r\ninterface Default {\r\n    default int defaultMethod() {\r\n        return 4396;\r\n    }\r\n}\r\n\r\npublic class DefaultMethod implements Default {\r\n    public static void main(String[] args) {\r\n        DefaultMethod defaultMethod = new DefaultMethod();\r\n        System.out.println(defaultMethod.defaultMethod());\r\n        //compile error : Non-static method \'defaultMethod()\' cannot be referenced from a static context\r\n        //! DefaultMethod.defaultMethod();\r\n    }\r\n}\r\n```\r\n可以看到default方法确实像实例方法一样，必须有实例对象才能调用，并且子类在实现接口时，可以不用实现default方法，也可以选择覆盖该方法。\r\n这有点像子类继承父类实例方法。\r\n<br>\r\n接口静态方法就像是类静态方法，唯一的区别是**接口静态方法只能通过接口名调用，而类静态方法既可以通过类名调用也可以通过实例调用**\r\n```java\r\ninterface Static {\r\n    static int staticMethod() {\r\n        return 4396;\r\n    }\r\n}\r\n ... main(String...args)\r\n    //!compile error: Static method may be invoked on containing interface class only\r\n    //!aInstanceOfStatic.staticMethod();\r\n ...\r\n```\r\n另一个问题是多继承问题，大家知道Java中类是不支持多继承的，但是接口是多继承和多实现(implements后跟多个接口)的，\r\n那么如果一个接口继承另一个接口，两个接口都有同名的default方法会怎么样呢？答案是会像类继承一样覆写(@Override)，以下代码在IDE中可以顺利编译\r\n```java\r\ninterface Default {\r\n    default int defaultMethod() {\r\n        return 4396;\r\n    }\r\n}\r\ninterface Default2 extends Default {\r\n    @Override\r\n    default int defaultMethod() {\r\n        return 9527;\r\n    }\r\n}\r\npublic class DefaultMethod implements Default,Default2 {\r\n    public static void main(String[] args) {\r\n        DefaultMethod defaultMethod = new DefaultMethod();\r\n        System.out.println(defaultMethod.defaultMethod());\r\n    }\r\n}\r\n\r\n输出 : 9527\r\n```\r\n出现上面的情况时，会优先找继承树上近的方法，类似于“短路优先”。\r\n<br>\r\n那么如果一个类实现了两个没有继承关系的接口，且这两个接口有同名方法的话会怎么样呢？IDE会要求你重写这个冲突的方法，让你自己选择去执行哪个方法，因为IDE它还没智能到你不告诉它，它就知道你想执行哪个方法。可以通过```java 接口名.super```指针来访问接口中定义的实例(default)方法。\r\n```java\r\ninterface Default {\r\n    default int defaultMethod() {\r\n        return 4396;\r\n    }\r\n}\r\n\r\ninterface Default2 {\r\n    default int defaultMethod() {\r\n        return 9527;\r\n    }\r\n}\r\n//如果不重写\r\n//compile error : defaults.DefaultMethod inherits unrelated defaults for defaultMethod() from types defaults.Default and defaults.Default2\r\npublic class DefaultMethod implements Default,Default2 {\r\n@Override\r\n    public int defaultMethod() {\r\n        System.out.println(Default.super.defaultMethod());\r\n        System.out.println(Default2.super.defaultMethod());\r\n        return 996;\r\n    }\r\n    public static void main(String[] args) {\r\n        DefaultMethod defaultMethod = new DefaultMethod();\r\n        System.out.println(defaultMethod.defaultMethod());\r\n    }\r\n}\r\n\r\n运行输出 : \r\n4396\r\n9527\r\n996\r\n```\r\n\r\n<!-- ---------------------------------------------------接口默认方法结束---------------------------------------------------- -->\r\n___\r\n<!-- --------------------------------------------------- 改进的类型推断 ---------------------------------------------------- -->\r\n<span id=\"ImprovedTypeInference\"></span>\r\n## 　　　　　　　　　　　　　改进的类型推断\r\n### 1.什么是类型推断\r\n类型推断就像它的字面意思一样，编译器根据<b><i>你显示声明的已知的信息</i></b> 推断出你没有显示声明的类型，这就是类型推断。\r\n看过《Java编程思想 第四版》的朋友可能还记得里面讲解泛型一章的时候，里面很多例子是下面这样的:\r\n```java\r\n  Map<String, Object> map = new Map<String, Object>();\r\n```\r\n而我们平常写的都是这样的:\r\n```java\r\n  Map<String, Object> map = new Map<>();\r\n```\r\n这就是类型推断，《Java编程思想 第四版》这本书出书的时候最新的JDK只有1.6(JDK7推出的类型推断)，在Java编程思想里Bruce Eckel大叔还提到过这个问题\r\n(可能JDK的官方人员看了Bruce Eckel大叔的Thinking in Java才加的类型推断，☺)，在JDK7中推出了上面这样的类型推断，可以减少一些无用的代码。\r\n(Java编程思想到现在还只有第四版，是不是因为Bruce Eckel大叔觉得Java新推出的语言特性“然并卵”呢？/滑稽)\r\n<br>\r\n在JDK7中，类型推断只有上面例子的那样的能力，即只有在使用**赋值语句**时才能自动推断出泛型参数信息(即<>里的信息)，下面的官方文档里的例子在JDK7里会编译\r\n错误\r\n```java\r\n  List<String> stringList = new ArrayList<>();\r\n  stringList.add(\"A\");\r\n  //error : addAll(java.util.Collection<? extends java.lang.String>)in List cannot be applied to (java.util.List<java.lang.Object>)\r\n  stringList.addAll(Arrays.asList());  \r\n```\r\n但是上面的代码在JDK8里可以通过，也就说，JDK8里，类型推断不仅可以用于赋值语句，而且可以根据代码中上下文里的信息推断出更多的信息，因此我们需要些的代码\r\n会更少。加强的类型推断还有一个就是用于Lambda表达式了。\r\n<br>\r\n大家其实不必细究类型推断，在日常使用中IDE会自动判断，当IDE自己无法推断出足够的信息时，就需要我们额外做一下工作，比如在<>里添加更多的类型信息，\r\n相信随着Java的进化，这些便利的功能会越来越强大。\r\n\r\n<!-- --------------------------------------------------- 改进的类型推断结束------------------------------------------------- -->\r\n____\r\n<!-- --------------------------------------------------- 反射获得方法参数信息------------------------------------------------- -->\r\n<span id=\"MethodParameterReflection\"></span>\r\n## 　　　　　　　　　　　　　通过反射获得方法的参数信息\r\nJDK8之前 .class文件是不会存储方法参数信息的，因此也就无法通过反射获取该信息(想想反射获取类信息的入口是什么？当然就是Class类了)。即是是在JDK11里\r\n也不会默认生成这些信息，可以通过在javac加上-parameters参数来让javac生成这些信息(javac就是java编译器，可以把java文件编译成.class文件)。生成额外\r\n的信息(运行时非必须信息)会消耗内存并且有可能公布敏感信息(某些方法参数比如password，JDK文档里这么说的)，并且确实很多信息javac并不会为我们生成，比如\r\nLocalVariableTable，javac就不会默认生成，需要你加上 -g:vars来强制让编译器生成，同样的，方法参数信息也需要加上\r\n-parameters来让javac为你在.class文件中生成这些信息，否则运行时反射是无法获取到这些信息的。在讲解Java语言层面的方法之前，先看一下javac加上该\r\n参数和不加生成的信息有什么区别(不感兴趣想直接看运行代码的可以跳过这段)。下面是随便写的一个类。\r\n```java\r\npublic class ByteCodeParameters {\r\n    public String simpleMethod(String canUGetMyName, Object yesICan) {\r\n        return \"9527\";\r\n    }\r\n}\r\n```\r\n先来不加参数编译和反编译一下这个类javac ByteCodeParameters.java , javap -v ByteCodeParameters:\r\n```java\r\n  //只截取了部分信息\r\n  public java.lang.String simpleMethod(java.lang.String, java.lang.Object);\r\n    descriptor: (Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/String;\r\n    flags: (0x0001) ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=3, args_size=3\r\n         0: ldc           #2                  // String 9527\r\n         2: areturn\r\n      LineNumberTable:\r\n        line 5: 0\r\n  //这个方法的描述到这里就结束了\r\n```\r\n接下来我们加上参数javac -parameters ByteCodeParameters.java 再来看反编译的信息:\r\n```java\r\n public java.lang.String simpleMethod(java.lang.String, java.lang.Object);\r\n    descriptor: (Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/String;\r\n    flags: (0x0001) ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=3, args_size=3\r\n         0: ldc           #2                  // String 9527\r\n         2: areturn\r\n      LineNumberTable:\r\n        line 8: 0\r\n    MethodParameters:\r\n      Name                           Flags\r\n      canUGetMyName\r\n      yesICan\r\n```\r\n可以看到.class文件里多了一个MethodParameters信息，这就是参数的名字，可以看到默认是不保存的。\r\n<br>下面看一下在Intelj Idea里运行的这个例子，我们试一下通过反射获取方法名 :\r\n```java\r\npublic class ByteCodeParameters {\r\n    public String simpleMethod(String canUGetMyName, Object yesICan) {\r\n        return \"9527\";\r\n    }\r\n\r\n    public static void main(String[] args) throws NoSuchMethodException {\r\n        Class<?> clazz = ByteCodeParameters.class;\r\n        Method simple = clazz.getDeclaredMethod(\"simpleMethod\", String.class, Object.class);\r\n        Parameter[] parameters = simple.getParameters();\r\n        for (Parameter p : parameters) {\r\n            System.out.println(p.getName());\r\n        }\r\n    }\r\n}\r\n输出 :\r\narg0\r\narg1\r\n```\r\n？？？说好的方法名呢？？？？别急，哈哈。前面说了，默认是不生成参数名信息的，因此我们需要做一些配置，我们找到IDEA的settings里的Java Compiler选项，在\r\nAdditional command line parameters:一行加上-parameters(Eclipse 也是找到Java Compiler选中Stoer information about method parameters)，或者自\r\n己编译一个.class文件放在IDEA的out下，然后再来运行 :\r\n```java\r\n输出 :\r\ncanUGetMyName\r\nyesICan\r\n```\r\n这样我们就通过反射获取到参数信息了。想要了解更多的同学可以自己研究一下 [官方文档]\r\n(https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html)\r\n<br>\r\n## 总结与补充\r\n在JDK8之后，可以通过-parameters参数来让编译器生成参数信息然后在运行时通过反射获取方法参数信息，其实在SpringFramework\r\n里面也有一个LocalVariableTableParameterNameDiscoverer对象可以获取方法参数名信息，有兴趣的同学可以自行百度(这个类在打印日志时可能会比较有用吧，个人感觉)。\r\n<!-- --------------------------------------------------- 反射获得方法参数信息结束------------------------------------------------- -->\r\n____\r\n<!-- --------------------------------------------------- JDK8流库------------------------------------------------------------- -->\r\n<span id=\"stream\"></span>\r\n\r\n<!-- --------------------------------------------------- JDK8流库结束------------------------------------------------- -->\r\n___\r\n', 0);
INSERT INTO `blog_course` VALUES (213, 'Java EE 基础知识', 2, '<!-- MarkdownTOC -->\r\n\r\n- [Servlet总结](#Servlet总结)\r\n- [阐述Servlet和CGI的区别?](#阐述Servlet和CGI的区别?)\r\n    - [CGI的不足之处:](#CGI的不足之处:)\r\n    - [Servlet的优点：](#Servlet的优点：)\r\n- [Servlet接口中有哪些方法及Servlet生命周期探秘](#Servlet接口中有哪些方法及Servlet生命周期探秘)\r\n- [get和post请求的区别](#get和post请求的区别)\r\n- [什么情况下调用doGet\\(\\)和doPost\\(\\)](#什么情况下调用doGet（）和doPost（）)\r\n- [转发（Forward）和重定向（Redirect）的区别](#转发（Forward）和重定向（Redirect）的区别)\r\n- [自动刷新\\(Refresh\\)](#自动刷新（Refresh）)\r\n- [Servlet与线程安全](#Servlet与线程安全)\r\n- [JSP和Servlet是什么关系](#JSP和Servlet是什么关系)\r\n- [JSP工作原理](#JSP工作原理)\r\n- [JSP有哪些内置对象、作用分别是什么](#JSP有哪些内置对象、作用分别是什么)\r\n- [Request对象的主要方法有哪些](#Request对象的主要方法有哪些)\r\n- [request.getAttribute\\(\\)和 request.getParameter\\(\\)有何区别](#request.getAttribute（）和 request.getParameter（）有何区别)\r\n- [include指令include的行为的区别](#include指令include的行为的区别)\r\n- [JSP九大内置对象，七大动作，三大指令](#JSP九大内置对象，七大动作，三大指令)\r\n- [讲解JSP中的四种作用域](#讲解JSP中的四种作用域)\r\n- [如何实现JSP或Servlet的单线程模式](#如何实现JSP或Servlet的单线程模式)\r\n- [实现会话跟踪的技术有哪些](#实现会话跟踪的技术有哪些)\r\n- [Cookie和Session的的区别](#Cookie和Session的的区别)\r\n\r\n<!-- /MarkdownTOC -->\r\n\r\n## Servlet总结\r\n\r\n在Java Web程序中，**Servlet**主要负责接收用户请求**HttpServletRequest**,在**doGet()**,**doPost()**中做相应的处理，并将回应**HttpServletResponse**反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用**init()方法**，销毁时调用**destroy()方法**。**Servlet需要在web.xml中配置**（MyEclipse中创建Servlet会自动配置），**一个Servlet可以设置多个URL访问**。**Servlet不是线程安全**，因此要谨慎使用类变量。\r\n\r\n## 阐述Servlet和CGI的区别?\r\n\r\n### CGI的不足之处:\r\n\r\n1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。\r\n\r\n2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销 \r\n\r\n3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。\r\n\r\n### Servlet的优点:\r\n\r\n1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销\r\n\r\n2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销\r\n\r\n3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。\r\n\r\n4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。\r\n\r\n补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。\r\n\r\n参考：《javaweb整合开发王者归来》P7\r\n\r\n## Servlet接口中有哪些方法及Servlet生命周期探秘\r\nServlet接口定义了5个方法，其中**前三个方法与Servlet生命周期相关**：\r\n\r\n- **void init(ServletConfig config) throws ServletException**\r\n- **void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException**\r\n- **void destory()**\r\n- java.lang.String getServletInfo()\r\n- ServletConfig getServletConfig()\r\n\r\n**生命周期：** **Web容器加载Servlet并将其实例化后，Servlet生命周期开始**，容器运行其**init()方法**进行Servlet的初始化；请求到达时调用Servlet的**service()方法**，service()方法会根据需要调用与请求对应的**doGet或doPost**等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的**destroy()方法**。**init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行**。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。\r\n\r\n参考：《javaweb整合开发王者归来》P81\r\n\r\n## get和post请求的区别\r\n\r\n> 网上也有文章说：get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：[https://www.cnblogs.com/logsharing/p/8448446.html](https://www.cnblogs.com/logsharing/p/8448446.html)，知乎对应的问题链接：[get和post区别？](https://www.zhihu.com/question/28586791)）！我下面给出的只是一种常见的答案。\r\n\r\n①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；\r\n\r\n②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用\"?\"连接，而各个变量之间使用\"&\"连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；\r\n\r\n③get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；\r\n\r\n④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；\r\n\r\n⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是\"%20\"。\r\n\r\n补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。\r\n\r\n还有另外一种回答。推荐大家看一下：\r\n\r\n- https://www.zhihu.com/question/28586791\r\n- https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd\r\n\r\n## 什么情况下调用doGet（）和doPost（）\r\nForm标签里的method的属性为get时调用doGet()，为post时调用doPost()。\r\n\r\n## 转发（Forward）和重定向（Redirect）的区别\r\n\r\n**转发是服务器行为，重定向是客户端行为。**\r\n\r\n**转发（Forword）**\r\n通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。\r\n```java\r\n     request.getRequestDispatcher(\"login_success.jsp\").forward(request, response);\r\n```\r\n**重定向（Redirect）**  是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 `HttpServletResponse` 的 `setStatus(int status)` 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。\r\n\r\n1. **从地址栏显示来说**\r\n\r\nforward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.\r\nredirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.\r\n\r\n2. **从数据共享来说**\r\n\r\nforward:转发页面和转发到的页面可以共享request里面的数据.\r\nredirect:不能共享数据.\r\n\r\n3. **从运用地方来说**\r\n\r\nforward:一般用于用户登陆的时候,根据角色转发到相应的模块.\r\nredirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等\r\n\r\n4. 从效率来说\r\n\r\nforward:高.\r\nredirect:低.\r\n\r\n## 自动刷新（Refresh）\r\n自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：\r\n```java\r\nResponse.setHeader(\"Refresh\",\"5;URL=http://localhost:8080/servlet/example.htm\");\r\n```\r\n其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次）\r\n\r\n\r\n## Servlet与线程安全\r\n**Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。** 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。\r\n注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。\r\n\r\n参考：《javaweb整合开发王者归来》P92\r\n\r\n\r\n\r\n## JSP和Servlet是什么关系\r\n其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。\r\n\r\n## JSP工作原理\r\nJSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。\r\n工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。\r\n.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。\r\n![JSP工作原理](https://user-gold-cdn.xitu.io/2018/3/31/1627bee073079a28?w=675&h=292&f=jpeg&s=133553)\r\n由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。\r\n\r\n开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。\r\n\r\n\r\n\r\n参考：《javaweb整合开发王者归来》P97\r\n\r\n## JSP有哪些内置对象、作用分别是什么\r\n[JSP内置对象 - CSDN博客 ](http://blog.csdn.net/qq_34337272/article/details/64310849 ) \r\n\r\nJSP有9个内置对象：\r\n- request：封装客户端的请求，其中包含来自GET或POST请求的参数；\r\n- response：封装服务器对客户端的响应；\r\n- pageContext：通过该对象可以获取其他对象；\r\n- session：封装用户会话的对象；\r\n- application：封装服务器运行环境的对象；\r\n- out：输出服务器响应的输出流对象；\r\n- config：Web应用的配置对象；\r\n- page：JSP页面本身（相当于Java程序中的this）；\r\n- exception：封装页面抛出异常的对象。\r\n\r\n\r\n## Request对象的主要方法有哪些\r\n- setAttribute(String name,Object)：设置名字为name的request 的参数值 \r\n- getAttribute(String name)：返回由name指定的属性值 \r\n- getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 \r\n- getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 \r\n- getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 \r\n- getHeader(String name) ：获得HTTP协议定义的文件头信息 \r\n- getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 \r\n- getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 \r\n- getInputStream() ：返回请求的输入流，用于获得请求中的数据 \r\n- getMethod() ：获得客户端向服务器端传送数据的方法 \r\n- getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 \r\n- getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 \r\n- getParameterValues(String name)：获得有name指定的参数的所有值 \r\n- getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 \r\n- getQueryString() ：获得查询字符串 \r\n- getRequestURI() ：获取发出请求字符串的客户端地址 \r\n- getRemoteAddr()：获取客户端的 IP 地址 \r\n- getRemoteHost() ：获取客户端的名字 \r\n- getSession([Boolean create]) ：返回和请求相关 Session \r\n- getServerName() ：获取服务器的名字 \r\n- getServletPath()：获取客户端所请求的脚本文件的路径 \r\n- getServerPort()：获取服务器的端口号 \r\n- removeAttribute(String name)：删除请求中的一个属性 \r\n\r\n## request.getAttribute（）和 request.getParameter（）有何区别\r\n**从获取方向来看：**\r\n\r\ngetParameter()是获取 POST/GET 传递的参数值；\r\n\r\ngetAttribute()是获取对象容器中的数据值；\r\n\r\n**从用途来看：**\r\n\r\ngetParameter用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。\r\n\r\ngetAttribute用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了\r\nmapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。\r\n\r\n另外，可以用 setAttribute,getAttribute 发送接收对象.而 getParameter 显然只能传字符串。\r\nsetAttribute 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。\r\n\r\n**总结：**\r\n\r\ngetParameter 返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）\r\n\r\ngetAttribute 返回的是Object，需进行转换,可用setAttribute 设置成任意对象，使用很灵活，可随时用\r\n\r\n## include指令include的行为的区别\r\n**include指令：** JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下： \r\n<%@ include file=\"文件相对 url 地址\" %>\r\n\r\ni**nclude动作：** <jsp:include>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：\r\n<jsp:include page=\"相对 URL 地址\" flush=\"true\" />\r\n\r\n## JSP九大内置对象，七大动作，三大指令\r\n[JSP九大内置对象，七大动作，三大指令总结](http://blog.csdn.net/qq_34337272/article/details/64310849)\r\n\r\n## 讲解JSP中的四种作用域\r\nJSP中的四种作用域包括page、request、session和application，具体来说：\r\n- **page**代表与一个页面相关的对象和属性。\r\n- **request**代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。\r\n- **session**代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。\r\n- **application**代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。\r\n\r\n\r\n\r\n## 如何实现JSP或Servlet的单线程模式\r\n对于JSP页面，可以通过page指令进行设置。\r\n<%@page isThreadSafe=”false”%>\r\n\r\n对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。\r\n\r\n说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。\r\n\r\n## 实现会话跟踪的技术有哪些\r\n1. **使用Cookie**\r\n\r\n向客户端发送Cookie\r\n```java\r\nCookie c =new Cookie(\"name\",\"value\"); //创建Cookie \r\nc.setMaxAge(60*60*24); //设置最大时效，此处设置的最大时效为一天\r\nresponse.addCookie(c); //把Cookie放入到HTTP响应中\r\n```\r\n从客户端读取Cookie\r\n```java\r\nString name =\"name\"; \r\nCookie[]cookies =request.getCookies(); \r\nif(cookies !=null){ \r\n   for(int i= 0;i<cookies.length;i++){ \r\n    Cookie cookie =cookies[i]; \r\n    if(name.equals(cookis.getName())) \r\n    //something is here. \r\n    //you can get the value \r\n    cookie.getValue(); \r\n       \r\n   }\r\n }\r\n\r\n```\r\n**优点:** 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value\r\n\r\n**缺点:** 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。\r\n\r\n2. URL 重写\r\n\r\n在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 \r\n\r\n**优点：** 在Cookie被禁用的时候依然可以使用\r\n\r\n**缺点：** 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。\r\n\r\n3.隐藏的表单域\r\n```html\r\n<input type=\"hidden\" name =\"session\" value=\"...\"/>\r\n```\r\n\r\n**优点：** Cookie被禁时可以使用\r\n\r\n**缺点：** 所有页面必须是表单提交之后的结果。\r\n\r\n4. HttpSession\r\n\r\n\r\n 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。\r\n## Cookie和Session的的区别\r\n\r\n1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。\r\n2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。\r\n3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。\r\n\r\n参考：\r\n\r\nhttps://www.zhihu.com/question/19786827/answer/28752144\r\n\r\n《javaweb整合开发王者归来》P158 Cookie和Session的比较\r\n', 0);
INSERT INTO `blog_course` VALUES (214, 'Redis 入门', 9, '# Redis入门\r\n***\r\n[TOC]\r\n\r\n主要介绍：\r\n\r\n1. NoSQL的概述\r\n2. Redis的概述\r\n3. Redis的安装和使用\r\n4. Jedis的入门\r\n5. Redis的数据类型\r\n6. Keys的特性\r\n7. Redis的特性\r\n8. Redis的持久化\r\n\r\n\r\n## 一、NoSQL概述\r\n什么是NoSQL？  \r\n>NoSQL(Not Only SQL)，是一种非关系型数据库。\r\n\r\n为什么需要使用NoSQL？\r\n>随着互联网的发展，互联网经历了1.0和2.0两个阶段。1.0指的就是类似于新浪，网易早期的时候，\r\n>我们只能打开浏览器去浏览里边的新闻，不能进行相应的互动。进入到Web2.0的时候，我们可以进行\r\n>之间的互动，就像你的朋友圈，你的新浪微博，都可以互动，我们可以进行评论，点赞等。随着Web2.0\r\n>的兴起，非关系型数据库已经成为了一个热门的新的领域。非关系型数据库的发展也是非常迅速的，关系型\r\n>数据库在处理Web2.0这种网站的时候，特别时超大规模的网站的时候，和一些高并发的SNS类型的Web2.0动态\r\n>类型的网站的时候，已经力不从心，暴露出很多问题，比如：\r\n>高并发读写问题、海量数据的高效率存储和访问、高可扩展性和高可用性等问题\r\n\r\nNoSQL相关产品    \r\n![](../images/redis/redis-nosql.png)    \r\n\r\nNoSQL数据库的四大分类    \r\n键值对（Key-Value）存储  （优点：快速查询。劣势：存储数据缺少结构化。例如：Redis）\r\n列储存  （优点：查询速度快，扩展性强。劣势：功能相对局限。例如：HBase）\r\n文档数据库  (优点：数据结构要求不是特别严格。劣势：查询性能不是特别的高,缺少统一查询语法。例如：mongoDB )\r\n图形数据库  (优点：利用图结构的算法。劣势：需要对整个图作计算才能得出结果，不容易做分布式的集群方案。例如：GridInfo)\r\n\r\n四类NoSQL数据库的比较  \r\n![](../images/redis/redis-nosql2.png)    \r\n\r\nNoSQL的特点  \r\n总的来说，NoSQL有如下特点  \r\n易扩展：去掉了关系型数据库中的关系，很容易扩展，数据只之间没有关系。  \r\n灵活的数据类型：无需事先定义字段。  \r\n大量数据，高性能：具有非常高的读写性能。  \r\n高可用：NoSQL可以在不影响性能的情况下就可以很方便的事先一些高可用的框架。  \r\n\r\n## 二、Redis概述\r\n### 2.1 Redis的由来\r\n2008年意大利的一家创业公司推出的一款基于MySql的网站时时的统计系统，然后没过多久，公司的创始人对MySql的性能感觉非常失望，\r\n于是为网站时时统计系统量身定做了一个数据库，与2009年开发完成。这个数据库就是Redis，不过创始人并不满足只将Redis用于这个\r\n产品，而是希望能有更多的人一起使用他，于是在同一年他将Redis开源，然后开始和另一名Redis的代码主要贡献者一起进行Redis的开发\r\n直到现在，创始人自己也没有想到在短短的几年时间，Redis就拥有了相当大的用户群体。之前在2012年在一个权威的网站上发布过一个\r\n调查的情况，全球约有12%在使用Redis，国内的如新浪、知乎等，国外如GitHub、stackoverflow等。\r\n\r\n### 2.2 什么是Redis\r\nRedis是用C语言开发的一个开源的高性能键值对的数据库，他通过提供多种键值的数据类型来适应不同场景下的存储需求，目前为止Redis\r\n支持的数据类型有很多种比如说字符串类型、列表类型、有序集合类型、散列类型、集合类型等。官方还提供了对Redis的测试数据，\r\n由50个并发程序来执行10万次请求，Redis读的速度每秒可以达到11万次，写的速度每秒能达到8万1千次，速度数据是相当惊人的。\r\n\r\n### 2.3 Redis的应用场景\r\n缓存  \r\n任务队列（秒杀，抢购）  \r\n网站访问统计  \r\n数据过期的处理（可以精确到毫秒）  \r\n应用排行榜  \r\n分布式的集群架构中的session分离  \r\n\r\n## 三、Redis安装与使用\r\n参考：https://redis.io/download\r\n### 3.1 Linux安装\r\n安装\r\n```shell\r\n# yum install gcc-c++  \r\n# wget http://download.redis.io/releases/redis-4.0.1.tar.gz  \r\n# cp redis-4.0.1.tar.gz /usr/loca/src/\r\n# tar -zxvf redis-4.0.1.tar.gz  \r\n# cd redis-4.0.1  \r\n# make  \r\n# make PREFIX=/usr/local/redis install\r\n```\r\n安装完成后  \r\n![](../images/redis/redis-bin.png)  \r\n\r\n复制redis.conf配置文件到安装目录  \r\n```shell\r\n# cp /usr/local/src/redis-4.0.1/redis.conf /usr/local/redis/\r\n```\r\n启动redis  \r\n```shell\r\n# cd /usr/local/redis/\r\n# ./redis-server\r\n```\r\n![](../images/redis/redis-server1.png)  \r\n\r\n上边的这中方式所有前端启动，关闭命令终端后就redis也就关闭了，下边我们需要修改redis.conf\r\n该为后端启动。  \r\n将daemonize no修改为daemonize yes  \r\n![](../images/redis/redis-conf.png)  \r\n\r\n使用后端启动，注意要指定加载的配置文件redis.conf,不然启动方式依然是前端启动。  \r\n```shell\r\n[root@ bin]# ./redis-server ../redis.conf  --启动redis服务\r\n7381:C 30 Jul 18:42:38.012 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\r\n7381:C 30 Jul 18:42:38.012 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=7381, just started\r\n7381:C 30 Jul 18:42:38.012 # Configuration loaded\r\n[root@ bin]# ps -ef | grep -i redis  --查看是否启动\r\nroot      7382     1  0 18:42 ?        00:00:00 ./redis-server 127.0.0.1:6379 （默认端口6379）\r\nroot      7403  6226  0 18:43 pts/0    00:00:00 grep --color=auto -i redis\r\n```\r\n停止redis\r\n```shell\r\n[root@ bin]# ./redis-cli shutdown\r\n[root@ bin]# ps -ef | grep -i redis\r\nroot      7964  6226  0 18:47 pts/0    00:00:00 grep --color=auto -i redis\r\n```\r\n简单使用redis\r\n```shell\r\n[root@ bin]# ./redis-server ../redis.conf \r\n8024:C 30 Jul 18:49:57.562 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\r\n8024:C 30 Jul 18:49:57.562 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=8024, just started\r\n8024:C 30 Jul 18:49:57.562 # Configuration loaded\r\n[root@ bin]# ./redis-cli \r\n127.0.0.1:6379> ping\r\nPONG\r\n127.0.0.1:6379> set name redis\r\nOK\r\n127.0.0.1:6379> get name\r\n\"redis\"\r\n127.0.0.1:6379> keys n*\r\n1) \"name\"\r\n127.0.0.1:6379> keys *\r\n1) \"name\"\r\n127.0.0.1:6379> del name\r\n(integer) 1\r\n127.0.0.1:6379> \r\n```\r\n### 3.2 Windows安装\r\nRedis官方是不支持Windows的，但是Microsoft Open Tech group 在 GitHub上开发了一个Win64的版本  \r\n地址是https://github.com/MicrosoftArchive/redis，在 Release 页面中，有 msi 安装文件以及 .zip 文件。    \r\n![](../images/redis/redis-windows1.png)      \r\n\r\n安装redis的msi安装文件  \r\n![](../images/redis/redis-windows2.png)  \r\n\r\n![](../images/redis/redis-windows3.png)  \r\n启动redis   \r\n```text \r\nredis-server.exe redis.windows.conf \r\n```\r\n但是问题又来了，关闭cmd窗口就会关闭Redis，难道服务器上要一直开着吗？这显然是不科学的，下面看怎么在服务器上部署。    \r\nredis部署  \r\n其实Redis是可以安装成windows服务的，开机自启动，命令如下：  \r\n```text\r\nredis-server --service-install redis.windows.conf\r\n```\r\n报错   \r\n```text\r\n[4600] 31 Jul 13:36:49.181 # HandleServiceCommands: system error caught. error code=1073, message = CreateService failed: unknown error\r\n```\r\n原因：系统服务中已经存在    \r\n解决办法：    \r\n先卸载服务再安装：    \r\n```text\r\nredis-server --service-uninstall\r\n```\r\n然后在：    \r\n```text\r\nredis-server --service-install redis.windows.conf  \r\n```\r\n安装完之后，就可看到Redis已经作为windows服务了   \r\n![](../images/redis/redis-windows4.png)        \r\n\r\n但是安装好之后，Redis并没有启动，启动命令如下：  \r\n```text\r\nredis-server --service-start\r\n```\r\nredis停止：  \r\n```text\r\nredis-server --service-stop\r\n```\r\n还可以安装多个实例  \r\n```text\r\nredis-server --service-install –service-name redisService1 –port 10001\r\nredis-server --service-start –service-name redisService1\r\nredis-server --service-install –service-name redisService2 –port 10002\r\nredis-server --service-start –service-name redisService2\r\nredis-server --service-install –service-name redisService3 –port 10003\r\nredis-server --service-start –service-name redisService3\r\n```\r\n卸载命令：  \r\n```text\r\nredis-server --service-uninstall\r\n```\r\n\r\n### 3.3 Redis 连接\r\n\r\n>由 youj 创建， 最后一次修改 2015-09-27\r\n\r\nRedis 连接命令主要是用于连接 redis 服务。\r\n\r\n**实例**\r\n\r\n以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：\r\n\r\n```\r\nredis 127.0.0.1:6379> AUTH \"password\"\r\nOK\r\nredis 127.0.0.1:6379> PING\r\nPONG\r\n```\r\n\r\n------\r\n\r\n**Redis 连接命令**\r\n\r\n下表列出了 redis 连接的基本命令：\r\n\r\n| 序号 | 命令及描述                                                   |\r\n| ---- | ------------------------------------------------------------ |\r\n| 1    | [AUTH password](https://www.w3cschool.cn/redis/connection-auth.html) 验证密码是否正确 |\r\n| 2    | [ECHO message](https://www.w3cschool.cn/redis/connection-echo.html) 打印字符串 |\r\n| 3    | [PING](https://www.w3cschool.cn/redis/connection-ping.html) 查看服务是否运行 |\r\n| 4    | [QUIT](https://www.w3cschool.cn/redis/connection-quit.html) 关闭当前连接 |\r\n| 5    | [SELECT index](https://www.w3cschool.cn/redis/connection-select.html) 切换到指定的数据库 |\r\n\r\n### 3.4 Redis 安全\r\n\r\n我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。\r\n\r\n**实例**\r\n\r\n我们可以通过以下命令查看是否设置了密码验证：\r\n\r\n```\r\n127.0.0.1:6379> CONFIG get requirepass\r\n1) \"requirepass\"\r\n2) \"\"\r\n\r\n```\r\n\r\n默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。\r\n\r\n你可以通过以下命令来修改该参数：\r\n\r\n```\r\n127.0.0.1:6379> CONFIG set requirepass \"w3cschool.cn\"\r\nOK\r\n127.0.0.1:6379> CONFIG get requirepass\r\n1) \"requirepass\"\r\n2) \"w3cschool.cn\"\r\n\r\n```\r\n\r\n设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。\r\n\r\n**语法**\r\n\r\n**AUTH** 命令基本语法格式如下：\r\n\r\n```\r\n127.0.0.1:6379> AUTH password\r\n\r\n```\r\n\r\n**实例**\r\n\r\n```\r\n127.0.0.1:6379> AUTH \"w3cschool.cn\"\r\nOK\r\n127.0.0.1:6379> SET mykey \"Test value\"\r\nOK\r\n127.0.0.1:6379> GET mykey\r\n\"Test value\"\r\n```\r\n\r\n## 四、Jedis入门\r\n\r\n- Jedis是Redis官方首选的Java客户端开发包,Redis的各种语言客户端列表，请参见[Redis Client](https://redis.io/clients)。  \r\n- [Jedis地址](https://github.com/xetorthio/jedis)\r\n\r\n使用Jedis依赖的Jar包,引入Maven依赖\r\n```xml\r\n<dependency>\r\n    <groupId>org.apache.commons</groupId>\r\n    <artifactId>commons-pool2</artifactId>\r\n    <version>2.4.2</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>redis.clients</groupId>\r\n    <artifactId>jedis</artifactId>\r\n    <version>2.9.0</version>\r\n    <type>jar</type>\r\n    <scope>compile</scope>\r\n</dependency>\r\n```\r\n\r\nJedisDemo.java Jedis简单使用测试\r\n```java\r\npackage personal.caojx;\r\n\r\nimport org.junit.Test;\r\nimport redis.clients.jedis.Jedis;\r\nimport redis.clients.jedis.JedisPool;\r\nimport redis.clients.jedis.JedisPoolConfig;\r\n\r\n/**\r\n * @ClassName: JedisDemo\r\n * @Description: Jedis的测试\r\n * @version: v1.0.0\r\n * @author: caojx\r\n * @date: 17-7-30 下午7:18\r\n */\r\npublic class JedisDemo {\r\n\r\n    /**\r\n     * 单实例的测试\r\n     */\r\n    @Test\r\n    public void jedisTest(){\r\n        //1.设置IP地址和端口\r\n        Jedis jedis = new Jedis(\"127.0.0.1\",6379);\r\n        //2.保存数据\r\n        jedis.set(\"name\", \"tom\");\r\n        //3.获取数据\r\n        String name = jedis.get(\"name\");\r\n        System.out.println(name);\r\n        //4.释放资源\r\n        jedis.close();\r\n    }\r\n\r\n    /**\r\n     * 连接池方式连接\r\n     * 注意Jedis对象并不是线程安全的，在多线程下使用同一个Jedis对象会出现并发问题。\r\n     * 为了避免每次使用Jedis对象时都需要重新构建，Jedis提供了JedisPool。\r\n     * JedisPool是基于Commons Pool 2实现的一个线程安全的连接池。\r\n     */\r\n    @Test\r\n    public void jedisPoolTest(){\r\n        //1.获取连接池对象\r\n        JedisPoolConfig config = new JedisPoolConfig();\r\n        //2.设置对大连接数\r\n        config.setMaxTotal(30);\r\n        //3.设置最大空闲连接数\r\n        config.setMaxIdle(10);\r\n        //4.获得连接池\r\n        JedisPool jedisPool = new JedisPool(config,\"127.0.0.1\",6379);\r\n\r\n        //5获取核心对象\r\n        Jedis jedis = null;\r\n        try{\r\n            //通过连接池获得连接\r\n            jedis = jedisPool.getResource();\r\n            //设置数据\r\n            jedis.set(\"name\",\"张三\");\r\n            //获取数据\r\n            String name = jedis.get(\"name\");\r\n            System.out.println(name);\r\n        }catch (Exception e){\r\n            e.printStackTrace();\r\n        }finally {\r\n            //6.释放资源\r\n            if(jedis!= null){\r\n                jedis.close();\r\n            }\r\n            if(jedisPool != null){\r\n                jedisPool.close();\r\n            }\r\n        }\r\n    }\r\n  }\r\n```\r\n\r\n## 五、Redis的数据结构\r\n- 字符串(String)\r\n- 字符串列表(list)\r\n- 有序字符串集合(sorted set)\r\n- 哈希(hash)\r\n- 字符串集合(set)\r\n\r\n### 5.1 存储String\r\n二进制安全的，存入和获取的数据相同  \r\nValue最多可以容纳的数据长度是512M  \r\n\r\n存储String常用命令\r\n- 赋值\r\n- 删除\r\n- 扩展命令\r\n- 取值\r\n\r\n```text\r\nset key value\r\n[root@ bin]# ./redis-cli \r\n127.0.0.1:6379> set name tom  --设置值set key value\r\nOK\r\n127.0.0.1:6379> get name --取值get key\r\n\"tom\"\r\n127.0.0.1:6379> getset company baidu --先取值在设置值，nil表示没有取到值\r\n(nil)\r\n127.0.0.1:6379> get company\r\n\"baidu\"\r\n127.0.0.1:6379> del company --删除值 del key\r\n(integer) 1\r\n127.0.0.1:6379> get company\r\n(nil)\r\n127.0.0.1:6379> incr num --数值的自增，如果这个值原来不存在，先初始化为0再加1，注意自增的值必须可以转成整形，不能转成整形的值是不能使用incr的\r\n(integer) 1\r\n127.0.0.1:6379> get num\r\n\"1\"\r\n127.0.0.1:6379> incr num\r\n\"2\"\r\n127.0.0.1:6379> set company baidu\r\nOK\r\n127.0.0.1:6379> incr company --company不能转成整形，所以不能自增\r\n(error) ERR value is not an integer or out of range\r\n127.0.0.1:6379> decr num --数值的自减，如果值原来不存在，先初始化为0再减1，注意自减的值必须可以转成整形，否则会报错\r\n(integer) 1\r\n127.0.0.1:6379> get num\r\n\"1\"\r\n127.0.0.1:6379> decr num2\r\n(integer) -1\r\n127.0.0.1:6379> get num2\r\n\"-1\"\r\n127.0.0.1:6379> incrby num 5 --指定自增值，指定自增5\r\n(integer) 6\r\n127.0.0.1:6379> incrby num3 5 --指定自增值，如果这个值原来不存在，初始化为0再增加指定值，注意这个值必须可以转化成整形\r\n(integer) 5\r\n127.0.0.1:6379> decrby num3 3 --指定自减值，如果这个值原来不存在，初始化为0再减少指定值，注意这个值必须可以转化成整形\r\n(integer) 2\r\n127.0.0.1:6379> decrby num4 3\r\n(integer) -3\r\n127.0.0.1:6379> append num4 5 --字符串追加\r\n(integer) 3\r\n127.0.0.1:6379> get num4\r\n\"-35\"\r\n127.0.0.1:6379> append num5 123\r\n(integer) 3\r\n127.0.0.1:6379> get num5\r\n\"123\"\r\n```\r\n### 5.2 存储Hash\r\nRedis中的hash可以看成具有String的key，String的value的map容器。这个容器非常是和存储值对象的信息，例如用户名、密码、年龄等。\r\n\r\n- 存储Hash常用命令\r\n  - 赋值\r\n  - 删除\r\n  - 取值\r\n  - 增加数字\r\n\r\n```text\r\n127.0.0.1:6379> hset myhash username jack --设置hash值，容器名为myhash，你可以将myhash当成一个map容器或集合\r\n(integer) 1\r\n127.0.0.1:6379> hset myhash age 18\r\n(integer) 1\r\n127.0.0.1:6379> hmset myhash2 username rose age 21--批量设置hash值\r\nOK\r\n127.0.0.1:6379> hget myhash username --获取hash值\r\n\"jack\"\r\n127.0.0.1:6379> hget myhash age\r\n\"18\"\r\n127.0.0.1:6379> hmget myhash2 username age --批量获取hash值\r\n1) \"rose\"\r\n2) \"21\"\r\n127.0.0.1:6379> hgetall myhash --或取所有的hash值\r\n1) \"username\"\r\n2) \"jack\"\r\n3) \"age\"\r\n4) \"18\"\r\n127.0.0.1:6379> hdel mysh2 username age --删除hash值，不存在返回长度0\r\n(integer) 0\r\n127.0.0.1:6379> hgetall myhash2\r\n1) \"username\"\r\n2) \"rose\"\r\n3) \"age\"\r\n4) \"21\"\r\n127.0.0.1:6379> hdel myhash2 username age\r\n(integer) 2\r\n127.0.0.1:6379> hmset myhash2 username rose age 21\r\nOK\r\n127.0.0.1:6379> hgetall myhash2\r\n1) \"username\"\r\n2) \"rose\"\r\n3) \"age\"\r\n4) \"21\"\r\n127.0.0.1:6379> del myhash2 --删除整个hash，即删除增个容器\r\n(integer) 1\r\n127.0.0.1:6379> hget myhash2 username\r\n(nil)\r\n127.0.0.1:6379> hget myhash age --hash值自增\r\n\"18\"\r\n127.0.0.1:6379> hincrby myhash age 5\r\n(integer) 23\r\n127.0.0.1:6379> hget myhash age\r\n\"23\"\r\n127.0.0.1:6379> hexists myhash username --判断hash中的某个属性是否存在，存在返回>1的值，不存在返回0\r\n(integer) 1\r\n127.0.0.1:6379> hexists myhash password\r\n(integer) 0\r\n127.0.0.1:6379> hgetall myhash\r\n1) \"username\"\r\n2) \"jack\"\r\n3) \"age\"\r\n4) \"23\"\r\n127.0.0.1:6379> hlen myhash --判断hash的大小\r\n(integer) 2\r\n127.0.0.1:6379> hkeys myhash --获取hash中的所有属性的key值\r\n1) \"username\"\r\n2) \"age\"\r\n127.0.0.1:6379> hvals myhash --获取hash中的所有属性的值\r\n1) \"jack\"\r\n2) \"23\"\r\n```\r\n\r\n### 5.3 存储list\r\n- ArrayList使用数组方式\r\n- LinkedList使用双向连接方式\r\n- 双向链表中增加数据\r\n- 双向俩链表中删除数据\r\n\r\n- 存储list的常用命令\r\n  - 两端添加\r\n  - 查看列表\r\n  - 两端弹出\r\n  - 获取列表元素个数\r\n```text\r\n127.0.0.1:6379> lpush mylist a b c --依次向左边插入元素 a b c\r\n(integer) 3\r\n127.0.0.1:6379> lpush mylist 1 2 3 --依次向左边插入元素 1 2 3\r\n(integer) 6\r\n127.0.0.1:6379> rpush mylist2 a b c --依次向右边插入元素 a b c\r\n(integer) 3\r\n127.0.0.1:6379> rpush mylist2 1 2 3 --依次向右边插入元素 1 2 3\r\n(integer) 6\r\n127.0.0.1:6379> lrange mylist 0 5 --查看list的中的元素lrange listKey start(开始索引0开始) stop(结束索引，如果是负数表示从最后开始取，-1表示最后一个元素，-2表示到数第二个，类推)\r\n1) \"3\"\r\n2) \"2\"\r\n3) \"1\"\r\n4) \"c\"\r\n5) \"b\"\r\n6) \"a\"\r\n127.0.0.1:6379> lrange mylist2 0 -1\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\n4) \"1\"\r\n5) \"2\"\r\n6) \"3\"\r\n127.0.0.1:6379> lrange mylist2 0 -2\r\n1) \"a\"\r\n2) \"b\"\r\n3) \"c\"\r\n4) \"1\"\r\n5) \"2\"\r\n127.0.0.1:6379> lpop mylist  --弹出mylist左边的元素\r\n\"3\"\r\n127.0.0.1:6379> lrange mylist 0 -1\r\n1) \"2\"\r\n2) \"1\"\r\n3) \"c\"\r\n4) \"b\"\r\n5) \"a\"\r\n127.0.0.1:6379> rpop mylist --弹出mylist右边的元素\r\n\"a\"\r\n127.0.0.1:6379> lrange mylist 0 -1\r\n1) \"2\"\r\n2) \"1\"\r\n3) \"c\"\r\n4) \"b\"\r\n127.0.0.1:6379> llen mylist --查看mylist的长度\r\n(integer) 4\r\n127.0.0.1:6379> lpushx mylist u --仅当mylist存在的时候，在左边插入元素u\r\n(integer) 5\r\n127.0.0.1:6379> lpushx mylist3 u --mylist不存在不会插入\r\n(integer) 0\r\n127.0.0.1:6379> rpushx mylist y --仅当mylist存在的时候，在右边插入元素y\r\n(integer) 6\r\n127.0.0.1:6379> lrange mylist 0 -1\r\n1) \"u\"\r\n2) \"2\"\r\n3) \"1\"\r\n4) \"c\"\r\n5) \"b\"\r\n6) \"y\"\r\n127.0.0.1:6379> lpush mylist3 1 2 3\r\n(integer) 3\r\n127.0.0.1:6379> lpush mylist3 1 2 3\r\n(integer) 6\r\n127.0.0.1:6379> lpush mylist3 1 2 3\r\n(integer) 9\r\n127.0.0.1:6379> lrange mylist3 0 -1\r\n1) \"3\"\r\n2) \"2\"\r\n3) \"1\"\r\n4) \"3\"\r\n5) \"2\"\r\n6) \"1\"\r\n7) \"3\"\r\n8) \"2\"\r\n9) \"1\"\r\n127.0.0.1:6379> lrem mylist3 2 3  --lrem key count value 从左向右便利key依次删除2个值为3的元素\r\n                                    如果：count > 0 从前往后删除count个值为value的元素\r\n                                    如果：count < 0 从后往前删除count个值为value的元素\r\n                                    如果: count = 0 删除所有值为value的元素\r\n127.0.0.1:6379> lrange mylist3 0 -1\r\n1) \"2\"\r\n2) \"1\"\r\n3) \"2\"\r\n4) \"1\"\r\n5) \"3\"\r\n6) \"2\"\r\n7) \"1\"\r\n127.0.0.1:6379> lrem mylist3 0 2  --删除所有等于2的元素\r\n(integer) 3\r\n127.0.0.1:6379> lrange mylist3 0 -1\r\n1) \"1\"\r\n2) \"1\"\r\n3) \"3\"\r\n4) \"1\"\r\n127.0.0.1:6379> lset mylist 3 mmm --在指定的索引为值插入元素\r\nOK\r\n127.0.0.1:6379> lrange mylist 0 -1\r\n1) \"u\"\r\n2) \"2\"\r\n3) \"1\"\r\n4) \"mmm\"\r\n5) \"b\"\r\n6) \"y\"\r\n127.0.0.1:6379> linsert mylist4 before b 11 --在指定的元素之前插入元素,即在第一个b之前插入11\r\n(integer) 7\r\n127.0.0.1:6379> linsert mylist4 after b 11 --在指定的元素之后插入元素，即在第一个b之后插入11\r\n(integer) 8\r\n127.0.0.1:6379> lrange mylist4 0 -1\r\n1) \"c\"\r\n2) \"11\"\r\n3) \"b\"\r\n4) \"11\"\r\n5) \"a\"\r\n6) \"c\"\r\n7) \"b\"\r\n8) \"a\"\r\n127.0.0.1:6379> lrange mylist5 0 -1\r\n1) \"3\"\r\n2) \"2\"\r\n3) \"1\"\r\n127.0.0.1:6379> lrange mylist6 0 -1\r\n1) \"c\"\r\n2) \"b\"\r\n3) \"a\"\r\n127.0.0.1:6379> rpoplpush mylist5 mylist6--rpoplpush source destination 将source中的元素弹出，push到destination中\r\n\"1\"\r\n127.0.0.1:6379> lrange mylist6 0 -1\r\n1) \"1\"\r\n2) \"c\"\r\n3) \"b\"\r\n4) \"a\"                 \r\n```\r\n\r\n### 5.4 存储Set\r\nRedis中可以将Set看成没有排序的字符集合，和List类型不同的是，Set集合中不允许出现重复的元素，\r\nSet中可以包含的最大元素数量是4294967295个\r\n\r\n- 存储Set的使用场景\r\n - 跟踪一些唯一性数据\r\n - 用于维护数据对象之间的关联关系\r\n\r\n- 存储Set的常用命令\r\n  - 添加/删除元素\r\n  - 获得集合中的元素\r\n  - 集合中的差集运算\r\n  - 集合中的交集运算\r\n  - 集合中的并集运算\r\n  - 扩展命令\r\n\r\n```text\r\n127.0.0.1:6379> sadd myset a b c  --set中添加元素\r\n(integer) 3\r\n127.0.0.1:6379> sadd myset a  --set中不能添加重复的元素\r\n(integer) 0\r\n127.0.0.1:6379> sadd myset 1 2 3\r\n(integer) 3\r\n127.0.0.1:6379> srem myset 1 2 --set中删除元素\r\n(integer) 2\r\n127.0.0.1:6379> smembers myset --查看set中的所有元素\r\n1) \"c\"\r\n2) \"b\"\r\n3) \"3\"\r\n4) \"a\"\r\n127.0.0.1:6379> scard myset --查看set的长度\r\n(integer) 4\r\n127.0.0.1:6379> sismember myset a --判断set中是否存在元素a，存在返回1，不存在返回0\r\n(integer) 1\r\n127.0.0.1:6379> sismember myset q\r\n(integer) 0\r\n127.0.0.1:6379> sadd mya1 a b c  \r\n(integer) 3\r\n127.0.0.1:6379> sadd myb1 a c 1 2\r\n(integer) 4\r\n127.0.0.1:6379> sdiff mya1 myb1 --set的差集运算，运算结果与key的顺序有关\r\n1) \"b\"\r\n127.0.0.1:6379> sdiff myb1 mya1\r\n1) \"1\"\r\n2) \"2\"\r\n127.0.0.1:6379> sadd mya2 a b c\r\n(integer) 3\r\n127.0.0.1:6379> sadd myb2 a c 1 2\r\n(integer) 4\r\n127.0.0.1:6379> sinter mya2 myb2 --set的交集运算\r\n1) \"c\"\r\n2) \"a\"\r\n127.0.0.1:6379> sadd mya3 a b c\r\n(integer) 3\r\n127.0.0.1:6379> sadd myb3 a c 1 2\r\n(integer) 4\r\n127.0.0.1:6379> sunion mya3 myb3 --set的并集运算，会去掉重复的元素\r\n1) \"a\"\r\n2) \"c\"\r\n3) \"b\"\r\n4) \"2\"\r\n5) \"1\"\r\n127.0.0.1:6379> srandmember myset --从set中随即取出一个元素\r\n\"c\"\r\n127.0.0.1:6379> sdiffstore my1 mya1 myb1 --将多个set集合的差值存放到my1集合上\r\n(integer) 1\r\n127.0.0.1:6379> smembers my1\r\n1) \"b\"\r\n127.0.0.1:6379> sinterstore my2 mya2 myb2 --将多个set集合的交集存放到my2集合上\r\n(integer) 2\r\n127.0.0.1:6379> smembers my2\r\n1) \"a\"\r\n2) \"c\"\r\n127.0.0.1:6379> sunion mya3 myb3\r\n1) \"a\"\r\n2) \"c\"\r\n3) \"b\"\r\n4) \"2\"\r\n5) \"1\"\r\n127.0.0.1:6379> sunionstore my3 mya3 myb3 --将多个set集合的并集存放到my3上\r\n(integer) 5\r\n127.0.0.1:6379> smembers my3\r\n1) \"a\"\r\n2) \"c\"\r\n3) \"b\"\r\n4) \"2\"\r\n5) \"1\" \r\n```\r\n\r\n### 5.5 存储Sorted-Set\r\n- Sorted-Set和Set的区别\r\n  1. Sorted-Set与Set很相似，都是存储字符串类型的集合，都不允许出现重复的元素在集合当中，\r\n  2. Sorted-Set与Set的区别就是Sorted-Set中的每个元素都会有一个分数与之关联，那么Redis\r\n    就会利用这个分数对Sorted-Set中的元素进行从小到大的排序，尽管Sorted-Set中的元素必须是\r\n    唯一的，但是分数是可以重复的。\r\n  3. Sorted-Set中的成员在集合中都是有序的\r\n\r\n- 使用场景\r\n  - 游戏的排名\r\n  - 微博的热门话题\r\n\r\n- 存储Sorted-Set常用命令\r\n  - 添加元素\r\n  - 获得元素\r\n  - 删除元素\r\n  - 范围查询\r\n  - 扩展命令\r\n```text\r\n127.0.0.1:6379> zadd mysort 70 zs 80 ls 90 ww --添加元素，每个元素需要与一个分数对应\r\n(integer) 3\r\n127.0.0.1:6379> zadd mysort 100 zs --zs的分数会覆盖成为100，但是元素智能存在一个，所以返回0\r\n(integer) 0\r\n127.0.0.1:6379> zadd mysort 60 tom\r\n(integer) 1\r\n127.0.0.1:6379> zscore mysort zs --查看zs的分数\r\n\"100\"\r\n127.0.0.1:6379> zcard mysort  --查看Sorted-Set的大小\r\n(integer) 4\r\n127.0.0.1:6379> zrem mysort tom ww --删除tom和ww\r\n(integer) 2\r\n127.0.0.1:6379> zcard mysort\r\n(integer) 2\r\n127.0.0.1:6379> zadd mysort 85 jack 95 rose\r\n(integer) 2\r\n127.0.0.1:6379> zrange mysort 0 -1 --通过索引查看某个范围的值，0表示开始，-1表示结尾\r\n1) \"ls\"\r\n2) \"jack\"\r\n3) \"rose\"\r\n4) \"zs\"\r\n127.0.0.1:6379> zrange mysort 0 -1 withscores --查看范围值同时显示分数，默认从小到大排序\r\n1) \"ls\"\r\n2) \"80\"\r\n3) \"jack\"\r\n4) \"85\"\r\n5) \"rose\"\r\n6) \"95\"\r\n7) \"zs\"\r\n8) \"100\"\r\n127.0.0.1:6379> zrevrange mysort 0 -1 withscores --从大到小排序\r\n1) \"zs\"\r\n2) \"100\"\r\n3) \"rose\"\r\n4) \"95\"\r\n5) \"jack\"\r\n6) \"85\"\r\n7) \"ls\"\r\n8) \"80\"\r\n127.0.0.1:6379> zremrangebyrank mysort 0 4 --按照范围进行删除\r\n(integer) 4\r\n127.0.0.1:6379> zadd mysort 80 zs 90 ls 100 ws\r\n(integer) 3\r\n127.0.0.1:6379> zremrangebyscore mysort 80 100 --按照分数范围排序\r\n(integer) 3\r\n127.0.0.1:6379> zrange mysort 0 -1\r\n(empty list or set)\r\n127.0.0.1:6379> zadd mysort 70 zs 80 li 90 ww\r\n(integer) 3\r\n127.0.0.1:6379> zrangebyscore mysort 0 100 withscores\r\n1) \"zs\"\r\n2) \"70\"\r\n3) \"li\"\r\n4) \"80\"\r\n5) \"ww\"\r\n6) \"90\"\r\n127.0.0.1:6379> zrangebyscore mysort 0 100 withscores limit 0 2 --查看某个分数在某个范围的元素，并指定查看个数\r\n1) \"zs\"\r\n2) \"70\"\r\n3) \"li\"\r\n4) \"80\"\r\n127.0.0.1:6379> zincrby mysort 3 li --某个元素的分数自增3\r\n\"83\"\r\n127.0.0.1:6379> zscore mysort li\r\n\"83\"\r\n127.0.0.1:6379> zcount mysort 80 90 --查看分数在某个范围内的个数\r\n(integer) 2\r\n```\r\n### 5.6 Redis HyperLogLog\r\n\r\n> 由 youj 创建， 最后一次修改 2015-09-29\r\n>\r\n> https://www.w3cschool.cn/redis/redis-hyperloglog.html\r\n\r\nRedis 在 2.8.9 版本添加了 HyperLogLog 结构。\r\n\r\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。\r\n\r\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\r\n\r\n但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\r\n\r\n**什么是基数?**\r\n\r\n比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。\r\n\r\n**实例**\r\n\r\n以下实例演示了 HyperLogLog 的工作过程：\r\n\r\n```\r\nredis 127.0.0.1:6379> PFADD w3ckey \"redis\"\r\n\r\n1) (integer) 1\r\n\r\nredis 127.0.0.1:6379> PFADD w3ckey \"mongodb\"\r\n\r\n1) (integer) 1\r\n\r\nredis 127.0.0.1:6379> PFADD w3ckey \"mysql\"\r\n\r\n1) (integer) 1\r\n\r\nredis 127.0.0.1:6379> PFCOUNT w3ckey\r\n\r\n(integer) 3\r\n\r\n```\r\n\r\n**Redis HyperLogLog 命令**\r\n\r\n下表列出了 redis HyperLogLog 的基本命令：\r\n\r\n| 序号 | 命令及描述                                                   |\r\n| ---- | ------------------------------------------------------------ |\r\n| 1    | [PFADD key element [element ...\\]](https://www.w3cschool.cn/redis/hyperloglog-pfadd.html) 添加指定元素到 HyperLogLog 中。 |\r\n| 2    | [PFCOUNT key [key ...\\]](https://www.w3cschool.cn/redis/hyperloglog-pfcount.html) 返回给定 HyperLogLog 的基数估算值。 |\r\n| 3    | [PFMERGE destkey sourcekey [sourcekey ...\\]](https://www.w3cschool.cn/redis/hyperloglog-pfmerge.html) 将多个 HyperLogLog 合并为一个 HyperLogLog |\r\n\r\n### 5.7 Redis 管道技术 \r\n\r\n> 由 youj 创建， 最后一次修改 2015-09-28\r\n>\r\n> https://www.w3cschool.cn/redis/redis-pipelining.html\r\n\r\nRedis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：\r\n\r\n- 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。\r\n- 服务端处理命令，并将结果返回给客户端。\r\n\r\nRedis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。\r\n\r\n**实例**\r\n\r\n查看 redis 管道，只需要启动 redis 实例并输入以下命令：\r\n\r\n```\r\n$(echo -en \"PING\\r\\n SET w3ckey redis\\r\\nGET w3ckey\\r\\nINCR visitor\\r\\nINCR visitor\\r\\nINCR visitor\\r\\n\"; sleep 10) | nc localhost 6379\r\n\r\n+PONG\r\n+OK\r\nredis\r\n:1\r\n:2\r\n:3\r\n```\r\n\r\n以上实例中我们通过使用 **PING** 命令查看redis服务是否可用， 之后我们们设置了 w3ckey 的值为 redis，然后我们获取 w3ckey 的值并使得 visitor 自增 3 次。\r\n\r\n在返回的结果中我们可以看到这些命令一次性向 redis 服务提交，并最终一次性读取所有服务端的响应\r\n\r\n**管道技术的优势**\r\n\r\n管道技术最显著的优势是提高了 redis 服务的性能。\r\n\r\n**一些测试数据**\r\n\r\n在下面的测试中，我们将使用Redis的Ruby客户端，支持管道技术特性，测试管道技术对速度的提升效果。\r\n\r\n```\r\nrequire \'rubygems\' \r\nrequire \'redis\'\r\ndef bench(descr) \r\nstart = Time.now \r\nyield \r\nputs \"#{descr} #{Time.now-start} seconds\" \r\nend\r\ndef without_pipelining \r\nr = Redis.new \r\n10000.times { \r\n  r.ping \r\n} \r\nend\r\ndef with_pipelining \r\nr = Redis.new \r\nr.pipelined { \r\n    10000.times { \r\n        r.ping \r\n   } \r\n} \r\nend\r\nbench(\"without pipelining\") { \r\n without_pipelining \r\n} \r\nbench(\"with pipelining\") { \r\n    with_pipelining \r\n}\r\n\r\n```\r\n\r\n从处于局域网中的Mac OS X系统上执行上面这个简单脚本的数据表明，开启了管道操作后，往返时延已经被改善得相当低了。\r\n\r\n```\r\nwithout pipelining 1.185238 seconds \r\nwith pipelining 0.250783 seconds\r\n\r\n```\r\n\r\n如你所见，开启管道后，我们的速度效率提升了5倍。\r\n\r\n**Java中使用管道技术实例**\r\n\r\n通过 pipeline 方式当有大批量的操作时候，我们可以节省很多原来浪费在网络延\r\n迟的时间，需要注意到是用 pipeline 方式打包命令发送，redis 必须在处理完所有命令前先缓\r\n存起所有命令的处理结果。打包的命令越多，缓存消耗内存也越多。所以并不是打包的命令\r\n越多越好。具体多少合适需要根据具体情况测试。\r\n\r\n```java\r\nimport org.jredis.JRedis;\r\nimport org.jredis.connector.ConnectionSpec;\r\nimport org.jredis.ri.alphazero.JRedisClient;\r\nimport org.jredis.ri.alphazero.JRedisPipelineService;\r\nimport org.jredis.ri.alphazero.connection.DefaultConnectionSpec;\r\n\r\npublic class TestPipeline {\r\n    public static void main(String[] args) {\r\n        long start = System.currentTimeMillis(); //采用 pipeline 方式发送指令 usePipeline();\r\n        long end = System.currentTimeMillis();\r\n        System.out.println(\"用 pipeline 方式耗时:\" + (end - start) + \"毫秒\");\r\n        start = System.currentTimeMillis();\r\n        //普通方式发送指令\r\n        withoutPipeline();\r\n        end = System.currentTimeMillis();\r\n        System.out.println(\"普通方式耗时:\" + (end - start) + \"毫秒\");\r\n    }\r\n\r\n    //采用 pipeline 方式发送指令\r\n    private static void usePipeline() {\r\n        try {\r\n            ConnectionSpec spec = DefaultConnectionSpec.newSpec(\r\n                    \"192.168.115.170\", 6379, 0, null);\r\n            JRedis jredis = new JRedisPipelineService(spec);\r\n            for (int i = 0; i < 100000; i++) {\r\n                jredis.incr(\"test2\");\r\n            }\r\n            jredis.quit();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n\r\n    //普通方式发送指令\r\n    private static void withoutPipeline() {\r\n        try {\r\n            JRedis jredis = new JRedisClient(\"192.168.115.170\", 6379);\r\n            for (int i = 0; i < 100000; i++) {\r\n                jredis.incr(\"test2\");\r\n            }\r\n            jredis.quit();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n执行结果如下:\r\n\r\n```text\r\n-- JREDIS -- INFO: Pipeline thread <response-handler> started.\r\n-- JREDIS -- INFO: Pipeline <org.jredis.ri.alphazero.connection.SynchPipelineConnection@1bf73fa>\r\nconnected\r\n用 pipeline 方式耗时:11531 毫秒\r\n-- JREDIS -- INFO: Pipeline <org.jredis.ri.alphazero.connection.SynchPipelineConnection@1bf73fa> disconnected\r\n-- JREDIS -- INFO: Pipeline thread <response-handler> stopped.\r\n普通方式耗时:15985 毫秒\r\n```\r\n\r\n\r\n所以用两种方式发送指令，耗时是不一样的，具体是否使用 pipeline 必须要基于大家手中的\r\n\r\n网络情况来决定，不能一切都按最新最好的技术来实施，因为它有可能不是最适合你的。\r\n\r\n## 六、Keys的通用操作\r\n\r\n```text\r\n127.0.0.1:6379> keys * --keys pattern 查看Redis中的key，可以使用通配符\r\n 1) \"myb2\"\r\n 2) \"mylist4\"\r\n 3) \"mya3\"\r\n 4) \"mylist5\"\r\n 5) \"mya2\"\r\n 6) \"my2\"\r\n.....\r\n 127.0.0.1:6379> del myb2 mylist4 mya3 --删除key\r\n (integer) 3\r\n 127.0.0.1:6379> exists myb2 --判断key是否存在，0表示不存在，1表示存在\r\n (integer) 0\r\n 127.0.0.1:6379> exists my2\r\n (integer) 1\r\n127.0.0.1:6379> get company\r\n\"baidu\"\r\n127.0.0.1:6379> rename company newcompany --对key进行重命名\r\nOK\r\n127.0.0.1:6379> get company\r\n(nil)\r\n127.0.0.1:6379> get newcompany\r\n\"baidu\"\r\n127.0.0.1:6379> expire newcompany 1000 --设置key值过期的时间，单位是s(秒)\r\n(integer) 1\r\n127.0.0.1:6379> ttl newcompany --查看key值剩余的过期时间\r\n(integer) 992\r\n127.0.0.1:6379> type newcompany --查看key的类型\r\nstring\r\n127.0.0.1:6379> type mylist\r\nlist\r\n127.0.0.1:6379> type myset\r\nset\r\n127.0.0.1:6379> type myhash\r\nhash\r\n127.0.0.1:6379> type mysort\r\nzset\r\n127.0.0.1:6379> flushall --清空所有的key\r\n```\r\n\r\n## 七、Redis的特性\r\n\r\n- 相关特性\r\n  - 多数据库\r\n\r\n  - 事物特性\r\n\r\n### 7.1 多数据库  \r\n\r\n  一个Redis实例，可以包含多个数据库，一个客户端可以指定连接Redis实例的那个数据库。  \r\n  一个Redis实例，最多可提供16个数据库，下标是0～15，客户端默认连接的是第0号数据库，可以通过select选择具体连接那个数据库。  \r\n\r\n```text\r\n127.0.0.1:6379> select 1 --1号数据库没有任何key\r\nOK\r\n127.0.0.1:6379[1]> keys * \r\n(empty list or set)\r\n127.0.0.1:6379[1]> select 0 --Redis默认连接0号数据库\r\nOK\r\n127.0.0.1:6379> keys *\r\n 1) \"name\"\r\n 2) \"newcompany\"\r\n 3) \"myb1\"\r\n 4) \"num\"\r\n....\r\n127.0.0.1:6379> move myset 1 --将key=myset移动到1号数据库\r\n(integer) 1\r\n127.0.0.1:6379> select 1\r\nOK\r\n127.0.0.1:6379[1]> keys *\r\n1) \"myset\"\r\n127.0.0.1:6379[1]> select 0\r\nOK\r\n127.0.0.1:6379> keys myset\r\n(empty list or set)\r\n```\r\n\r\n### 7.2 事物特性\r\n\r\nRedis和其他众多的数据库一样，Redis也提供了事物的操作，在Redis中可以使用multi、exec、discard三个命令\r\n来实现事物。Redis在事物中所有的命令都将顺序化，串行化执行，在事物进行期间，Redis不会为其他的客户端提供\r\n任何的服务，从而保证事物中的所有命令都被原子化执行。和关系型数据库相比，如果Redis总某个命令执行失败，后边\r\n的命令还会执行。其中multi相当与开启事物，在开启事物之后，没有提交之前，所有的操作都在这个事物中。exec相当\r\n于提交事物，discard相当与事物回滚。如果在事物开启之前，如果客户端和服务器之间出现通讯故障，被导致网络断开，\r\n那么他所执行的这些语句都将不会被提交。然而如果网络中断事件发生在执行exec之后的那么这个事物的所有命令都会被\r\n服务器执行。\r\n\r\nmulti命令：相当于开启事物，执行该命令后会将multi之后的所有命令存放到一个队列中，待执行exec后才会将队列中的执行到服务器中\r\nexec：提交事物，将队列中的命令执行到服务器中\r\ndiscard：事物回滚\r\n\r\n下边对三个命令进行演示，我们会开启两个命令窗口，都连接到0号数据库\r\n窗口1：\r\n```text\r\n127.0.0.1:6379> select 0\r\nOK\r\n127.0.0.1:6379> get num\r\n\"1\"\r\n127.0.0.1:6379> incr num\r\n(integer) 2\r\n127.0.0.1:6379> get num\r\n\"2\"\r\n```\r\n窗口2：\r\n```text\r\n127.0.0.1:6379> select 0\r\nOK\r\n127.0.0.1:6379> get num\r\n\"2\"\r\n```\r\n上边可以看到，两个窗口的数据是一致的，下边我们开启事物\r\n\r\n窗口1：\r\n```text\r\n127.0.0.1:6379> select 0\r\nOK\r\n127.0.0.1:6379> get num\r\n\"1\"\r\n127.0.0.1:6379> incr num\r\n(integer) 2\r\n127.0.0.1:6379> get num\r\n\"2\"\r\n127.0.0.1:6379> multi  --开启事物\r\nOK\r\n127.0.0.1:6379> incr num\r\nQUEUED\r\n```\r\n\r\n窗口2：\r\n```text\r\n127.0.0.1:6379> select 0\r\nOK\r\n127.0.0.1:6379> get num\r\n\"2\"\r\n127.0.0.1:6379> get num --由于事物没有提交，依然是2\r\n\"2\"\r\n```\r\n下边进行事物的提交\r\n窗口1：\r\n```text\r\n127.0.0.1:6379> select 0\r\nOK\r\n127.0.0.1:6379> get num\r\n\"1\"\r\n127.0.0.1:6379> incr num\r\n(integer) 2\r\n127.0.0.1:6379> get num\r\n\"2\"\r\n127.0.0.1:6379> multi  --开启事物\r\nOK\r\n127.0.0.1:6379> incr num\r\nQUEUED\r\n127.0.0.1:6379> exec --提交事物\r\n1) (integer) 3\r\n2) \"3\"\r\n\r\n```\r\n\r\n窗口2：\r\n```text\r\n127.0.0.1:6379> select 0\r\nOK\r\n127.0.0.1:6379> get num\r\n\"2\"\r\n127.0.0.1:6379> get num --由于事物没有提交，依然是2\r\n\"2\"\r\n127.0.0.1:6379> get num --事物提交后，结果变成了3\r\n\"3\"\r\n```\r\n\r\n事物的回滚演示\r\n```text\r\n127.0.0.1:6379> set user tom\r\nOK\r\n127.0.0.1:6379> get user\r\n\"tom\"\r\n127.0.0.1:6379> multi --开启事物\r\nOK\r\n127.0.0.1:6379> set user jerry\r\nQUEUED\r\n127.0.0.1:6379> discard --回滚事物\r\nOK\r\n127.0.0.1:6379> get user\r\n\"tom\"\r\n```\r\n\r\n## 八、Redis持久化\r\nRedis的高性能是由于他所有的数据都存放在内存中，那怎么能保证Redis在重启之后数据不丢失，那么就需要将数据\r\n从内存中同步到我们的硬盘上，那么这个过程我们将之称为持久化操作，Redis的持久化有两种方式。\r\n- RDB方式\r\n- AOF方式\r\n\r\n- 持久化使用方式\r\n  - RDB持久化，Redis默认使用的方式，即在指定的时间内，将内存中的数据或快照写入到硬盘的文件中。\r\n  - AOF持久化，这种机制将以日志的方式记录服务器处理的每一个操作，在Redis启动之初，他会读取该配置文件\r\n    然后重新构建我们的数据库，这个的话来保证我们数据库中的数据是完整的。\r\n  - 无持久话，我们可以通过配置来禁用Redis的持久化功能，这样我们就可以任务Redis就是一个缓存的功能\r\n  - 同时使用RDB和AOF来进行持久化\r\n\r\n### 8.1 RDB方式持久化\r\n优势：\r\n如果使用这种方式，那么整个Redis数据库将会只包含一个文件，那么这对于我们文件备份而言是非常完美的。比如说你可能每个小时\r\n归档一次最近24小时的数据，同时还要每天归档依次最近30天的数据，那么可以通过这样的策略，一旦系统出现灾难性的故障我们可以\r\n非常容易进行数据恢复，即优势如下。\r\n- 对于灾难的恢复对于我们而言是非常不错的选择，我们可以非常容易的将一个单独文件压缩后再将它转移到\r\n  其他的存储介质上。\r\n- 性能最大化，对于Redis的服务进程而言，在开始进行持久化的时候，唯一需要做的就是分岔出一些进程，之后再由子进程完成这些持久化的操作，\r\n  这样就可以极大的避免服务器进行IO的操作。\r\n- 相比AOF那种操作，如果数据集很大，RDB这种启动的效率会更高。\r\n  劣势：\r\n- 如果想要保证数据的高可用性，最大限度的避免数据丢失，那么RDB将不是一个很好的选择，因为系统一般会在数据库持久化时间之前出现一些宕机的情况，\r\n  这就会出现Redis还没有来的及往硬盘上写，数据就丢失了。\r\n- 由于RDB是通过Fork子进程的方式进行持久化，在数据量非常大的时候，可能会导致整个服务器停止几秒甚至几百毫秒情况\r\n\r\nredis.conf配置：\r\n```text\r\nsave 900 1  #   after 900 sec (15 min) if at least 1 key changed（每900秒即15分钟，至少由一个key发生改变往硬盘上写一次)\r\nsave 300 10 #   after 300 sec (5 min) if at least 10 keys changed(每300秒即5分钟，至少有10个key发生改变往硬盘上写一次）\r\nsave 60 10000 #   after 60 sec if at least 10000 keys changed（每60秒，至少由10000个key发生改变往硬盘上写一次）\r\n.....\r\n# The filename where to dump the DB\r\ndbfilename dump.rdb --数据库RDB备份文件名\r\n\r\n# The working directory.\r\n#\r\n# The DB will be written inside this directory, with the filename specified\r\n# above using the \'dbfilename\' configuration directive.\r\n# The Append Only File will also be created inside this directory.\r\n# Note that you must specify a directory here, not a file name.\r\ndir ./  --数据库RDB文件的存放路径，默认是当前目录\r\n```\r\n![](../images/redis/redis-dump.png)  \r\n\r\n### 8.2 AOF持久化机制\r\n优势：\r\n- 这种方式可以带来更安全的持久化机制，Redis中提供了三种同步策略(每秒同步、每修改同步、不同步)\r\n  每秒同步：事实上每秒同步也是异步完成的，但是他的效率也是非常高的，所差的是一旦系统出现宕机的现象，那么这一秒中之内修改的数据就会出现丢失。\r\n  每修改同步：我们可以将其视为同步持久化，每一次数据发生变化都会被立即记录到磁盘当中，当然这种效率比较底，但是他是最安全的。\r\n  不同步：不持久化\r\n\r\n- 由于这种机制对日志文件的写入操作采用的是append追加方式，所以即使出现宕机的情况也不会破坏日志文件里边原有的内容，然而如果我们只写入了\r\n  一半的数据就出现了系统崩溃问题，这种方式也不用当心，在Redis下一次启动之前我们可以通过redis -check -aof 这个工具来帮助我们解决数据一致性的问题\r\n\r\n- 如果日志过大，Redis可以启动自动重写机制，那么Redis以append这个模式，不断将修改的数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录\r\n  此期间来产生的那些修改命令被执行了，那么因此在进行重写切换的时候可以更好的取保证数据的安全性。\r\n\r\n- AOF包含一个格式清晰，易于理解的文件，用于记录所有的修改操作，我们可以通过这个文件来完成数据的重建工作。\r\n\r\n劣势：\r\n- 对于我们一个相同数量的数据集而言，AOF文件要比RDB的文件要大一些\r\n- 根据同步策略的不同，AOF在运行效率上往往会底与RDB\r\n\r\nredis.conf配置：\r\n```text\r\nappendonly no #aof这个方式默认是关闭的，如果需要打开则需要将no修改为yes\r\n\r\n# The name of the append only file (default: \"appendonly.aof\")\r\n\r\nappendfilename \"appendonly.aof\" #aof日志文件存放路径\r\n\r\nappendfsync always #同步策略，总是同步\r\n# appendfsync everysec\r\n# appendfsync no\r\n```\r\n\r\n重启Redis之后我们执行如下命令\r\n```text\r\n127.0.0.1:6379> set name jack\r\nOK\r\n127.0.0.1:6379> set num 10\r\nOK\r\n127.0.0.1:6379> set n1 10\r\nOK\r\n127.0.0.1:6379> set n2 10\r\nOK\r\n127.0.0.1:6379> keys *\r\n1) \"name\"\r\n2) \"n1\"\r\n3) \"num\"\r\n4) \"n2\"\r\n127.0.0.1:6379> flushall --清空所有的key\r\nOK\r\n127.0.0.1:6379> keys *\r\n(empty list or set)\r\n```\r\n\r\n关闭redis之后我们可以看到生成了appendonly.aof文件  \r\n![](../images/redis/redis-aof.png)  \r\n去掉appendonly.aof中最后一行,保存\r\n```text\r\nvim appendonly.aof\r\n\r\n$2\r\n10\r\n*1\r\n$8\r\nflushall --去掉该行\r\n```\r\n重启redis之后，可以看到redis中的所有数据都恢复了\r\n```text\r\n[caojx@ bin]$ sudo ./redis-server ../redis.conf \r\n[caojx@ bin]$ ./redis-cli\r\n127.0.0.1:6379> keys *\r\n1) \"name\"\r\n2) \"n2\"\r\n3) \"n1\"\r\n4) \"num\"\r\n```\r\n\r\n### 8.3 Redis 数据备份与恢复\r\n\r\n> 由 youj 创建， 最后一次修改 2015-09-19\r\n>\r\n> https://www.w3cschool.cn/redis/redis-backup.html\r\n\r\nRedis **SAVE** 命令用于创建当前数据库的备份。\r\n\r\n**语法**\r\n\r\nredis Save 命令基本语法如下：\r\n\r\n```\r\nredis 127.0.0.1:6379> SAVE \r\n\r\n```\r\n\r\n**实例**\r\n\r\n```\r\nredis 127.0.0.1:6379> SAVE \r\nOK\r\n\r\n```\r\n\r\n该命令将在 redis 安装目录中创建dump.rdb文件。\r\n\r\n**恢复数据**\r\nCONFIG\r\n```\r\nredis 127.0.0.1:6379> CONFIG GET dir\r\n1) \"dir\"\r\n2) \"/usr/local/redis/bin\"\r\n\r\n\r\n```\r\n\r\n以上命令 **CONFIG GET dir** 输出的 redis 安装目录为 /usr/local/redis/bin。\r\n\r\n------\r\n\r\n**Bgsave**\r\n\r\n创建 redis 备份文件也可以使用命令 **BGSAVE**，该命令在后台执行。\r\n\r\n**实例**\r\n\r\n```\r\n127.0.0.1:6379> BGSAVE\r\n\r\nBackground saving started\r\n```\r\n\r\n## 九、Redis发布订阅\r\n\r\n> 由 youj 创建，小路依依 最后一次修改 2015-09-16\r\n>\r\n> https://www.w3cschool.cn/redis/redis-pub-sub.html\r\n\r\nRedis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\r\n\r\nRedis 客户端可以订阅任意数量的频道。\r\n\r\n下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\r\n\r\n![](../images/redis/redis_subscribe_1.png)  \r\n\r\n当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\r\n\r\n![](../images/redis/redis_subscribe_2.png)  \r\n\r\n### 9.1 实例\r\n\r\n以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 **redisChat**:\r\n\r\n```Sh\r\nredis 127.0.0.1:6379> SUBSCRIBE redisChat\r\n\r\nReading messages... (press Ctrl-C to quit)\r\n1) \"subscribe\"\r\n2) \"redisChat\"\r\n3) (integer) 1\r\n```\r\n\r\n现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。\r\n\r\n```\r\nredis 127.0.0.1:6379> PUBLISH redisChat \"Redis is a great caching technique\"\r\n\r\n(integer) 1\r\n\r\nredis 127.0.0.1:6379> PUBLISH redisChat \"Learn redis by w3cschool.cn\"\r\n\r\n(integer) 1\r\n\r\n# 订阅者的客户端会显示如下消息\r\n1) \"message\"\r\n2) \"redisChat\"\r\n3) \"Redis is a great caching technique\"\r\n1) \"message\"\r\n2) \"redisChat\"\r\n3) \"Learn redis by w3cschool.cn\"\r\n```\r\n\r\n### 9.2 Redis 发布订阅命令\r\n\r\n下表列出了 redis 发布订阅常用命令：\r\n\r\n下表列出了 redis 发布订阅常用命令：\r\n\r\n| 序号 | 命令及描述                                                   |\r\n| ---- | ------------------------------------------------------------ |\r\n| 1    | [PSUBSCRIBE pattern [pattern ...\\]](https://www.w3cschool.cn/redis/pub-sub-psubscribe.html) 订阅一个或多个符合给定模式的频道。 |\r\n| 2    | [PUBSUB subcommand [argument [argument ...\\]]](https://www.w3cschool.cn/redis/pub-sub-pubsub.html) 查看订阅与发布系统状态。 |\r\n| 3    | [PUBLISH channel message](https://www.w3cschool.cn/redis/pub-sub-publish.html) 将信息发送到指定的频道。 |\r\n| 4    | [PUNSUBSCRIBE [pattern [pattern ...\\]]](https://www.w3cschool.cn/redis/pub-sub-punsubscribe.html) 退订所有给定模式的频道。 |\r\n| 5    | [SUBSCRIBE channel [channel ...\\]](https://www.w3cschool.cn/redis/pub-sub-subscribe.html) 订阅给定的一个或多个频道的信息。 |\r\n| 6    | [UNSUBSCRIBE [channel [channel ...\\]]](https://www.w3cschool.cn/redis/pub-sub-unsubscribe.html) 指退订给定的频道。 |\r\n\r\n## 十、Redis 服务器\r\n\r\n>由 youj 创建， 最后一次修改 2015-09-15\r\n>\r\n>https://www.w3cschool.cn/redis/redis-server.html\r\n\r\nRedis 服务器命令主要是用于管理 redis 服务。\r\n\r\n### 10.1 实例\r\n\r\n以下实例演示了如何获取 redis 服务器的统计信息：\r\n\r\n```\r\nredis 127.0.0.1:6379> INFO\r\n\r\n# Server\r\nredis_version:2.8.13\r\nredis_git_sha1:00000000\r\nredis_git_dirty:0\r\nredis_build_id:c2238b38b1edb0e2\r\nredis_mode:standalone\r\nos:Linux 3.5.0-48-generic x86_64\r\narch_bits:64\r\nmultiplexing_api:epoll\r\ngcc_version:4.7.2\r\nprocess_id:3856\r\nrun_id:0e61abd297771de3fe812a3c21027732ac9f41fe\r\ntcp_port:6379\r\nuptime_in_seconds:11554\r\nuptime_in_days:0\r\nhz:10\r\nlru_clock:16651447\r\nconfig_file:\r\n\r\n# Clients\r\nconnected_clients:1\r\nclient-longest_output_list:0\r\nclient-biggest_input_buf:0\r\nblocked_clients:0\r\n\r\n# Memory\r\nused_memory:589016\r\nused_memory_human:575.21K\r\nused_memory_rss:2461696\r\nused_memory_peak:667312\r\nused_memory_peak_human:651.67K\r\nused_memory_lua:33792\r\nmem_fragmentation_ratio:4.18\r\nmem_allocator:jemalloc-3.6.0\r\n\r\n# Persistence\r\nloading:0\r\nrdb_changes_since_last_save:3\r\nrdb_bgsave_in_progress:0\r\nrdb_last_save_time:1409158561\r\nrdb_last_bgsave_status:ok\r\nrdb_last_bgsave_time_sec:0\r\nrdb_current_bgsave_time_sec:-1\r\naof_enabled:0\r\naof_rewrite_in_progress:0\r\naof_rewrite_scheduled:0\r\naof_last_rewrite_time_sec:-1\r\naof_current_rewrite_time_sec:-1\r\naof_last_bgrewrite_status:ok\r\naof_last_write_status:ok\r\n\r\n# Stats\r\ntotal_connections_received:24\r\ntotal_commands_processed:294\r\ninstantaneous_ops_per_sec:0\r\nrejected_connections:0\r\nsync_full:0\r\nsync_partial_ok:0\r\nsync_partial_err:0\r\nexpired_keys:0\r\nevicted_keys:0\r\nkeyspace_hits:41\r\nkeyspace_misses:82\r\npubsub_channels:0\r\npubsub_patterns:0\r\nlatest_fork_usec:264\r\n\r\n# Replication\r\nrole:master\r\nconnected_slaves:0\r\nmaster_repl_offset:0\r\nrepl_backlog_active:0\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:0\r\nrepl_backlog_histlen:0\r\n\r\n# CPU\r\nused_cpu_sys:10.49\r\nused_cpu_user:4.96\r\nused_cpu_sys_children:0.00\r\nused_cpu_user_children:0.01\r\n\r\n# Keyspace\r\ndb0:keys=94,expires=1,avg_ttl=41638810\r\ndb1:keys=1,expires=0,avg_ttl=0\r\ndb3:keys=1,expires=0,avg_ttl=0\r\n\r\n```\r\n\r\n------\r\n\r\n### 10.2 Redis 服务器命令\r\n\r\n下表列出了 redis 服务器的相关命令:\r\n\r\n| 序号 | 命令及描述                                                   |\r\n| ---- | ------------------------------------------------------------ |\r\n| 1    | [BGREWRITEAOF](https://www.w3cschool.cn/redis/server-bgrewriteaof.html) 异步执行一个 AOF（AppendOnly File） 文件重写操作 |\r\n| 2    | [BGSAVE](https://www.w3cschool.cn/redis/server-bgsave.html) 在后台异步保存当前数据库的数据到磁盘 |\r\n| 3    | [CLIENT KILL [ip:port\\] [ID client-id]](https://www.w3cschool.cn/redis/server-client-kill.html) 关闭客户端连接 |\r\n| 4    | [CLIENT LIST](https://www.w3cschool.cn/redis/server-client-list.html) 获取连接到服务器的客户端连接列表 |\r\n| 5    | [CLIENT GETNAME](https://www.w3cschool.cn/redis/server-client-getname.html) 获取连接的名称 |\r\n| 6    | [CLIENT PAUSE timeout](https://www.w3cschool.cn/redis/server-client-pause.html) 在指定时间内终止运行来自客户端的命令 |\r\n| 7    | [CLIENT SETNAME connection-name](https://www.w3cschool.cn/redis/server-client-setname.html) 设置当前连接的名称 |\r\n| 8    | [CLUSTER SLOTS](https://www.w3cschool.cn/redis/server-cluster-slots.html) 获取集群节点的映射数组 |\r\n| 9    | [COMMAND](https://www.w3cschool.cn/redis/server-command.html) 获取 Redis 命令详情数组 |\r\n| 10   | [COMMAND COUNT](https://www.w3cschool.cn/redis/server-command-count.html) 获取 Redis 命令总数 |\r\n| 11   | [COMMAND GETKEYS](https://www.w3cschool.cn/redis/server-command-getkeys.html) 获取给定命令的所有键 |\r\n| 12   | [TIME](https://www.w3cschool.cn/redis/server-time.html) 返回当前服务器时间 |\r\n| 13   | [COMMAND INFO command-name [command-name ...\\]](https://www.w3cschool.cn/redis/server-command-info.html) 获取指定 Redis 命令描述的数组 |\r\n| 14   | [CONFIG GET parameter](https://www.w3cschool.cn/redis/server-config-get.html) 获取指定配置参数的值 |\r\n| 15   | [CONFIG REWRITE](https://www.w3cschool.cn/redis/server-config-rewrite.html) 对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写 |\r\n| 16   | [CONFIG SET parameter value](https://www.w3cschool.cn/redis/server-config-set.html) 修改 redis 配置参数，无需重启 |\r\n| 17   | [CONFIG RESETSTAT](https://www.w3cschool.cn/redis/server-config-resetstat.html) 重置 INFO 命令中的某些统计数据 |\r\n| 18   | [DBSIZE](https://www.w3cschool.cn/redis/server-dbsize.html) 返回当前数据库的 key 的数量 |\r\n| 19   | [DEBUG OBJECT key](https://www.w3cschool.cn/redis/server-debug-object.html) 获取 key 的调试信息 |\r\n| 20   | [DEBUG SEGFAULT](https://www.w3cschool.cn/redis/server-debug-segfault.html) 让 Redis 服务崩溃 |\r\n| 21   | [FLUSHALL](https://www.w3cschool.cn/redis/server-flushall.html) 删除所有数据库的所有key |\r\n| 22   | [FLUSHDB](https://www.w3cschool.cn/redis/server-flushdb.html) 删除当前数据库的所有key |\r\n| 23   | [INFO [section\\]](https://www.w3cschool.cn/redis/server-info.html) 获取 Redis 服务器的各种信息和统计数值 |\r\n| 24   | [LASTSAVE](https://www.w3cschool.cn/redis/server-lastsave.html) 返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示 |\r\n| 25   | [MONITOR](https://www.w3cschool.cn/redis/server-monitor.html) 实时打印出 Redis 服务器接收到的命令，调试用 |\r\n| 26   | [ROLE](https://www.w3cschool.cn/redis/server-role.html) 返回主从实例所属的角色 |\r\n| 27   | [SAVE](https://www.w3cschool.cn/redis/server-save.html) 异步保存数据到硬盘 |\r\n| 28   | [SHUTDOWN [NOSAVE\\] [SAVE]](https://www.w3cschool.cn/redis/server-shutdown.html) 异步保存数据到硬盘，并关闭服务器 |\r\n| 29   | [SLAVEOF host port](https://www.w3cschool.cn/redis/server-slaveof.html) 将当前服务器转变为指定服务器的从属服务器(slave server) |\r\n| 30   | [SLOWLOG subcommand [argument\\]](https://www.w3cschool.cn/redis/server-showlog.html) 管理 redis 的慢日志 |\r\n| 31   | [SYNC](https://www.w3cschool.cn/redis/server-sync.html) 用于复制功能(replication)的内部命令 |\r\n\r\n## 十一、Redis高可用\r\n\r\n参考：http://blog.csdn.net/hechurui/article/details/49508813\r\n\r\n​	    https://www.cnblogs.com/jager/p/6349860.html\r\n\r\n### 11.1 Redis 主从同步\r\n\r\n1. **原理**\r\n\r\n如果设置了一个从服务器，在连接时它发送了一个SYNC命令，不管它是第一次连接还是再次连接都没有关系。\r\n\r\n然后主服务器开始后台存储，并且开始缓存新连接进来的修改数据的命令。当后台存储完成后，主服务器把数据文件发送到从服务器，\r\n从服务器将其保存在磁盘上，然后加载到内存中。然后主服务器把刚才缓存的命令发送到从服务器。这是作为命令流来完成的，并且\r\n和Redis协议本身格式相同。\r\n\r\n你可以通过telnet自己尝试一下。在Redis服务器工作时连接到Redis端口，发送SYNC命令，会看到一个批量的传输，并且主服务器接收\r\n的每一个命令都会通过telnet会话重新发送一遍。\r\n\r\n当主从服务器之间的连接由于某些原因断开时，从服务器可以自动进行重连接。当有多个从服务器同时请求同步时，主服务器只进行一个后台存储。\r\n\r\n当连接断开又重新连上之后，一般都会进行一个完整的重新同步，但是从Redis2.8开始，只重新同步一部分也可以。\r\n\r\n2. **案例**\r\n\r\n> 电子商务网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”\r\n\r\n对于这种场景，我们可以使如下这种架构：\r\n\r\n![](../images/redis/redis_ha_1.png)  \r\n\r\n如图中所示，我们将一台Redis服务器作主库(Matser)，其他三台作为从库(Slave)，主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处：\r\n\r\n- 读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量，棒极了；\r\n- 数据被复制成了了好几份，就算有一台机器出现故障，也可以使用其他机器的数据快速恢复。\r\n\r\n需要注意的是：在Redis主从模式中，一台主库可以拥有多个从库，但是一个从库只能隶属于一个主库。\r\n\r\n2.**安装**\r\n\r\n````shell\r\n#mkdir /home/caojx/redis\r\n#mkdir /home/caojx/redis/redis_master 	   #创建reids安装目录\r\n#mkdir /home/caojx/redis/redis_master/conf #用来存放redis配置文件\r\n#mkdir /home/caojx/redis/redis_slave1\r\n#mkdir /home/caojx/redis/redis_slave1/conf\r\n#mkdir /home/caojx/redis/redis_slave2\r\n#mkdir /home/caojx/redis/redis_slave2/conf\r\n#mkdir /home/caojx/redis/redis_slave3\r\n#mkdir /home/caojx/redis/redis_slave3/conf\r\n#cd /home/caojx/redis\r\n#yum install yum install gcc-c++\r\n#wget http://download.redis.io/releases/redis-4.0.8.tar.gz\r\n#tar -zxvf redis-4.0.8.tar.gz\r\n#cd redis-4.0.8\r\n#make\r\n#make PREFIX=/home/caojx/redis/redis_master install #redis安装\r\n#make PREFIX=/home/caojx/redis/redis_slave1 install\r\n#make PREFIX=/home/caojx/redis/redis_slave2 install\r\n#make PREFIX=/home/caojx/redis/redis_slave3 install\r\n#cp /home/caojx/redis/redis-4.0.8/redis.conf /home/caojx/redis/redis_master/conf #将redis配置文件复制到对应的安装目录\r\n#cp /home/caojx/redis/redis-4.0.8/redis.conf /home/caojx/redis/redis_slave1/conf\r\n#cp /home/caojx/redis/redis-4.0.8/redis.conf /home/caojx/redis/redis_slave2/conf\r\n#cp /home/caojx/redis/redis-4.0.8/redis.conf /home/caojx/redis/redis_slave3/conf\r\n#cp /home/caojx/redis/redis-4.0.8/sentinel.conf /home/caojx/redis/redis_slave3/conf\r\n#cp /home/caojx/redis/redis-4.0.8/sentinel.conf /home/caojx/redis/redis_slave2/conf\r\n#cp /home/caojx/redis/redis-4.0.8/sentinel.conf /home/caojx/redis/redis_slave1/conf\r\n#cp /home/caojx/redis/redis-4.0.8/sentinel.conf /home/caojx/redis/redis_master/conf\r\n````\r\n\r\n3.**配置**\r\n\r\n主节点（master）:127.0.0.1:6376\r\n从节点（slave1）:127.0.0.1:6377\r\n从节点（slave2）:127.0.0.1:6378\r\n从节点（slave3）:127.0.0.1:6379\r\n\r\n在Redis中，要实现主从复制架构非常简单，只需要在从数据库的(redis.conf)配置文件中加上如下命令即可,主数据库不用配置：\r\n\r\n> 方式1：在从数据的redis.conf配置主数据库的ip/port\r\n\r\n```Shell\r\nslaveof 主数据库地址  主数据库端口\r\n```\r\n\r\n> 方式2：在启动从数据库的时候指定主数据库的ip/port\r\n\r\n```shell\r\n# ./redis-server --slaveof 主数据库地址 主数据库端口\r\n```\r\n\r\n**master的redis.conf配置**\r\n\r\n主数据库master的不需要要配置什么，这里主要配置一下端口和密码\r\n\r\n```shell\r\n#vim /home/caojx/redis/redis_master/conf/redis.conf\r\nport 6376 #设置主数据库的启动端口\r\nrequirepass 123456 #设置主数据库的密码\r\ndaemonize yes #支持后端启动\r\n```\r\n\r\n**slave1的redis.conf配置**\r\n\r\n```shell\r\nport 6377 #slave1的启动端口\r\nslaveof 127.0.0.1 6376 #主数据库的ip 主数据库的port\r\nmasterauth 123456 #主数据库的认证密码\r\nrequirepass 123456 #从数据库密码\r\ndaemonize yes #支持后端启动\r\n```\r\n\r\n**slave2的redis.conf配置**\r\n```shell\r\nport 6378\r\nslaveof 127.0.0.1 6376\r\nmasterauth 123456\r\nrequirepass 123456\r\ndaemonize yes\r\n```\r\n\r\n**slave3的redis.conf配置**\r\n```shell\r\nport 6379\r\nslaveof 127.0.0.1 6376\r\nmasterauth 123456\r\nrequirepass 123456\r\ndaemonize yes\r\n```\r\n\r\n注意： requirepass：是认证密码，应该之后要作主从切换，所以建议所有的密码都一致。masterauth是从机对主机验证时，所需的密码(即主机的requirepass)。\r\n\r\n4. **启动**\r\n\r\n```shell\r\n#启动master\r\n#cd /home/caojx/redis/redis_master/bin\r\n#./redis-server ../conf/redis.conf \r\n#启动slave1\r\n#cd /home/caojx/redis/redis_slave1/bin\r\n#./redis-server ../conf/redis.conf \r\n#启动slave2\r\n#cd /home/caojx/redis/redis_slave2/bin\r\n#./redis-server ../conf/redis.conf \r\n#启动slave3\r\n#cd /home/caojx/redis/redis_slave3/bin\r\n#./redis-server ../conf/redis.conf \r\n\r\n#ps -ef | grep -i redis #查看是否启动\r\ncaojx      5024      1  0 04:00 ?        00:00:00 ./redis-server 127.0.0.1:6376\r\ncaojx      5029      1  0 04:00 ?        00:00:00 ./redis-server 127.0.0.1:6377\r\ncaojx      5035      1  0 04:00 ?        00:00:00 ./redis-server 127.0.0.1:6378\r\ncaojx      5041      1  0 04:00 ?        00:00:00 ./redis-server 127.0.0.1:6379\r\n\r\n#连接master\r\n#/home/caojx/redis/redis_master/bin/redis-cli -p 6376\r\n127.0.0.1:6376> auth 123456\r\nOK\r\n127.0.0.1:6376> info replication\r\n# Replication #检查启动结果\r\nrole:master #显示未主数据库\r\nconnected_slaves:3\r\nslave0:ip=127.0.0.1,port=6377,state=online,offset=630,lag=0\r\nslave1:ip=127.0.0.1,port=6378,state=online,offset=630,lag=1\r\nslave2:ip=127.0.0.1,port=6379,state=online,offset=630,lag=0\r\nmaster_replid:164ccc098cc0a663b443d0ca4c81f44800380e5a\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:630\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:630\r\n127.0.0.1:6376> exit\r\n\r\n#连接slave1\r\n[caojx@localhost bin]$ /home/caojx/redis/redis_slave1/bin/redis-cli -p 6377\r\n127.0.0.1:6377> auth 123456\r\nOK\r\n127.0.0.1:6377> info replication\r\n# Replication\r\nrole:slave #现实为从数据库\r\nmaster_host:127.0.0.1\r\nmaster_port:6376\r\nmaster_link_status:up\r\nmaster_last_io_seconds_ago:2\r\nmaster_sync_in_progress:0\r\nslave_repl_offset:798\r\nslave_priority:100\r\nslave_read_only:1\r\nconnected_slaves:0\r\nmaster_replid:164ccc098cc0a663b443d0ca4c81f44800380e5a\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:798\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:798\r\n```\r\n\r\n5. **主从同步验证**\r\n\r\n我们在主数据库127.0.0.1:6376中设置值，查看是否会同步到从数据库中，如果同步则配置成功。\r\n\r\n```shell\r\n#连接主数据库，并设置test-sync的值为helloredis\r\n#/home/caojx/redis/redis_master/bin/redis-cli -p 6376\r\n127.0.0.1:6376> auth 123456\r\nOK\r\n127.0.0.1:6376> set test-sync helloredis\r\nOK\r\n127.0.0.1:6376> get test-sync\r\n\"helloredis\"\r\n127.0.0.1:6376> exit\r\n\r\n#测试slave1是否可以取得test-sync的值\r\n#/home/caojx/redis/redis_slave1/bin/redis-cli -p 6377\r\n127.0.0.1:6377> auth 123456\r\nOK\r\n127.0.0.1:6377> get test-sync\r\n\"helloredis\"\r\n127.0.0.1:6377> exit\r\n\r\n#测试slave2是否可以取得test-sync的值\r\n#/home/caojx/redis/redis_slave2/bin/redis-cli -p 6378\r\n127.0.0.1:6378> auth 123456\r\nOK\r\n127.0.0.1:6378> get test-sync\r\n\"helloredis\"\r\n127.0.0.1:6378> exit\r\n\r\n#测试slave3是否可以取得test-sync的值\r\n#/home/caojx/redis/redis_slave3/bin/redis-cli -p 6379\r\n127.0.0.1:6379> auth 123456\r\nOK\r\n127.0.0.1:6379> get test-sync\r\n\"helloredis\"\r\n\r\n#测试从数据库是否可写\r\n127.0.0.1:6379> set x y\r\n(error) READONLY You can\'t write against a read only slave.\r\n127.0.0.1:6379> \r\n```\r\n\r\n由上边的结果可以看到，数据确实从主库同步到了从库，但是从数据库不可写，主从复制，读写分离就实现了。\r\n\r\n可以在从库的配置文件中加上如下的配置项允许从库写数据：\r\n\r\n```shell\r\nslave-read-only no\r\n```\r\n\r\n但是，因为从库中修改的数据不会被同步到任何其他数据库，并且一旦主库修改了数据，从库的数据就会因为自动同步被覆盖，所以一般情况下，不建议将从库设置为可写。\r\n\r\n有至少同步给指定数量的数据库时，主数据库才是可写的：\r\n\r\n```shell\r\nmin-slaves-to-write 3\r\nmin-slave2-max-lag 10\r\n```\r\n\r\n第一个参数表示只有当3个或3个以上的从数据库连接到主库时，主数据库才是可写的，否则返回错误。\r\n第二个参数表示允许从数据库失去连接的最长时间，该选项默认是关闭的，在分布式系统中，打开并合理配置该选项可以降低主从架构因为网络分区导致的数据不一致问题。\r\n\r\n### 11.2 Redis 主从切换\r\n\r\n上边实现类主从同步，但是万一主机挂了怎么办，这是个麻烦事情，所以redis提供了一个sentinel（哨兵），以此来实现主从切换的功能，类似与zookeeper。\r\n\r\n1. **手动切换(不建议使用)**\r\n\r\nRedis的主从架构，如果没有设置哨兵，那么如果master出现故障，需要手动将slave切换成master继续服务。下面先说明如何进行手动切换：\r\n\r\n```shell\r\n#在新的master上执行：\r\nSLAVEOF NO ONE #从数据库还可以通过运行命令,来停止接受来自其他数据库的同步而升级成为主库。\r\n#在其他的slave上执行：\r\nSLAVEOF <新的masterip> <新的masterport>\r\n```\r\n\r\n原来的主redis恢复正常了，要重新切换回去。重新切回的步骤如下：\r\n\r\n```shell\r\n1 将现在的主redis的数据进行保存（save指令）\r\n2 将现在的主redis根目录下dump.rdb文件拷贝覆盖到原来主redis的根目录\r\n3 启动原来的主redis\r\n4 在现在的主redis中切换 SLAVEOF <旧的masterip> <旧的masterport>\r\n5 在其他的slave节点切换 SLAVEOF <旧的masterip> <旧的masterport>\r\n6 完毕\r\n```\r\n\r\n2. **自动切换（高可用方案）**\r\n\r\n手动的方式容易造成失误，容易导致数据丢失，而且如果主从节点很多，切换起来也很麻烦。自动切换一般通过设置哨兵实现。哨兵可以对master和slave进行监控，并在master出现故障的时候，能自动将slave切换成master。\r\n\r\n**Redis哨兵（Redis Sentinel）**的启动和redis实例的启动没有关系。所以可以在任何机器上启动redis哨兵。Redis Sentinel 是一个分布式系统，可以在整个redis主从架构中运行多个 Sentinel 进程（progress）。建议至少要保证有两个哨兵在运行，要不然物理机宕机后哨兵进程也不存在了，就无法进行主从切换。\r\n\r\n注意：主服务器判断为失效至少需要 2 个 Sentinel 同意\r\n\r\n3. **配置**\r\n\r\n我们这里有4台redis服务器（1主3从），我这里启动4个哨兵（至少启动2个哨兵）。每个哨兵的配置如下\r\n\r\n配置sentinel.conf文件\r\n\r\n```shell\r\n#vi /home/caojx/redis/redis_master/conf/sentinel.conf\r\n\r\n# 指名哨兵启动端口\r\nport 26376\r\n# 指明日志文件名\r\n#logfile \"/home/caojx/redis/log/sentinel_master_log.log\"\r\n# 是否支持后端启动\r\n#daemonize yes\r\n# 哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。\r\nsentinel monitor mymaster 127.0.0.1 6376 2#这个2代表，当集群中有2个sentinel认为master挂了时，才能真正认为该master已经不可用了 \r\n# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。\r\nsentinel down-after-milliseconds mymaster 5000\r\n# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。\r\nsentinel failover-timeout mymaster 18000\r\n# 设置master和slaves验证密码\r\nsentinel auth-pass mymaster 123456 \r\n# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步\r\nsentinel parallel-syncs mymaster 1\r\n\r\n#vi /home/caojx/redis/redis_slave1/conf/sentinel.conf\r\n\r\n# 指名哨兵启动端口\r\nport 26377\r\n# 指明日志文件名\r\n#logfile \"/home/caojx/redis/log/sentinel_slave1_log.log\"\r\n# 是否支持后端启动\r\n#daemonize yes\r\n# 哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。\r\nsentinel monitor mymaster 127.0.0.1 6376 2#这个2代表，当集群中有2个sentinel认为master挂了时，才能真正认为该master已经不可用了 \r\n# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。\r\nsentinel down-after-milliseconds mymaster 5000\r\n# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。\r\nsentinel failover-timeout mymaster 18000\r\n# 设置master和slaves验证密码\r\nsentinel auth-pass mymaster 123456 \r\n# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步\r\nsentinel parallel-syncs mymaster 1\r\n\r\n\r\n#vi /home/caojx/redis/redis_slave2/conf/sentinel.conf\r\n\r\n# 指名哨兵启动端口\r\nport 26378\r\n# 指明日志文件名\r\nlogfile \"/home/caojx/redis/log/sentinel_slave2_log.log\"\r\n# 哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。\r\nsentinel monitor mymaster 127.0.0.1 6376 2#这个2代表，当集群中有2个sentinel认为master挂了时，才能真正认为该master已经不可用了 \r\n# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。\r\nsentinel down-after-milliseconds mymaster 5000\r\n# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。\r\nsentinel failover-timeout mymaster 18000\r\n# 设置master和slaves验证密码\r\nsentinel auth-pass mymaster 123456 \r\n# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步\r\nsentinel parallel-syncs mymaster 1\r\n\r\n#vi /home/caojx/redis/redis_slave3/conf/sentinel.conf\r\n\r\n# 指名哨兵启动端口\r\nport 26379\r\n# 指明日志文件名\r\n#logfile \"/home/caojx/redis/log/sentinel_slave3_log.log\"\r\n# 是否支持后端启动\r\n#daemonize yes\r\n# 哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。\r\nsentinel monitor mymaster 127.0.0.1 6376 2#这个2代表，当集群中有2个sentinel认为master挂了时，才能真正认为该master已经不可用了 \r\n# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。\r\nsentinel down-after-milliseconds mymaster 5000\r\n# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。\r\nsentinel failover-timeout mymaster 18000\r\n# 设置master和slaves验证密码\r\nsentinel auth-pass mymaster 123456 \r\n# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步\r\nsentinel parallel-syncs mymaster 1\r\n```\r\n\r\n4. **启动sentinel**\r\n\r\n```shell\r\n#启动master\r\n#/home/caojx/redis/redis_master/bin/redis-server /home/caojx/redis/redis_master/conf/sentinel.conf --sentinel\r\n\r\n#/home/caojx/redis/redis_slave1/bin/redis-server /home/caojx/redis/redis_slave1/conf/sentinel.conf --sentinel\r\n\r\n#/home/caojx/redis/redis_slave2/bin/redis-server /home/caojx/redis/redis_slave2/conf/sentinel.conf --sentinel\r\n\r\n#/home/caojx/redis/redis_slave3/bin/redis-server /home/caojx/redis/redis_slave3/conf/sentinel.conf --sentinel\r\n\r\n#ps -ef | grep redis\r\ncaojx  1116  1  0 04:01 ?  00:00:02 /home/caojx/redis/redis_slave1/bin/redis-server 127.0.0.1:6377\r\ncaojx  1122  1  0 04:02 ?  00:00:02 /home/caojx/redis/redis_slave2/bin/redis-server 127.0.0.1:6378\r\ncaojx  1127  1  0 04:02 ?  00:00:02 /home/caojx/redis/redis_slave3/bin/redis-server 127.0.0.1:6379\r\ncaojx  1958  1  0 04:46 ?  00:00:00 ./redis-server 127.0.0.1:6376\r\n\r\ncaojx  1936  1068  0 04:44 pts/0 00:00:00 /home/caojx/redis/redis_master/bin/redis-server *:26376 [sentinel]\r\ncaojx  1940  1168  0 04:45 pts/1    00:00:00 ./redis-server *:26377 [sentinel]\r\ncaojx  1944  1200  0 04:45 pts/2    00:00:00 ./redis-server *:26378 [sentinel]\r\ncaojx  1949  1255  0 04:45 pts/4    00:00:00 ./redis-server *:26379 [sentinel]\r\n```\r\n\r\n5. **测试**\r\n\r\n杀死master（6376）看是否自动切换到其中的一台slave\r\n\r\n```shell\r\n#kill -9 1958\r\n#在setinel日志信息中可以看到如下信息，即master从6376切换到了6379\r\n1940:X 27 Feb 04:47:09.779 # +switch-master mymaster 127.0.0.1 6376 127.0.0.1 6379\r\n1940:X 27 Feb 04:47:09.779 * +slave slave 127.0.0.1:6378 127.0.0.1 6378 @ mymaster 127.0.0.1 6379\r\n#登录6379验证\r\n# ../../redis_slave3/bin/redis-cli -p 6379\r\n127.0.0.1:6379> auth 123456\r\nOK\r\n127.0.0.1:6379> info replication\r\n# Replication\r\nrole:master #现实6379变成了master,实现了自动切换\r\nconnected_slaves:2\r\nslave0:ip=127.0.0.1,port=6378,state=online,offset=31212,lag=0\r\nslave1:ip=127.0.0.1,port=6377,state=online,offset=31079,lag=1\r\nmaster_replid:edd3fa87e36e165ba811052fab54bf5c1797ecd9\r\nmaster_replid2:ce6109ff57ca0183044ee0e22d2a02a997320672\r\nmaster_repl_offset:31478\r\nsecond_repl_offset:9665\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:290\r\nrepl_backlog_histlen:31189\r\n```\r\n\r\n6. **其他**\r\n\r\n通过哨兵查看集群的信息：\r\n\r\n```shell\r\n#redis-cli -p 26379\r\nsentinel master mymaster//查看master的状态 \r\nSENTINEL slaves mymaster //查看salves的状态\r\nSENTINEL sentinels mymaster //查看哨兵的状态\r\nSENTINEL get-master-addr-by-name mymaster//获取当前master的地址\r\ninfo sentinel//查看哨兵信息\r\n```\r\n\r\n### 11.3 Jedis 代码测试 \r\n\r\n```java\r\npublic static void main(String[] args) {\r\n        Set<String> sentinels = new HashSet<String>();\r\n        sentinels.add(new HostAndPort(\"127.0.0.1\", 26376).toString());\r\n        sentinels.add(new HostAndPort(\"127.0.0.1\", 26377).toString());\r\n        sentinels.add(new HostAndPort(\"127.0.0.1\", 26378).toString());\r\n        sentinels.add(new HostAndPort(\"127.0.0.1\", 26379).toString());\r\n        JedisSentinelPool sentinelPool = new JedisSentinelPool(\"mymaster\", sentinels);\r\n\r\n        System.out.println(\"Current master: \" + sentinelPool.getCurrentHostMaster().toString());\r\n\r\n        Jedis master = sentinelPool.getResource();\r\n        //master.set(\"username\",\"jager\");\r\n\r\n        System.out.println(master.get(\"username\"));\r\n\r\n        sentinelPool.close();\r\n        sentinelPool.destroy();\r\n    }\r\n```\r\n\r\n## 参考文章\r\n\r\n- http://www.jianshu.com/p/7913f9984765\r\n- https://www.w3cschool.cn/redis/\r\n- http://blog.csdn.net/hechurui/article/details/49508813\r\n- https://www.cnblogs.com/jager/p/6349860.html\r\n', 0);
INSERT INTO `blog_course` VALUES (215, 'Redis 主从配置', 9, '# Redis主从配置\r\n\r\n[TOC]\r\n\r\n参考：http://blog.csdn.net/hechurui/article/details/49508813\r\n\r\n​	    https://www.cnblogs.com/jager/p/6349860.html\r\n\r\n## 1 Redis 主从同步\r\n\r\n1. **原理**\r\n\r\n如果设置了一个从服务器，在连接时它发送了一个SYNC命令，不管它是第一次连接还是再次连接都没有关系。\r\n\r\n然后主服务器开始后台存储，并且开始缓存新连接进来的修改数据的命令。当后台存储完成后，主服务器把数据文件发送到从服务器，\r\n从服务器将其保存在磁盘上，然后加载到内存中。然后主服务器把刚才缓存的命令发送到从服务器。这是作为命令流来完成的，并且\r\n和Redis协议本身格式相同。\r\n\r\n你可以通过telnet自己尝试一下。在Redis服务器工作时连接到Redis端口，发送SYNC命令，会看到一个批量的传输，并且主服务器接收\r\n的每一个命令都会通过telnet会话重新发送一遍。\r\n\r\n当主从服务器之间的连接由于某些原因断开时，从服务器可以自动进行重连接。当有多个从服务器同时请求同步时，主服务器只进行一个后台存储。\r\n\r\n当连接断开又重新连上之后，一般都会进行一个完整的重新同步，但是从Redis2.8开始，只重新同步一部分也可以。\r\n\r\n1. **案例**\r\n\r\n> 电子商务网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”\r\n\r\n对于这种场景，我们可以使如下这种架构：\r\n\r\n![](../images/redis/redis_ha_1.png)  \r\n\r\n如图中所示，我们将一台Redis服务器作主库(Matser)，其他三台作为从库(Slave)，主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处：\r\n\r\n- 读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量，棒极了；\r\n- 数据被复制成了了好几份，就算有一台机器出现故障，也可以使用其他机器的数据快速恢复。\r\n\r\n需要注意的是：在Redis主从模式中，一台主库可以拥有多个从库，但是一个从库只能隶属于一个主库。\r\n\r\n2.**安装**\r\n\r\n```shell\r\n#mkdir /home/caojx/redis\r\n#mkdir /home/caojx/redis/redis_master 	   #创建reids安装目录\r\n#mkdir /home/caojx/redis/redis_master/conf #用来存放redis配置文件\r\n#mkdir /home/caojx/redis/redis_slave1\r\n#mkdir /home/caojx/redis/redis_slave1/conf\r\n#mkdir /home/caojx/redis/redis_slave2\r\n#mkdir /home/caojx/redis/redis_slave2/conf\r\n#mkdir /home/caojx/redis/redis_slave3\r\n#mkdir /home/caojx/redis/redis_slave3/conf\r\n#cd /home/caojx/redis\r\n#yum install yum install gcc-c++\r\n#wget http://download.redis.io/releases/redis-4.0.8.tar.gz\r\n#tar -zxvf redis-4.0.8.tar.gz\r\n#cd redis-4.0.8\r\n#make\r\n#make PREFIX=/home/caojx/redis/redis_master install #redis安装\r\n#make PREFIX=/home/caojx/redis/redis_slave1 install\r\n#make PREFIX=/home/caojx/redis/redis_slave2 install\r\n#make PREFIX=/home/caojx/redis/redis_slave3 install\r\n#cp /home/caojx/redis/redis-4.0.8/redis.conf /home/caojx/redis/redis_master/conf #将redis配置文件复制到对应的安装目录\r\n#cp /home/caojx/redis/redis-4.0.8/redis.conf /home/caojx/redis/redis_slave1/conf\r\n#cp /home/caojx/redis/redis-4.0.8/redis.conf /home/caojx/redis/redis_slave2/conf\r\n#cp /home/caojx/redis/redis-4.0.8/redis.conf /home/caojx/redis/redis_slave3/conf\r\n#cp /home/caojx/redis/redis-4.0.8/sentinel.conf /home/caojx/redis/redis_slave3/conf\r\n#cp /home/caojx/redis/redis-4.0.8/sentinel.conf /home/caojx/redis/redis_slave2/conf\r\n#cp /home/caojx/redis/redis-4.0.8/sentinel.conf /home/caojx/redis/redis_slave1/conf\r\n#cp /home/caojx/redis/redis-4.0.8/sentinel.conf /home/caojx/redis/redis_master/conf\r\n```\r\n\r\n3.**配置**\r\n\r\n主节点（master）:127.0.0.1:6376\r\n从节点（slave1）:127.0.0.1:6377\r\n从节点（slave2）:127.0.0.1:6378\r\n从节点（slave3）:127.0.0.1:6379\r\n\r\n在Redis中，要实现主从复制架构非常简单，只需要在从数据库的(redis.conf)配置文件中加上如下命令即可,主数据库不用配置：\r\n\r\n> 方式1：在从数据的redis.conf配置主数据库的ip/port\r\n\r\n```shell\r\nslaveof 主数据库地址  主数据库端口\r\n```\r\n\r\n> 方式2：在启动从数据库的时候指定主数据库的ip/port\r\n\r\n```shell\r\n# ./redis-server --slaveof 主数据库地址 主数据库端口\r\n```\r\n\r\n**master的redis.conf配置**\r\n\r\n主数据库master的不需要要配置什么，这里主要配置一下端口和密码\r\n\r\n```shell\r\n#vim /home/caojx/redis/redis_master/conf/redis.conf\r\nport 6376 #设置主数据库的启动端口\r\nrequirepass 123456 #设置主数据库的密码\r\ndaemonize yes #支持后端启动\r\n```\r\n\r\n**slave1的redis.conf配置**\r\n\r\n```shell\r\nport 6377 #slave1的启动端口\r\nslaveof 127.0.0.1 6376 #主数据库的ip 主数据库的port\r\nmasterauth 123456 #主数据库的认证密码\r\nrequirepass 123456 #从数据库密码\r\ndaemonize yes #支持后端启动\r\n```\r\n\r\n**slave2的redis.conf配置**\r\n\r\n```shell\r\nport 6378\r\nslaveof 127.0.0.1 6376\r\nmasterauth 123456\r\nrequirepass 123456\r\ndaemonize yes\r\n```\r\n\r\n**slave3的redis.conf配置**\r\n\r\n```shell\r\nport 6379\r\nslaveof 127.0.0.1 6376\r\nmasterauth 123456\r\nrequirepass 123456\r\ndaemonize yes\r\n```\r\n\r\n注意： requirepass：是认证密码，应该之后要作主从切换，所以建议所有的密码都一致。masterauth是从机对主机验证时，所需的密码(即主机的requirepass)。\r\n\r\n1. **启动**\r\n\r\n```shell\r\n#启动master\r\n#cd /home/caojx/redis/redis_master/bin\r\n#./redis-server ../conf/redis.conf \r\n#启动slave1\r\n#cd /home/caojx/redis/redis_slave1/bin\r\n#./redis-server ../conf/redis.conf \r\n#启动slave2\r\n#cd /home/caojx/redis/redis_slave2/bin\r\n#./redis-server ../conf/redis.conf \r\n#启动slave3\r\n#cd /home/caojx/redis/redis_slave3/bin\r\n#./redis-server ../conf/redis.conf \r\n\r\n#ps -ef | grep -i redis #查看是否启动\r\ncaojx      5024      1  0 04:00 ?        00:00:00 ./redis-server 127.0.0.1:6376\r\ncaojx      5029      1  0 04:00 ?        00:00:00 ./redis-server 127.0.0.1:6377\r\ncaojx      5035      1  0 04:00 ?        00:00:00 ./redis-server 127.0.0.1:6378\r\ncaojx      5041      1  0 04:00 ?        00:00:00 ./redis-server 127.0.0.1:6379\r\n\r\n#连接master\r\n#/home/caojx/redis/redis_master/bin/redis-cli -p 6376\r\n127.0.0.1:6376> auth 123456\r\nOK\r\n127.0.0.1:6376> info replication\r\n# Replication #检查启动结果\r\nrole:master #显示未主数据库\r\nconnected_slaves:3\r\nslave0:ip=127.0.0.1,port=6377,state=online,offset=630,lag=0\r\nslave1:ip=127.0.0.1,port=6378,state=online,offset=630,lag=1\r\nslave2:ip=127.0.0.1,port=6379,state=online,offset=630,lag=0\r\nmaster_replid:164ccc098cc0a663b443d0ca4c81f44800380e5a\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:630\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:630\r\n127.0.0.1:6376> exit\r\n\r\n#连接slave1\r\n[caojx@localhost bin]$ /home/caojx/redis/redis_slave1/bin/redis-cli -p 6377\r\n127.0.0.1:6377> auth 123456\r\nOK\r\n127.0.0.1:6377> info replication\r\n# Replication\r\nrole:slave #现实为从数据库\r\nmaster_host:127.0.0.1\r\nmaster_port:6376\r\nmaster_link_status:up\r\nmaster_last_io_seconds_ago:2\r\nmaster_sync_in_progress:0\r\nslave_repl_offset:798\r\nslave_priority:100\r\nslave_read_only:1\r\nconnected_slaves:0\r\nmaster_replid:164ccc098cc0a663b443d0ca4c81f44800380e5a\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:798\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:798\r\n```\r\n\r\n1. **主从同步验证**\r\n\r\n我们在主数据库127.0.0.1:6376中设置值，查看是否会同步到从数据库中，如果同步则配置成功。\r\n\r\n```shell\r\n#连接主数据库，并设置test-sync的值为helloredis\r\n#/home/caojx/redis/redis_master/bin/redis-cli -p 6376\r\n127.0.0.1:6376> auth 123456\r\nOK\r\n127.0.0.1:6376> set test-sync helloredis\r\nOK\r\n127.0.0.1:6376> get test-sync\r\n\"helloredis\"\r\n127.0.0.1:6376> exit\r\n\r\n#测试slave1是否可以取得test-sync的值\r\n#/home/caojx/redis/redis_slave1/bin/redis-cli -p 6377\r\n127.0.0.1:6377> auth 123456\r\nOK\r\n127.0.0.1:6377> get test-sync\r\n\"helloredis\"\r\n127.0.0.1:6377> exit\r\n\r\n#测试slave2是否可以取得test-sync的值\r\n#/home/caojx/redis/redis_slave2/bin/redis-cli -p 6378\r\n127.0.0.1:6378> auth 123456\r\nOK\r\n127.0.0.1:6378> get test-sync\r\n\"helloredis\"\r\n127.0.0.1:6378> exit\r\n\r\n#测试slave3是否可以取得test-sync的值\r\n#/home/caojx/redis/redis_slave3/bin/redis-cli -p 6379\r\n127.0.0.1:6379> auth 123456\r\nOK\r\n127.0.0.1:6379> get test-sync\r\n\"helloredis\"\r\n\r\n#测试从数据库是否可写\r\n127.0.0.1:6379> set x y\r\n(error) READONLY You can\'t write against a read only slave.\r\n127.0.0.1:6379> \r\n```\r\n\r\n由上边的结果可以看到，数据确实从主库同步到了从库，但是从数据库不可写，主从复制，读写分离就实现了。\r\n\r\n可以在从库的配置文件中加上如下的配置项允许从库写数据：\r\n\r\n```shell\r\nslave-read-only no\r\n```\r\n\r\n但是，因为从库中修改的数据不会被同步到任何其他数据库，并且一旦主库修改了数据，从库的数据就会因为自动同步被覆盖，所以一般情况下，不建议将从库设置为可写。\r\n\r\n有至少同步给指定数量的数据库时，主数据库才是可写的：\r\n\r\n```shell\r\nmin-slaves-to-write 3\r\nmin-slave2-max-lag 10\r\n```\r\n\r\n第一个参数表示只有当3个或3个以上的从数据库连接到主库时，主数据库才是可写的，否则返回错误。\r\n第二个参数表示允许从数据库失去连接的最长时间，该选项默认是关闭的，在分布式系统中，打开并合理配置该选项可以降低主从架构因为网络分区导致的数据不一致问题。\r\n\r\n## 2 Redis 主从切换\r\n\r\n上边实现类主从同步，但是万一主机挂了怎么办，这是个麻烦事情，所以redis提供了一个sentinel（哨兵），以此来实现主从切换的功能，类似与zookeeper。\r\n\r\n1. **手动切换(不建议使用)**\r\n\r\nRedis的主从架构，如果没有设置哨兵，那么如果master出现故障，需要手动将slave切换成master继续服务。下面先说明如何进行手动切换：\r\n\r\n```shell\r\n#在新的master上执行：\r\nSLAVEOF NO ONE #从数据库还可以通过运行命令,来停止接受来自其他数据库的同步而升级成为主库。\r\n#在其他的slave上执行：\r\nSLAVEOF <新的masterip> <新的masterport>\r\n```\r\n\r\n原来的主redis恢复正常了，要重新切换回去。重新切回的步骤如下：\r\n\r\n```shell\r\n1 将现在的主redis的数据进行保存（save指令）\r\n2 将现在的主redis根目录下dump.rdb文件拷贝覆盖到原来主redis的根目录\r\n3 启动原来的主redis\r\n4 在现在的主redis中切换 SLAVEOF <旧的masterip> <旧的masterport>\r\n5 在其他的slave节点切换 SLAVEOF <旧的masterip> <旧的masterport>\r\n6 完毕\r\n```\r\n\r\n1. **自动切换（高可用方案）**\r\n\r\n手动的方式容易造成失误，容易导致数据丢失，而且如果主从节点很多，切换起来也很麻烦。自动切换一般通过设置哨兵实现。哨兵可以对master和slave进行监控，并在master出现故障的时候，能自动将slave切换成master。\r\n\r\n**Redis哨兵（Redis Sentinel）**的启动和redis实例的启动没有关系。所以可以在任何机器上启动redis哨兵。Redis Sentinel 是一个分布式系统，可以在整个redis主从架构中运行多个 Sentinel 进程（progress）。建议至少要保证有两个哨兵在运行，要不然物理机宕机后哨兵进程也不存在了，就无法进行主从切换。\r\n\r\n注意：主服务器判断为失效至少需要 2 个 Sentinel 同意\r\n\r\n1. **配置**\r\n\r\n我们这里有4台redis服务器（1主3从），我这里启动4个哨兵（至少2启动2个）。每个哨兵的配置如下\r\n\r\n配置sentinel.conf文件\r\n\r\n```shell\r\n#vi /home/caojx/redis/redis_master/conf/sentinel.conf\r\n\r\n# 指名哨兵启动端口\r\nport 26376\r\n# 指明日志文件名\r\n#logfile \"/home/caojx/redis/log/sentinel_master_log.log\"\r\n# 是否支持后端启动\r\n#daemonize yes\r\n# 哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。\r\nsentinel monitor mymaster 127.0.0.1 6376 2#这个2代表，当集群中有2个sentinel认为master挂了时，才能真正认为该master已经不可用了 \r\n# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。\r\nsentinel down-after-milliseconds mymaster 5000\r\n# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。\r\nsentinel failover-timeout mymaster 18000\r\n# 设置master和slaves验证密码\r\nsentinel auth-pass mymaster 123456 \r\n# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步\r\nsentinel parallel-syncs mymaster 1\r\n\r\n#vi /home/caojx/redis/redis_slave1/conf/sentinel.conf\r\n\r\n# 指名哨兵启动端口\r\nport 26377\r\n# 指明日志文件名\r\n#logfile \"/home/caojx/redis/log/sentinel_slave1_log.log\"\r\n# 是否支持后端启动\r\n#daemonize yes\r\n# 哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。\r\nsentinel monitor mymaster 127.0.0.1 6376 2#这个2代表，当集群中有2个sentinel认为master挂了时，才能真正认为该master已经不可用了 \r\n# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。\r\nsentinel down-after-milliseconds mymaster 5000\r\n# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。\r\nsentinel failover-timeout mymaster 18000\r\n# 设置master和slaves验证密码\r\nsentinel auth-pass mymaster 123456 \r\n# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步\r\nsentinel parallel-syncs mymaster 1\r\n\r\n\r\n#vi /home/caojx/redis/redis_slave2/conf/sentinel.conf\r\n\r\n# 指名哨兵启动端口\r\nport 26378\r\n# 指明日志文件名\r\nlogfile \"/home/caojx/redis/log/sentinel_slave2_log.log\"\r\n# 哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。\r\nsentinel monitor mymaster 127.0.0.1 6376 2#这个2代表，当集群中有2个sentinel认为master挂了时，才能真正认为该master已经不可用了 \r\n# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。\r\nsentinel down-after-milliseconds mymaster 5000\r\n# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。\r\nsentinel failover-timeout mymaster 18000\r\n# 设置master和slaves验证密码\r\nsentinel auth-pass mymaster 123456 \r\n# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步\r\nsentinel parallel-syncs mymaster 1\r\n\r\n#vi /home/caojx/redis/redis_slave3/conf/sentinel.conf\r\n\r\n# 指名哨兵启动端口\r\nport 26379\r\n# 指明日志文件名\r\n#logfile \"/home/caojx/redis/log/sentinel_slave3_log.log\"\r\n# 是否支持后端启动\r\n#daemonize yes\r\n# 哨兵监控的master，主从配置一样，这里只用输入redis主节点的ip/port和法定人数。\r\nsentinel monitor mymaster 127.0.0.1 6376 2#这个2代表，当集群中有2个sentinel认为master挂了时，才能真正认为该master已经不可用了 \r\n# master或slave多长时间（默认30秒）不能使用后标记为s_down状态。\r\nsentinel down-after-milliseconds mymaster 5000\r\n# 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败。\r\nsentinel failover-timeout mymaster 18000\r\n# 设置master和slaves验证密码\r\nsentinel auth-pass mymaster 123456 \r\n# 指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步\r\nsentinel parallel-syncs mymaster 1\r\n```\r\n\r\n1. **启动sentinel**\r\n\r\n```shell\r\n#启动master\r\n#/home/caojx/redis/redis_master/bin/redis-server /home/caojx/redis/redis_master/conf/sentinel.conf --sentinel\r\n\r\n#redis_slave1\r\n#/home/caojx/redis/redis_slave1/bin/redis-server /home/caojx/redis/redis_slave1/conf/sentinel.conf --sentinel\r\n\r\n#redis_slave2\r\n#/home/caojx/redis/redis_slave2/bin/redis-server /home/caojx/redis/redis_slave2/conf/sentinel.conf --sentinel\r\n\r\n#redis_slave3\r\n#/home/caojx/redis/redis_slave3/bin/redis-server /home/caojx/redis/redis_slave3/conf/sentinel.conf --sentinel\r\n\r\n#ps -ef | grep redis\r\ncaojx  1116  1  0 04:01 ?  00:00:02 /home/caojx/redis/redis_slave1/bin/redis-server 127.0.0.1:6377\r\ncaojx  1122  1  0 04:02 ?  00:00:02 /home/caojx/redis/redis_slave2/bin/redis-server 127.0.0.1:6378\r\ncaojx  1127  1  0 04:02 ?  00:00:02 /home/caojx/redis/redis_slave3/bin/redis-server 127.0.0.1:6379\r\ncaojx  1958  1  0 04:46 ?  00:00:00 ./redis-server 127.0.0.1:6376\r\n\r\ncaojx  1936  1068  0 04:44 pts/0 00:00:00 /home/caojx/redis/redis_master/bin/redis-server *:26376 [sentinel]\r\ncaojx  1940  1168  0 04:45 pts/1    00:00:00 ./redis-server *:26377 [sentinel]\r\ncaojx  1944  1200  0 04:45 pts/2    00:00:00 ./redis-server *:26378 [sentinel]\r\ncaojx  1949  1255  0 04:45 pts/4    00:00:00 ./redis-server *:26379 [sentinel]\r\n```\r\n\r\n1. **测试**\r\n\r\n杀死master（6376）看是否自动切换到其中的一台slave\r\n\r\n```shell\r\n#kill -9 1958\r\n#在setinel日志信息中可以看到如下信息，即master从6376切换到了6379\r\n1940:X 27 Feb 04:47:09.779 # +switch-master mymaster 127.0.0.1 6376 127.0.0.1 6379\r\n1940:X 27 Feb 04:47:09.779 * +slave slave 127.0.0.1:6378 127.0.0.1 6378 @ mymaster 127.0.0.1 6379\r\n#登录6379验证\r\n# ../../redis_slave3/bin/redis-cli -p 6379\r\n127.0.0.1:6379> auth 123456\r\nOK\r\n127.0.0.1:6379> info replication\r\n# Replication\r\nrole:master #现实6379变成了master,实现了自动切换\r\nconnected_slaves:2\r\nslave0:ip=127.0.0.1,port=6378,state=online,offset=31212,lag=0\r\nslave1:ip=127.0.0.1,port=6377,state=online,offset=31079,lag=1\r\nmaster_replid:edd3fa87e36e165ba811052fab54bf5c1797ecd9\r\nmaster_replid2:ce6109ff57ca0183044ee0e22d2a02a997320672\r\nmaster_repl_offset:31478\r\nsecond_repl_offset:9665\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:290\r\nrepl_backlog_histlen:31189\r\n```\r\n\r\n1. **其他**\r\n\r\n通过哨兵查看集群的信息：\r\n\r\n```shell\r\n#redis-cli -p 26379\r\nsentinel master mymaster//查看master的状态 \r\nSENTINEL slaves mymaster //查看salves的状态\r\nSENTINEL sentinels mymaster //查看哨兵的状态\r\nSENTINEL get-master-addr-by-name mymaster//获取当前master的地址\r\ninfo sentinel//查看哨兵信息\r\n```\r\n\r\n## 3 Jedis 代码测试\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n        Set<String> sentinels = new HashSet<String>();\r\n        sentinels.add(new HostAndPort(\"127.0.0.1\", 26376).toString());\r\n        sentinels.add(new HostAndPort(\"127.0.0.1\", 26377).toString());\r\n        sentinels.add(new HostAndPort(\"127.0.0.1\", 26378).toString());\r\n        sentinels.add(new HostAndPort(\"127.0.0.1\", 26379).toString());\r\n        JedisSentinelPool sentinelPool = new JedisSentinelPool(\"mymaster\", sentinels);\r\n\r\n        System.out.println(\"Current master: \" + sentinelPool.getCurrentHostMaster().toString());\r\n\r\n        Jedis master = sentinelPool.getResource();\r\n        //master.set(\"username\",\"jager\");\r\n\r\n        System.out.println(master.get(\"username\"));\r\n\r\n        sentinelPool.close();\r\n        sentinelPool.destroy();\r\n    }\r\n```\r\n\r\n## ', 0);
INSERT INTO `blog_course` VALUES (216, 'Redis 集群', 9, '\r\n\r\n# Redis 集群\r\n\r\n[TOC]\r\n\r\n# 一、Redis集群简介\r\n\r\n第一节原文来自：http://www.redis.cn/topics/cluster-tutorial.html\r\n\r\n本文档是Redis集群的一般介绍，没有涉及复杂难懂的分布式概念的赘述，只是提供了从用户角度来如何搭建测试以及使用的方法，如果你打算使用并深入了解Redis集群，推荐阅读完本章节后,仔细阅读 [Redis 集群规范](http://www.redis.cn/topics/cluster-spec.html) 一章。\r\n\r\n本教程试图提供最终用户一个简单的关于集群和一致性特征的描述\r\n\r\n请注意，本教程使用于Redis3.0（包括3.0）以上版本\r\n\r\n如果你计划部署集群，那么我们建议你从阅读这个文档开始。\r\n\r\n## 1.1 Redis 集群介绍\r\n\r\nRedis 集群是一个提供在**多个Redis间节点间共享数据**的程序集。\r\n\r\nRedis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.\r\n\r\nRedis 集群通过分区来提供**一定程度的可用性**,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:\r\n\r\n- 自动分割数据到不同的节点上。\r\n- 整个集群的部分节点失败或者不可达的情况下能够继续处理命令。\r\n\r\n## 1.2 Redis 集群的数据分片\r\n\r\nRedis 集群没有使用一致性hash, 而是引入了 **哈希槽**的概念.\r\n\r\nRedis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:\r\n\r\n- 节点 A 包含 0 到 5500号哈希槽.\r\n- 节点 B 包含5501 到 11000 号哈希槽.\r\n- 节点 C 包含11001 到 16384号哈希槽.\r\n\r\n这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.\r\n\r\n## 1.3 Redis 集群的主从复制模型\r\n\r\n为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.\r\n\r\n在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.\r\n\r\n然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了\r\n\r\n不过当B和B1 都失败后，集群是不可用的.\r\n\r\n## 1.4 Redis 一致性保证\r\n\r\nRedis 并不能保证数据的**强一致性**. 这意味这在实际中集群在特定的条件下可能会丢失写操作.\r\n\r\n第一个原因是因为集群是用了异步复制. 写操作过程:\r\n\r\n- 客户端向主节点B写入一条命令.\r\n- 主节点B向客户端回复命令状态.\r\n- 主节点将写操作复制给他得从节点 B1, B2 和 B3.\r\n\r\n主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。\r\n\r\n举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .\r\n\r\nZ1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.\r\n\r\n注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：\r\n\r\n# 二、Redis Cluster集群搭建\r\n\r\n原文：https://www.cnblogs.com/yingchen/p/6763524.html\r\n\r\n## 2.1 Redis Cluster 设计\r\n\r\n[Redis](http://lib.csdn.net/base/redis)集群搭建的方式有多种，例如使用zookeeper等，但从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。其redis-cluster[架构](http://lib.csdn.net/base/architecture)图如下：\r\n\r\n![](../images/redis/redis_cluster_1.jpeg)  \r\n\r\n其结构特点：\r\n\r\n1. 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。\r\n2. 节点的fail是通过集群中超过半数的节点检测失效时才生效。\r\n3. 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。\r\n4. redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node<->slot<->value。\r\n5. Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。\r\n\r\n\r\n\r\n##2.2 Redis Cluster 节点分配\r\n\r\n   现在我们是三个主节点分别是：A, B, C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是：\r\n​      节点A覆盖0－5460;\r\n​      节点B覆盖5461－10922;\r\n​      节点C覆盖10923－16383.\r\n\r\n**获取数据**：\r\n\r\n​      如果存入一个值，按照redis cluster哈希槽的[算法](http://lib.csdn.net/base/datastructure)： CRC16(\'key\')384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取\'key\'这个key时，也会这样的算法，然后内部跳转到B节点上获取数据 \r\n\r\n\r\n**新增一个主节点：**\r\n\r\n​      新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样：\r\n\r\n​    节点A覆盖1365-5460\r\n​    节点B覆盖6827-10922\r\n​    节点C覆盖12288-16383\r\n​    节点D覆盖0-1364,5461-6826,10923-12287\r\n​    同样删除一个节点也是类似，移动完成后就可以删除这个节点了。\r\n\r\n## 2.3 Redis Cluster 主从模式\r\n\r\n​	redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。\r\n\r\n​	上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。\r\n\r\n​     	所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。\r\n\r\n​     	B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。\r\n\r\n​	不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。\r\n\r\n## 2.4 Redis Cluster 集群的搭建\r\n\r\n要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。\r\n\r\n### 1. 安装Redis节点指定端口\r\n\r\n```shell\r\n#mkdir redis-cluster/\r\n#cd redis-cluster\r\n#cp redis-4.0.8.tar.gz ../redis-cluster/\r\n#ls\r\nredis-4.0.8.tar.gz\r\n\r\n#安装redis\r\n#mkdir -p redis01 redis02 redis03 redis04 redis05 redis06 #创建6个redis目录\r\n#tar -zxvf redis-4.0.8.tar.gz \r\n#make\r\n#make install PREFIX=/home/caojx/redis-cluster #安装redis\r\n\r\n#安装成功后将bin文件夹复制6份\r\n#cp -rf bin ../redis01/\r\n#cp -rf bin ../redis02/\r\n#cp -rf bin ../redis03/\r\n#cp -rf bin ../redis04/\r\n#cp -rf bin ../redis05/\r\n#cp -rf bin ../redis06/\r\n\r\n#安装成功后配置redis-cluster下的redis.conf文件\r\n\r\n#文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文#件的路径， 默认值为 nodes.conf节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动#进行更新。\r\n	port 7001 #端从7001到70006\r\n	cluster-enabled yes #开启集群\r\n	cluster-config-file nodes.conf\r\n	cluster-node-timeout 15000\r\n	appendonly yes\r\n	\r\n# 复制六份配置文件，修改对应的端口号\r\n#cp redis.conf ../redis01/\r\n#cp redis.conf ../redis02/\r\n#cp redis.conf ../redis03/\r\n#cp redis.conf ../redis04/\r\n#cp redis.conf ../redis05/\r\n#cp redis.conf ../redis06/\r\n```\r\n\r\n创建启动start.all脚本，启动6个redis实例\r\n\r\n```shell\r\n#vi start-all.sh\r\ncd /home/caojx/redis-cluster/redis01/bin\r\n./redis-server ../redis.conf \r\ncd /home/caojx/redis-cluster/redis02/bin\r\n./redis-server ../redis.conf \r\ncd /home/caojx/redis-cluster/redis03/bin\r\n./redis-server ../redis.conf \r\ncd /home/caojx/redis-cluster/redis04/bin\r\n./redis-server ../redis.conf \r\ncd /home/caojx/redis-cluster/redis05/bin\r\n./redis-server ../redis.conf \r\ncd /home/caojx/redis-cluster/redis06/bin\r\n./redis-server ../redis.conf \r\n\r\n#chmod +x start-all.sh\r\n#./start-all.sh\r\n#ps -ef | grep redis\r\n# ps -ef | grep redis\r\ncaojx     16663      1  0 23:22 ?        00:00:01 ./redis-server *:7001 [cluster]\r\ncaojx     16788      1  0 23:24 ?        00:00:01 ./redis-server *:7002 [cluster]\r\ncaojx     16904      1  0 23:25 ?        00:00:00 ./redis-server *:7003 [cluster]\r\ncaojx     17710      1  0 23:41 ?        00:00:00 ./redis-server *:7004 [cluster]\r\ncaojx     17715      1  0 23:41 ?        00:00:00 ./redis-server *:7005 [cluster]\r\ncaojx     17720      1  0 23:41 ?        00:00:00 ./redis-server *:7006 [cluster]\r\ncaojx     17741   1117  0 23:41 pts/0    00:00:00 grep --color=auto redis\r\n```\r\n\r\n### 2. 搭建集群\r\n\r\n现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。\r\n\r\n通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。\r\n\r\n1. **安装redis-trib所需的 ruby脚本**\r\n  ​\r\n\r\n  ```shell\r\n  #复制redis解压文件src下的redis-trib.rb文件到redis-cluster目录\r\n  #cp ~/redis-cluster/redis-4.0.8/src/redis-trib.rb ../\r\n\r\n  # 安装ruby环境\r\n  #yum install ruby  \r\n  #yum install rubygems  \r\n\r\n  #安装redis-trib.rb运行依赖的ruby的包redis\r\n  #gem install redis\r\n  ```\r\n\r\n  如果gem install redis 安装出错可以参考 https://www.cnblogs.com/carryping/p/7447823.html，升级redis版本，再运行gem install redis \r\n\r\n2. **启动集群**\r\n\r\n\r\n注意，启动集群前需要先启动6个redis实例，运行start-all.sh即可\r\n\r\n```shell\r\n./redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 \r\n```\r\n\r\n这个命令在这里用于创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。\r\n\r\n之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：\r\n\r\n```shell\r\n[caojx@localhost redis-cluster]$ ./redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006\r\n>>> Creating cluster\r\n>>> Performing hash slots allocation on 6 nodes...\r\nUsing 3 masters:\r\n127.0.0.1:7001\r\n127.0.0.1:7002\r\n127.0.0.1:7003\r\nAdding replica 127.0.0.1:7005 to 127.0.0.1:7001\r\nAdding replica 127.0.0.1:7006 to 127.0.0.1:7002\r\nAdding replica 127.0.0.1:7004 to 127.0.0.1:7003\r\n>>> Trying to optimize slaves allocation for anti-affinity\r\n[WARNING] Some slaves are in the same host as their master\r\nM: c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea 127.0.0.1:7001\r\n   slots:0-5460 (5461 slots) master\r\nM: 19615b40d6494564a729caa3b0c0995391df4ec3 127.0.0.1:7002\r\n   slots:5461-10922 (5462 slots) master\r\nM: 53626c1c77f210e57ac7c20181a689350a828d2a 127.0.0.1:7003\r\n   slots:10923-16383 (5461 slots) master\r\nS: d16f3f8adbdb809eb6871f49a0233bceef12118f 127.0.0.1:7004\r\n   replicates 19615b40d6494564a729caa3b0c0995391df4ec3\r\nS: 8526763d0ad16fa49d80a8694dfdadb25ca98eee 127.0.0.1:7005\r\n   replicates 53626c1c77f210e57ac7c20181a689350a828d2a\r\nS: a61ba9dfdc361915832fbd9e6a4d2109c16a40ef 127.0.0.1:7006\r\n   replicates c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea\r\nCan I set the above configuration? (type \'yes\' to accept): yes\r\n>>> Nodes configuration updated\r\n>>> Assign a different config epoch to each node\r\n>>> Sending CLUSTER MEET messages to join the cluster\r\nWaiting for the cluster to join.....\r\n>>> Performing Cluster Check (using node 127.0.0.1:7001)\r\nM: c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea 127.0.0.1:7001\r\n   slots:0-5460 (5461 slots) master\r\n   1 additional replica(s)\r\nM: 53626c1c77f210e57ac7c20181a689350a828d2a 127.0.0.1:7003\r\n   slots:10923-16383 (5461 slots) master\r\n   1 additional replica(s)\r\nM: 19615b40d6494564a729caa3b0c0995391df4ec3 127.0.0.1:7002\r\n   slots:5461-10922 (5462 slots) master\r\n   1 additional replica(s)\r\nS: a61ba9dfdc361915832fbd9e6a4d2109c16a40ef 127.0.0.1:7006\r\n   slots: (0 slots) slave\r\n   replicates c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea\r\nS: d16f3f8adbdb809eb6871f49a0233bceef12118f 127.0.0.1:7004\r\n   slots: (0 slots) slave\r\n   replicates 19615b40d6494564a729caa3b0c0995391df4ec3\r\nS: 8526763d0ad16fa49d80a8694dfdadb25ca98eee 127.0.0.1:7005\r\n   slots: (0 slots) slave\r\n   replicates 53626c1c77f210e57ac7c20181a689350a828d2a\r\n[OK] All nodes agree about slots configuration.\r\n>>> Check for open slots...\r\n>>> Check slots coverage...\r\n[OK] All 16384 slots covered.\r\n```\r\n\r\n上面显示创建成功，有3个主节点，3个从节点，每个节点都是成功连接状态。\r\n\r\n\r\n\r\n3个主节点[M]以及分配的哈希卡槽如下\r\n\r\n```shell\r\nM: c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea 127.0.0.1:7001\r\n   slots:0-5460 (5461 slots) master\r\nM: 19615b40d6494564a729caa3b0c0995391df4ec3 127.0.0.1:7002\r\n   slots:5461-10922 (5462 slots) master\r\nM: 53626c1c77f210e57ac7c20181a689350a828d2a 127.0.0.1:7003\r\n   slots:10923-16383 (5461 slots) master\r\n\r\n```\r\n\r\n\r\n\r\n3个从节点[S]以及附属的主节点如下\r\n\r\n```shell\r\nS: d16f3f8adbdb809eb6871f49a0233bceef12118f 127.0.0.1:7004\r\n   replicates 19615b40d6494564a729caa3b0c0995391df4ec3\r\nS: 8526763d0ad16fa49d80a8694dfdadb25ca98eee 127.0.0.1:7005\r\n   replicates 53626c1c77f210e57ac7c20181a689350a828d2a\r\nS: a61ba9dfdc361915832fbd9e6a4d2109c16a40ef 127.0.0.1:7006\r\n   replicates c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea\r\n```\r\n\r\n\r\n\r\n以上集群安装成功了，如果安装未成功报如下错误\r\n\r\n```shell\r\n>>> Creating cluster\r\n[ERR] Sorry, can\'t connect to node  ....\r\n```\r\n\r\n\r\n\r\n### 3. 安装集群出错常见问题\r\n\r\n参考:http://blog.csdn.net/ownfire/article/details/46624005\r\n\r\n1. 集群搭建报错如下\r\n\r\n```shell\r\n/home/caojx/.rvm/gems/ruby-2.3.3/gems/redis-4.0.1/lib/redis/client.rb:119:in `call\': ERR Slot 0 is already busy (Redis::CommandError)\r\n	from /home/caojx/.rvm/gems/ruby-2.3.3/gems/redis-4.0.1/lib/redis.rb:2764:in `block in method_missing\'\r\n	from /home/caojx/.rvm/gems/ruby-2.3.3/gems/redis-4.0.1/lib/redis.rb:45:in `block in synchronize\'\r\n	from /home/caojx/.rvm/rubies/ruby-2.3.3/lib/ruby/2.3.0/monitor.rb:214:in `mon_synchronize\'\r\n	from /home/caojx/.rvm/gems/ruby-2.3.3/gems/redis-4.0.1/lib/redis.rb:45:in `synchronize\'\r\n	from /home/caojx/.rvm/gems/ruby-2.3.3/gems/redis-4.0.1/lib/redis.rb:2763:in `method_missing\'\r\n	from ./redis-trib.rb:212:in `flush_node_config\'\r\n	from ./redis-trib.rb:906:in `block in flush_nodes_config\'\r\n	from ./redis-trib.rb:905:in `each\'\r\n	from ./redis-trib.rb:905:in `flush_nodes_config\'\r\n	from ./redis-trib.rb:1426:in `create_cluster_cmd\'\r\n	from ./redis-trib.rb:1830:in `<main>\'\r\n```\r\n\r\n​	经检查，这是由于上一次配置集群失败时留下的配置信息导致的。 只要把redis.conf中定义的 cluster-config-file 所在的文件删除，重新启动redis-server及运行redis-trib即可。\r\n\r\n2. 创建集群时一直处于\"Waiting for the cluster to join....................................\"的状态\r\n\r\n   这个问题原因不知,但解决方法是在redis.conf文件中把bind 127.0.0.1本地环回口改为物理接口.\r\n\r\n3. 安装ruby redis时长时间没响应\r\n\r\n   这是由于天朝网络,解决办法是改ruby源(请自行baidu)或手动安装\r\n\r\n# 三、Redis Cluster集群的测试\r\n\r\n###   3.1 测试存取值\r\n\r\n​         客户端连接集群redis-cli需要带上 -c ，redis-cli -c -p 端口号\r\n\r\n```shell\r\n[caojx@localhost bin]$ ./redis-cli -c -p 7001 \r\n127.0.0.1:7001> set name tom\r\n-> Redirected to slot [5798] located at 127.0.0.1:7002\r\nOK\r\n127.0.0.1:7002> get name\r\n\"tom\"\r\n127.0.0.1:7002>   \r\n```\r\n\r\n​         根据redis-cluster的key值分配，name应该分配到节点7002[5461-10922]上，上面显示redis cluster自动从7001跳转到了7002节点。\r\n\r\n​       我们可以测试一下7006从节点获取name值\r\n\r\n```shell\r\n[caojx@localhost bin]$ ./redis-cli -c -p 7006\r\n127.0.0.1:7006> get name\r\n-> Redirected to slot [5798] located at 127.0.0.1:7002\r\n\"tom\"\r\n127.0.0.1:7002> \r\n```\r\n\r\n7006位7003的从节点，从上面也是自动跳转至7002获取值，这也是redis cluster的特点，它是去中心化，每个节点都是对等的，连接哪个节点都可以获取和设置数据。\r\n\r\n###3.2 集群节点选举\r\n\r\n 现在模拟将7002节点挂掉，按照redis-cluster原理会选举会将 7002的从节点7005选举为主节点。\r\n\r\n```shell\r\n[caojx@localhost redis-cluster]$ ps -ef | grep redis\r\ncaojx      1908      1  0 01:54 ?        00:00:00 ./redis-server *:7001 [cluster]\r\ncaojx      1910      1  0 01:54 ?        00:00:00 ./redis-server *:7002 [cluster]\r\ncaojx      1915      1  0 01:54 ?        00:00:00 ./redis-server *:7003 [cluster]\r\ncaojx      1920      1  0 01:54 ?        00:00:00 ./redis-server *:7004 [cluster]\r\ncaojx      1925      1  0 01:54 ?        00:00:00 ./redis-server *:7005 [cluster]\r\ncaojx      1927      1  0 01:54 ?        00:00:00 ./redis-server *:7006 [cluster]\r\ncaojx      2609   2314  0 02:04 pts/1    00:00:00 grep --color=auto redis\r\n[caojx@localhost redis-cluster]$ kill -9 1910\r\n```\r\n\r\n查看集群中的7002节点\r\n\r\n```shell\r\n[caojx@localhost redis-cluster]$ ./redis-trib.rb check 127.0.0.1:7002\r\n[ERR] Sorry, can\'t connect to node 127.0.0.1:7002\r\n[caojx@localhost redis-cluster]$ ./redis-trib.rb check 127.0.0.1:7004\r\n>>> Performing Cluster Check (using node 127.0.0.1:7004)\r\nM: d16f3f8adbdb809eb6871f49a0233bceef12118f 127.0.0.1:7004\r\n   slots:5461-10922 (5462 slots) master\r\n   0 additional replica(s)\r\nM: 53626c1c77f210e57ac7c20181a689350a828d2a 127.0.0.1:7003\r\n   slots:10923-16383 (5461 slots) master\r\n   1 additional replica(s)\r\nS: 8526763d0ad16fa49d80a8694dfdadb25ca98eee 127.0.0.1:7005\r\n   slots: (0 slots) slave\r\n   replicates 53626c1c77f210e57ac7c20181a689350a828d2a\r\nS: a61ba9dfdc361915832fbd9e6a4d2109c16a40ef 127.0.0.1:7006\r\n   slots: (0 slots) slave\r\n   replicates c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea\r\nM: c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea 127.0.0.1:7001\r\n   slots:0-5460 (5461 slots) master\r\n   1 additional replica(s)\r\n[OK] All nodes agree about slots configuration.\r\n>>> Check for open slots...\r\n>>> Check slots coverage...\r\n[OK] All 16384 slots covered.\r\n[caojx@localhost redis-cluster]$ \r\n```\r\n\r\n可以看到集群连接不了7002节点，而7004有原来的S转换为M节点，代替了原来的7002节点\r\n\r\n\r\n\r\n现在我们将7002节点恢复，看是否会自动加入集群中以及充当的M还是S节点。\r\n\r\n```shell\r\n[caojx@localhost redis-cluster]$ cd redis02/bin\r\n[caojx@localhost bin]$ ./redis-server ../redis.conf \r\n```\r\n\r\ncheck一下7002节点，查看时master还是slave\r\n\r\n```shell\r\n[caojx@localhost redis-cluster]$ ./redis-trib.rb check 127.0.0.1:7002\r\n>>> Performing Cluster Check (using node 127.0.0.1:7002)\r\nS: 19615b40d6494564a729caa3b0c0995391df4ec3 127.0.0.1:7002\r\n   slots: (0 slots) slave\r\n   replicates d16f3f8adbdb809eb6871f49a0233bceef12118f\r\nS: a61ba9dfdc361915832fbd9e6a4d2109c16a40ef 127.0.0.1:7006\r\n   slots: (0 slots) slave\r\n   replicates c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea\r\nM: c1eaf4b0267674c95d78b6cf1c1d91f37bfd91ea 127.0.0.1:7001\r\n   slots:0-5460 (5461 slots) master\r\n   1 additional replica(s)\r\nS: 8526763d0ad16fa49d80a8694dfdadb25ca98eee 127.0.0.1:7005\r\n   slots: (0 slots) slave\r\n   replicates 53626c1c77f210e57ac7c20181a689350a828d2a\r\nM: d16f3f8adbdb809eb6871f49a0233bceef12118f 127.0.0.1:7004\r\n   slots:5461-10922 (5462 slots) master\r\n   1 additional replica(s)\r\nM: 53626c1c77f210e57ac7c20181a689350a828d2a 127.0.0.1:7003\r\n   slots:10923-16383 (5461 slots) master\r\n   1 additional replica(s)\r\n[OK] All nodes agree about slots configuration.\r\n>>> Check for open slots...\r\n>>> Check slots coverage...\r\n[OK] All 16384 slots covered.\r\n```\r\n\r\n可以看到7002节点变成了 7004的从节点。\r\n\r\n\r\n\r\n参考：\r\n\r\nhttp://www.redis.cn/topics/cluster-tutorial.html\r\n\r\nhttps://www.cnblogs.com/yingchen/p/6763524.html\r\n\r\n https://www.cnblogs.com/carryping/p/7447823.html\r\n\r\nhttp://blog.csdn.net/ownfire/article/details/46624005', 0);
INSERT INTO `blog_course` VALUES (217, 'Redis 集群方案', 9, '# Redis集群方案\r\n\r\n[TOC]\r\n\r\nRedis集群方案应该怎么做？ - 知乎\r\n\r\n知乎原文：https://www.zhihu.com/question/21419897/answer/89771396\r\n\r\n作者：[小钢蹦儿](https://www.zhihu.com/people/yang-shuai-83-7) [编辑于 2017-06-12](https://www.zhihu.com/question/21419897/answer/89771396)\r\n\r\n## 1. 为什么集群？\r\n\r\n通常，为了提高网站响应速度，总是把热点数据保存在内存中而不是直接从后端数据库中读取。Redis是一个很好的Cache工具。大型网站应用，热点数据量往往巨大，几十G上百G是很正常的事儿，在这种情况下，如何正确架构Redis呢？\r\n\r\n首先，无论我们是使用自己的物理主机，还是使用云服务主机，内存资源往往是有限制的，scale up不是一个好办法，我们需要scale out横向可伸缩扩展，这需要由多台主机协同提供服务，即分布式多个Redis实例协同运行。\r\n\r\n其次，目前硬件资源成本降低，多核CPU，几十G内存的主机很普遍，对于主进程是单线程工作的Redis，只运行一个实例就显得有些浪费。同时，管理一个巨大内存不如管理相对较小的内存高效。因此，实际使用中，通常一台机器上同时跑多个Redis实例。\r\n\r\n**集群方案**\r\n\r\n## 2. Redis官方集群方案 Redis Cluster\r\n\r\nRedis Cluster是一种服务器Sharding技术，3.0版本开始正式提供。\r\n\r\nRedis Cluster中，Sharding采用slot(槽)的概念，一共分成16384个槽，这有点儿类pre sharding思路。对于每个进入Redis的键值对，根据key进行散列，分配到这16384个slot中的某一个中。使用的hash算法也比较简单，就是CRC16后16384取模。\r\n\r\nRedis集群中的每个node(节点)负责分摊这16384个slot中的一部分，也就是说，每个slot都对应一个node负责处理。当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程，在目前实现中，还处于半自动状态，需要人工介入。\r\n\r\nRedis集群，要保证16384个槽对应的node都正常工作，如果某个node发生故障，那它负责的slots也就失效，整个集群将不能工作。\r\n\r\n为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，整个集群继续对外提供服务。这非常类似前篇文章提到的Redis Sharding场景下服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。\r\n\r\nRedis Cluster的新节点识别能力、故障判断及故障转移能力是通过集群中的每个node都在和其它nodes进行通信，这被称为集群总线(cluster bus)。它们使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。\r\n\r\n对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点儿像浏览器页面的302 redirect跳转。\r\n\r\n**Redis Cluster是Redis 3.0以后才正式推出，时间较晚，目前能证明在大规模生产环境下成功的案例还不是很多，需要时间检验。**\r\n\r\n## 3. Redis Sharding集群\r\n\r\nRedis 3正式推出了官方集群技术，解决了多Redis实例协同服务问题。Redis Cluster可以说是服务端Sharding分片技术的体现，即将键值按照一定算法合理分配到各个实例分片上，同时各个实例节点协调沟通，共同对外承担一致服务。\r\n\r\n多Redis实例服务，比单Redis实例要复杂的多，这涉及到定位、协同、容错、扩容等技术难题。这里，我们介绍一种轻量级的客户端Redis Sharding技术。\r\n\r\nRedis Sharding可以说是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。这样，客户端就知道该向哪个Redis节点操作数据。Sharding架构如图：\r\n\r\n![](../images/redis/redis_sharding_1.jpg)  \r\n\r\n庆幸的是，java redis客户端驱动jedis，已支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool。\r\n\r\nJedis的Redis Sharding实现具有如下特点：\r\n\r\n1. 采用一致性哈希算法(consistent hashing)，将key和节点name同时hashing，然后进行映射匹配，采用的算法是MURMUR_HASH。采用一致性哈希而不是采用简单类似哈希求模映射的主要原因是当增加或减少节点时，不会产生由于重新匹配造成的rehashing。一致性哈希只影响相邻节点key分配，影响量小。\r\n2. 为了避免一致性哈希只影响相邻节点造成节点分配压力，ShardedJedis会对每个Redis节点根据名字(没有，Jedis会赋予缺省名字)会虚拟化出160个虚拟节点进行散列。根据权重weight，也可虚拟化出160倍数的虚拟节点。用虚拟节点做映射匹配，可以在增加或减少Redis节点时，key在各Redis节点移动再分配更均匀，而不是只有相邻节点受影响。\r\n3. ShardedJedis支持keyTagPattern模式，即抽取key的一部分keyTag做sharding，这样通过合理命名key，可以将一组相关联的key放入同一个Redis节点，这在避免跨节点访问相关数据时很重要。\r\n\r\n> **扩容问题**\r\n\r\nRedis Sharding采用客户端Sharding方式，服务端Redis还是一个个相对独立的Redis实例节点，没有做任何变动。同时，我们也不需要增加额外的中间处理组件，这是一种非常轻量、灵活的Redis多实例集群方法。\r\n\r\n当然，Redis Sharding这种轻量灵活方式必然在集群其它能力方面做出妥协。比如扩容，当想要增加Redis节点时，尽管采用一致性哈希，毕竟还是会有key匹配不到而丢失，这时需要键值迁移。\r\n\r\n作为轻量级客户端sharding，处理Redis键值迁移是不现实的，这就要求应用层面允许Redis中数据丢失或从后端数据库重新加载数据。但有些时候，击穿缓存层，直接访问数据库层，会对系统访问造成很大压力。有没有其它手段改善这种情况？\r\n\r\nRedis作者给出了一个比较讨巧的办法--presharding，即预先根据系统规模尽量部署好多个Redis实例，这些实例占用系统资源很小，一台物理机可部署多个，让他们都参与sharding，当需要扩容时，选中一个实例作为主节点，新加入的Redis节点作为从节点进行数据复制。数据同步后，修改sharding配置，让指向原实例的Shard指向新机器上扩容后的Redis节点，同时调整新Redis节点为主节点，原实例可不再使用。\r\n\r\npresharding是预先分配好足够的分片，扩容时只是将属于某一分片的原Redis实例替换成新的容量更大的Redis实例。参与sharding的分片没有改变，所以也就不存在key值从一个区转移到另一个分片区的现象，只是将属于同分片区的键值从原Redis实例同步到新Redis实例。 并不是只有增删Redis节点引起键值丢失问题，更大的障碍来自Redis节点突然宕机。在《Redis持久化》一文中已提到，为不影响Redis性能，尽量不开启AOF和RDB文件保存功能，可架构Redis主备模式，主Redis宕机，数据不会丢失，备Redis留有备份。\r\n\r\n这样，我们的架构模式变成一个Redis节点切片包含一个主Redis和一个备Redis。在主Redis宕机时，备Redis接管过来，上升为主Redis，继续提供服务。主备共同组成一个Redis节点，通过自动故障转移，保证了节点的高可用性。则Sharding架构演变成： Redis Sentinel提供了主备模式下Redis监控、故障转移功能达到系统的高可用性。\r\n\r\n高访问量下，即使采用Sharding分片，一个单独节点还是承担了很大的访问压力，这时我们还需要进一步分解。通常情况下，应用访问Redis读操作量和写操作量差异很大，读常常是写的数倍，这时我们可以将读写分离，而且读提供更多的实例数。\r\n\r\n可以利用主从模式实现读写分离，主负责写，从负责只读，同时一主挂多个从。在Sentinel监控下，还可以保障节点故障的自动监测。\r\n\r\n## 4. 利用代理中间件实现大规模Redis集群\r\n\r\n上面分别介绍了多Redis服务器集群的两种方式，它们是基于客户端sharding的Redis Sharding和基于服务端sharding的Redis Cluster。\r\n\r\n客户端sharding技术其优势在于服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强。其不足之处在于：\r\n\r\n1. 由于sharding处理放到客户端，规模进步扩大时给运维带来挑战。\r\n2. 服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。\r\n3. 连接不能共享，当应用规模增大时，资源浪费制约优化。\r\n\r\n服务端sharding的Redis Cluster其优势在于服务端Redis集群拓扑结构变化时，客户端不需要感知，客户端像使用单Redis服务器一样使用Redis集群，运维管理也比较方便。\r\n\r\n不过Redis Cluster正式版推出时间不长，系统稳定性、性能等都需要时间检验，尤其在大规模使用场合。\r\n\r\n能不能结合二者优势？即能使服务端各实例彼此独立，支持线性可伸缩，同时sharding又能集中处理，方便统一管理？本篇介绍的Redis代理中间件twemproxy就是这样一种利用中间件做sharding的技术。\r\n\r\ntwemproxy处于客户端和服务器的中间，将客户端发来的请求，进行一定的处理后(如sharding)，再转发给后端真正的Redis服务器。也就是说，客户端不直接访问Redis服务器，而是通过twemproxy代理中间件间接访问。\r\n\r\n参照Redis Sharding架构，增加代理中间件的Redis集群架构如下：\r\n\r\ntwemproxy中间件的内部处理是无状态的，它本身可以很轻松地集群，这样可避免单点压力或故障。\r\n\r\ntwemproxy又叫nutcracker，起源于twitter系统中redis/memcached集群开发实践，运行效果良好，后代码奉献给开源社区。其轻量高效，采用C语言开发，工程网址是：[GitHub - twitter/twemproxy: A fast, light-weight proxy for memcached and redis](https://link.zhihu.com/?target=https%3A//github.com/twitter/twemproxy)\r\n\r\ntwemproxy后端不仅支持redis，同时也支持memcached，这是twitter系统具体环境造成的。\r\n\r\n由于使用了中间件，twemproxy可以通过共享与后端系统的连接，降低客户端直接连接后端服务器的连接数量。同时，它也提供sharding功能，支持后端服务器集群水平扩展。统一运维管理也带来了方便。\r\n\r\n当然，也是由于使用了中间件代理，相比客户端直连服务器方式，性能上会有所损耗，实测结果大约降低了20%左右。', 0);
INSERT INTO `blog_course` VALUES (218, 'MySQL 简介', 7, '\r\n# 思维导图-索引篇\r\n\r\n> 系列思维导图源文件（数据库+架构）以及思维导图制作软件—XMind8 破解安装，公众号后台回复：**“思维导图”** 免费领取！（下面的图片不是很清楚，原图非常清晰，另外提供给大家源文件也是为了大家根据自己需要进行修改）\r\n\r\n![【思维导图-索引篇】](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/70973487.jpg)\r\n\r\n> **下面是我补充的一些内容**\r\n\r\n# 为什么索引能提高查询速度\r\n\r\n> 以下内容整理自：\r\n>  地址： https://juejin.im/post/5b55b842f265da0f9e589e79\r\n>  作者 ：Java3y\r\n\r\n### 先从 MySQL 的基本存储结构说起\r\n\r\nMySQL的基本存储结构是页(记录都存在页里边)：\r\n\r\n![MySQL的基本存储结构是页](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/28559421.jpg)\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/82053134.jpg)\r\n\r\n - **各个数据页可以组成一个双向链表**\r\n -   **每个数据页中的记录又可以组成一个单向链表**\r\n       - 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录\r\n       - 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。\r\n\r\n所以说，如果我们写select * from user where indexname = \'xxx\'这样没有进行任何优化的sql语句，默认会这样做：\r\n\r\n1. **定位到记录所在的页:需要遍历双向链表，找到所在的页**\r\n2. **从所在的页内中查找相应的记录:由于不是根据主键查询，只能遍历所在页的单链表了**\r\n\r\n很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。\r\n\r\n\r\n### 使用索引之后\r\n\r\n索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/5373082.jpg)\r\n\r\n要找到id为8的记录简要步骤：\r\n\r\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-2/89338047.jpg)\r\n\r\n很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 **“目录”** 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）\r\n\r\n其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。\r\n\r\n# 关于索引其他重要的内容补充\r\n\r\n> 以下内容整理自：《Java工程师修炼之道》\r\n\r\n\r\n### 最左前缀原则\r\n\r\nMySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：        \r\n\r\n```                                                                                       \r\nselect * from user where name=xx and city=xx ; ／／可以命中索引\r\nselect * from user where name=xx ; // 可以命中索引\r\nselect * from user where city=xx; // 无法命中索引            \r\n```                                                          \r\n这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的.\r\n\r\n由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDERBY子句也遵循此规则。\r\n\r\n### 注意避免冗余索引\r\n\r\n冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。\r\n\r\nMySQLS.7 版本后，可以通过查询 sys 库的 `schema_redundant_indexes` 表来查看冗余索引             \r\n\r\n### Mysql如何为表字段添加索引？？？\r\n\r\n1.添加PRIMARY KEY（主键索引）\r\n\r\n```\r\nALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) \r\n```\r\n2.添加UNIQUE(唯一索引) \r\n\r\n```\r\nALTER TABLE `table_name` ADD UNIQUE ( `column` ) \r\n```\r\n \r\n3.添加INDEX(普通索引) \r\n\r\n```\r\nALTER TABLE `table_name` ADD INDEX index_name ( `column` )\r\n```\r\n \r\n4.添加FULLTEXT(全文索引) \r\n\r\n```\r\nALTER TABLE `table_name` ADD FULLTEXT ( `column`) \r\n```\r\n \r\n5.添加多列索引\r\n\r\n```\r\nALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )\r\n```\r\n\r\n\r\n# 参考\r\n\r\n- 《Java工程师修炼之道》\r\n- 《MySQL高性能书籍_第3版》\r\n- https://juejin.im/post/5b55b842f265da0f9e589e79\r\n                           \r\n', 0);
INSERT INTO `blog_course` VALUES (219, 'MySQL 常见问题', 7, '\r\n\r\nJava面试通关手册（Java学习指南，欢迎Star，会一直完善下去，欢迎建议和指导）：[https://github.com/Snailclimb/Java_Guide](https://github.com/Snailclimb/Java_Guide)\r\n\r\n> ## 书籍推荐\r\n\r\n**《高性能MySQL : 第3版》**\r\n\r\n> ## 文字教程推荐\r\n\r\n[MySQL 教程（菜鸟教程）](http://www.runoob.com/mysql/mysql-tutorial.html)\r\n\r\n[MySQL教程（易百教程）](https://www.yiibai.com/mysql/)\r\n\r\n> ## 视频教程推荐\r\n\r\n\r\n**基础入门：** [与MySQL的零距离接触-慕课网](https://www.imooc.com/learn/122)\r\n\r\n**Mysql开发技巧：** [MySQL开发技巧（一）](https://www.imooc.com/learn/398)　　[MySQL开发技巧（二）](https://www.imooc.com/learn/427)　　[MySQL开发技巧（三）](https://www.imooc.com/learn/449)\r\n\r\n**Mysql5.7新特性及相关优化技巧：** [MySQL5.7版本新特性](https://www.imooc.com/learn/533)　　[性能优化之MySQL优化](https://www.imooc.com/learn/194)\r\n\r\n[MySQL集群（PXC）入门](https://www.imooc.com/learn/993)　　[MyCAT入门及应用](https://www.imooc.com/learn/951)\r\n\r\n\r\n\r\n> ## 常见问题总结\r\n\r\n- ### ①存储引擎\r\n\r\n  [MySQL常见的两种存储引擎：MyISAM与InnoDB的爱恨情仇](https://juejin.im/post/5b1685bef265da6e5c3c1c34)\r\n  \r\n- ### ②字符集及校对规则\r\n\r\n   字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。Mysql中每一种字符集都会对应一系列的校对规则。\r\n\r\n   Mysql采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》\r\n   \r\n   详细内容可以参考：   [MySQL字符集及校对规则的理解](https://www.cnblogs.com/geaozhang/p/6724393.html#mysqlyuzifuji)\r\n\r\n-  ### ③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）\r\n    \r\n   　　Mysql索引使用的数据结构主要有**BTree索引** 和 **哈希索引** 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。\r\n   \r\n   　　Mysql的BTree索引使用的是B数中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。\r\n\r\n   　　**MyISAM:** B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。\r\n   \r\n   　　**InnoDB:** 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。** **因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。** PS：整理自《Java工程师修炼之道》\r\n   \r\n    详细内容可以参考：\r\n    \r\n    [干货：mysql索引的数据结构](https://www.jianshu.com/p/1775b4ff123a)\r\n    \r\n    [MySQL优化系列（三）--索引的使用、原理和设计优化](https://blog.csdn.net/Jack__Frost/article/details/72571540)\r\n \r\n    [数据库两大神器【索引和锁】](https://juejin.im/post/5b55b842f265da0f9e589e79#comment)\r\n    \r\n- ### ④查询缓存的使用\r\n\r\n   my.cnf加入以下配置，重启Mysql开启查询缓存\r\n   ```\r\n   query_cache_type=1\r\n   query_cache_size=600000\r\n   ```\r\n   \r\n   Mysql执行以下命令也可以开启查询缓存\r\n   \r\n   ```\r\n   set global  query_cache_type=1;\r\n   set global  query_cache_size=600000;\r\n   ```\r\n   如上，**开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果**。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、Mysql库中的系统表，其查询结果也不会被缓存。\r\n   \r\n   缓存建立之后，Mysql的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。\r\n   \r\n   **缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。** 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，**还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：**\r\n   ```\r\n   select sql_no_cache count(*) from usr;\r\n   ```\r\n   \r\n- ### ⑤事务机制\r\n   \r\n   **关系性数据库需要遵循ACID规则，具体内容如下：**\r\n\r\n![事务的特性](https://user-gold-cdn.xitu.io/2018/5/20/1637b08b98619455?w=312&h=305&f=png&s=22430)\r\n\r\n   1.  **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\r\n   2.  **一致性：** 执行事务前后，数据库从一个一致性状态转换到另一个一致性状态。\r\n   3.  **隔离性：** 并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间数据库是独立的；\r\n   4.  **持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。\r\n   \r\n  **为了达到上述事务特性，数据库定义了几种不同的事务隔离级别：**\r\n\r\n-  **READ_UNCOMMITTED（未提交读）:** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**\r\n-  **READ_COMMITTED（提交读）:** 	允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**\r\n-  **REPEATABLE_READ（可重复读）:** 	对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**\r\n- **SERIALIZABLE（串行）:** 	最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\r\n\r\n  这里需要注意的是：**Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.**\r\n\r\n  事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVCC（多版本并发控制），通过行的创建时间和行的过期时间来支持并发一致性读和回滚等特性。\r\n\r\n   详细内容可以参考：   [可能是最漂亮的Spring事务管理详解](https://blog.csdn.net/qq_34337272/article/details/80394121)\r\n\r\n- ### ⑥锁机制与InnoDB锁算法\r\n   **MyISAM和InnoDB存储引擎使用的锁：**\r\n\r\n  - MyISAM采用表级锁(table-level locking)。\r\n  - InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁\r\n\r\n   **表级锁和行级锁对比：**\r\n\r\n    - **表级锁：** Mysql中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。\r\n   - **行级锁：** Mysql中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 \r\n\r\n   详细内容可以参考：\r\n   [Mysql锁机制简单了解一下](https://blog.csdn.net/qq_34337272/article/details/80611486)\r\n   \r\n  **InnoDB存储引擎的锁的算法有三种：**\r\n   - Record lock：单个行记录上的锁\r\n   - Gap lock：间隙锁，锁定一个范围，不包括记录本身\r\n   - Next-key lock：record+gap 锁定一个范围，包含记录本身\r\n \r\n   **相关知识点：**\r\n    1. innodb对于行的查询使用next-key lock\r\n    2. Next-locking keying为了解决Phantom Problem幻读问题\r\n    3. 当查询的索引含有唯一属性时，将next-key lock降级为record key\r\n    4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生\r\n    5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1\r\n\r\n-  ### ⑦大表优化\r\n\r\n   当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\r\n  \r\n  1. **限定数据的范围：** 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；\r\n  2. **读/写分离：** 经典的数据库拆分方案，主库负责写，从库负责读；\r\n  3 . **垂直分区：** \r\n     \r\n      **根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\r\n\r\n      **简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。\r\n    ![](https://user-gold-cdn.xitu.io/2018/6/16/164084354ba2e0fd?w=950&h=279&f=jpeg&s=26015)\r\n  \r\n      **垂直拆分的优点：** 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。\r\n\r\n      **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；\r\n\r\n  4. **水平分区：** \r\n  \r\n   \r\n     **保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。** \r\n   \r\n     水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。\r\n   \r\n     ![数据库水平拆分](https://user-gold-cdn.xitu.io/2018/6/16/164084b7e9e423e3?w=690&h=271&f=jpeg&s=23119)\r\n   \r\n     水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。\r\n   \r\n     水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决**  ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\r\n   \r\n     **下面补充一下数据库分片的两种常见方案：**\r\n     - **客户端代理：**  **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。\r\n     - **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。\r\n  \r\n  \r\n  详细内容可以参考：\r\n  [MySQL大表优化方案](https://segmentfault.com/a/1190000006158186)\r\n  \r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (220, 'MySQL 一千行命令', 7, '> 原文地址：https://shockerli.net/post/1000-line-mysql-note/ ，JavaGuide 对本文进行了简答排版，新增了目录。\r\n> 作者：格物\r\n\r\n非常不错的总结，强烈建议保存下来，需要的时候看一看。\r\n\r\n<!-- TOC -->\r\n- [基本操作](#基本操作)\r\n- [数据库操作](#数据库操作)\r\n- [表的操作](#表的操作)\r\n- [数据操作](#数据操作)\r\n- [字符集编码](#字符集编码)\r\n- [数据类型(列类型)](#数据类型（列类型）)\r\n- [列属性(列约束)](#列属性（列约束）)\r\n- [建表规范](#建表规范)\r\n- [SELECT](#SELECT)\r\n- [UNION](#UNION)\r\n- [子查询](#子查询)\r\n- [连接查询(join)](#连接查询（join）)\r\n- [TRUNCATE](#TRUNCATE)\r\n- [备份与还原](#备份与还原)\r\n- [视图](#视图)\r\n- [事务(transaction)](#事务（transaction）)\r\n- [锁表](#锁表)\r\n- [触发器](#触发器)\r\n- [SQL编程](#sql编程)\r\n- [存储过程](#存储过程)\r\n- [用户和权限管理](#用户和权限管理)\r\n- [表维护](#表维护)\r\n- [杂项](#杂项)\r\n\r\n<!-- /TOC -->\r\n\r\n### 基本操作\r\n\r\n```mysql\r\n/* Windows服务 */\r\n-- 启动MySQL\r\n    net start mysql\r\n-- 创建Windows服务\r\n    sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)\r\n/* 连接与断开服务器 */\r\nmysql -h 地址 -P 端口 -u 用户名 -p 密码\r\nSHOW PROCESSLIST -- 显示哪些线程正在运行\r\nSHOW VARIABLES -- 显示系统变量信息\r\n```\r\n\r\n### 数据库操作\r\n\r\n```mysql\r\n/* 数据库操作 */ ------------------\r\n-- 查看当前数据库\r\n    SELECT DATABASE();\r\n-- 显示当前时间、用户名、数据库版本\r\n    SELECT now(), user(), version();\r\n-- 创建库\r\n    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项\r\n    数据库选项：\r\n        CHARACTER SET charset_name\r\n        COLLATE collation_name\r\n-- 查看已有库\r\n    SHOW DATABASES[ LIKE \'PATTERN\']\r\n-- 查看当前库信息\r\n    SHOW CREATE DATABASE 数据库名\r\n-- 修改库的选项信息\r\n    ALTER DATABASE 库名 选项信息\r\n-- 删除库\r\n    DROP DATABASE[ IF EXISTS] 数据库名\r\n        同时删除该数据库相关的目录及其目录内容\r\n```\r\n\r\n### 表的操作 \r\n\r\n```mysql\r\n-- 创建表\r\n    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]\r\n        每个字段必须有数据类型\r\n        最后一个字段后不能有逗号\r\n        TEMPORARY 临时表，会话结束时表自动消失\r\n        对于字段的定义：\r\n            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT \'string\']\r\n-- 表选项\r\n    -- 字符集\r\n        CHARSET = charset_name\r\n        如果表没有设定，则使用数据库字符集\r\n    -- 存储引擎\r\n        ENGINE = engine_name\r\n        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同\r\n        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive\r\n        不同的引擎在保存表的结构和数据时采用不同的方式\r\n        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引\r\n        InnoDB表文件含义：.frm表定义，表空间数据和日志文件\r\n        SHOW ENGINES -- 显示存储引擎的状态信息\r\n        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息\r\n    -- 自增起始数\r\n    	AUTO_INCREMENT = 行数\r\n    -- 数据文件目录\r\n        DATA DIRECTORY = \'目录\'\r\n    -- 索引文件目录\r\n        INDEX DIRECTORY = \'目录\'\r\n    -- 表注释\r\n        COMMENT = \'string\'\r\n    -- 分区选项\r\n        PARTITION BY ... (详细见手册)\r\n-- 查看所有表\r\n    SHOW TABLES[ LIKE \'pattern\']\r\n    SHOW TABLES FROM  库名\r\n-- 查看表机构\r\n    SHOW CREATE TABLE 表名 （信息更详细）\r\n    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE \'PATTERN\']\r\n    SHOW TABLE STATUS [FROM db_name] [LIKE \'pattern\']\r\n-- 修改表\r\n    -- 修改表本身的选项\r\n        ALTER TABLE 表名 表的选项\r\n        eg: ALTER TABLE 表名 ENGINE=MYISAM;\r\n    -- 对表进行重命名\r\n        RENAME TABLE 原表名 TO 新表名\r\n        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）\r\n        -- RENAME可以交换两个表名\r\n    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）\r\n        ALTER TABLE 表名 操作名\r\n        -- 操作名\r\n            ADD[ COLUMN] 字段定义       -- 增加字段\r\n                AFTER 字段名          -- 表示增加在该字段名后面\r\n                FIRST               -- 表示增加在第一个\r\n            ADD PRIMARY KEY(字段名)   -- 创建主键\r\n            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引\r\n            ADD INDEX [索引名] (字段名) -- 创建普通索引\r\n            DROP[ COLUMN] 字段名      -- 删除字段\r\n            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)\r\n            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改\r\n            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)\r\n            DROP INDEX 索引名 -- 删除索引\r\n            DROP FOREIGN KEY 外键    -- 删除外键\r\n-- 删除表\r\n    DROP TABLE[ IF EXISTS] 表名 ...\r\n-- 清空表数据\r\n    TRUNCATE [TABLE] 表名\r\n-- 复制表结构\r\n    CREATE TABLE 表名 LIKE 要复制的表名\r\n-- 复制表结构和数据\r\n    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名\r\n-- 检查表是否有错误\r\n    CHECK TABLE tbl_name [, tbl_name] ... [option] ...\r\n-- 优化表\r\n    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\r\n-- 修复表\r\n    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]\r\n-- 分析表\r\n    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\r\n```\r\n\r\n### 数据操作\r\n\r\n```mysql\r\n/* 数据操作 */ ------------------\r\n-- 增\r\n    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]\r\n        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。\r\n        -- 可同时插入多条数据记录！\r\n        REPLACE 与 INSERT 完全一样，可互换。\r\n    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]\r\n-- 查\r\n    SELECT 字段列表 FROM 表名[ 其他子句]\r\n        -- 可来自多个表的多个字段\r\n        -- 其他子句可以不使用\r\n        -- 字段列表可以用*代替，表示所有字段\r\n-- 删\r\n    DELETE FROM 表名[ 删除条件子句]\r\n        没有条件子句，则会删除全部\r\n-- 改\r\n    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]\r\n```\r\n\r\n### 字符集编码\r\n\r\n```mysql\r\n/* 字符集编码 */ ------------------\r\n-- MySQL、数据库、表、字段均可设置编码\r\n-- 数据编码与客户端编码不需一致\r\nSHOW VARIABLES LIKE \'character_set_%\'   -- 查看所有字符集编码项\r\n    character_set_client        客户端向服务器发送数据时使用的编码\r\n    character_set_results       服务器端将结果返回给客户端所使用的编码\r\n    character_set_connection    连接层编码\r\nSET 变量名 = 变量值\r\n    SET character_set_client = gbk;\r\n    SET character_set_results = gbk;\r\n    SET character_set_connection = gbk;\r\nSET NAMES GBK;  -- 相当于完成以上三个设置\r\n-- 校对集\r\n    校对集用以排序\r\n    SHOW CHARACTER SET [LIKE \'pattern\']/SHOW CHARSET [LIKE \'pattern\']   查看所有字符集\r\n    SHOW COLLATION [LIKE \'pattern\']     查看所有校对集\r\n    CHARSET 字符集编码     设置字符集编码\r\n    COLLATE 校对集编码     设置校对集编码\r\n```\r\n\r\n### 数据类型（列类型）\r\n\r\n```mysql\r\n/* 数据类型（列类型） */ ------------------\r\n1. 数值类型\r\n-- a. 整型 ----------\r\n    类型         字节     范围（有符号位）\r\n    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255\r\n    smallint    2字节    -32768 ~ 32767\r\n    mediumint   3字节    -8388608 ~ 8388607\r\n    int         4字节\r\n    bigint      8字节\r\n    int(M)  M表示总位数\r\n    - 默认存在符号位，unsigned 属性修改\r\n    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改\r\n        例：int(5)   插入一个数\'123\'，补填后为\'00123\'\r\n    - 在满足要求的情况下，越小越好。\r\n    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。\r\n-- b. 浮点型 ----------\r\n    类型             字节     范围\r\n    float(单精度)     4字节\r\n    double(双精度)    8字节\r\n    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。\r\n        不同于整型，前后均会补填0.\r\n    定义浮点型时，需指定总位数和小数位数。\r\n        float(M, D)     double(M, D)\r\n        M表示总位数，D表示小数位数。\r\n        M和D的大小会决定浮点数的范围。不同于整型的固定范围。\r\n        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。\r\n        支持科学计数法表示。\r\n        浮点数表示近似值。\r\n-- c. 定点数 ----------\r\n    decimal -- 可变长度\r\n    decimal(M, D)   M也表示总位数，D表示小数位数。\r\n    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。\r\n    将浮点数转换为字符串来保存，每9位数字保存为4个字节。\r\n2. 字符串类型\r\n-- a. char, varchar ----------\r\n    char    定长字符串，速度快，但浪费空间\r\n    varchar 变长字符串，速度慢，但节省空间\r\n    M表示能存储的最大长度，此长度是字符数，非字节数。\r\n    不同的编码，所占用的空间不同。\r\n    char,最多255个字符，与编码无关。\r\n    varchar,最多65535字符，与编码有关。\r\n    一条有效记录最大不能超过65535个字节。\r\n        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符\r\n    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。\r\n    varchar 的最大有效长度由最大行大小和使用的字符集确定。\r\n    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。\r\n    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3\r\n-- b. blob, text ----------\r\n    blob 二进制字符串（字节字符串）\r\n        tinyblob, blob, mediumblob, longblob\r\n    text 非二进制字符串（字符字符串）\r\n        tinytext, text, mediumtext, longtext\r\n    text 在定义时，不需要定义长度，也不会计算总长度。\r\n    text 类型在定义时，不可给default值\r\n-- c. binary, varbinary ----------\r\n    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。\r\n    char, varchar, text 对应 binary, varbinary, blob.\r\n3. 日期时间类型\r\n    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。\r\n    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59\r\n    date        3字节    日期         1000-01-01 到 9999-12-31\r\n    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07\r\n    time        3字节    时间         -838:59:59 到 838:59:59\r\n    year        1字节    年份         1901 - 2155\r\ndatetime    YYYY-MM-DD hh:mm:ss\r\ntimestamp   YY-MM-DD hh:mm:ss\r\n            YYYYMMDDhhmmss\r\n            YYMMDDhhmmss\r\n            YYYYMMDDhhmmss\r\n            YYMMDDhhmmss\r\ndate        YYYY-MM-DD\r\n            YY-MM-DD\r\n            YYYYMMDD\r\n            YYMMDD\r\n            YYYYMMDD\r\n            YYMMDD\r\ntime        hh:mm:ss\r\n            hhmmss\r\n            hhmmss\r\nyear        YYYY\r\n            YY\r\n            YYYY\r\n            YY\r\n4. 枚举和集合\r\n-- 枚举(enum) ----------\r\nenum(val1, val2, val3...)\r\n    在已知的值中进行单选。最大数量为65535.\r\n    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。\r\n    表现为字符串类型，存储却是整型。\r\n    NULL值的索引是NULL。\r\n    空字符串错误值的索引值是0。\r\n-- 集合（set） ----------\r\nset(val1, val2, val3...)\r\n    create table tab ( gender set(\'男\', \'女\', \'无\') );\r\n    insert into tab values (\'男, 女\');\r\n    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。\r\n    当创建表时，SET成员值的尾部空格将自动被删除。\r\n```\r\n\r\n### 列属性（列约束）\r\n\r\n```mysql\r\n/* 列属性（列约束） */ ------------------\r\n1. PRIMARY 主键\r\n    - 能唯一标识记录的字段，可以作为主键。\r\n    - 一个表只能有一个主键。\r\n    - 主键具有唯一性。\r\n    - 声明字段时，用 primary key 标识。\r\n        也可以在字段列表之后声明\r\n            例：create table tab ( id int, stu varchar(10), primary key (id));\r\n    - 主键字段的值不能为null。\r\n    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。\r\n        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));\r\n2. UNIQUE 唯一索引（唯一约束）\r\n    使得某字段的值也不能重复。\r\n3. NULL 约束\r\n    null不是数据类型，是列的一个属性。\r\n    表示当前列是否可以为null，表示什么都没有。\r\n    null, 允许为空。默认。\r\n    not null, 不允许为空。\r\n    insert into tab values (null, \'val\');\r\n        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null\r\n4. DEFAULT 默认值属性\r\n    当前字段的默认值。\r\n    insert into tab values (default, \'val\');    -- 此时表示强制使用默认值。\r\n    create table tab ( add_time timestamp default current_timestamp );\r\n        -- 表示将当前时间的时间戳设为默认值。\r\n        current_date, current_time\r\n5. AUTO_INCREMENT 自动增长约束\r\n    自动增长必须为索引（主键或unique）\r\n    只能存在一个字段为自动增长。\r\n    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;\r\n6. COMMENT 注释\r\n    例：create table tab ( id int ) comment \'注释内容\';\r\n7. FOREIGN KEY 外键约束\r\n    用于限制主表与从表数据完整性。\r\n    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);\r\n        -- 将表t1的t1_id外键关联到表t2的id字段。\r\n        -- 每个外键都有一个名字，可以通过 constraint 指定\r\n    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。\r\n    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。\r\n    MySQL中，可以对InnoDB引擎使用外键约束：\r\n    语法：\r\n    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]\r\n    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。\r\n    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。\r\n    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：\r\n    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。\r\n    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。\r\n    3. restrict，拒绝父表删除和更新。\r\n    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。\r\n\r\n```\r\n\r\n### 建表规范\r\n\r\n```mysql\r\n/* 建表规范 */ ------------------\r\n    -- Normal Format, NF\r\n        - 每个表保存一个实体信息\r\n        - 每个具有一个ID字段作为主键\r\n        - ID主键 + 原子表\r\n    -- 1NF, 第一范式\r\n        字段不能再分，就满足第一范式。\r\n    -- 2NF, 第二范式\r\n        满足第一范式的前提下，不能出现部分依赖。\r\n        消除符合主键就可以避免部分依赖。增加单列关键字。\r\n    -- 3NF, 第三范式\r\n        满足第二范式的前提下，不能出现传递依赖。\r\n        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。\r\n        将一个实体信息的数据放在一个表内实现。\r\n```\r\n\r\n### SELECT \r\n\r\n```mysql\r\n/* SELECT */ ------------------\r\nSELECT [ALL|DISTINCT] select_expr FROM -> WHERE -> GROUP BY [合计函数] -> HAVING -> ORDER BY -> LIMIT\r\na. select_expr\r\n    -- 可以用 * 表示所有字段。\r\n        select * from tb;\r\n    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）\r\n        select stu, 29+25, now() from tb;\r\n    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。\r\n        - 使用 as 关键字，也可省略 as.\r\n        select stu+10 as add10 from tb;\r\nb. FROM 子句\r\n    用于标识查询来源。\r\n    -- 可以为表起别名。使用as关键字。\r\n        SELECT * FROM tb1 AS tt, tb2 AS bb;\r\n    -- from子句后，可以同时出现多个表。\r\n        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。\r\n        SELECT * FROM tb1, tb2;\r\n    -- 向优化符提示如何选择索引\r\n        USE INDEX、IGNORE INDEX、FORCE INDEX\r\n        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;\r\n        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;\r\nc. WHERE 子句\r\n    -- 从from获得的数据源中进行筛选。\r\n    -- 整型1表示真，0表示假。\r\n    -- 表达式由运算符和运算数组成。\r\n        -- 运算数：变量（字段）、值、函数返回值\r\n        -- 运算符：\r\n            =, <=>, <>, !=, <=, <, >=, >, !, &&, ||,\r\n            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor\r\n            is/is not 加上ture/false/unknown，检验某个值的真假\r\n            <=>与<>功能相同，<=>可用于null比较\r\nd. GROUP BY 子句, 分组子句\r\n    GROUP BY 字段/别名 [排序方式]\r\n    分组后会进行排序。升序：ASC，降序：DESC\r\n    以下[合计函数]需配合 GROUP BY 使用：\r\n    count 返回不同的非NULL值数目  count(*)、count(字段)\r\n    sum 求和\r\n    max 求最大值\r\n    min 求最小值\r\n    avg 求平均值\r\n    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。\r\ne. HAVING 子句，条件子句\r\n    与 where 功能、用法相同，执行时机不同。\r\n    where 在开始时执行检测数据，对原数据进行过滤。\r\n    having 对筛选出的结果再次进行过滤。\r\n    having 字段必须是查询出来的，where 字段必须是数据表存在的。\r\n    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。\r\n    where 不可以使用合计函数。一般需用合计函数才会用 having\r\n    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。\r\nf. ORDER BY 子句，排序子句\r\n    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...\r\n    升序：ASC，降序：DESC\r\n    支持多个字段的排序。\r\ng. LIMIT 子句，限制结果数量子句\r\n    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。\r\n    limit 起始位置, 获取条数\r\n    省略第一个参数，表示从索引0开始。limit 获取条数\r\nh. DISTINCT, ALL 选项\r\n    distinct 去除重复记录\r\n    默认为 all, 全部记录\r\n```\r\n\r\n###  UNION\r\n\r\n```mysql\r\n/* UNION */ ------------------\r\n    将多个select查询的结果组合成一个结果集合。\r\n    SELECT ... UNION [ALL|DISTINCT] SELECT ...\r\n    默认 DISTINCT 方式，即所有返回的行都是唯一的\r\n    建议，对每个SELECT查询加上小括号包裹。\r\n    ORDER BY 排序时，需加上 LIMIT 进行结合。\r\n    需要各select查询的字段数量一样。\r\n    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。\r\n```\r\n\r\n### 子查询\r\n\r\n```mysql\r\n/* 子查询 */ ------------------\r\n    - 子查询需用括号包裹。\r\n-- from型\r\n    from后要求是一个表，必须给子查询结果取个别名。\r\n    - 简化每个查询内的条件。\r\n    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。\r\n    - 子查询返回一个表，表型子查询。\r\n    select * from (select * from tb where id>0) as subfrom where id>1;\r\n-- where型\r\n    - 子查询返回一个值，标量子查询。\r\n    - 不需要给子查询取别名。\r\n    - where子查询内的表，不能直接用以更新。\r\n    select * from tb where money = (select max(money) from tb);\r\n    -- 列子查询\r\n        如果子查询结果返回的是一列。\r\n        使用 in 或 not in 完成查询\r\n        exists 和 not exists 条件\r\n            如果子查询返回数据，则返回1或0。常用于判断条件。\r\n            select column1 from t1 where exists (select * from t2);\r\n    -- 行子查询\r\n        查询条件是一个行。\r\n        select * from t1 where (id, gender) in (select id, gender from t2);\r\n        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)\r\n        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。\r\n    -- 特殊运算符\r\n    != all()    相当于 not in\r\n    = some()    相当于 in。any 是 some 的别名\r\n    != some()   不等同于 not in，不等于其中某一个。\r\n    all, some 可以配合其他运算符一起使用。\r\n```\r\n\r\n### 连接查询（join）\r\n\r\n```mysql\r\n/* 连接查询(join) */ ------------------\r\n    将多个表的字段进行连接，可以指定连接条件。\r\n-- 内连接(inner join)\r\n    - 默认就是内连接，可省略inner。\r\n    - 只有数据存在时才能发送连接。即连接结果不能出现空行。\r\n    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）\r\n    也可用where表示连接条件。\r\n    还有 using, 但需字段名相同。 using(字段名)\r\n    -- 交叉连接 cross join\r\n        即，没有条件的内连接。\r\n        select * from tb1 cross join tb2;\r\n-- 外连接(outer join)\r\n    - 如果数据不存在，也会出现在连接结果中。\r\n    -- 左外连接 left join\r\n        如果数据不存在，左表记录会出现，而右表为null填充\r\n    -- 右外连接 right join\r\n        如果数据不存在，右表记录会出现，而左表为null填充\r\n-- 自然连接(natural join)\r\n    自动判断连接条件完成连接。\r\n    相当于省略了using，会自动查找相同字段名。\r\n    natural join\r\n    natural left join\r\n    natural right join\r\nselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;\r\n```\r\n\r\n### TRUNCATE \r\n\r\n```mysql\r\n/* TRUNCATE */ ------------------\r\nTRUNCATE [TABLE] tbl_name\r\n清空数据\r\n删除重建表\r\n区别：\r\n1，truncate 是删除表再创建，delete 是逐条删除\r\n2，truncate 重置auto_increment的值。而delete不会\r\n3，truncate 不知道删除了几条，而delete知道。\r\n4，当被用于带分区的表时，truncate 会保留分区\r\n```\r\n\r\n### 备份与还原\r\n\r\n```mysql\r\n/* 备份与还原 */ ------------------\r\n备份，将数据的结构与表内数据保存起来。\r\n利用 mysqldump 指令完成。\r\n-- 导出\r\nmysqldump [options] db_name [tables]\r\nmysqldump [options] ---database DB1 [DB2 DB3...]\r\nmysqldump [options] --all--database\r\n1. 导出一张表\r\n　　mysqldump -u用户名 -p密码 库名 表名 > 文件名(D:/a.sql)\r\n2. 导出多张表\r\n　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 > 文件名(D:/a.sql)\r\n3. 导出所有表\r\n　　mysqldump -u用户名 -p密码 库名 > 文件名(D:/a.sql)\r\n4. 导出一个库\r\n　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 > 文件名(D:/a.sql)\r\n可以-w携带WHERE条件\r\n-- 导入\r\n1. 在登录mysql的情况下：\r\n　　source  备份文件\r\n2. 在不登录的情况下\r\n　　mysql -u用户名 -p密码 库名 < 备份文件\r\n```\r\n\r\n### 视图\r\n\r\n```mysql\r\n什么是视图：\r\n    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。\r\n    视图具有表结构文件，但不存在数据文件。\r\n    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。\r\n    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。\r\n-- 创建视图\r\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement\r\n    - 视图名必须唯一，同时不能与表重名。\r\n    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。\r\n    - 可以指定视图执行的算法，通过ALGORITHM指定。\r\n    - column_list如果存在，则数目必须等于SELECT语句检索的列数\r\n-- 查看结构\r\n    SHOW CREATE VIEW view_name\r\n-- 删除视图\r\n    - 删除视图后，数据依然存在。\r\n    - 可同时删除多个视图。\r\n    DROP VIEW [IF EXISTS] view_name ...\r\n-- 修改视图结构\r\n    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。\r\n    ALTER VIEW view_name [(column_list)] AS select_statement\r\n-- 视图作用\r\n    1. 简化业务逻辑\r\n    2. 对客户端隐藏真实的表结构\r\n-- 视图算法(ALGORITHM)\r\n    MERGE       合并\r\n        将视图的查询语句，与外部查询需要先合并再执行！\r\n    TEMPTABLE   临时表\r\n        将视图执行完毕后，形成临时表，再做外层查询！\r\n    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。\r\n```\r\n\r\n### 事务（transaction）\r\n\r\n```mysql\r\n事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。\r\n    - 支持连续SQL的集体成功或集体撤销。\r\n    - 事务是数据库在数据晚自习方面的一个功能。\r\n    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。\r\n    - InnoDB被称为事务安全型引擎。\r\n-- 事务开启\r\n    START TRANSACTION; 或者 BEGIN;\r\n    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。\r\n-- 事务提交\r\n    COMMIT;\r\n-- 事务回滚\r\n    ROLLBACK;\r\n    如果部分操作发生问题，映射到事务开启前。\r\n-- 事务的特性\r\n    1. 原子性（Atomicity）\r\n        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\r\n    2. 一致性（Consistency）\r\n        事务前后数据的完整性必须保持一致。\r\n        - 事务开始和结束时，外部数据一致\r\n        - 在整个事务过程中，操作是连续的\r\n    3. 隔离性（Isolation）\r\n        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。\r\n    4. 持久性（Durability）\r\n        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。\r\n-- 事务的实现\r\n    1. 要求是事务支持的表类型\r\n    2. 执行一组相关的操作前开启事务\r\n    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。\r\n-- 事务的原理\r\n    利用InnoDB的自动提交(autocommit)特性完成。\r\n    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\r\n    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。\r\n-- 注意\r\n    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。\r\n    2. 事务不能被嵌套\r\n-- 保存点\r\n    SAVEPOINT 保存点名称 -- 设置一个事务保存点\r\n    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点\r\n    RELEASE SAVEPOINT 保存点名称 -- 删除保存点\r\n-- InnoDB自动提交特性设置\r\n    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。\r\n    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。\r\n    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，\r\n        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)\r\n        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)\r\n\r\n```\r\n\r\n### 锁表\r\n\r\n```mysql\r\n/* 锁表 */\r\n表锁定只用于防止其它客户端进行不正当地读取和写入\r\nMyISAM 支持表锁，InnoDB 支持行锁\r\n-- 锁定\r\n    LOCK TABLES tbl_name [AS alias]\r\n-- 解锁\r\n    UNLOCK TABLES\r\n```\r\n\r\n### 触发器\r\n\r\n```mysql\r\n/* 触发器 */ ------------------\r\n    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象\r\n    监听：记录的增加、修改、删除。\r\n-- 创建触发器\r\nCREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt\r\n    参数：\r\n    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。\r\n    trigger_event指明了激活触发程序的语句的类型\r\n        INSERT：将新行插入表时激活触发程序\r\n        UPDATE：更改某一行时激活触发程序\r\n        DELETE：从表中删除某一行时激活触发程序\r\n    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。\r\n    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构\r\n-- 删除\r\nDROP TRIGGER [schema_name.]trigger_name\r\n可以使用old和new代替旧的和新的数据\r\n    更新操作，更新前是old，更新后是new.\r\n    删除操作，只有old.\r\n    增加操作，只有new.\r\n-- 注意\r\n    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。\r\n-- 字符连接函数\r\nconcat(str1,str2,...])\r\nconcat_ws(separator,str1,str2,...)\r\n-- 分支语句\r\nif 条件 then\r\n    执行语句\r\nelseif 条件 then\r\n    执行语句\r\nelse\r\n    执行语句\r\nend if;\r\n-- 修改最外层语句结束符\r\ndelimiter 自定义结束符号\r\n    SQL语句\r\n自定义结束符号\r\ndelimiter ;     -- 修改回原来的分号\r\n-- 语句块包裹\r\nbegin\r\n    语句块\r\nend\r\n-- 特殊的执行\r\n1. 只要添加记录，就会触发程序。\r\n2. Insert into on duplicate key update 语法会触发：\r\n    如果没有重复记录，会触发 before insert, after insert;\r\n    如果有重复记录并更新，会触发 before insert, before update, after update;\r\n    如果有重复记录但是没有发生更新，则触发 before insert, before update\r\n3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert\r\n```\r\n\r\n### SQL编程\r\n\r\n```mysql\r\n/* SQL编程 */ ------------------\r\n--// 局部变量 ----------\r\n-- 变量声明\r\n    declare var_name[,...] type [default value]\r\n    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。\r\n-- 赋值\r\n    使用 set 和 select into 语句为变量赋值。\r\n    - 注意：在函数内是可以使用全局变量（用户自定义的变量）\r\n--// 全局变量 ----------\r\n-- 定义、赋值\r\nset 语句可以定义并为变量赋值。\r\nset @var = value;\r\n也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。\r\n还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。\r\nselect @var:=20;\r\nselect @v1:=id, @v2=name from t1 limit 1;\r\nselect * from tbl_name where @var:=30;\r\nselect into 可以将表中查询获得的数据赋给变量。\r\n    -| select max(height) into @max_height from tb;\r\n-- 自定义变量名\r\n为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。\r\n@var=10;\r\n    - 变量被定义后，在整个会话周期都有效（登录到退出）\r\n--// 控制结构 ----------\r\n-- if语句\r\nif search_condition then\r\n    statement_list   \r\n[elseif search_condition then\r\n    statement_list]\r\n...\r\n[else\r\n    statement_list]\r\nend if;\r\n-- case语句\r\nCASE value WHEN [compare-value] THEN result\r\n[WHEN [compare-value] THEN result ...]\r\n[ELSE result]\r\nEND\r\n-- while循环\r\n[begin_label:] while search_condition do\r\n    statement_list\r\nend while [end_label];\r\n- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。\r\n    -- 退出循环\r\n        退出整个循环 leave\r\n        退出当前循环 iterate\r\n        通过退出的标签决定退出哪个循环\r\n--// 内置函数 ----------\r\n-- 数值函数\r\nabs(x)          -- 绝对值 abs(-10.9) = 10\r\nformat(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46\r\nceil(x)         -- 向上取整 ceil(10.1) = 11\r\nfloor(x)        -- 向下取整 floor (10.1) = 10\r\nround(x)        -- 四舍五入去整\r\nmod(m, n)       -- m%n m mod n 求余 10%3=1\r\npi()            -- 获得圆周率\r\npow(m, n)       -- m^n\r\nsqrt(x)         -- 算术平方根\r\nrand()          -- 随机数\r\ntruncate(x, d)  -- 截取d位小数\r\n-- 时间日期函数\r\nnow(), current_timestamp();     -- 当前日期时间\r\ncurrent_date();                 -- 当前日期\r\ncurrent_time();                 -- 当前时间\r\ndate(\'yyyy-mm-dd hh:ii:ss\');    -- 获取日期部分\r\ntime(\'yyyy-mm-dd hh:ii:ss\');    -- 获取时间部分\r\ndate_format(\'yyyy-mm-dd hh:ii:ss\', \'%d %y %a %d %m %b %j\'); -- 格式化时间\r\nunix_timestamp();               -- 获得unix时间戳\r\nfrom_unixtime();                -- 从时间戳获得时间\r\n-- 字符串函数\r\nlength(string)          -- string长度，字节\r\nchar_length(string)     -- string的字符个数\r\nsubstring(str, position [,length])      -- 从str的position开始,取length个字符\r\nreplace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str\r\ninstr(string ,substring)    -- 返回substring首次在string中出现的位置\r\nconcat(string [,...])   -- 连接字串\r\ncharset(str)            -- 返回字串字符集\r\nlcase(string)           -- 转换成小写\r\nleft(string, length)    -- 从string2中的左边起取length个字符\r\nload_file(file_name)    -- 从文件读取内容\r\nlocate(substring, string [,start_position]) -- 同instr,但可指定开始位置\r\nlpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length\r\nltrim(string)           -- 去除前端空格\r\nrepeat(string, count)   -- 重复count次\r\nrpad(string, length, pad)   --在str后用pad补充,直到长度为length\r\nrtrim(string)           -- 去除后端空格\r\nstrcmp(string1 ,string2)    -- 逐字符比较两字串大小\r\n-- 流程函数\r\ncase when [condition] then result [when [condition] then result ...] [else result] end   多分支\r\nif(expr1,expr2,expr3)  双分支。\r\n-- 聚合函数\r\ncount()\r\nsum();\r\nmax();\r\nmin();\r\navg();\r\ngroup_concat()\r\n-- 其他常用函数\r\nmd5();\r\ndefault();\r\n--// 存储函数，自定义函数 ----------\r\n-- 新建\r\n    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型\r\n        函数体\r\n    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。\r\n    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。\r\n    - 参数部分，由\"参数名\"和\"参数类型\"组成。多个参数用逗号隔开。\r\n    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。\r\n    - 多条语句应该使用 begin...end 语句块包含。\r\n    - 一定要有 return 返回值语句。\r\n-- 删除\r\n    DROP FUNCTION [IF EXISTS] function_name;\r\n-- 查看\r\n    SHOW FUNCTION STATUS LIKE \'partten\'\r\n    SHOW CREATE FUNCTION function_name;\r\n-- 修改\r\n    ALTER FUNCTION function_name 函数选项\r\n--// 存储过程，自定义功能 ----------\r\n-- 定义\r\n存储存储过程 是一段代码（过程），存储在数据库中的sql组成。\r\n一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。\r\n而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。\r\n-- 创建\r\nCREATE PROCEDURE sp_name (参数列表)\r\n    过程体\r\n参数列表：不同于函数的参数列表，需要指明参数类型\r\nIN，表示输入型\r\nOUT，表示输出型\r\nINOUT，表示混合型\r\n注意，没有返回值。\r\n```\r\n\r\n### 存储过程\r\n\r\n```mysql\r\n/* 存储过程 */ ------------------\r\n存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。\r\n调用：CALL 过程名\r\n-- 注意\r\n- 没有返回值。\r\n- 只能单独调用，不可夹杂在其他语句中\r\n-- 参数\r\nIN|OUT|INOUT 参数名 数据类型\r\nIN      输入：在调用过程中，将数据输入到过程体内部的参数\r\nOUT     输出：在调用过程中，将过程体处理完的结果返回到客户端\r\nINOUT   输入输出：既可输入，也可输出\r\n-- 语法\r\nCREATE PROCEDURE 过程名 (参数列表)\r\nBEGIN\r\n    过程体\r\nEND\r\n```\r\n\r\n### 用户和权限管理\r\n\r\n```mysql\r\n/* 用户和权限管理 */ ------------------\r\n-- root密码重置\r\n1. 停止MySQL服务\r\n2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &\r\n    [Windows] mysqld --skip-grant-tables\r\n3. use mysql;\r\n4. UPDATE `user` SET PASSWORD=PASSWORD(\"密码\") WHERE `user` = \"root\";\r\n5. FLUSH PRIVILEGES;\r\n用户信息表：mysql.user\r\n-- 刷新权限\r\nFLUSH PRIVILEGES;\r\n-- 增加用户\r\nCREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)\r\n    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。\r\n    - 只能创建用户，不能赋予权限。\r\n    - 用户名，注意引号：如 \'user_name\'@\'192.168.1.1\'\r\n    - 密码也需引号，纯数字密码也要加引号\r\n    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD\r\n-- 重命名用户\r\nRENAME USER old_user TO new_user\r\n-- 设置密码\r\nSET PASSWORD = PASSWORD(\'密码\')  -- 为当前用户设置密码\r\nSET PASSWORD FOR 用户名 = PASSWORD(\'密码\') -- 为指定用户设置密码\r\n-- 删除用户\r\nDROP USER 用户名\r\n-- 分配权限/添加用户\r\nGRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] \'password\']\r\n    - all privileges 表示所有权限\r\n    - *.* 表示所有库的所有表\r\n    - 库名.表名 表示某库下面的某表\r\n    GRANT ALL PRIVILEGES ON `pms`.* TO \'pms\'@\'%\' IDENTIFIED BY \'pms0817\';\r\n-- 查看权限\r\nSHOW GRANTS FOR 用户名\r\n    -- 查看当前用户权限\r\n    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();\r\n-- 撤消权限\r\nREVOKE 权限列表 ON 表名 FROM 用户名\r\nREVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限\r\n-- 权限层级\r\n-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。\r\n全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user\r\n    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。\r\n数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host\r\n    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。\r\n表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv\r\n    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。\r\n列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv\r\n    当使用REVOKE时，您必须指定与被授权列相同的列。\r\n-- 权限列表\r\nALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限\r\nALTER   -- 允许使用ALTER TABLE\r\nALTER ROUTINE   -- 更改或取消已存储的子程序\r\nCREATE  -- 允许使用CREATE TABLE\r\nCREATE ROUTINE  -- 创建已存储的子程序\r\nCREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE\r\nCREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。\r\nCREATE VIEW     -- 允许使用CREATE VIEW\r\nDELETE  -- 允许使用DELETE\r\nDROP    -- 允许使用DROP TABLE\r\nEXECUTE     -- 允许用户运行已存储的子程序\r\nFILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE\r\nINDEX   -- 允许使用CREATE INDEX和DROP INDEX\r\nINSERT  -- 允许使用INSERT\r\nLOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES\r\nPROCESS     -- 允许使用SHOW FULL PROCESSLIST\r\nREFERENCES  -- 未被实施\r\nRELOAD  -- 允许使用FLUSH\r\nREPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址\r\nREPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）\r\nSELECT  -- 允许使用SELECT\r\nSHOW DATABASES  -- 显示所有数据库\r\nSHOW VIEW   -- 允许使用SHOW CREATE VIEW\r\nSHUTDOWN    -- 允许使用mysqladmin shutdown\r\nSUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。\r\nUPDATE  -- 允许使用UPDATE\r\nUSAGE   -- “无权限”的同义词\r\nGRANT OPTION    -- 允许授予权限\r\n```\r\n\r\n### 表维护\r\n\r\n```mysql\r\n/* 表维护 */\r\n-- 分析和存储表的关键字分布\r\nANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...\r\n-- 检查一个或多个表是否有错误\r\nCHECK TABLE tbl_name [, tbl_name] ... [option] ...\r\noption = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}\r\n-- 整理数据文件的碎片\r\nOPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...\r\n```\r\n\r\n### 杂项\r\n\r\n```mysql\r\n/* 杂项 */ ------------------\r\n1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！\r\n2. 每个库目录存在一个保存当前数据库的选项文件db.opt。\r\n3. 注释：\r\n    单行注释 # 注释内容\r\n    多行注释 /* 注释内容 */\r\n    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)\r\n4. 模式通配符：\r\n    _   任意单个字符\r\n    %   任意多个字符，甚至包括零字符\r\n    单引号需要进行转义 \\\'\r\n5. CMD命令行内的语句结束符可以为 \";\", \"\\G\", \"\\g\"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。\r\n6. SQL对大小写不敏感\r\n7. 清除已有语句：\\c\r\n```\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (221, 'MySQL 一条sql语句是如何在mysql中执行的', 7, '本文来自[木木匠](https://github.com/kinglaw1204)投稿，[SnailClimb](https://github.com/Snailclimb) 对本文进行了内容和排版进行了修改完善。\r\n\r\n<!-- TOC -->\r\n\r\n- [一 MySQL 基础架构分析](#一 MySQL 基础架构分析)\r\n    - [1.1 MySQL 基本架构概览](#1.1 MySQL 基本架构概览)\r\n    - [1.2 Server 层基本组件介绍](#1.2 Server 层基本组件介绍)\r\n        - [1) 连接器](#1）连接器)\r\n        - [2) 查询缓存(MySQL 8.0 版本后移除)](#2）查询缓存（MySQL 8.0 版本后移除）)\r\n        - [3) 分析器](#3）分析器)\r\n        - [4) 优化器](#4）优化器)\r\n        - [5) 执行器](#5）执行器)\r\n- [二 语句分析](#[二 语句分析)\r\n    - [2.1 查询语句](#2.1 查询语句)\r\n    - [2.2 更新语句](#2.2 更新语句)\r\n- [三 总结](#三 总结)\r\n- [四 参考](#四 参考)\r\n\r\n<!-- /TOC -->\r\n\r\n本篇文章会分析下一个 sql 语句在 MySQL 中的执行流程，包括 sql 的查询在 MySQL 内部会怎么流转，sql 语句的更新是怎么完成的。\r\n\r\n在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成已经这些组件的作用是什么，可以帮助我们理解和解决这些问题。\r\n\r\n## 一 MySQL 基础架构分析\r\n\r\n### 1.1 MySQL 基本架构概览\r\n\r\n下图是 MySQL  的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。\r\n\r\n先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。\r\n\r\n- **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。\r\n- **查询缓存:**  执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。\r\n- **分析器:**  没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。\r\n- **优化器：**  按照 MySQL 认为最优的方案去执行。\r\n- **执行器:** 执行语句，然后从存储引擎返回数据。\r\n\r\n![](https://user-gold-cdn.xitu.io/2019/3/23/169a8bc60a083849?w=950&h=1062&f=jpeg&s=38189)\r\n\r\n简单来说 MySQL  主要分为 Server 层和存储引擎层：\r\n\r\n- **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。\r\n- **存储引擎**： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**\r\n\r\n### 1.2 Server 层基本组件介绍\r\n\r\n#### 1）连接器\r\n\r\n连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。\r\n\r\n主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。\r\n\r\n#### 2）查询缓存（MySQL 8.0 版本后移除）\r\n\r\n查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。\r\n\r\n连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。\r\n\r\nMySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。\r\n\r\n所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。\r\n\r\nMySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。\r\n\r\n#### 3）分析器\r\n\r\nMySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：\r\n\r\n**第一步，词法分析**，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。\r\n\r\n**第二步，语法分析**，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。\r\n\r\n完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。\r\n\r\n#### 4）优化器\r\n\r\n优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。\r\n\r\n可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。\r\n\r\n#### 5）执行器\r\n\r\n当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。\r\n\r\n## 二 语句分析\r\n\r\n### 2.1 查询语句\r\n\r\n说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为 2 中，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：\r\n\r\n```sql\r\nselect * from tb_student  A where A.age=\'18\' and A.name=\' 张三 \';\r\n```\r\n\r\n结合上面的说明，我们分析下这个语句的执行流程：\r\n\r\n* 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。\r\n* 通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id=\'1\'。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。\r\n* 接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：\r\n  \r\n        a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。\r\n        b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。\r\n    那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。\r\n\r\n* 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。\r\n\r\n### 2.2 更新语句\r\n\r\n以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：\r\n\r\n```\r\nupdate tb_student A set A.age=\'19\' where A.name=\' 张三 \';\r\n```\r\n我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 **binlog（归档日志）** ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 **redo log（重做日志）**，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：\r\n\r\n* 先查询到张三这一条数据，如果有缓存，也是会用到缓存。\r\n* 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。\r\n* 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。\r\n* 更新完成。\r\n\r\n**这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?**\r\n\r\n这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。\r\n\r\n并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？\r\n\r\n* **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。\r\n* **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。\r\n\r\n如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？\r\n这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：\r\n\r\n* 判断 redo log 是否完整，如果判断是完整的，就立即提交。\r\n* 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。\r\n\r\n这样就解决了数据一致性的问题。\r\n\r\n## 三 总结\r\n\r\n* MySQL 主要分为 Server 曾和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。\r\n* 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。\r\n* SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎\r\n* 对于更新等语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit\r\n\r\n## 四 参考\r\n\r\n* 《一起构建 MySQL 知识网络》\r\n* MySQL 5.6参考手册:<https://dev.MySQL.com/doc/refman/5.6/en/>\r\n', 0);
INSERT INTO `blog_course` VALUES (222, 'Docker 简介与安装', 10, '<!-- TOC -->\r\n\r\n- [前言](#前言)\r\n- [1. Docker 简介](#1. Docker 简介)\r\n    - [1.1 什么是 Docker](#1.1 什么是 Docker)\r\n    - [1.2 为什么要使用 Docker](#1.2 为什么要使用 Docker)\r\n- [2. Docker 基本概念](#2. Docker 基本概念)\r\n    - [2.1 Docker 引擎](#2.1 Docker 引擎)\r\n    - [2.2 Docker 架构](#2.2 Docker 架构)\r\n    - [2.3 Docker 镜像](#2.3 Docker 镜像)\r\n    - [2.4 Docker 容器](#2.4 Docker 容器)\r\n    - [2.5 Docker 仓库](#2.5 Docker 仓库)\r\n- [3. 安装 Docker](#3. 安装 Docker)\r\n    - [3.1 Ubuntu 安装 Docker](#3.1 Ubuntu 安装 Docker)\r\n        - [准备工作](#准备工作-Ubuntu)\r\n            - [系统要求](#系统要求-Ubuntu)\r\n            - [卸载旧版本](#卸载旧版本-Ubuntu)\r\n            - [Ubuntu 14.04 可选内核模块](#Ubuntu 14.04 可选内核模块)\r\n            - [Ubuntu 16.04 +](#Ubuntu 16.04 +)\r\n        - [使用 APT 安装](#使用 APT 安装-Ubuntu)\r\n            - [安装必要的一些系统工具](#安装必要的一些系统工具-Ubuntu)\r\n            - [安装 GPG 证书](#安装 GPG 证书-Ubuntu)\r\n            - [写入软件源信息](#写入软件源信息-Ubuntu)\r\n            - [更新并安装 Docker CE](#更新并安装 Docker CE-Ubuntu)\r\n        - [使用脚本自动安装](#使用脚本自动安装-Ubuntu)\r\n            - [特别说明](#特别说明-Ubuntu)\r\n        - [启动 Docker CE](#启动 Docker CE-Ubuntu)\r\n        - [建立 docker 用户组](#建立 docker 用户组-Ubuntu)\r\n        - [测试 Docker 是否安装正确](#测试 Docker 是否安装正确-Ubuntu)\r\n        - [镜像加速](#镜像加速-Ubuntu)\r\n        - [参考文档](#参考文档-Ubuntu)\r\n    - [3.2 CentOS 安装 Docker](#3.2 CentOS 安装 Docker)\r\n        - [准备工作](#准备工作-Centos)\r\n            - [系统要求](#系统要求-Centos)\r\n            - [卸载旧版本](#卸载旧版本-Centos)\r\n        - [使用 yum 安装](#使用 yum 安装-Centos)\r\n            - [安装 Docker CE](#安装 Docker CE-Centos)\r\n        - [使用脚本自动安装](#使用脚本自动安装-Centos)\r\n        - [启动 Docker CE](#启动 Docker CE-Centos)\r\n        - [建立 docker 用户组](#建立 docker 用户组-Centos)\r\n        - [测试 Docker 是否安装正确](#测试 Docker 是否安装正确]-Centos)\r\n        - [镜像加速](#镜像加速-Centos)\r\n        - [添加内核参数](#添加内核参数-Centos)\r\n        - [参考文档](#参考文档-Centos)\r\n    - [3.3 树莓派卡片电脑安装 Docker](#3.3 树莓派卡片电脑安装 Docker)\r\n        - [系统要求](#系统要求-树莓派)\r\n        - [使用 APT 安装](#使用 APT 安装-树莓派-树莓派)\r\n            - [安装 Docker CE](#安装 Docker CE-树莓派)\r\n        - [使用脚本自动安装](#使用脚本自动安装-树莓派)\r\n        - [启动 Docker CE](#启动 Docker CE-树莓派)\r\n        - [建立 docker 用户组](#建立 docker 用户组-树莓派)\r\n        - [测试 Docker 是否安装正确](#测试 Docker 是否安装正确-树莓派)\r\n        - [镜像加速](#镜像加速-树莓派)\r\n    - [3.4 macOS 安装 Docker](#3.4 macOS 安装 Docker)\r\n        - [系统要求](#系统要求-macOs)\r\n        - [安装](#安装-macOs)\r\n            - [使用 Homebrew 安装](#使用 Homebrew 安装)\r\n            - [手动下载安装](#手动下载安装)\r\n        - [运行](#运行-macOs)\r\n        - [镜像加速](#镜像加速-macOs)\r\n    - [3.5 Windows 安装 Docker](#3.5 Windows 安装 Docker)\r\n        - [系统要求](#系统要求-Windows)\r\n        - [安装](#安装-Windows)\r\n        - [运行](#运行-Windows)\r\n        - [镜像加速](#镜像加速-Windows)\r\n    - [3.6 Docker 镜像加速器](#3.6 Docker 镜像加速器)\r\n        - [Ubuntu 14.04、Debian 7 Wheezy](#Ubuntu 14.04、Debian 7 Wheezy)\r\n        - [Ubuntu 16.04+、Debian 8+、CentOS 7](#Ubuntu 16.04+、Debian 8+、CentOS 7)\r\n        - [Windows 10](#Windows 10)\r\n        - [macOS](#macOS)\r\n        - [检查加速器是否生效](#检查加速器是否生效)\r\n\r\n<!-- /TOC -->\r\n# 前言\r\n\r\nDocker 容器化引擎，更详细请转向：[Docker_Tutorial: Docker 容器化引擎入门手册](https://github.com/frank-lam/Docker_Tutorial)\r\n\r\n> 参考资料：\r\n>\r\n> - http://www.funtl.com/\r\n> - [Docker —— 从入门到实践](https://yeasy.gitbooks.io/docker_practice/content/)\r\n>\r\n> 基于以上部分内容做一定的修改\r\n\r\n# 1. Docker 简介\r\n\r\n## 1.1 什么是 Docker\r\n\r\nDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 [2013 年 3 月以 Apache 2.0 授权协议开源](https://en.wikipedia.org/wiki/Docker_(software))，主要项目代码在 [GitHub](https://github.com/moby/moby) 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 [开放容器联盟（OCI）](https://www.opencontainers.org/)。\r\n\r\nDocker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，[dotCloud 公司决定改名为 Docker](https://blog.docker.com/2013/10/dotcloud-is-becoming-docker-inc/)。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\r\n\r\nDocker 使用 Google 公司推出的 [Go 语言](https://golang.org/) 进行开发实现，基于 Linux 内核的 [cgroup](https://zh.wikipedia.org/wiki/Cgroups)，[namespace](https://en.wikipedia.org/wiki/Linux_namespaces)，以及 [AUFS](https://en.wikipedia.org/wiki/Aufs) 类的 [Union FS](https://en.wikipedia.org/wiki/Union_mount) 等技术，对进程进行封装隔离，属于 [操作系统层面的虚拟化技术](https://en.wikipedia.org/wiki/Operating-system-level_virtualization)。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 [LXC](https://linuxcontainers.org/lxc/introduction/)，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 [libcontainer](https://github.com/docker/libcontainer)，从 1.11 开始，则进一步演进为使用 [runC](https://github.com/opencontainers/runc) 和 [containerd](https://github.com/containerd/containerd)。\r\n\r\nDocker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。\r\n\r\n下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\r\n\r\n![img](assets/virtualization.png)\r\n\r\n![img](assets/docker.png)\r\n\r\n\r\n\r\n## 1.2 为什么要使用 Docker\r\n\r\n作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。\r\n\r\n**更高效的利用系统资源**\r\n\r\n由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\r\n\r\n**更快速的启动时间**\r\n\r\n传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。\r\n\r\n**一致的运行环境**\r\n\r\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 *「这段代码在我机器上没问题啊」* 这类问题。\r\n\r\n**持续交付和部署**\r\n\r\n对开发和运维（[DevOps](https://zh.wikipedia.org/wiki/DevOps)）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\r\n\r\n使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 `Dockerfile` 来进行镜像构建，并结合 [持续集成(Continuous Integration)](https://en.wikipedia.org/wiki/Continuous_integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 [持续部署(Continuous Delivery/Deployment)](https://en.wikipedia.org/wiki/Continuous_delivery) 系统进行自动部署。\r\n\r\n而且使用 `Dockerfile` 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\r\n\r\n**更轻松的迁移**\r\n\r\n由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\r\n\r\n**更轻松的维护和扩展**\r\n\r\nDocker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 [官方镜像](https://store.docker.com/search?q=&source=verified&type=image)，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\r\n\r\n**对比传统虚拟机总结**\r\n\r\n| 特性       | 容器               | 虚拟机      |\r\n| ---------- | ------------------ | ----------- |\r\n| 启动       | 秒级               | 分钟级      |\r\n| 硬盘使用   | 一般为 `MB`        | 一般为 `GB` |\r\n| 性能       | 接近原生           | 弱于        |\r\n| 系统支持量 | 单机支持上千个容器 | 一般几十个  |\r\n\r\n# 2. Docker 基本概念\r\n\r\nDocker 包括三个基本概念\r\n\r\n- 镜像（`Image`）\r\n- 容器（`Container`）\r\n- 仓库（`Repository`）\r\n\r\n理解了这三个概念，就理解了 Docker 的整个生命周期。\r\n\r\n## 2.1 Docker 引擎\r\n\r\nDocker 引擎是一个包含以下主要组件的客户端服务器应用程序。\r\n\r\n- 一种服务器，它是一种称为守护进程并且长时间运行的程序。\r\n- REST API 用于指定程序可以用来与守护进程通信的接口，并指示它做什么。\r\n- 一个有命令行界面 (CLI) 工具的客户端。\r\n\r\nDocker 引擎组件的流程如下图所示：\r\n\r\n![img](assets/620140640_31678.png)\r\n\r\n\r\n\r\n## 2.2 Docker 架构\r\n\r\nDocker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。\r\n\r\nDocker 容器通过 Docker 镜像来创建。\r\n\r\n**容器与镜像**的关系类似于**面向对象**编程中的**对象与类**。\r\n\r\n| Docker | 面向对象 |\r\n| ------ | -------- |\r\n| 容器   | 对象     |\r\n| 镜像   | 类       |\r\n\r\n![img](assets/262150629_86976.png)\r\n\r\n| 标题                | 说明                                                         |\r\n| ------------------- | ------------------------------------------------------------ |\r\n| **镜像**(Images)    | Docker 镜像是用于创建 Docker 容器的模板。                    |\r\n| **容器**(Container) | 容器是独立运行的一个或一组应用。                             |\r\n| **客户端**(Client)  | Docker 客户端通过命令行或者其他工具使用 Docker API (<https://docs.docker.com/reference/api/docker_remote_api>) 与 Docker 的守护进程通信。 |\r\n| **主机**(Host)      | 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。       |\r\n| **仓库**(Registry)  | Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub([https://hub.docker.com](https://hub.docker.com/)) 提供了庞大的镜像集合供使用。 |\r\n| **Docker Machine**  | Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 |\r\n\r\n## 2.3 Docker 镜像\r\n\r\n我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 `root` 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 `root` 文件系统。比如官方镜像 `ubuntu:16.04` 就包含了完整的一套 Ubuntu 16.04 最小系统的 `root` 文件系统。\r\n\r\nDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\r\n\r\n**分层存储**\r\n\r\n因为镜像包含操作系统完整的 `root` 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 [Union FS](https://en.wikipedia.org/wiki/Union_mount) 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。\r\n\r\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\r\n\r\n分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。\r\n\r\n关于镜像构建，将会在后续相关章节中做进一步的讲解。\r\n\r\n## 2.4 Docker 容器\r\n\r\n镜像（`Image`）和容器（`Container`）的关系，就像是面向对象程序设计中的 `类` 和 `实例` 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\r\n\r\n容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 [命名空间](https://en.wikipedia.org/wiki/Linux_namespaces)。因此容器可以拥有自己的 `root` 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。\r\n\r\n前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为**容器存储层**。\r\n\r\n容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\r\n\r\n按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 `数据卷（Volume）`、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。\r\n\r\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。\r\n\r\n## 2.5 Docker 仓库\r\n\r\n镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，`Docker Registry` 就是这样的服务。\r\n\r\n一个 **Docker Registry** 中可以包含多个**仓库**（`Repository`）；每个仓库可以包含多个**标签**（`Tag`）；每个标签对应一个镜像。\r\n\r\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 `latest` 作为默认标签。\r\n\r\n以 [Ubuntu 镜像](https://store.docker.com/images/ubuntu) 为例，`ubuntu` 是仓库的名字，其内包含有不同的版本标签，如，`14.04`, `16.04`。我们可以通过 `ubuntu:14.04`，或者 `ubuntu:16.04` 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 `ubuntu`，那将视为 `ubuntu:latest`。\r\n\r\n仓库名经常以 *两段式路径* 形式出现，比如 `jwilder/nginx-proxy`，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。\r\n\r\n**公有 Docker Registry**\r\n\r\nDocker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。\r\n\r\n最常使用的 Registry 公开服务是官方的 [Docker Hub](https://hub.docker.com/)，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 [CoreOS](https://coreos.com/) 的 [Quay.io](https://quay.io/repository/)，CoreOS 相关的镜像存储在这里；Google 的 [Google Container Registry](https://cloud.google.com/container-registry/)，[Kubernetes](http://kubernetes.io/) 的镜像使用的就是这个服务。\r\n\r\n由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（`Registry Mirror`），这些镜像服务被称为**加速器**。常见的有 [阿里云加速器](https://cr.console.aliyun.com/#/accelerator)、[DaoCloud 加速器](https://www.daocloud.io/mirror#accelerator-doc) 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。\r\n\r\n国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 [时速云镜像仓库](https://hub.tenxcloud.com/)、[网易云镜像服务](https://c.163.com/hub#/m/library/)、[DaoCloud 镜像市场](https://hub.daocloud.io/)、[阿里云镜像库](https://cr.console.aliyun.com/) 等。\r\n\r\n**私有 Docker Registry**\r\n\r\n除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 [Docker Registry](https://store.docker.com/images/registry/) 镜像，可以直接使用做为私有 Registry 服务。\r\n\r\n开源的 Docker Registry 镜像只提供了 [Docker Registry API](https://docs.docker.com/registry/spec/api/) 的服务端实现，足以支持 `docker` 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 [Docker Trusted Registry](https://docs.docker.com/datacenter/dtr/2.0/) 中，提供了这些高级功能。\r\n\r\n除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，[VMWare Harbor](https://github.com/vmware/harbor) 和 [Sonatype Nexus](https://www.sonatype.com/docker)。\r\n\r\n# 3. 安装 Docker\r\n\r\nDocker 在 1.13 版本之后，从 2017 年的 3 月 1 日开始，版本命名规则变为如下：\r\n\r\n| 项目        | 说明         |\r\n| ----------- | ------------ |\r\n| 版本格式    | YY.MM        |\r\n| Stable 版本 | 每个季度发行 |\r\n| Edge 版本   | 每个月发行   |\r\n\r\n同时 Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。\r\n\r\nDocker CE 每月发布一个 Edge 版本 (17.03, 17.04, 17.05…)，每三个月发布一个 Stable 版本 (17.03, 17.06, 17.09…)，Docker EE 和 Stable 版本号保持一致，但每个版本提供一年维护。\r\n\r\n官方网站上有各种环境下的 [安装指南](https://docs.docker.com/engine/installation/)，这里主要介绍 Docker CE 在 Linux 、Windows 10 (PC) 和 macOS 上的安装。\r\n\r\n## 3.1 Ubuntu 安装 Docker\r\n\r\n> 警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.\r\n\r\n### 准备工作-Ubuntu\r\n\r\n#### 系统要求-Ubuntu\r\n\r\nDocker CE 支持以下版本的 [Ubuntu](https://www.ubuntu.com/server) 操作系统：\r\n\r\n- Artful 17.10 (Docker CE 17.11 Edge +)\r\n- Xenial 16.04 (LTS)\r\n- Trusty 14.04 (LTS)\r\n\r\nDocker CE 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本,当前最新的 LTS 版本为 Ubuntu 16.04。\r\n\r\n#### 卸载旧版本-Ubuntu\r\n\r\n旧版本的 Docker 称为 `docker` 或者 `docker-engine`，使用以下命令卸载旧版本：\r\n\r\n```\r\n$ sudo apt-get remove docker \\\r\n               docker-engine \\\r\n               docker.io\r\n```\r\n\r\n#### Ubuntu 14.04 可选内核模块\r\n\r\n从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (`linux-image-extra-*`) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。`AUFS` 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 `AUFS`。\r\n\r\n如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：\r\n\r\n```\r\n$ sudo apt-get update\r\n\r\n$ sudo apt-get install \\\r\n    linux-image-extra-$(uname -r) \\\r\n    linux-image-extra-virtual\r\n```\r\n\r\n#### Ubuntu 16.04 +\r\n\r\nUbuntu 16.04 + 上的 Docker CE 默认使用 `overlay2` 存储层驱动,无需手动配置。\r\n\r\n### 使用 APT 安装-Ubuntu\r\n\r\n#### 安装必要的一些系统工具-Ubuntu\r\n\r\n```\r\nsudo apt-get update\r\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common\r\n```\r\n\r\n#### 安装 GPG 证书-Ubuntu\r\n\r\n```\r\ncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\r\n```\r\n\r\n#### 写入软件源信息-Ubuntu\r\n\r\n```\r\nsudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\r\n```\r\n\r\n#### 更新并安装 Docker CE-Ubuntu\r\n\r\n```\r\nsudo apt-get -y update\r\nsudo apt-get -y install docker-ce\r\n```\r\n\r\n> 以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新或者测试版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。\r\n\r\n### 使用脚本自动安装-Ubuntu\r\n\r\n在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：\r\n\r\n```\r\n$ curl -fsSL get.docker.com -o get-docker.sh\r\n# 可能会出现 404 错误，请移步下面的特别说明\r\n$ sudo sh get-docker.sh --mirror Aliyun\r\n```\r\n\r\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。\r\n\r\n#### 特别说明-Ubuntu\r\n\r\n2018 年 7 月 21 日，貌似阿里云这边在做调整，故导致 Docker 的 Aliyun 安装脚本不可用，是永久性还是临时性的尚不清除，如果你已经按照之前的操作安装 Docker，请按以下步骤进行修复并重新安装\r\n\r\n- 如果已经使用了 Aliyun 脚本安装并成功的\r\n  - 请先卸载 Docker，命令为：`apt-get autoremove docker-ce`\r\n  - 删除 `/etc/apt/sources.list.d` 目录下的 `docker.list` 文件\r\n- 使用 `AzureChinaCloud` 镜像脚本重新安装，命令为：`sudo sh get-docker.sh --mirror AzureChinaCloud`\r\n\r\n### 启动 Docker CE-Ubuntu\r\n\r\n```\r\n$ sudo systemctl enable docker\r\n$ sudo systemctl start docker\r\n```\r\n\r\nUbuntu 14.04 请使用以下命令启动：\r\n\r\n```\r\n$ sudo service docker start\r\n```\r\n\r\n### 建立 docker 用户组-Ubuntu\r\n\r\n默认情况下，`docker` 命令会使用 [Unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket) 与 Docker 引擎通讯。而只有 `root` 用户和 `docker` 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 `root` 用户。因此，更好地做法是将需要使用 `docker` 的用户加入 `docker` 用户组。\r\n\r\n建立 `docker` 组：\r\n\r\n```\r\n$ sudo groupadd docker\r\n```\r\n\r\n将当前用户加入 `docker` 组：\r\n\r\n```\r\n$ sudo usermod -aG docker $USER\r\n```\r\n\r\n退出当前终端并重新登录，进行如下测试。\r\n\r\n### 测试 Docker 是否安装正确-Ubuntu\r\n\r\n```\r\n$ docker run hello-world\r\n\r\nUnable to find image \'hello-world:latest\' locally\r\nlatest: Pulling from library/hello-world\r\nca4f61b1923c: Pull complete\r\nDigest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c\r\nStatus: Downloaded newer image for hello-world:latest\r\n\r\nHello from Docker!\r\nThis message shows that your installation appears to be working correctly.\r\n\r\nTo generate this message, Docker took the following steps:\r\n 1. The Docker client contacted the Docker daemon.\r\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\r\n    (amd64)\r\n 3. The Docker daemon created a new container from that image which runs the\r\n    executable that produces the output you are currently reading.\r\n 4. The Docker daemon streamed that output to the Docker client, which sent it\r\n    to your terminal.\r\n\r\nTo try something more ambitious, you can run an Ubuntu container with:\r\n $ docker run -it ubuntu bash\r\n\r\nShare images, automate workflows, and more with a free Docker ID:\r\n https://cloud.docker.com/\r\n\r\nFor more examples and ideas, visit:\r\n https://docs.docker.com/engine/userguide/\r\n```\r\n\r\n若能正常输出以上信息，则说明安装成功。\r\n\r\n### 镜像加速-Ubuntu\r\n\r\n鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 `国内镜像加速`。\r\n\r\n### 参考文档-Ubuntu\r\n\r\n- [Docker 官方 Ubuntu 安装文档](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/)\r\n\r\n## 3.2 CentOS 安装 Docker\r\n\r\n> 警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.\r\n\r\n### 准备工作-Centos\r\n\r\n#### 系统要求-Centos\r\n\r\nDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 `overlay2` 存储层驱动）无法使用，并且部分功能可能不太稳定。\r\n\r\n#### 卸载旧版本-Centos\r\n\r\n旧版本的 Docker 称为 `docker` 或者 `docker-engine`，使用以下命令卸载旧版本：\r\n\r\n```\r\n$ sudo yum remove docker \\\r\n                  docker-client \\\r\n                  docker-client-latest \\\r\n                  docker-common \\\r\n                  docker-latest \\\r\n                  docker-latest-logrotate \\\r\n                  docker-logrotate \\\r\n                  docker-selinux \\\r\n                  docker-engine-selinux \\\r\n                  docker-engine\r\n```\r\n\r\n### 使用 yum 安装-Centos\r\n\r\n执行以下命令安装依赖包：\r\n\r\n```\r\n$ sudo yum install -y yum-utils \\\r\n           device-mapper-persistent-data \\\r\n           lvm2\r\n```\r\n\r\n鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。\r\n\r\n执行下面的命令添加 `yum` 软件源：\r\n\r\n```\r\n$ sudo yum-config-manager \\\r\n    --add-repo \\\r\n    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo\r\n\r\n\r\n# 官方源\r\n# $ sudo yum-config-manager \\\r\n#     --add-repo \\\r\n#     https://download.docker.com/linux/centos/docker-ce.repo    \r\n```\r\n\r\n如果需要最新版本的 Docker CE 请使用以下命令：\r\n\r\n```\r\n$ sudo yum-config-manager --enable docker-ce-edge\r\n```\r\n\r\n如果需要测试版本的 Docker CE 请使用以下命令：\r\n\r\n```\r\n$ sudo yum-config-manager --enable docker-ce-test\r\n```\r\n\r\n#### 安装 Docker CE-Centos\r\n\r\n更新 `yum` 软件源缓存，并安装 `docker-ce`。\r\n\r\n```\r\n$ sudo yum makecache fast\r\n$ sudo yum install docker-ce\r\n```\r\n\r\n### 使用脚本自动安装-Centos\r\n\r\n在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：\r\n\r\n```\r\n$ curl -fsSL get.docker.com -o get-docker.sh\r\n$ sudo sh get-docker.sh --mirror Aliyun\r\n```\r\n\r\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。\r\n\r\n### 启动 Docker CE-Centos\r\n\r\n```\r\n$ sudo systemctl enable docker\r\n$ sudo systemctl start docker\r\n```\r\n\r\n### 建立 docker 用户组-Centos\r\n\r\n默认情况下，`docker` 命令会使用 [Unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket) 与 Docker 引擎通讯。而只有 `root` 用户和 `docker` 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 `root` 用户。因此，更好地做法是将需要使用 `docker` 的用户加入 `docker` 用户组。\r\n\r\n建立 `docker` 组：\r\n\r\n```\r\n$ sudo groupadd docker\r\n```\r\n\r\n将当前用户加入 `docker` 组：\r\n\r\n```\r\n$ sudo usermod -aG docker $USER\r\n```\r\n\r\n退出当前终端并重新登录，进行如下测试。\r\n\r\n### 测试 Docker 是否安装正确-Centos\r\n\r\n```\r\n$ docker run hello-world\r\n\r\nUnable to find image \'hello-world:latest\' locally\r\nlatest: Pulling from library/hello-world\r\nca4f61b1923c: Pull complete\r\nDigest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c\r\nStatus: Downloaded newer image for hello-world:latest\r\n\r\nHello from Docker!\r\nThis message shows that your installation appears to be working correctly.\r\n\r\nTo generate this message, Docker took the following steps:\r\n 1. The Docker client contacted the Docker daemon.\r\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\r\n    (amd64)\r\n 3. The Docker daemon created a new container from that image which runs the\r\n    executable that produces the output you are currently reading.\r\n 4. The Docker daemon streamed that output to the Docker client, which sent it\r\n    to your terminal.\r\n\r\nTo try something more ambitious, you can run an Ubuntu container with:\r\n $ docker run -it ubuntu bash\r\n\r\nShare images, automate workflows, and more with a free Docker ID:\r\n https://cloud.docker.com/\r\n\r\nFor more examples and ideas, visit:\r\n https://docs.docker.com/engine/userguide/\r\n```\r\n\r\n若能正常输出以上信息，则说明安装成功。\r\n\r\n### 镜像加速-Centos\r\n\r\n鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 `国内镜像加速`。\r\n\r\n### 添加内核参数-Centos\r\n\r\n默认配置下，如果在 CentOS 使用 Docker CE 看到下面的这些警告信息：\r\n\r\n```\r\nWARNING: bridge-nf-call-iptables is disabled\r\nWARNING: bridge-nf-call-ip6tables is disabled\r\n```\r\n\r\n请添加内核配置参数以启用这些功能。\r\n\r\n```\r\n$ sudo tee -a /etc/sysctl.conf <<-EOF\r\nnet.bridge.bridge-nf-call-ip6tables = 1\r\nnet.bridge.bridge-nf-call-iptables = 1\r\nEOF\r\n```\r\n\r\n然后重新加载 `sysctl.conf` 即可\r\n\r\n```\r\n$ sudo sysctl -p\r\n```\r\n\r\n### 参考文档-Centos\r\n\r\n- [Docker 官方 CentOS 安装文档](https://docs.docker.com/engine/installation/linux/docker-ce/centos/)。\r\n\r\n## 3.3 树莓派卡片电脑安装 Docker\r\n\r\n> 警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.\r\n\r\n### 系统要求-树莓派\r\n\r\nDocker CE 不仅支持 `x86_64` 架构的计算机，同时也支持 `ARM` 架构的计算机，本小节内容以树莓派单片电脑为例讲解 `ARM` 架构安装 Docker CE。\r\n\r\nDocker CE 支持以下版本的 [Raspbian](https://www.raspberrypi.org/downloads/raspbian/) 操作系统：\r\n\r\n- Raspbian Stretch\r\n- Raspbian Jessie\r\n\r\n*注：* `Raspbian` 是树莓派的开发与维护机构 [树莓派基金会](http://www.raspberrypi.org/) 推荐用于树莓派的首选系统，其基于 `Debian`。\r\n\r\n### 使用 APT 安装-树莓派\r\n\r\n由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。\r\n\r\n```\r\n$ sudo apt-get update\r\n\r\n$ sudo apt-get install \\\r\n     apt-transport-https \\\r\n     ca-certificates \\\r\n     curl \\\r\n     gnupg2 \\\r\n     lsb-release \\\r\n     software-properties-common\r\n```\r\n\r\n鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。\r\n\r\n为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。\r\n\r\n```\r\n$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/raspbian/gpg | sudo apt-key add -\r\n\r\n# 官方源\r\n# $ curl -fsSL https://download.docker.com/linux/raspbian/gpg | sudo apt-key add -\r\n```\r\n\r\n然后，我们需要向 `source.list` 中添加 Docker CE 软件源：\r\n\r\n```\r\n$ sudo add-apt-repository \\\r\n    \"deb [arch=armhf] https://mirrors.ustc.edu.cn/docker-ce/linux/raspbian \\\r\n    $(lsb_release -cs) \\\r\n    stable\"\r\n\r\n\r\n# 官方源\r\n# $ sudo add-apt-repository \\\r\n#    \"deb [arch=armhf] https://download.docker.com/linux/raspbian \\\r\n#    $(lsb_release -cs) \\\r\n#    stable\"    \r\n```\r\n\r\n> 以上命令会添加稳定版本的 Docker CE APT 源，如果需要最新版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 源也会包含稳定版本的 Docker CE。\r\n\r\n#### 安装 Docker CE-树莓派\r\n\r\n更新 apt 软件包缓存，并安装 `docker-ce`。\r\n\r\n```\r\n$ sudo apt-get update\r\n\r\n$ sudo apt-get install docker-ce\r\n```\r\n\r\n### 使用脚本自动安装-树莓派\r\n\r\n在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Raspbian 系统上可以使用这套脚本安装：\r\n\r\n```\r\n$ curl -fsSL get.docker.com -o get-docker.sh\r\n$ sudo sh get-docker.sh --mirror Aliyun\r\n```\r\n\r\n执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。\r\n\r\n### 启动 Docker CE-树莓派\r\n\r\n```\r\n$ sudo systemctl enable docker\r\n$ sudo systemctl start docker\r\n```\r\n\r\n### 建立 docker 用户组-树莓派\r\n\r\n默认情况下，`docker` 命令会使用 [Unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket) 与 Docker 引擎通讯。而只有 `root` 用户和 `docker` 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 `root` 用户。因此，更好地做法是将需要使用 `docker` 的用户加入 `docker` 用户组。\r\n\r\n建立 `docker` 组：\r\n\r\n```\r\n$ sudo groupadd docker\r\n```\r\n\r\n将当前用户加入 `docker` 组：\r\n\r\n```\r\n$ sudo usermod -aG docker $USER\r\n```\r\n\r\n退出当前终端并重新登录，进行如下测试。\r\n\r\n### 测试 Docker 是否安装正确-树莓派\r\n\r\n```\r\n$ docker run arm32v7/hello-world\r\n\r\nUnable to find image \'hello-world:latest\' locally\r\nlatest: Pulling from library/hello-world\r\nca4f61b1923c: Pull complete\r\nDigest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c\r\nStatus: Downloaded newer image for hello-world:latest\r\n\r\nHello from Docker!\r\nThis message shows that your installation appears to be working correctly.\r\n\r\nTo generate this message, Docker took the following steps:\r\n 1. The Docker client contacted the Docker daemon.\r\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\r\n    (amd64)\r\n 3. The Docker daemon created a new container from that image which runs the\r\n    executable that produces the output you are currently reading.\r\n 4. The Docker daemon streamed that output to the Docker client, which sent it\r\n    to your terminal.\r\n\r\nTo try something more ambitious, you can run an Ubuntu container with:\r\n $ docker run -it ubuntu bash\r\n\r\nShare images, automate workflows, and more with a free Docker ID:\r\n https://cloud.docker.com/\r\n\r\nFor more examples and ideas, visit:\r\n https://docs.docker.com/engine/userguide/\r\n```\r\n\r\n若能正常输出以上信息，则说明安装成功。\r\n\r\n*注意：* ARM 平台不能使用 `x86` 镜像，查看 Raspbian 可使用镜像请访问 [arm32v7](https://hub.docker.com/u/arm32v7/)。\r\n\r\n### 镜像加速-树莓派\r\n\r\n鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 `国内镜像加速`。\r\n\r\n## 3.4 macOS 安装 Docker\r\n\r\n### 系统要求-macOs\r\n\r\n[Docker for Mac](https://docs.docker.com/docker-for-mac/) 要求系统最低为 macOS 10.10.3 Yosemite。如果系统不满足需求，可以安装 [Docker Toolbox](https://docs.docker.com/toolbox/overview/)。\r\n\r\n### 安装-macOs\r\n\r\n#### 使用 Homebrew 安装\r\n\r\n[Homebrew](http://brew.sh/) 的 [Cask](https://caskroom.github.io/) 已经支持 Docker for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：\r\n\r\n```\r\n$ brew cask install docker\r\n```\r\n\r\n#### 手动下载安装-macOs\r\n\r\n如果需要手动下载，请点击以下链接下载 [Stable](https://download.docker.com/mac/stable/Docker.dmg) 或 [Edge](https://download.docker.com/mac/edge/Docker.dmg) 版本的 Docker for Mac。\r\n\r\n如同 macOS 其它软件一样，安装也非常简单，双击下载的 `.dmg` 文件，然后将那只叫 [Moby](https://blog.docker.com/2013/10/call-me-moby-dock/) 的鲸鱼图标拖拽到 `Application` 文件夹即可（其间需要输入用户密码）。\r\n\r\n![img](assets/install-mac-dmg.png)\r\n\r\n### 运行-macOs\r\n\r\n从应用中找到 Docker 图标并点击运行。\r\n\r\n![img](assets/install-mac-apps.png)\r\n\r\n运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。\r\n\r\n![img](assets/install-mac-menubar.png)\r\n\r\n第一次点击图标，可能会看到这个安装成功的界面，点击 “Got it!” 可以关闭这个窗口。\r\n\r\n![img](assets/install-mac-success.png)\r\n\r\n以后每次点击鲸鱼图标会弹出操作菜单。\r\n\r\n![img](assets/install-mac-menu.png)\r\n\r\n启动终端后，通过命令可以检查安装后的 Docker 版本。\r\n\r\n```\r\n$ docker --version\r\nDocker version 17.10.0-ce, build f4ffd25\r\n$ docker-compose --version\r\ndocker-compose version 1.17.0-rc1, build a0f95af\r\n$ docker-machine --version\r\ndocker-machine version 0.13.0, build 9ba6da9\r\n```\r\n\r\n如果 `docker version`、`docker info` 都正常的话，可以尝试运行一个 [Nginx 服务器](https://store.docker.com/images/nginx/)：\r\n\r\n```\r\n$ docker run -d -p 80:80 --name webserver nginx\r\n```\r\n\r\n服务运行后，可以访问 [http://localhost](http://localhost/)，如果看到了 “Welcome to nginx!”，就说明 Docker for Mac 安装成功了。\r\n\r\n![img](assets/install-mac-example-nginx.png)\r\n\r\n要停止 Nginx 服务器并删除执行下面的命令：\r\n\r\n```\r\n$ docker stop webserver\r\n$ docker rm webserver\r\n```\r\n\r\n### 镜像加速-macOs\r\n\r\n鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 `国内镜像加速`。\r\n\r\n\r\n\r\n## 3.5 Windows 安装 Docker\r\n\r\n### 系统要求-Windows\r\n\r\n[Docker for Windows](https://docs.docker.com/docker-for-windows/install/) 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V。\r\n\r\n### 安装-Windows\r\n\r\n点击以下链接下载 [Stable](https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe) 或 [Edge](https://download.docker.com/win/edge/Docker%20for%20Windows%20Installer.exe) 版本的 Docker for Windows。\r\n\r\n下载好之后双击 Docker for Windows Installer.exe 开始安装。\r\n\r\n### 运行-Windows\r\n\r\n在 Windows 搜索栏输入 Docker 点击 Docker for Windows 开始运行。\r\n\r\n![img](assets/install-win-docker-app-search.png)\r\n\r\nDocker CE 启动之后会在 Windows 任务栏出现鲸鱼图标。\r\n\r\n![img](assets/install-win-taskbar-circle.png)\r\n\r\n等待片刻，点击 Got it 开始使用 Docker CE。\r\n\r\n![img](assets/install-win-success-popup-cloud.png)\r\n\r\n### 镜像加速-Windows\r\n\r\n鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 `国内镜像加速`。\r\n\r\n## 3.6 Docker 镜像加速器-Windows\r\n\r\n国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：\r\n\r\n- [Docker 官方提供的中国 registry mirror](https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror)\r\n- [阿里云加速器](https://cr.console.aliyun.com/#/accelerator)\r\n- [DaoCloud 加速器](https://www.daocloud.io/mirror#accelerator-doc)\r\n\r\n我们以 Docker 官方加速器为例进行介绍。\r\n\r\n### Ubuntu 14.04、Debian 7 Wheezy\r\n\r\n对于使用 [upstart](http://upstart.ubuntu.com/) 的系统而言，编辑 `/etc/default/docker` 文件，在其中的 `DOCKER_OPTS` 中配置加速器地址：\r\n\r\n```\r\nDOCKER_OPTS=\"--registry-mirror=https://registry.docker-cn.com\"\r\n```\r\n\r\n重新启动服务。\r\n\r\n```\r\n$ sudo service docker restart\r\n```\r\n\r\n### Ubuntu 16.04+、Debian 8+、CentOS 7\r\n\r\n对于使用 [systemd](https://www.freedesktop.org/wiki/Software/systemd/) 的系统，请在 `/etc/docker/daemon.json` 中写入如下内容（如果文件不存在请新建该文件）\r\n\r\n```json\r\n{\r\n  \"registry-mirrors\": [\r\n    \"https://registry.docker-cn.com\"\r\n  ]\r\n}\r\n```\r\n\r\n> 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。\r\n\r\n之后重新启动服务。\r\n\r\n```shell\r\n$ sudo systemctl daemon-reload\r\n$ sudo systemctl restart docker\r\n```\r\n\r\n> 注意：如果您之前查看旧教程，修改了 `docker.service` 文件内容，请去掉您添加的内容（`--registry-mirror=https://registry.docker-cn.com`），这里不再赘述。\r\n\r\n### Windows 10\r\n\r\n对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 `Settings`，打开配置窗口后左侧导航菜单选择 `Daemon`。在 `Registry mirrors`一栏中填写加速器地址 `https://registry.docker-cn.com`，之后点击 `Apply` 保存后 Docker 就会重启并应用配置的镜像地址了。\r\n\r\n### macOS\r\n\r\n对于使用 macOS 的用户，在任务栏点击 Docker for mac 应用图标 -> Perferences… -> Daemon -> Registry mirrors。在列表中填写加速器地址 `https://registry.docker-cn.com`。修改完成之后，点击 `Apply & Restart` 按钮，Docker 就会重启并应用配置的镜像地址了。\r\n\r\n### 检查加速器是否生效\r\n\r\n配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 `docker info`，如果从结果中看到了如下内容，说明配置成功。\r\n\r\n```\r\nRegistry Mirrors:\r\n https://registry.docker-cn.com/\r\n```', 0);
INSERT INTO `blog_course` VALUES (223, 'Docker 基础', 10, '<!-- TOC -->\r\n\r\n- [一、Docker 快速入门](#一、Docker 快速入门)\r\n    - [初探 Docker](#初探 Docker)\r\n        - [什么是 Docker](#什么是 Docker)\r\n        - [为什么要使用 Docker](#为什么要使用 Docker)\r\n    - [CentOS 7 安装 Docker](#CentOS 7 安装 Docker)\r\n    - [Docker 镜像加速器](#Docker 镜像加速器)\r\n    - [Docker 常用命令](#Docker 常用命令)\r\n        - [1. 启动、停止、重启服务](#1. 启动、停止、重启服务)\r\n        - [2. 拉取一个镜像，启动容器](#2. 拉取一个镜像，启动容器)\r\n        - [3. 启动的容器列表](#3. 启动的容器列表)\r\n        - [4. 查看所有的容器](#4. 查看所有的容器)\r\n        - [5. 启动、停止、重启某个容器](#5. 启动、停止、重启某个容器)\r\n        - [6. 查看指定容器的日志记录](#6. 查看指定容器的日志记录)\r\n        - [7. 删除某个容器，若正在运行，需要先停止](#7. 删除某个容器，若正在运行，需要先停止)\r\n        - [8. 删除容器](#8. 删除容器)\r\n        - [9. 删除镜像](#9. 删除镜像)\r\n        - [10. 删除虚悬镜像](#10. 删除虚悬镜像)\r\n        - [11. 镜像导入与导出](#11. 镜像导入与导出)\r\n- [二、Docker File 镜像构建](#二、Docker File 镜像构建)\r\n- [三、Docker Compose](#三、Docker Compose)\r\n    - [docker-compose 命令安装](#docker-compose 命令安装)\r\n        - [1. 安装 python-pip](#1. 安装 python-pip)\r\n        - [2. 安装 Docker-Compose](#2. 安装 Docker-Compose)\r\n    - [docker-compose.yml 规范](#docker-compose.yml 规范)\r\n- [四、Docker 实战](#四、Docker 实战)\r\n    - [实战1：快速搭建 MySQL](#实战1：快速搭建 MySQL)\r\n    - [实战2：快速搭建 phpMyAdmin](#实战2：快速搭建 phpMyAdmin)\r\n    - [实战3：快速搭建 GitLab](#实战3：快速搭建 GitLab)\r\n- [参考资料](#参考资料)\r\n\r\n<!-- /TOC -->\r\n# 一、Docker 快速入门\r\n\r\n本文部分内容引用来自：【千锋-李卫民老师博客，推荐大家学习】http://www.funtl.com/\r\n\r\nA simple, interactive and fun playground to learn Docker：[Play with Docker](https://labs.play-with-docker.com/)\r\n\r\n\r\n## 初探 Docker\r\n\r\n### 什么是 Docker\r\n\r\n　　Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 [2013 年 3 月以 Apache 2.0 授权协议开源](https://en.wikipedia.org/wiki/Docker_(software))，主要项目代码在 [GitHub](https://github.com/moby/moby) 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 [开放容器联盟（OCI）](https://www.opencontainers.org/)。\r\n\r\n　　Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，[dotCloud 公司决定改名为 Docker](https://blog.docker.com/2013/10/dotcloud-is-becoming-docker-inc/)。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。\r\n\r\n　　Docker 使用 Google 公司推出的 [Go 语言](https://golang.org/) 进行开发实现，基于 Linux 内核的 [cgroup](https://zh.wikipedia.org/wiki/Cgroups)，[namespace](https://en.wikipedia.org/wiki/Linux_namespaces)，以及 [AUFS](https://en.wikipedia.org/wiki/Aufs) 类的 [Union FS](https://en.wikipedia.org/wiki/Union_mount) 等技术，对进程进行封装隔离，属于 [操作系统层面的虚拟化技术](https://en.wikipedia.org/wiki/Operating-system-level_virtualization)。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 [LXC](https://linuxcontainers.org/lxc/introduction/)，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 [libcontainer](https://github.com/docker/libcontainer)，从 1.11 开始，则进一步演进为使用 [runC](https://github.com/opencontainers/runc) 和 [containerd](https://github.com/containerd/containerd)。\r\n\r\n　　Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。\r\n\r\n　　下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\r\n\r\n![img](assets/VMs-and-Containers.jpg)\r\n\r\n\r\n\r\n### 为什么要使用 Docker\r\n\r\n![Docker architecture](assets/docker-architecture.png)\r\n\r\n　　作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。\r\n\r\n**更高效的利用系统资源**\r\n\r\n　　由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\r\n\r\n**更快速的启动时间**\r\n\r\n　　传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。\r\n\r\n**一致的运行环境**\r\n\r\n　　开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 *「这段代码在我机器上没问题啊」* 这类问题。\r\n\r\n**持续交付和部署**\r\n\r\n　　对开发和运维（[DevOps](https://zh.wikipedia.org/wiki/DevOps)）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\r\n\r\n　　使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 `Dockerfile` 来进行镜像构建，并结合 [持续集成(Continuous Integration)](https://en.wikipedia.org/wiki/Continuous_integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 [持续部署(Continuous Delivery/Deployment)](https://en.wikipedia.org/wiki/Continuous_delivery) 系统进行自动部署。\r\n\r\n　　而且使用 `Dockerfile` 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\r\n\r\n**更轻松的迁移**\r\n\r\n　　由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\r\n\r\n**更轻松的维护和扩展**\r\n\r\n　　Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 [官方镜像](https://store.docker.com/search?q=&source=verified&type=image)，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\r\n\r\n**对比传统虚拟机总结**\r\n\r\n| 特性       | 容器               | 虚拟机      |\r\n| ---------- | ------------------ | ----------- |\r\n| 启动       | 秒级               | 分钟级      |\r\n| 硬盘使用   | 一般为 `MB`        | 一般为 `GB` |\r\n| 性能       | 接近原生           | 弱于        |\r\n| 系统支持量 | 单机支持上千个容器 | 一般几十个  |\r\n\r\n\r\n\r\n## CentOS 7 安装 Docker\r\n\r\n1. 先更新 yum 软件管理器，然后再安装 Docker\r\n\r\n```shell\r\n[root@localhost /] yum -y update\r\n[root@localhost /] yum install -y docker\r\n```\r\n\r\n　　说明：上述 `-y` 代表选择程序安装中的 yes 选项\r\n\r\n　　或是，直接安装 \r\n\r\n```shell\r\nyum install docker\r\n```\r\n\r\n2. 验证安装，查看 Docker 版本信息\r\n\r\n```shell\r\n[root@localhost /] docker -v\r\nDocker version 1.13.1, build 8633870/1.13.1\r\nYou have new mail in /var/spool/mail/root\r\n```\r\n\r\n3. 启动 / 重启 / 关闭 Docker \r\n\r\n```shell\r\n[root@localhost /] docker start\r\n[root@localhost /] docker restart\r\n[root@localhost /] docker stop\r\n```\r\n\r\n\r\n\r\n【意外情况】service docker start 无法启动问题\r\n\r\n- centos 安装 docker 显示 No package docker available，原因是 yum 没有找到 docker 的包，需要 epel 第三方软件库，运行下面的命令\r\n\r\n  `sudo yum install epel-release`\r\n\r\n- [【亲测有效】Centos安装完成docker后启动docker报错docker](http://www.cnblogs.com/ECJTUACM-873284962/p/9362840.html)\r\n\r\n\r\n\r\n1. 配置yum源\r\n\r\n   vim /etc/yum.repos.d/docker.repo\r\n\r\n```ini\r\n[dockerrepo]\r\nname=Docker Repository\r\nbaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/\r\nenabled=1\r\ngpgcheck=1\r\ngpgkey=https://yum.dockerproject.org/gpg\r\n```\r\n\r\n2. 通过yum安装\r\n\r\n```\r\nyum install docker-engine\r\nservice docker start\r\nservice docker status\r\n```\r\n\r\n3. 日志\r\n\r\n```\r\nvim /var/log/docker\r\n```\r\n\r\n\r\n\r\n在 Ubuntu 16.04 LTS 上 离线安装 Docker / Docker-compose - TonyZhang24 - 博客园\r\nhttps://www.cnblogs.com/atuotuo/p/9272368.html\r\n\r\n\r\n\r\n## Docker 镜像加速器\r\n\r\n1. 加速器服务\r\n\r\n   [DaoCloud 加速器，一行命令，镜像万千](https://www.daocloud.io/mirror)\r\n\r\n   [阿里云 - 开发者平台 - 容器 hub](https://dev.aliyun.com/search.html)\r\n\r\n2. 配置 Docker 加速器\r\n\r\n　　以 Linux 为例\r\n\r\n```shell\r\ncurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io\r\n```\r\n\r\n　　该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。\r\n\r\n　　删除 /etc/docker/daemon.json 中最后一个逗号，重启 Docker 服务即可\r\n\r\n\r\n\r\n## Docker 常用命令\r\n\r\n![docker-cmd](assets/docker-cmd.png)\r\n\r\n### 1. 启动、停止、重启服务\r\n\r\n```shell\r\n[root@localhost ~]# service docker restart\r\nRedirecting to /bin/systemctl restart docker.service\r\n[root@localhost ~]# service docker stop\r\nRedirecting to /bin/systemctl stop docker.service\r\n[root@localhost ~]# service docker start\r\nRedirecting to /bin/systemctl start docker.service\r\n```\r\n\r\n### 2. 拉取一个镜像，启动容器\r\n\r\n```shell\r\n[root@localhost ~]# docker pull centos\r\n[root@localhost ~]# docker run -it -v /centos_dir:/docker_dir --name biodwhu-1 centos\r\n```\r\n\r\n- -i：允许我们对容器内的 (STDIN) 进行交互\r\n- -t：在新容器内指定一个伪终端或终端\r\n- -v：是挂在宿机目录， /centos_dir 是宿机目录，/docker_dir 是当前 Docker 容器的目录，宿机目录必须是绝对的。\r\n- -p：端口映射\r\n- --name：是给容器起一个名字，可省略，省略的话 docker 会随机产生一个名字\r\n\r\n- --restart：always\r\n\r\n### 3. 启动的容器列表\r\n\r\n```shell\r\n[root@localhost ~]# docker ps\r\n```\r\n\r\n### 4. 查看所有的容器\r\n\r\n```shell\r\n[root@localhost ~]# docker ps -a\r\n```\r\n\r\n### 5. 启动、停止、重启某个容器\r\n\r\n```shell\r\n[root@localhost ~]# docker start biodwhu-1\r\nbiodwhu-1\r\n[root@localhost ~]# docker stop biodwhu-2\r\nbiodwhu-2\r\n[root@localhost ~]# docker restart biodwhu-3\r\nbiodwhu-3\r\n```\r\n\r\n### 6. 查看指定容器的日志记录\r\n\r\n```shell\r\n[root@localhost ~]# docker logs -f biodwhu-1\r\n```\r\n\r\n### 7. 删除某个容器，若正在运行，需要先停止\r\n\r\n```shell\r\n[root@localhost ~]# docker rm biodwhu-1\r\nError response from daemon: You cannot remove a running container 2d48fc5b7c17b01e6247cbc012013306faf1e54f24651d5e16d6db4e15f92d33. Stop the container before attempting removal or use -f\r\n[root@localhost ~]# docker stop biodwhu-1\r\nbiodwhu-1\r\n[root@localhost ~]# docker rm biodwhu-1\r\nbiodwhu-1\r\n```\r\n\r\n### 8. 删除容器\r\n\r\n```shell\r\n# 删除某个容器\r\n[root@localhost ~]# docker rm f3b346204a39\r\n\r\n# 删除所有容器\r\n[root@localhost ~]# docker stop $(docker ps -a -q)\r\n[root@localhost ~]# docker rm $(docker ps -a -q)\r\n```\r\n\r\n### 9. 删除镜像\r\n\r\n```shell\r\n# 删除某个镜像\r\n[root@localhost ~]# docker rmi docker.io/mysql:5.6\r\n\r\n# 删除所有镜像\r\n[root@localhost ~]# docker rmi $(docker images -q)\r\n\r\n# 强制删除所有镜像\r\n[root@localhost ~]# docker rmi -f $(docker images -q)\r\n```\r\n\r\n### 10. 删除虚悬镜像\r\n\r\n我们在 build 镜像的过程中，可能会产生一些临时的不具有名称也没有作用的镜像他们的名称一般都是 `<none>` ,我们可以执行下面的命令将其清除掉：\r\n\r\n```shell\r\n[root@localhost ~]# docker rmi $(docker images -f \"dangling=true\" -q)\r\n# 或者\r\n[root@localhost ~]# docker image prune -a -f\r\n```\r\n\r\n### 11. 镜像导入与导出\r\n\r\n保存镜像\r\n\r\n```shell\r\n[root@localhost ~]# docker save a46c2a2722b9 > /var/docker/images_save/mysql.tar.gz\r\n```\r\n\r\n加载镜像\r\n\r\n```shell\r\n[root@localhost ~]# docker load -i /var/docker/images_save/mysql.tar.gz\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 二、Docker File 镜像构建\r\n\r\n# 三、Docker Compose\r\n\r\n## docker-compose 命令安装\r\n\r\nDocker-Compose 是一个部署多个容器的简单但是非常必要的工具.\r\n\r\n安装 Docker-Compose 之前，请先安装 python-pip\r\n\r\n### 1. 安装 python-pip\r\n\r\n1. 首先检查 Linux 有没有安装 python-pip 包，终端执行 pip -v\r\n\r\n```shell\r\n[root@localhost ~]# pip -V\r\n-bash: pip: command not found\r\n```\r\n\r\n2. 没有 python-pip 包就执行命令\r\n\r\n```shell\r\n[root@localhost ~]# yum -y install epel-release\r\n```\r\n\r\n3. 执行成功之后，再次执行\r\n\r\n```shell\r\n[root@localhost ~]# yum -y install python-pip\r\n```\r\n\r\n4. 对安装好的 pip 进行升级\r\n\r\n```shell\r\n[root@localhost ~]# pip install --upgrade pip\r\n```\r\n\r\n### 2. 安装 Docker-Compose\r\n\r\n1. 终端执行\r\n\r\n```shell\r\n[root@localhost ~]# pip install docker-compose\r\n```\r\n\r\n2. 检查 docker-compose 安装\r\n\r\n```shell\r\n[root@localhost ~]# docker-compose -version\r\n```\r\n\r\n参考资料：\r\n\r\n- [CentOS7下安装Docker-Compose - YatHo - 博客园](https://www.cnblogs.com/YatHo/p/7815400.html)\r\n\r\n## docker-compose.yml 规范\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 四、Docker 实战\r\n\r\n## 实战1：快速搭建 MySQL\r\n\r\n- 官方镜像仓库\r\n\r\n  [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/)\r\n\r\n- docker-compose.yml\r\n\r\n```yml\r\nversion: \'3.1\'\r\nservices:\r\n  mysql:\r\n    restart: always\r\n    image: mysql:5.6\r\n    container_name: mysql\r\n    ports:\r\n      - 3306:3306\r\n    environment:\r\n      TZ: Asia/Shanghai\r\n      MYSQL_ROOT_PASSWORD: 123456\r\n    command:\r\n      --character-set-server=utf8mb4\r\n      --collation-server=utf8mb4_general_ci\r\n      --explicit_defaults_for_timestamp=true\r\n      --lower_case_table_names=1\r\n      --max_allowed_packet=128M\r\n      --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\r\n    volumes:\r\n      - /usr/local/docker/mysql/mysql-data:/var/lib/mysql\r\n```\r\n\r\n\r\n\r\n## 实战2：快速搭建 phpMyAdmin\r\n\r\n- 官方镜像仓库\r\n\r\n  [phpmyadmin/phpmyadmin](phpmyadmin/phpmyadmin)\r\n\r\n- docker-compose.yml\r\n\r\n```yml\r\nversion: \'3.1\'\r\nservices:\r\n  phpmyadmin:\r\n    image: phpmyadmin/phpmyadmin\r\n    container_name: phpmyadmin\r\n    environment:\r\n     - PMA_ARBITRARY=1\r\n     - PMA_HOST=120.92.17.12\r\n    # - PMA_PORT=3306\r\n    # - PMA_USER=xxx\r\n    # - PMA_PASSWORD=xxx\r\n    restart: always\r\n    ports:\r\n     - 6060:80\r\n    volumes:\r\n     - /sessions\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 实战3：快速搭建 GitLab\r\n\r\nGitLab 使用163邮箱发送邮件 - 刘锐群的笔记 - CSDN博客\r\nhttps://blog.csdn.net/liuruiqun/article/details/50000213\r\n\r\n\r\n\r\ngitlab服务器邮箱配置 - weifengCorp - 博客园\r\nhttps://www.cnblogs.com/weifeng1463/p/8489563.html\r\n\r\n\r\n\r\ntwang2218/gitlab-ce-zh - Docker Hub\r\nhttps://hub.docker.com/r/twang2218/gitlab-ce-zh/\r\n\r\n```yml\r\nversion: \'3\'\r\nservices:\r\n    web:\r\n      image: \'twang2218/gitlab-ce-zh:10.5\'\r\n      restart: always\r\n      hostname: \'120.131.11.187\'\r\n      environment:\r\n        TZ: \'Asia/Shanghai\'\r\n        GITLAB_OMNIBUS_CONFIG: |\r\n          external_url \'http://120.131.11.187:3000\'\r\n          gitlab_rails[\'gitlab_shell_ssh_port\'] = 2222\r\n          unicorn[\'port\'] = 8888\r\n          nginx[\'listen_port\'] = 3000\r\n      ports:\r\n        - \'3000:3000\'\r\n        - \'8443:443\'\r\n        - \'2222:22\'\r\n      volumes:\r\n        - /usr/local/docker/gitlab/config:/etc/gitlab\r\n        - /usr/local/docker/gitlab/data:/var/opt/gitlab\r\n        - /usr/local/docker/gitlab/logs:/var/log/gitlab\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 参考资料\r\n\r\n- [docker前后分离笔记 - 小翼的前端天地](https://my-fe.pub/post/docker-front-and-backend-separation.html#toc-619)\r\n', 0);
INSERT INTO `blog_course` VALUES (224, 'Docker 实战', 10, '# Docker实战系列\r\n\r\n## Docker搭建自己的Gitlab CI Runner\r\n\r\n> 这里主要将采用 docker 镜像方式安装\r\n>\r\n\r\n1. 拉取gitlab-runner镜像\r\n\r\n```\r\ndocker pull gitlab/gitlab-runner:latest\r\n```\r\n\r\n2. 添加 gitlab-runner container\r\n\r\n```\r\nsudo docker run -d --name gitlab-runner --restart always \\\r\n  -v /srv/gitlab-runner/config:/etc/gitlab-runner \\\r\n  -v /var/run/docker.sock:/var/run/docker.sock \\\r\n  gitlab/gitlab-runner:latest\r\n  \r\n  sudo docker run -d --restart always \\\r\n  -v /srv/gitlab-runner/config:/etc/gitlab-runner \\\r\n  -v /var/run/docker.sock:/var/run/docker.sock \\\r\n  gitlab/gitlab-runner:latest\r\n```\r\n\r\n3. 注册runner\r\n\r\n```\r\nsudo docker exec -it gitlab-runner gitlab-ci-multi-runner register\r\n```\r\n\r\n4. 注册\r\n\r\n```shell\r\nsudo docker exec -it gitlab-runner gitlab-ci-multi-runner register\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nsudo docker run -d --name gitlab-runner --restart always \\\r\n  -v /srv/gitlab-runner/config:/etc/gitlab-runner \\\r\n  -v /var/run/docker.sock:/var/run/docker.sock \\\r\n  gitlab/gitlab-runner:latest\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n[Docker搭建自己的Gitlab CI Runner - 哎_小羊的博客 - CSDN博客](https://blog.csdn.net/aixiaoyang168/article/details/72168834)\r\n', 0);
INSERT INTO `blog_course` VALUES (225, 'Git 基础', 13, '<!-- TOC -->\r\n\r\n- [前言](#前言)\r\n- [一、Git 简介](#一、Git 简介)\r\n    - [什么是版本控制系统](#什么是版本控制系统)\r\n        - [为什么需要版本控制](#为什么需要版本控制？)\r\n        - [什么是版本控制系统](#什么是版本控制系统？)\r\n        - [版本控制系统的发展史](#版本控制系统的发展史)\r\n    - [什么是 Git](#什么是 Git)\r\n    - [如何安装 Git](#如何安装 Git)\r\n- [二、Git 常用命令速查](#二、Git 常用命令速查)\r\n    - [配置](#配置)\r\n    - [基础操作](#基础操作)\r\n    - [比对 diff](#比对 diff)\r\n    - [历史 log](#历史 log)\r\n    - [分支 branch](#分支 branch)\r\n    - [远程](#远程)\r\n- [三、Git 常用场景](#三、Git 常用场景)\r\n    - [1. 删除本地文件后，想从远程仓库中重新Pull最新版文件](#1. 删除本地文件后，想从远程仓库中重新Pull最新版文件)\r\n    - [2. 储藏与清理](#2. 储藏与清理)\r\n\r\n<!-- /TOC -->\r\n\r\n# 前言\r\n\r\n这是一篇入门级使用指南，更多详细的请参考 [Git 官网电子书](https://git-scm.com/book/zh/v2)。\r\n\r\n在这里将列举一些常用命令和场景解决方案，欢迎大家补充学习。\r\n\r\n\r\n\r\n# 一、Git 简介\r\n\r\n## 什么是版本控制系统\r\n\r\n### 为什么需要版本控制？\r\n\r\n在软件开发过程，每天都会产生新的代码，代码合并的过程中可能会出现如下问题：\r\n\r\n- 代码被覆盖或丢失\r\n- 代码写的不理想希望还原之前的版本\r\n- 希望知道与之前版本的差别\r\n- 是谁修改了代码以及为什么修改\r\n- 发版时希望分成不同的版本(测试版、发行版等)\r\n\r\n因此，我们希望有一种机制，能够帮助我们：\r\n\r\n- 可以随时回滚到之前的版本\r\n- 协同开发时不会覆盖别人的代码\r\n- 留下修改记录，以便随时查看\r\n- 发版时可以方便的管理不同的版本\r\n\r\n### 什么是版本控制系统？\r\n\r\n一个标准的版本控制系统 Version Control System (VCS)，通常需要有以下功能：\r\n\r\n- 能够创建 Repository (仓库)，用来保存代码\r\n- 协同开发时方便将代码分发给团队成员\r\n- 记录每次修改代码的内容、时间、原因等信息\r\n- 能够创建 Branch (分支)，可以根据不同的场景进行开发\r\n- 能够创建 Tag (标签)，建立项目里程碑\r\n\r\n### 版本控制系统的发展史\r\n\r\n版本控制系统发展至今有几种不同的模式：\r\n\r\n**Local VCS**\r\n\r\n本地使用 `复制/粘贴` 的方式进行管理，缺点是无法协同开发\r\n\r\n**Centralized VCS (Lock，悲观锁)**\r\n\r\n中央集中式版本控制系统团队共用仓库，当某人需要编辑文件时，进行锁定，以免其他人同时编辑时造成冲突。缺点是虽然避免了冲突，但不是很方便。其他人需要排队才能编辑文件，如果有人编辑了很久或是忘记解锁就会造成其他人长时间等待的情况。\r\n\r\n**Centralized VCS (Merge，乐观锁)**\r\n\r\n中央集中式版本控制系统团队共用仓库，不采用悲观锁方式来避免冲突，而是事后发现如果别人也修改相同文件(冲突)，再进行手动修改解决。有很多 VCS 属于这种类型，如：CVS，Subversion，Perforce 等\r\n\r\n中央集中式版本控制系统的共同问题是，做任何操作都需要和服务器同步，如果服务器宕机则会造成无法继续工作的窘迫。\r\n\r\n**Distributed VCS**\r\n\r\n分布式版本控制系统，本地也拥有完整的代码仓库，就不会出现上述集中式管理的问题，即使没有网络，依然可以 `commit` 和看 `log`，也无需担心服务器同步问题。如：Git，Mercurial，Bazaar 等就属于分布式版本控制系统。缺点是功能比较复杂，上手需要一定的学习时间。\r\n\r\n\r\n\r\n## 什么是 Git\r\n\r\n- Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\r\n- Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\r\n- Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\r\n\r\n## 如何安装 Git\r\n\r\n- Git 官网下载地址：[Git 版本管理工具](https://git-scm.com/downloads)\r\n\r\n- 客户端推荐：[SourceTree](https://www.sourcetreeapp.com/)，软件安装跳过注册，[请参考这里](https://www.cnblogs.com/lucio110/p/8192792.html?tdsourcetag=s_pcqq_aiomsg)\r\n\r\n\r\n\r\n\r\n\r\n# 二、Git 常用命令速查\r\n\r\n一图胜千言\r\n\r\n![img](assets/TQDj8Uo1pj3YkMSoeSitYC1QB4a019V68N6GZFBE.png)\r\n\r\n\r\n\r\n推荐一个不错的可视化工具：[Git Cheat Sheet](http://ndpsoftware.com/git-cheatsheet.html)\r\n\r\n## 配置\r\n\r\n设置提交者姓名\r\n\r\n```shell\r\n$ git config --global user.name \"John Doe\"\r\n```\r\n\r\n设置提交者邮箱\r\n\r\n```shell\r\n$ git config --global user.email johndoe@example.com\r\n```\r\n\r\n查看配置列表\r\n\r\n```shell\r\n$ git config --list\r\n```\r\n\r\n\r\n\r\n## 基础操作\r\n\r\n在指定目录创建仓库，如果没有指定目录名将在当前目录创建仓库\r\n\r\n```shell\r\n$ git init [目录名]\r\n\r\n# 当前文件夹初始化\r\n$ git init .\r\n\r\n# 指定目录\r\n$ git init frank\r\n```\r\n\r\n从指定地址克隆仓库，若不指定`目录名`将默认创建与远程同名目录\r\n\r\n```shell\r\n$ git clone <远程仓库地址> [目录名]\r\n\r\n# 不想创建目录，目录名为 . ，直接加在内容到当前目录下\r\n$ git clone https://github.com/frank-lam/2019_campus_apply.git .\r\n```\r\n\r\n将文件或目录中已修改的代码添加追暂存区\r\n\r\n```shell\r\n$ git add <目录名|文件名>\r\n```\r\n\r\n提交暂存区内容\r\n\r\n```shell\r\n$ git commit -m \"<注释>\"\r\n```\r\n\r\n查看仓库状态\r\n\r\n```shell\r\n$ git status\r\n```\r\n\r\n\r\n\r\n## 比对 diff\r\n\r\n比对当前内容和暂存区内容\r\n\r\n```shell\r\n$ git diff\r\n```\r\n\r\n比对当前内容和最近一次提交\r\n\r\n```shell\r\n$ git diff HEAD\r\n```\r\n\r\n比对当前内容和倒数第二次提交\r\n\r\n```shell\r\n$ git diff HEAD^\r\n```\r\n\r\n比对最近两次提交\r\n\r\n```shell\r\n$ git diff HEAD^ HEAD\r\n```\r\n\r\n\r\n\r\n## 历史 log\r\n\r\n查看提交历史\r\n\r\n```shell\r\n$ git log --oneline\r\n```\r\n\r\n打印为单行log\r\n\r\n```shell\r\n$ git log --oneline\r\n```\r\n\r\n打印所有记录（忽略HEAD的位置）\r\n\r\n```shell\r\n$ git log --all\r\n```\r\n\r\n打印示意图（忽略HEAD的位置）\r\n\r\n```shell\r\n$ git log --graph\r\n```\r\n\r\n\r\n\r\n## 分支 branch\r\n\r\n查看所有分支\r\n\r\n```shell\r\n$ git branch\r\n```\r\n\r\n有分支：创建分支，无分支：列出所有分支\r\n\r\n```shell\r\n$ git branch [分支]\r\n```\r\n\r\n切换至分支\r\n\r\n```shell\r\n$ git checkout <分支>\r\n```\r\n\r\n创建并切换至分支分支\r\n\r\n```shell\r\n$ git checkout -b <分支>\r\n```\r\n\r\n将分支与当前分支合并\r\n\r\n```shell\r\n$ git merge <分支>\r\n```\r\n\r\n\r\n\r\n## 远程\r\n\r\n拉取远程仓库\r\n\r\n```shell\r\n$ git pull\r\n```\r\n\r\n推送至远程仓库\r\n\r\n```shell\r\n$ git push <远程仓库> <分支>\r\n```\r\n\r\n新增远程仓库 origin\r\n\r\n```shell\r\n$ git remote add origin https://xxx.git\r\n```\r\n\r\n修改远程仓库 origin\r\n\r\n```shell\r\n$ git remote set-url origin https://xxx.git\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 三、Git 常用场景\r\n\r\n## 1. 删除本地文件后，想从远程仓库中重新 Pull 最新版文件\r\n\r\nGit提示：up-to-date，但未得到删除的文件\r\n\r\n原因：当前本地库处于另一个分支中，需将本分支发 Head 重置至 master\r\n\r\n```bash\r\n$ git checkout master \r\n$ git reset --hard\r\n```\r\n\r\ngit 强行 pull 并覆盖本地文件\r\n\r\n```shell\r\n$ git fetch --all  \r\n$ git reset --hard origin/master \r\n$ git pull\r\n```\r\n\r\n## 2. 储藏与清理\r\n\r\n应用场景：\r\n\r\n1. 当正在 dev 分支上开发某个项目，这时项目中出现一个 bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用 git stash 命令将修改的内容保存至堆栈区，然后顺利切换到 hotfix 分支进行 bug 修复，修复完成后，再次切回到 dev 分支，从堆栈中恢复刚刚保存的内容。 \r\n2. 由于疏忽，本应该在 dev 分支开发的内容，却在 master 上进行了开发，需要重新切回到 dev 分支上进行开发，可以用 git stash 将内容保存至堆栈中，切回到 dev 分支后，再次恢复内容即可。 \r\n\r\n总的来说，git stash 命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash 中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash 作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。\r\n\r\n\r\n\r\n- [Git - 储藏与清理](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86)\r\n- [git stash详解 - stone_yw的博客 - CSDN博客](https://blog.csdn.net/stone_yw/article/details/80795669)\r\n\r\n\r\n\r\n## 3. SSH 连接配置\r\n\r\n### 1. 生成密钥对\r\n\r\n大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。\r\n\r\nSSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看：\r\n\r\n```shell\r\n$ cd ~/.ssh\r\n$ ls\r\nauthorized_keys2  id_dsa       known_hosts config            id_dsa.pub\r\n```\r\n\r\n看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。\r\n\r\n假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：\r\n\r\n```shell\r\n$ ssh-keygen -t rsa -C \"your_email@youremail.com\"\r\n\r\nCreates a new ssh key using the provided email # Generating public/private rsa key pair.\r\n\r\nEnter file in which to save the key (/home/you/.ssh/id_rsa):\r\n```\r\n\r\n直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：\r\n\r\n```shell\r\nEnter same passphrase again: [Type passphrase again]\r\n```\r\n\r\n完了之后，大概是这样：\r\n\r\n```shell\r\nYour public key has been saved in /home/you/.ssh/id_rsa.pub.\r\nThe key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com\r\n```\r\n\r\n到此为止，你本地的密钥对就生成了。\r\n\r\n\r\n(9+条消息)Mac OS 配置多个ssh-key - maoxinwen1的博客 - CSDN博客\r\nhttps://blog.csdn.net/maoxinwen1/article/details/80269299\r\n\r\n\r\n### 2. 添加公钥到你的远程仓库（github）\r\n\r\n1. 查看你生成的公钥：\r\n\r\n```\r\n$ cat ~/.ssh/id_rsa.pub\r\n\r\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC\r\n```\r\n\r\n2. 登陆你的 GitHub 帐户。点击你的头像，然后 `Settings -> 左栏点击 SSH and GPG keys -> 点击 New SSH key`\r\n\r\n3. 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。\r\n\r\n4. 点击 Add key。\r\n\r\n完成以后，验证下这个key是不是正常工作：\r\n\r\n```shell\r\n$ ssh -T git@github.com\r\n\r\nAttempts to ssh to github\r\n```\r\n\r\n如果，看到：\r\n\r\n```\r\nHi xxx! You\'ve successfully authenticated, but GitHub does not # provide shell access.\r\n```\r\n\r\n恭喜你，你的设置已经成功了。\r\n\r\n### 3. 修改git的remote url\r\n\r\n 使用命令 git remote -v 查看你当前的 remote url\r\n\r\n```shell\r\n$ git remote -v\r\norigin https://github.com/someaccount/someproject.git (fetch)\r\norigin https://github.com/someaccount/someproject.git (push)\r\n```\r\n\r\n如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议）\r\n\r\n你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url，类似：\r\n\r\n ![img](assets/1160195-20170512120555144-795931549.png)\r\n\r\n复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。\r\n\r\n```shell\r\n$ git remote set-url origin git@github.com:someaccount/someproject.git\r\n```\r\n\r\n然后你可以再用命令 git remote -v 查看一下，url是否已经变成了ssh地址。\r\n\r\n然后你就可以愉快的使用 git fetch, git pull , git push，再也不用输入烦人的密码了\r\n\r\n\r\n\r\n\r\n\r\n### 4. 常见问题\r\n\r\n- [Git 提交大文件提示 fatal: The remote end hung up unexpectedly - WNFK - 博客园](https://www.cnblogs.com/hanxianlong/p/3464224.html)\r\n\r\n\r\n\r\n## 4. Git 记住密码\r\n\r\n- [Git Pull 避免用户名和密码方法 - 王信平 - 博客园](https://www.cnblogs.com/wangshuo1/p/5531200.html)\r\n\r\n\r\n\r\n## 5. Git FTP 使用\r\n\r\n利用Git版本管理将只修改过的文件上传到FTP服务器 支持SFTP协议 - 吕滔博客\r\nhttps://lvtao.net/tool/gitftp.html\r\n\r\n\r\n\r\n## 6. Git 删除文件如何提交\r\n\r\n\r\n\r\n## 7. Git 中的 origin 是什么意思\r\n\r\ngit学习：关于origin和master - mashiqi - 博客园\r\nhttps://www.cnblogs.com/mashiqi/p/6002671.html\r\n\r\n\r\n\r\nGit 里面的 origin 到底代表啥意思? - Not Only DBA. - CSDN博客\r\nhttps://blog.csdn.net/u011478909/article/details/77683754\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (226, 'Git 命令速查', 13, '# Git 命令速查\r\n\r\n> 本文参考极客时间苏玲老师的《玩转Git三剑客》\r\n\r\n\r\n\r\n## 添加配置\r\n```bash\r\ngit config [--local | --global | --system] user.name \'Your name\'\r\ngit config [--local | --global | --system] user.email \'Your email\'\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 查看配置\r\n\r\n```bash\r\ngit config --list [--local | --global | --system]\r\n```\r\n### 区别\r\n```bash\r\nlocal：区域为本仓库\r\nglobal: 当前用户的所有仓库\r\nsystem: 本系统的所有用户\r\n```\r\n\r\n\r\n## git add . 和 git add -u区别\r\n\r\n```bash\r\ngit add . ：将工作空间新增和被修改的文件添加的暂存区\r\ngit add -u :将工作空间被修改和被删除的文件添加到暂存区(不包含没有纳入Git管理的新增文件)\r\n```\r\n\r\n\r\n\r\n## 创建仓库\r\n\r\n```bash\r\ngit init [project folder name]  初始化 git 仓库\r\ngit add [fileName]  把文件从工作目录添加到暂存区\r\ngit commit -m\'some information\'  用于提交暂存区的文件\r\ngit commit -am\'Some information\' 用于提交跟踪过的文件\r\ngit log  查看历史\r\ngit status  查看状态\r\n```\r\n\r\n**额外**    \r\ngit add -u 可以添加所有已经被 git 控制的文件到暂存区\r\n以前删除文件夹只会用 「-rf」，今天学到了 「-r」，并得知它们两个区别：「-r」 有时候会提示是否确认删除。    \r\n\r\n\r\n\r\n## 给文件重命名的简便方法\r\n\r\n```bash\r\ngit  mv  [old file name]  [new file name]\r\ngit commit -m \'some information\'\r\n```\r\n\r\n\r\n\r\n## 通过git log查看版本演变历史\r\n\r\n```bash\r\ngit log --all 查看所有分支的历史\r\ngit log --all --graph 查看图形化的 log 地址\r\ngit log --oneline 查看单行的简洁历史。\r\ngit log --oneline -n4 查看最近的4条简洁历史。\r\ngit log --oneline --all -n4 --graph 查看所有分支最近4条单行的图形化历史。\r\ngit help --web log 跳转到git log 的帮助文档网页\r\n```\r\n\r\n```bash\r\ngit branch -v 查看本地有多少分支\r\n```\r\n\r\n\r\n\r\n## 通过图形界面工具来查看版本历史\r\n\r\n```bash\r\ngitk\r\n```\r\n\r\n\r\n\r\n## 探密.git目录\r\n\r\n查看`.git`文件夹下的内容：    \r\n```bash\r\nls .git/ -al\r\n```\r\n如下:   \r\n```shell\r\ndrwxr-xr-x 1 Andy 197609   0 12月 17 22:38 ./\r\ndrwxr-xr-x 1 Andy 197609   0 12月 17 21:50 ../\r\n-rw-r--r-- 1 Andy 197609   7 12月 17 22:38 COMMIT_EDITMSG\r\n-rw-r--r-- 1 Andy 197609 301 12月 12 22:55 config\r\n-rw-r--r-- 1 Andy 197609  73 12月 12 22:55 description\r\n-rw-r--r-- 1 Andy 197609  96 12月 19 00:00 FETCH_HEAD\r\n-rw-r--r-- 1 Andy 197609  23 12月 12 22:55 HEAD\r\ndrwxr-xr-x 1 Andy 197609   0 12月 12 22:55 hooks/\r\n-rw-r--r-- 1 Andy 197609 249 12月 17 22:38 index\r\ndrwxr-xr-x 1 Andy 197609   0 12月 12 22:55 info/\r\ndrwxr-xr-x 1 Andy 197609   0 12月 12 22:55 logs/\r\ndrwxr-xr-x 1 Andy 197609   0 12月 17 22:38 objects/\r\n-rw-r--r-- 1 Andy 197609 114 12月 12 22:55 packed-refs\r\ndrwxr-xr-x 1 Andy 197609   0 12月 12 22:55 refs/\r\n```\r\n\r\n```bash\r\ncat命令主要用来查看文件内容，创建文件，文件合并，追加文件内容等功能。\r\ncat HEAD 查看HEAD文件的内容\r\ngit cat-file 命令 显示版本库对象的内容、类型及大小信息。\r\ngit cat-file -t b44dd71d62a5a8ed3 显示版本库对象的类型\r\ngit cat-file -s b44dd71d62a5a8ed3 显示版本库对象的大小\r\ngit cat-file -p b44dd71d62a5a8ed3 显示版本库对象的内容\r\n```\r\n\r\n`.git`里几个常用的如下：    \r\n```bash\r\nHEAD：指向当前的工作路径\r\nconfig：存放本地仓库（local）相关的配置信息。\r\nrefs/heads: 存放分支\r\nrefs/heads/master/: 指向master分支最后一次commit\r\nrefs/tags: 存放tag，又叫里程牌 （当这次commit是具有里程碑意义的 比如项目1.0的时候 就可以打tag）\r\nobjects：核心文件，存储文件\r\n```\r\n.git/objects/ 存放所有的 git 对象，对象哈希值前 2 位作为文件夹名称，后 38 位作为对象文件名, 可通过 git cat-file -p 命令，拼接文件夹名称+文件名查看。    \r\n\r\n## commit、tree和blob三个对象之间的关系\r\n![tree](./images/img1.jpg)     \r\n\r\n```bash\r\ncommit: 提交时的镜像\r\ntree: 文件夹\r\nblob: 文件\r\n```\r\n\r\n**【同学问题】** 每次commit，git 都会将当前项目的所有文件夹及文件快照保存到objects目录，如果项目文件比较大，不断迭代，commit无数次后，objects目录中文件大小是不是会变得无限大？    \r\n**【老师解答】** Git对于内容相同的文件只会存一个blob，不同的commit的区别是commit、tree和有差异的blob，多数未变更的文件对应的blob都是相同的，这么设计对于版本管理系统来说可以省很多存储空间。其次，Git还有增量存储的机制，我估计是对于差异很小的blob设计的吧。    \r\n\r\n\r\n\r\n## 分离头指针情况下的注意事项\r\n\r\ndetached HEAD   \r\n\r\n\r\n\r\n## 进一步理解HEAD和branch\r\n\r\n```bash\r\ngit checkout -b new_branch [具体分支 或 commit] 创建新分支并切换到新分支\r\ngit diff HEAD HEAD~1 比较最近两次提交\r\ngit diff HEAD HEAD~2 比较最近和倒数第三次提交\r\ngit diff HEAD HEAD^  比较最近两次提交\r\ngit diff HEAD HEAD^^ 比较最近和倒数第三次提交\r\n```\r\n\r\n\r\n\r\n## 怎么删除不需要的分支？\r\n\r\n查看分支：   \r\n```bash\r\ngit branch -av\r\n```\r\n删除分支命令：    \r\n```bash\r\ngit branch -d [branch name]  删除\r\ngit branch -D [branch name]  强制删除\r\n```\r\n\r\n\r\n\r\n## 怎么修改最新 commit 的 message？\r\n\r\n```bash\r\ngit commit --amend  对最近一次的commit信息进行修改\r\n```\r\n\r\n\r\n\r\n## 怎么修改老旧 commit 的 message？\r\n\r\n```bash\r\ngit rebase -i [要更改的commit的上一级commit]\r\n```\r\n接下来就是一个交互过程...    \r\n这期间会产生一个detached HEAD，然后将改好的commit指向该detached HEAD，如下图所示：    \r\n![rebase](./images/img2.jpg)    \r\n\r\n**git rebase工作的过程中，就是用了分离头指针。rebase意味着基于新base的commit来变更部分commits。它处理的时候，把HEAD指向base的commit，此时如果该commit没有对应branch，就处于分离头指针的状态，然后重新一个一个生成新的commit，当rebase创建完最后一个commit后，结束分离头状态，Git让变完基的分支名指向HEAD。**    \r\n\r\n\r\n\r\n## 怎样把连续的多个commit整理成1个？\r\n\r\n```bash\r\ngit rebase -i [要更改的commit的上一级commit]\r\n```\r\n```bash\r\n$ git log --graph\r\n* commit 7d3386842a2168ae630b65f687364243139c893c (HEAD -> master, origin/master, origin/HEAD)\r\n| Author: aimuch <liuvay@gmail.com>\r\n| Date:   Thu Dec 20 23:34:18 2018 +0800\r\n|\r\n|     update\r\n|\r\n* commit 9eb3188bbc63cae1bfed5f9dfc1593019e360a6a\r\n| Author: aimuch <liuvay@gmail.com>\r\n| Date:   Wed Dec 19 20:30:14 2018 +0800\r\n|\r\n|     update\r\n|\r\n* commit bbe6d53e2b477f2d2aa402af7f315ecdfc63459e\r\n| Author: aimuch <liuvay@gmail.com>\r\n| Date:   Wed Dec 19 20:12:29 2018 +0800\r\n|\r\n|     update\r\n|\r\n* commit 7735d66ded7f98adeca93d96fb7be12ffb67c76a\r\n| Author: aimuch <liuvay@gmail.com>\r\n| Date:   Wed Dec 19 00:27:00 2018 +0800\r\n|\r\n|     update\r\n|\r\n* commit d9f9d115fab425b5654f8ccfec6a996aef35b76b\r\n| Author: aimuch <liuvay@gmail.com>\r\n| Date:   Wed Dec 19 00:23:36 2018 +0800\r\n|\r\n|     update\r\n\r\n```\r\n```bash\r\npick   7735d66 update #合并到该commit上\r\nsquash bbe6d53 update\r\nsquash 9eb3188 update\r\nsquash 7d33868 update\r\n# Rebase d9f9d11..7d33868 onto d9f9d11 (4 commands)\r\n#\r\n# Commands:\r\n# p, pick <commit> = use commit\r\n# r, reword <commit> = use commit, but edit the commit message\r\n# e, edit <commit> = use commit, but stop for amending\r\n# s, squash <commit> = use commit, but meld into previous commit\r\n# f, fixup <commit> = like \"squash\", but discard this commit\'s log message\r\n# x, exec <command> = run command (the rest of the line) using shell\r\n# b, break = stop here (continue rebase later with \'git rebase --continue\')\r\n# d, drop <commit> = remove commit\r\n# l, label <label> = label current HEAD with a name\r\n# t, reset <label> = reset HEAD to a label\r\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\r\n# .       create a merge commit using the original merge commit\'s\r\n# .       message (or the oneline, if no original merge commit was\r\n# .       specified). Use -c <commit> to reword the commit message.\r\n```\r\n\r\n```bash\r\n# This is a combination of 4 commits.\r\n# This is the 1st commit message:\r\n\r\nupdate\r\n\r\n# This is the commit message #2:\r\n\r\nupdate\r\n\r\n# This is the commit message #3:\r\n\r\nupdate\r\n\r\n# This is the commit message #4:\r\n\r\nupdate\r\n\r\n```\r\n## git 修改.gitignore后生效\r\n```bash\r\ngit rm -r --cached .    #清除缓存\r\ngit add .               #重新trace file\r\ngit commit -m \"update .gitignore\" #提交和注释\r\ngit push origin master  #可选，如果需要同步到remote上的话\r\n```\r\n\r\n\r\n\r\n## 怎么比较暂存区和HEAD所含文件的差异？\r\n\r\n```bash\r\ngit diff --cached\r\n```\r\n或者\r\n```bash\r\ngit diff --staged\r\n```\r\n\r\n\r\n\r\n## 怎么比较工作区和暂存区所含文件的差异？\r\n\r\n```bash\r\ngit diff\r\n```\r\n```bash\r\ngit diff -- [filename/pathname] #比较具体的文件或者路径\r\n```\r\n\r\n\r\n\r\n## 如何让暂存区恢复成和HEAD的一样？\r\n\r\n```bash\r\ngit reset HEAD\r\n```\r\n```bash\r\ngit reset 有三个参数\r\n--soft 这个只是把 HEAD 指向的 commit 恢复到你指定的 commit，暂存区 工作区不变\r\n--hard 这个是 把 HEAD， 暂存区， 工作区 都修改为 你指定的 commit 的时候的文件状态\r\n--mixed 这个是不加时候的默认参数，把 HEAD，暂存区 修改为 你指定的 commit 的时候的文件状态，工作区保持不变\r\n```\r\n\r\n\r\n\r\n##  如何让工作区的文件恢复为和暂存区一样？\r\n\r\n```bash\r\ngit checkout -- <file>...\r\n```\r\n**恢复工作区用checkout，恢复暂存区用reset。**   \r\n\r\n\r\n\r\n## 怎样取消暂存区部分文件的更改？\r\n\r\n```bash\r\ngit reset HEAD -- <file>...\r\n```\r\n\r\n\r\n\r\n## 看看不同提交的指定文件的差异\r\n\r\n```bash\r\ngit diff commit-id1 commit-id2 -- <file>...\r\n```\r\n\r\n\r\n\r\n## 正确删除文件的方法\r\n\r\n```bash\r\ngit rm <file>\r\n```\r\n\r\n\r\n\r\n## 开发中临时加塞了紧急任务怎么处理？\r\n\r\n```bash\r\ngit stash list #查看stash中存放的信息\r\ngit stash #将当前工作区内容存放到\"堆栈\"中\r\n```\r\n```bash\r\ngit stash apply #把\"堆栈\"里面的内容弹出到工作区中，同时\"堆栈\"中信息还在\r\n```\r\n```bash\r\ngit stash pop #把\"堆栈\"里面的内容弹出到工作区中，同时丢弃\"堆栈\"中最新的信息\r\n```\r\n\r\n\r\n\r\n## 如何指定不需要Git管理的文件？\r\n\r\n```bash\r\n.gitignore\r\n```\r\n**【同学提问】** 如果提交commit后，想再忽略一些已经提交的文件，怎么处理。    \r\n**【老师回答】** The problem is that .gitignore ignores just files that weren\'t tracked before (by git add). Run git reset name_of_file to unstage the file and keep it. In case you want to also remove given file from the repository (after pushing), use git rm --cached name_of_file.    \r\n把想忽略的文件添加到 .gitignore ；然后通过 git rm -- cached name_of_file 的方式删除掉git仓库里面无需跟踪的文件。    \r\n\r\n\r\n\r\n##  添加远程仓库\r\n```bash\r\ngit remote add [shortname] [url]\r\n```\r\n\r\n\r\n\r\n## 配置公私钥\r\n\r\n1、 检查是否已存在相应的`ssh key`:    \r\n打开终端, 输入:   \r\n\r\n```bash\r\nls -al ~/.ssh\r\n```\r\n核对列出来的ssh key是否有已存在的，假如你没有看到列出的公私钥对，或是不想再用之前的公私钥对，你可以选择下面的步骤生成新的公私钥对.    \r\n\r\n2、生成新的`ssh key`,并添加至`ssh-agent`:    \r\n打开终端, 使用`ssh key`生成命令：\r\n```bash\r\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\r\n```\r\n**注意** ：后面的邮箱对应相应账号的邮箱，假如是github的账号，且注册账号的邮箱为xxxx@qq.com，则命令行为：`ssh-keygen -t rsa -b 4096 -C \"xxxx@qq.com`。    \r\n\r\n3、接下来会提示你保存的`ssh key`的名称以及路径。默认路径是(`/Users/you/.ssh/id_rsa`) (`you`为用户个人目录)。这一步很重要，如果你使用默认的，且下一个账号也是使用默认的路径和文件名，那么之前的`ssh key`就会被后来生成的`ssh key`重写，从而导致之前的账号不可用。因此，正确的做法是给它命名，最后以应用名进行命名，因为更容易区分。以下是我个人配的：\r\n```bash\r\n/Users/andy/.ssh/github_rsa \r\n```\r\n\r\n4、接下来会提示设置ssh安全密码。这一步可以使用默认的（即不设置密码），直接按回车即可。倘若想了解更多关于ssh key密码设置的细节，可访问： “Working with SSH key passphrases” 。    \r\n\r\n5、 `ssh key`生成后，接下来需要为`ssh key`添加代理，这是为了让请求自动对应相应的账号。网上很多文章写到需要另外配置`config`文件，经本人亲测，其实是不需要的，在生成了`ssh key`后，通过为生成的`ssh key`添加代理即可，为`ssh key`添加代理命令：`ssh-add ~/.ssh/xxx_rsa,xxx_rsa`是你生成的`ssh key`的私钥名。    \r\n\r\n6、连接测试    \r\n接下来我们测试是否配置成功，打开终端，输入:    \r\n```bash\r\nssh -T git@github.com\r\n```\r\n\r\n\r\n\r\n## 怎么快速淘到感兴趣的开源项目？\r\n\r\n**UI界面高级搜索**： https://github.com/search/advanced     \r\n\r\n**命令高级搜索**：   \r\n```bash\r\ngit 最好 学习 资料 in:readme stars:>1000 language:c\r\n```\r\n上述命令的意思是搜索reademe中包含`git、最好、学习、资料`”且`star大于1000`的，用`C语言编写`的仓库。    ', 0);
INSERT INTO `blog_course` VALUES (227, 'GIt 工作流', 13, '<!-- TOC -->\r\n\r\n- [前言](#前言)\r\n- [一、Git 工作流简介](#一、Git 工作流简介)\r\n    - [集中式工作流](#集中式工作流)\r\n    - [功能分支工作流](#功能分支工作流)\r\n    - [GitFlow 工作流](#GitFlow 工作流)\r\n    - [Forking 工作流](#Forking 工作流)\r\n    - [Pull Requests](#Pull Requests)\r\n- [二、工作流](#二、工作流)\r\n    - [1. 集中式工作流](#1. 集中式工作流)\r\n        - [工作方式](#工作方式-集中式工作流)\r\n        - [解决冲突](#解决冲突-集中式工作流)\r\n        - [示例](#示例-集中式工作流)\r\n            - [有人先初始化好中央仓库](#有人先初始化好中央仓库)\r\n            - [所有人克隆中央仓库](#所有人克隆中央仓库)\r\n            - [小明开发功能](#小明开发功能)\r\n            - [小红开发功能](#小红开发功能)\r\n            - [小明发布功能](#小明发布功能)\r\n            - [小红试着发布功能](#小红试着发布功能)\r\n            - [小红在小明的提交之上 rebase](#小红在小明的提交之上 rebase)\r\n            - [小红解决合并冲突](#小红解决合并冲突)\r\n            - [小红成功发布功能](#小红成功发布功能)\r\n        - [总结](#总结-集中式工作流)\r\n    - [2. 功能分支工作流](#2. 功能分支工作流)\r\n        - [工作方式](#工作方式-功能分支工作流)\r\n        - [Pull Requests](#pull-requests-功能分支工作流)\r\n        - [示例](#示例-功能分支工作流)\r\n            - [小红开始开发一个新功能](#小红开始开发一个新功能)\r\n            - [小红要去吃个午饭](#小红要去吃个午饭)\r\n            - [小红完成功能开发](#小红完成功能开发)\r\n            - [小黑收到 Pull Request](#小黑收到 Pull Request)\r\n            - [小红再做修改](#小红再做修改)\r\n            - [小红发布她的功能](#小红发布她的功能)\r\n            - [与此同时，小明在做和小红一样的事](#与此同时，小明在做和小红一样的事)\r\n        - [总结](#总结-功能分支工作流)\r\n    - [3. GitFlow工作流](#3. GitFlow工作流)\r\n        - [工作方式](#工作方式-GitFlow工作流)\r\n            - [历史分支](#历史分支)\r\n            - [功能分支](#功能分支)\r\n            - [发布分支](#发布分支)\r\n            - [维护分支](#维护分支)\r\n        - [示例](#示例-GitFlow工作流)\r\n            - [创建开发分支](#创建开发分支-GitFlow工作流)\r\n            - [小红和小明开始开发新功能](#小红和小明开始开发新功能)\r\n            - [小红完成功能开发](#小红完成功能开发-1)\r\n            - [小红开始准备发布](#小红开始准备发布)\r\n            - [小红完成发布](#小红完成发布)\r\n            - [最终用户发现 Bug](#最终用户发现 Bug)\r\n        - [总结](#总结-GitFlow工作流)\r\n    - [4. Forking 工作流](#4. Forking 工作流)\r\n        - [工作方式](#工作方式-Forking 工作流)\r\n            - [正式仓库](#正式仓库-Forking 工作流)\r\n            - [Forking 工作流的分支使用方式](#Forking 工作流的分支使用方式)\r\n        - [示例](#示例-Forking 工作流)\r\n            - [项目维护者初始化正式仓库](#项目维护者初始化正式仓库)\r\n            - [开发者 fork 正式仓库](#开发者 fork 正式仓库)\r\n            - [开发者克隆自己 fork 出来的仓库](#开发者克隆自己 fork 出来的仓库)\r\n            - [开发者开发自己的功能](#开发者开发自己的功能)\r\n            - [开发者发布自己的功能](#开发者发布自己的功能)\r\n            - [项目维护者集成开发者的功能](#项目维护者集成开发者的功能)\r\n            - [开发者和正式仓库做同步](#开发者和正式仓库做同步)\r\n        - [总结](#总结-Forking 工作流)\r\n    - [5. Pull Requests](#5. Pull Requests)\r\n        - [解析 Pull Request](#解析 Pull Request)\r\n        - [工作方式](#工作方式-Pull Requests)\r\n            - [在功能分支工作流中使用 Pull Request](#在功能分支工作流中使用 Pull Request)\r\n            - [在 GitFlow 工作流中使用 Pull Request](#在 GitFlow 工作流中使用 Pull Request)\r\n            - [在 Forking 工作流中使用 Pull Request](#在 Forking 工作流中使用 Pull Request)\r\n        - [示例](#示例-Pull Requests)\r\n            - [小红 fork 正式项目](#小红 fork 正式项目)\r\n            - [小红克隆她的 Bitbucket 仓库](#小红克隆她的 Bitbucket 仓库)\r\n            - [小红开发新功能](#小红开发新功能)\r\n        - [编辑代码](#编辑代码)\r\n            - [小红 push 功能到她的 Bitbucket 仓库中](#小红 push 功能到她的 Bitbucket 仓库中)\r\n            - [小红发起 Pull Request](#小红发起 Pull Request)\r\n            - [小明 review Pull Request](#小明 review Pull Request])\r\n            - [小红补加提交](#小红补加提交)\r\n            - [小明接受 Pull Request](#小明接受 Pull Request)\r\n        - [总结](#总结-Pull Requests)\r\n\r\n<!-- /TOC -->\r\n\r\n# 前言\r\n\r\n　　本文将介绍 Git 工作流相关知识，包含集中式工作流，功能分支工作流， GitFlow 工作流，Forking 工作流，Pull Requests 等等基本概念。\r\n\r\n# 一、Git 工作流简介\r\n\r\n工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用增加了难度。这篇指南通过总览公司团队中最常用的几种 Git 工作流让大家可以上手使用。\r\n\r\n在阅读的过程中请记住，本文中的几种工作流是作为方案指导而不是条例规定。在展示了各种工作流可能的用法后，你可以从不同的工作流中挑选或揉合出一个满足你自己需求的工作流。\r\n\r\n## 集中式工作流\r\n\r\n如果你的开发团队成员已经很熟悉 Subversion，集中式工作流让你无需去适应一个全新流程就可以体验 Git 带来的收益。这个工作流也可以作为向更 Git 风格工作流迁移的友好过渡。\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn.png\" height=\"200px\"/></div>\r\n\r\n\r\n\r\n## 功能分支工作流\r\n\r\n功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用 `Pull Requests` 的方式讨论变更。\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-feature-branch-1.png\" width=\"400px\" /></div>\r\n\r\n\r\n\r\n## GitFlow 工作流\r\n\r\nGitFlow 工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-gitflow.png\" /></div>\r\n\r\n## Forking 工作流\r\n\r\nForking 工作流是分布式工作流，充分利用了 Git 在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。x\r\n\r\n\r\n\r\n\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-forking.png\" /></div>\r\n\r\n## Pull Requests\r\n\r\nPull requests 让开发者更方便地进行协作的功能，提供了友好的 Web 界面可以在提议的修改合并到正式项目之前对修改进行讨论。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request.png\" /></div>\r\n\r\n# 二、工作流\r\n\r\n## 1. 集中式工作流\r\n\r\n转到分布式版本控制系统看起来像个令人生畏的任务，但不改变已用的工作流你也可以用上 Git 带来的收益。团队可以用和 Subversion 完全不变的方式来开发项目。\r\n\r\n但使用 Git 加强开发的工作流，Git 比 SVN 有几个优势。首先，每个开发可以有属于自己的整个工程的本地拷贝。隔离的环境让各个开发者的工作和项目的其他部分（修改）独立开来 —— 即自由地提交到自己的本地仓库，先完全忽略上游的开发，直到方便的时候再把修改反馈上去。\r\n\r\n其次，Git 提供了强壮的分支和合并模型。不像 SVN，Git 的分支设计成可以做为一种用来在仓库之间集成代码和分享修改的『失败安全』的机制。\r\n\r\n### 工作方式-集中式工作流\r\n\r\n像 Subversion 一样，集中式工作流以中央仓库作为项目所有修改的单点实体。相比 SVN 缺省的开发分支 trunk，Git 叫做 master，所有修改提交到这个分支上。该工作流只用到 master 这一个分支。\r\n\r\n开发者开始先克隆中央仓库。在自己的项目拷贝中，像 SVN 一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。\r\n\r\n要发布修改到正式项目中，开发者要把本地 master 分支的修改『推（`push`）』到中央仓库中。这相当于 svn commit 操作，但 `push` 操作会把所有还不在中央仓库的本地提交都推上去。\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-push-local.png\" width=\"\"/></div>\r\n\r\n### 解决冲突-集中式工作流\r\n\r\n中央仓库代表了正式项目，所以提交历史应该被尊重且是稳定不变的。如果开发者本地的提交历史和中央仓库有分歧，Git 会拒绝 `push` 提交否则会覆盖已经在中央库的正式提交。\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-managingconflicts.png\" width=\"\"/></div>\r\n\r\n在开发者提交自己功能修改到中央库前，需要先 `fetch` 在中央库的新增提交，`rebase` 自己提交到中央库提交历史之上。这样做的意思是在说，『我要把自己的修改加到别人已经完成的修改上。』最终的结果是一个完美的线性历史，就像以前的 `SVN` 的工作流中一样。\r\n\r\n如果本地修改和上游提交有冲突，Git 会暂停 `rebase` 过程，给你手动解决冲突的机会。Git 解决合并冲突，用和生成提交一样的 `git status` 和 `git add` 命令，很一致方便。还有一点，如果解决冲突时遇到麻烦，Git 可以很简单中止整个 `rebase` 操作，重来一次（或者让别人来帮助解决）。\r\n\r\n### 示例-集中式工作流\r\n\r\n让我们一起逐步分解来看看一个常见的小团队如何用这个工作流来协作的。有两个开发者小明和小红，看他们是如何开发自己的功能并提交到中央仓库上的。\r\n\r\n#### 有人先初始化好中央仓库\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-initialize.png\" width=\"\"/></div>\r\n\r\n第一步，有人在服务器上创建好中央仓库。如果是新项目，你可以初始化一个空仓库；否则你要导入已有的 Git 或 SVN 仓库。\r\n\r\n中央仓库应该是个裸仓库（bare repository），即没有工作目录（working directory）的仓库。\r\n\r\n#### 所有人克隆中央仓库\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-clone.png\" width=\"\"/></div>\r\n\r\n下一步，各个开发者创建整个项目的本地拷贝。通过 `git clone` 命令完成：\r\n\r\n```\r\ngit clone https://github.com/path/to/repo.git\r\n```\r\n\r\n基于你后续会持续和克隆的仓库做交互的假设，克隆仓库时 Git 会自动添加远程别名 origin 指回『父』仓库。\r\n\r\n#### 小明开发功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-1.png\" width=\"\"/></div>\r\n\r\n在小明的本地仓库中，他使用标准的 Git 过程开发功能：编辑、暂存（Stage）和提交。如果你不熟悉暂存区（Staging Area），这里说明一下：暂存区的用来准备一个提交，但可以不用把工作目录中所有的修改内容都包含进来。这样你可以创建一个高度聚焦的提交，尽管你本地修改很多内容。\r\n\r\n```\r\ngit status # 查看本地仓库的修改状态\r\ngit add # 暂存文件\r\ngit commit # 提交文件\r\n```\r\n\r\n请记住，因为这些命令生成的是本地提交，小明可以按自己需求反复操作多次，而不用担心中央仓库上有了什么操作。对需要多个更简单更原子分块的大功能，这个做法是很有用的。\r\n\r\n#### 小红开发功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-2.png\" width=\"\"/></div>\r\n\r\n与此同时，小红在自己的本地仓库中用相同的编辑、暂存和提交过程开发功能。和小明一样，她也不关心中央仓库有没有新提交；当然更不关心小明在他的本地仓库中的操作，因为所有本地仓库都是私有的。\r\n\r\n#### 小明发布功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-3.png\" width=\"\"/></div>\r\n\r\n一旦小明完成了他的功能开发，会发布他的本地提交到中央仓库中，这样其它团队成员可以看到他的修改。他可以用下面的 `git push` 命令：\r\n\r\n```\r\ngit push origin master\r\n```\r\n\r\n注意，origin 是在小明克隆仓库时 Git 创建的远程中央仓库别名。master 参数告诉 Git 推送的分支。由于中央仓库自从小明克隆以来还没有被更新过，所以 push 操作不会有冲突，成功完成。\r\n\r\n#### 小红试着发布功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-4.png\" width=\"\"/></div>\r\n\r\n一起来看看在小明发布修改后，小红 push 修改会怎么样？她使用完全一样的 push 命令：\r\n\r\n```\r\ngit push origin master\r\n```\r\n\r\n但她的本地历史已经和中央仓库有分岐了，Git 拒绝操作并给出下面很长的出错消息：\r\n\r\n```\r\nerror: failed to push some refs to \'/path/to/repo.git\'\r\nhint: Updates were rejected because the tip of your current branch is behind\r\nhint: its remote counterpart. Merge the remote changes (e.g. \'git pull\')\r\nhint: before pushing again.\r\nhint: See the \'Note about fast-forwards\' in \'git push --help\' for details.\r\n```\r\n\r\n这避免了小红覆写正式的提交。她要先 pull 小明的更新到她的本地仓库合并上她的本地修改后，再重试。\r\n\r\n#### 小红在小明的提交之上 rebase\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-5.png\" width=\"\"/></div>\r\n\r\n小红用 `git pull` 合并上游的修改到自己的仓库中。这条命令类似 `svn update` ——拉取所有上游提交命令到小红的本地仓库，并尝试和她的本地修改合并：\r\n\r\n```\r\ngit pull --rebase origin master\r\n```\r\n\r\n`--rebase` 选项告诉 Git 把小红的提交移到同步了中央仓库修改后的 master 分支的顶部，如下图所示：\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-6.png\" width=\"\"/></div>\r\n\r\n如果你忘加了这个选项，pull 操作仍然可以完成，但每次 pull 操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。对于集中式工作流，最好是使用 rebase 而不是生成一个合并提交。\r\n\r\n#### 小红解决合并冲突\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-7.png\" width=\"\"/></div>\r\n\r\nrebase 操作过程是把本地提交一次一个地迁移到更新了的中央仓库 master 分支之上。这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入 Bug 的分析，如果有必要，回滚修改也可以做到对项目影响最小。\r\n\r\n如果小红和小明的功能是相关的，不大可能在 rebase 过程中有冲突。如果有，Git 在合并有冲突的提交处暂停 rebase 过程，输出下面的信息并带上相关的指令：\r\n\r\n```\r\nCONFLICT (content): Merge conflict in\r\n```\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-8.png\" width=\"\"/></div>\r\n\r\nGit 很赞的一点是，任何人可以解决他自己的冲突。在这个例子中，小红可以简单的运行 `git status` 命令来查看哪里有问题。冲突文件列在 Unmerged paths（未合并路径）一节中：\r\n\r\n```\r\n# Unmerged paths:\r\n# (use \"git reset HEAD <some-file>...\" to unstage)\r\n# (use \"git add/rm <some-file>...\" as appropriate to mark resolution)\r\n#\r\n# both modified: <some-file>\r\n```\r\n\r\n接着小红编辑这些文件。修改完成后，用老套路暂存这些文件，并让 `git rebase` 完成剩下的事：\r\n\r\n```\r\ngit add\r\ngit rebase --continue\r\n```\r\n\r\n要做的就这些了。Git 会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。\r\n\r\n如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行 `git pull --rebase` 命令前的样子：\r\n\r\n```\r\ngit rebase --abort\r\n```\r\n\r\n#### 小红成功发布功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-svn-9.png\" width=\"\"/></div>\r\n\r\n小红完成和中央仓库的同步后，就能成功发布她的修改了：\r\n\r\n```\r\ngit push origin master\r\n```\r\n\r\n### 总结-集中式工作流\r\n\r\n如你所见，仅使用几个 Git 命令我们就可以模拟出传统 Subversion 开发环境。对于要从 SVN 迁移过来的团队来说这太好了，但没有发挥出 Git 分布式本质的优势。\r\n\r\n如果你的团队适应了集中式工作流，但想要更流畅的协作效果，绝对值得探索一下功能分支工作流的收益。通过为一个功能分配一个专门的分支，能够做到一个新增功能集成到正式项目之前对新功能进行深入讨论。\r\n\r\n\r\n\r\n## 2. 功能分支工作流\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-feature-branch-1-1542442210570.png\" width=\"\"/></div>\r\n\r\n一旦你玩转了集中式工作流，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。\r\n\r\n功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在 master 分支上。这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。另外，也保证了 master 分支的代码一定不会是有问题的，极大有利于集成环境。\r\n\r\n功能开发隔离也让 pull requests 工作流成功可能，pull requests 工作流能为每个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。另外，如果你在功能开发中有问题卡住了，可以开一个 pull requests 来向同学们征求建议。这些做法的重点就是，pull requests 让团队成员之间互相评论工作变成非常方便！\r\n\r\n### 工作方式-功能分支工作流\r\n\r\n功能分支工作流仍然用中央仓库，并且 master 分支还是代表了正式项目的历史。但不是直接提交本地历史到各自的本地 master 分支，开发者每次在开始新功能前先创建一个新分支。功能分支应该有个有描述性的名字，比如 animated-menu-items 或 issue-#1061，这样可以让分支有个清楚且高聚焦的用途。\r\n\r\n在 master 分支和功能分支之间，Git 是没有技术上的区别，所以开发者可以用和集中式工作流中完全一样的方式编辑、暂存和提交修改到功能分支上。\r\n\r\n另外，功能分支也可以（且应该）push 到中央仓库中。这样不修改正式代码就可以和其它开发者分享提交的功能。由于 master 仅有的一个『特殊』分支，在中央仓库上存多个功能分支不会有任何问题。当然，这样做也可以很方便地备份各自的本地提交。\r\n\r\n### Pull Requests-功能分支工作流\r\n\r\n功能分支除了可以隔离功能的开发，也使得通过 Pull Requests 讨论变更成为可能。一旦某个开发完成一个功能，不是立即合并到 master，而是 push 到中央仓库的功能分支上并发起一个 Pull Request 请求去合并修改到 master。在修改成为主干代码前，这让其它的开发者有机会先去 Review 变更。\r\n\r\nCode Review 是 Pull Requests 的一个重要的收益，但 Pull Requests 目的是讨论代码一个通用方式。你可以把 Pull Requests 作为专门给某个分支的讨论。这意味着可以在更早的开发过程中就可以进行 Code Review。比如，一个开发者开发功能需要帮助时，要做的就是发起一个 Pull Request，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。\r\n\r\n一旦 Pull Request 被接受了，发布功能要做的就和集中式工作流就很像了。首先，确定本地的 master 分支和上游的 master 分支是同步的。然后合并功能分支到本地 master 分支并 push 已经更新的本地 master 分支到中央仓库。\r\n\r\n### 示例-功能分支工作流\r\n\r\n下面的示例演示了如何把 Pull Requests 作为 Code Review 的方式，但注意 Pull Requests 可以用于很多其它的目的。\r\n\r\n#### 小红开始开发一个新功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-feature-branch-2.png\" width=\"\"/></div>\r\n\r\n在开始开发功能前，小红需要一个独立的分支。使用下面的命令新建一个分支：\r\n\r\n```\r\ngit checkout -b marys-feature master\r\n```\r\n\r\n这个命令检出一个基于 master 名为 marys-feature 的分支，Git 的 `-b` 选项表示如果分支还不存在则新建分支。这个新分支上，小红按老套路编辑、暂存和提交修改，按需要提交以实现功能：\r\n\r\n```\r\ngit status\r\ngit add\r\ngit commit\r\n```\r\n\r\n#### 小红要去吃个午饭\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-feature-branch-3.png\" width=\"\"/></div>\r\n\r\n早上小红为新功能添加一些提交。去吃午饭前，push 功能分支到中央仓库是很好的做法，这样可以方便地备份，如果和其它开发协作，也让他们可以看到小红的提交。\r\n\r\n```\r\ngit push -u origin marys-feature\r\n```\r\n\r\n这条命令 `push marys-feature` 分支到中央仓库（origin），`-u` 选项设置本地分支去跟踪远程对应的分支。设置好跟踪的分支后，小红就可以使用 `git push` 命令省去指定推送分支的参数。\r\n\r\n#### 小红完成功能开发\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-feature-branch-4.png\" width=\"\"/></div>\r\n\r\n小红吃完午饭回来，完成整个功能的开发。在合并到 master 之前，她发起一个 Pull Request 让团队的其它人知道功能已经完成。但首先，她要确认中央仓库中已经有她最近的提交：\r\n\r\n```\r\ngit push\r\n```\r\n\r\n然后，在她的 Git GUI 客户端中发起 Pull Request，请求合并 marys-feature 到 master，团队成员会自动收到通知。Pull Request 很酷的是可以在相关的提交旁边显示评注，所以你可以很对某个变更集提问。\r\n\r\n#### 小黑收到 Pull Request\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-feature-branch-5.png\" width=\"\"/></div>\r\n\r\n小黑收到了 Pull Request 后会查看 marys-feature 的修改。决定在合并到正式项目前是否要做些修改，且通过 Pull Request 和小红来回地讨论。\r\n\r\n#### 小红再做修改\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-feature-branch-6.png\" width=\"\"/></div>\r\n\r\n要再做修改，小红用和功能第一个迭代完全一样的过程。编辑、暂存、提交并push更新到中央仓库。小红这些活动都会显示在 Pull Request 上，小黑可以断续做评注。\r\n\r\n如果小黑有需要，也可以把 marys-feature 分支拉到本地，自己来修改，他加的提交也会一样显示在 Pull Request 上。\r\n\r\n#### 小红发布她的功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-feature-branch-7.png\" width=\"\"/></div>\r\n\r\n一旦小黑可以的接受 Pull Request，就可以合并功能到稳定项目代码中（可以由小黑或是小红来做这个操作）：\r\n\r\n```\r\ngit checkout master\r\ngit pull\r\ngit pull origin marys-feature\r\ngit push\r\n```\r\n\r\n无论谁来做合并，首先要检出 master 分支并确认是它是最新的。然后执行 `git pull origin marys-feature` 合并 marys-feature 分支到和已经和远程一致的本地 master 分支。你可以使用简单 `git merge marys-feature` 命令，但前面的命令可以保证总是最新的新功能分支。最后更新的 master 分支要重新 push 回到 origin。\r\n\r\n这个过程常常会生成一个合并提交。有些开发者喜欢有合并提交，因为它像一个新功能和原来代码基线的连通符。但如果你偏爱线性的提交历史，可以在执行合并时 rebase 新功能到 master 分支的顶部，这样生成一个快进（fast-forward）的合并。\r\n\r\n一些 GUI 客户端可以只要点一下『接受』按钮执行好上面的命令来自动化 Pull Request 接受过程。如果你的不能这样，至少在功能合并到 master 分支后能自动关闭 Pull Request。\r\n\r\n#### 与此同时，小明在做和小红一样的事\r\n\r\n当小红和小黑在 marys-feature 上工作并讨论她的 Pull Request 的时候，小明在自己的功能分支上做完全一样的事。\r\n\r\n通过隔离功能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。\r\n\r\n### 总结-功能分支工作流\r\n\r\n到了这里，但愿你发现了功能分支可以很直接地在集中式工作流的仅有的 master 分支上完成多功能的开发。另外，功能分支还使用了 Pull Request，使得可以在你的版本控制 GUI 客户端中讨论某个提交。\r\n\r\n功能分支工作流是开发项目异常灵活的方式。问题是，有时候太灵活了。对于大型团队，常常需要给不同分支分配一个更具体的角色。GitFlow 工作流是管理功能开发、发布准备和维护的常用模式。\r\n\r\n\r\n\r\n## 3. GitFlow工作流\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-gitflow-1542442241823.png\" width=\"\"/></div>\r\n\r\nGitFlow 工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。\r\n\r\nGitFlow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。\r\n\r\n### 工作方式-GitFlow工作流\r\n\r\nGitFlow 工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并 push 分支到中央仓库中。\r\n\r\n#### 历史分支\r\n\r\n相对使用仅有的一个 master 分支，GitFlow 工作流使用2个分支来记录项目的历史。master 分支存储了正式发布的历史，而 develop 分支作为功能的集成分支。这样也方便 master 分支上的所有提交分配一个版本号。\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-1historical.png\" width=\"\"/></div>\r\n\r\n剩下要说明的问题围绕着这2个分支的区别展开。\r\n\r\n#### 功能分支\r\n\r\n每个新功能位于一个自己的分支，这样可以 push 到中央仓库以备份和协作。但功能分支不是从 master 分支上拉出新分支，而是使用 develop 分支作为父分支。当新功能完成时，合并回 develop 分支。新功能提交应该从不直接与 master 分支交互。\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-2feature.png\" width=\"\"/></div>\r\n\r\n注意，从各种含义和目的上来看，功能分支加上 develop 分支就是功能分支工作流的用法。但 GitFlow 工作流没有在这里止步。\r\n\r\n#### 发布分支\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-3release.png\" width=\"\"/></div>\r\n\r\n一旦 develop 分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从 develop 分支上 fork 一个发布分支。新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上 —— 这个分支只应该做 Bug 修复、文档生成和其它面向发布任务。一旦对外发布的工作都完成了，发布分支合并到 master 分支并分配一个版本号打好 Tag。另外，这些从新建发布分支以来的做的修改要合并回 develop 分支。\r\n\r\n使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本 4.0』，并且在仓库的目录结构中可以实际看到）。\r\n\r\n常用的分支约定：\r\n\r\n- 用于新建发布分支的分支: develop\r\n- 用于合并的分支: master\r\n- 分支命名: release- *或 release/*\r\n\r\n#### 维护分支\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-4maintenance.png\" width=\"\"/></div>\r\n\r\n维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从 master 分支 fork 出来的分支。修复完成，修改应该马上合并回 master 分支和 develop 分支（当前的发布分支），master 分支应该用新的版本号打好 Tag。\r\n\r\n为 Bug 修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。你可以把维护分支想成是一个直接在 master 分支上处理的临时发布。\r\n\r\n### 示例-GitFlow工作流\r\n\r\n下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。\r\n\r\n#### 创建开发分支-GitFlow工作流\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-5createdev.png\" width=\"\"/></div>\r\n\r\n第一步为 master 分支配套一个 develop 分支。简单来做可以本地创建一个空的 develop 分支，push 到服务器上：\r\n\r\n```\r\ngit branch develop\r\ngit push -u origin develop\r\n```\r\n\r\n以后这个分支将会包含了项目的全部历史，而 master 分支将只包含了部分历史。其它开发者这时应该克隆中央仓库，建好 develop 分支的跟踪分支：\r\n\r\n```\r\ngit clone ssh://user@host/path/to/repo.git\r\ngit checkout -b develop origin/develop\r\n```\r\n\r\n现在每个开发都有了这些历史分支的本地拷贝。\r\n\r\n#### 小红和小明开始开发新功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-6maryjohnbeginnew.png\" width=\"\"/></div>\r\n\r\n这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于 master 分支，而是应该基于 develop 分支：\r\n\r\n```\r\ngit checkout -b some-feature develop\r\n```\r\n\r\n他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：\r\n\r\n```\r\ngit status\r\ngit add\r\ngit commit\r\n```\r\n\r\n#### 小红完成功能开发-1\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-7maryfinishes.png\" width=\"\"/></div>\r\n\r\n添加了提交后，小红觉得她的功能 OK 了。如果团队使用 Pull Requests，这时候可以发起一个用于合并到 develop 分支。否则她可以直接合并到她本地的 develop 分支后 push 到中央仓库：\r\n\r\n```\r\ngit pull origin develop\r\ngit checkout develop\r\ngit merge some-feature\r\ngit push\r\ngit branch -d some-feature\r\n```\r\n\r\n第一条命令在合并功能前确保 develop 分支是最新的。注意，功能决不应该直接合并到 master 分支。冲突解决方法和集中式工作流一样。\r\n\r\n#### 小红开始准备发布\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-8maryprepsrelease.png\" width=\"\"/></div>\r\n\r\n这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号：\r\n\r\n```\r\ngit checkout -b release-0.1 develop\r\n```\r\n\r\n这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。\r\n\r\n只要小红创建这个分支并 push 到中央仓库，这个发布就是功能冻结的。任何不在 develop 分支中的新功能都推到下个发布循环中。\r\n\r\n#### 小红完成发布\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-release-cycle-9maryfinishes.png\" width=\"\"/></div>\r\n\r\n一旦准备好了对外发布，小红合并修改到 master 分支和 develop 分支上，删除发布分支。合并回 develop 分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。另外，如果小红的团队要求 Code Review，这是一个发起 Pull Request 的理想时机。\r\n\r\n```\r\ngit checkout master\r\ngit merge release-0.1\r\ngit push\r\ngit checkout develop\r\ngit merge release-0.1\r\ngit push\r\ngit branch -d release-0.1\r\n```\r\n\r\n发布分支是作为功能开发（develop 分支）和对外发布（master 分支）间的缓冲。只要有合并到 master 分支，就应该打好 Tag 以方便跟踪。\r\n\r\n```\r\ngit tag -a 0.1 -m \"Initial public release\" master\r\ngit push --tags\r\n```\r\n\r\nGit 有提供各种勾子（hook），即仓库有事件发生时触发执行的脚本。可以配置一个勾子，在你 push 中央仓库的 master 分支时，自动构建好对外发布。\r\n\r\n#### 最终用户发现 Bug\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflow-gitflow-enduserbug.png\" width=\"\"/></div>\r\n\r\n对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个 Ticket 抱怨当前版本的一个 Bug。为了处理 Bug，小红（或小明）从 master 分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回 master 分支：\r\n\r\n```\r\ngit checkout -b issue-#001 master\r\n# Fix the bug\r\ngit checkout master\r\ngit merge issue-#001\r\ngit push\r\n```\r\n\r\n就像发布分支，维护分支中新加这些重要修改需要包含到 develop 分支中，所以小红要执行一个合并操作。然后就可以安全地删除这个分支了：\r\n\r\n```\r\ngit checkout develop\r\ngit merge issue-#001\r\ngit push\r\ngit branch -d issue-#001\r\n```\r\n\r\n### 总结-GitFlow工作流\r\n\r\n到了这里，但愿你对集中式工作流、功能分支工作流和 GitFlow 工作流已经感觉很舒适了。你应该也牢固的掌握了本地仓库的潜能，push/pull 模式和 Git 健壮的分支和合并模型。\r\n\r\n记住，这里演示的工作流只是可能用法的例子，而不是在实际工作中使用 Git 不可违逆的条例。所以不要畏惧按自己需要对工作流的用法做取舍。不变的目标就是让 Git 为你所用。\r\n\r\n\r\n\r\n## 4. Forking 工作流\r\n\r\nForking 工作流和前面讨论的几种工作流有根本的不同。这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有 2 个 Git 仓库而不是 1 个：一个本地私有的，另一个服务端公开的。\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-forking.png\" width=\"\"/></div>\r\n\r\nForking 工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能 push 代码到仅有的中央仓库中。开发者 push 到自己的服务端仓库，而只有项目维护者才能 push 到正式仓库。这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。\r\n\r\n效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。也让这个工作流成为开源项目的理想工作流。\r\n\r\n### 工作方式-Forking 工作流\r\n\r\n和其它的 Git 工作流一样，Forking 工作流要先有一个公开的正式仓库存储在服务器上。但一个新的开发者想要在项目上工作时，不是直接从正式仓库克隆，而是 fork 正式项目在服务器上创建一个拷贝。\r\n\r\n这个仓库拷贝作为他个人公开仓库 —— 其它开发者不允许 push 到这个仓库，但可以 pull 到修改（后面我们很快就会看这点很重要）。在创建了自己服务端拷贝之后，和之前的工作流一样，开发者执行 git clone 命令克隆仓库到本地机器上，作为私有的开发环境。\r\n\r\n要提交本地修改时，push 提交到自己公开仓库中 —— 而不是正式仓库中。然后，给正式仓库发起一个 pull request，让项目维护者知道有更新已经准备好可以集成了。对于贡献的代码，pull request 也可以很方便地作为一个讨论的地方。\r\n\r\n为了集成功能到正式代码库，维护者 pull 贡献者的变更到自己的本地仓库中，检查变更以确保不会让项目出错，合并变更到自己本地的 master 分支，然后 push master 分支到服务器的正式仓库中。到此，贡献的提交成为了项目的一部分，其它的开发者应该执行 pull 操作与正式仓库同步自己本地仓库。\r\n\r\n#### 正式仓库-Forking 工作流\r\n\r\n在 Forking 工作流中，『官方』仓库的叫法只是一个约定，理解这点很重要。从技术上来看，各个开发者仓库和正式仓库在Git看来没有任何区别。事实上，让正式仓库之所以正式的唯一原因是它是项目维护者的公开仓库。\r\n\r\n#### Forking 工作流的分支使用方式\r\n\r\n所有的个人公开仓库实际上只是为了方便和其它的开发者共享分支。各个开发者应该用分支隔离各个功能，就像在功能分支工作流和 GitFlow 工作流一样。唯一的区别是这些分支被共享了。在 Forking 工作流中这些分支会被 pull 到另一个开发者的本地仓库中，而在功能分支工作流和 GitFlow 工作流中是直接被 push 到正式仓库中。\r\n\r\n### 示例-Forking 工作流\r\n\r\n#### 项目维护者初始化正式仓库\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-forking-1.png\" width=\"\"/></div>\r\n\r\n和任何使用 Git 项目一样，第一步是创建在服务器上一个正式仓库，让所有团队成员都可以访问到。通常这个仓库也会作为项目维护者的公开仓库。\r\n\r\n公开仓库应该是裸仓库，不管是不是正式代码库。所以项目维护者会运行像下面的命令来搭建正式仓库：\r\n\r\n```\r\nssh user@host\r\ngit init --bare /path/to/repo.git\r\n```\r\n\r\nBitbucket 和 Stash 提供了一个方便的 GUI 客户端以完成上面命令行做的事。这个搭建中央仓库的过程和前面提到的工作流完全一样。如果有现存的代码库，维护者也要 push 到这个仓库中。\r\n\r\n#### 开发者 fork 正式仓库\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-forking-2.png\" width=\"\"/></div>\r\n\r\n其它所有的开发需要 fork 正式仓库。可以用 git clone 命令用 SSH 协议连通到服务器，拷贝仓库到服务器另一个位置 —— 是的，fork 操作基本上就只是一个服务端的克隆。Bitbucket 和 Stash 上可以点一下按钮就让开发者完成仓库的 fork 操作。\r\n\r\n这一步完成后，每个开发都在服务端有一个自己的仓库。和正式仓库一样，这些仓库应该是裸仓库。\r\n\r\n#### 开发者克隆自己 fork 出来的仓库\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-forking-3.png\" width=\"\"/></div>\r\n\r\n下一步，各个开发者要克隆自己的公开仓库，用熟悉的 git clone 命令。\r\n\r\n在这个示例中，假定用 Bitbucket 托管了仓库。记住，如果这样的话各个开发者需要有各自的 Bitbucket 账号，使用下面命令克隆服务端自己的仓库：\r\n\r\n```\r\ngit clone https://user@bitbucket.org/user/repo.git\r\n```\r\n\r\n相比前面介绍的工作流只用了一个 origin 远程别名指向中央仓库，Forking 工作流需要 2 个远程别名 —— 一个指向正式仓库，另一个指向开发者自己的服务端仓库。别名的名字可以任意命名，常见的约定是使用 origin 作为远程克隆的仓库的别名（这个别名会在运行 git clone 自动创建），upstream（上游）作为正式仓库的别名。\r\n\r\n```\r\ngit remote add upstream https://bitbucket.org/maintainer/repo\r\n```\r\n\r\n需要自己用上面的命令创建 upstream 别名。这样可以简单地保持本地仓库和正式仓库的同步更新。注意，如果上游仓库需要认证（比如不是开源的），你需要提供用户：\r\n\r\n```\r\ngit remote add upstream https://user@bitbucket.org/maintainer/repo.git\r\n```\r\n\r\n这时在克隆和 pull 正式仓库时，需要提供用户的密码。\r\n\r\n#### 开发者开发自己的功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-forking-4.png\" width=\"\"/></div>\r\n\r\n在刚克隆的本地仓库中，开发者可以像其它工作流一样的编辑代码、提交修改和新建分支：\r\n\r\n```\r\ngit checkout -b some-feature\r\n// Edit some code\r\ngit commit -a -m \"Add first draft of some feature\"\r\n```\r\n\r\n所有的修改都是私有的直到 push 到自己公开仓库中。如果正式项目已经往前走了，可以用 git pull 命令获得新的提交：\r\n\r\n```\r\ngit pull upstream master\r\n```\r\n\r\n由于开发者应该都在专门的功能分支上工作，pull 操作结果会都是快进合并。\r\n\r\n#### 开发者发布自己的功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-forking-5.png\" width=\"\"/></div>\r\n\r\n一旦开发者准备好了分享新功能，需要做二件事。首先，通过push他的贡献代码到自己的公开仓库中，让其它的开发者都可以访问到。他的 origin 远程别名应该已经有了，所以要做的就是：\r\n\r\n```\r\ngit push origin feature-branch\r\n```\r\n\r\n这里和之前的工作流的差异是，origin 远程别名指向开发者自己的服务端仓库，而不是正式仓库。\r\n\r\n第二件事，开发者要通知项目维护者，想要合并他的新功能到正式库中。Bitbucket 和 Stash 提供了 Pull Request 按钮，弹出表单让你指定哪个分支要合并到正式仓库。一般你会想集成你的功能分支到上游远程仓库的 master 分支中。\r\n\r\n#### 项目维护者集成开发者的功能\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-forking-6.png\" width=\"\"/></div>\r\n\r\n当项目维护者收到 pull request，他要做的是决定是否集成它到正式代码库中。有二种方式来做：\r\n\r\n- 直接在 pull request 中查看代码\r\n- pull 代码到他自己的本地仓库，再手动合并\r\n\r\n第一种做法更简单，维护者可以在 GUI 中查看变更的差异，做评注和执行合并。但如果出现了合并冲突，需要第二种做法来解决。这种情况下，维护者需要从开发者的服务端仓库中 fetch 功能分支，合并到他本地的 master 分支，解决冲突：\r\n\r\n```\r\ngit fetch https://bitbucket.org/user/repo feature-branch\r\n// 查看变更\r\ngit checkout master\r\ngit merge FETCH_HEAD\r\n```\r\n\r\n变更集成到本地的 master 分支后，维护者要 push 变更到服务器上的正式仓库，这样其它的开发者都能访问到：\r\n\r\n```\r\ngit push origin master\r\n```\r\n\r\n注意，维护者的 origin 是指向他自己公开仓库的，即是项目的正式代码库。到此，开发者的贡献完全集成到了项目中\r\n\r\n#### 开发者和正式仓库做同步\r\n\r\n<div align=\"center\"> <img src=\"assets/git-workflows-forking-7.png\" width=\"\"/></div>\r\n\r\n由于正式代码库往前走了，其它的开发需要和正式仓库做同步：\r\n\r\n```\r\ngit pull upstream master\r\n```\r\n\r\n### 总结-Forking 工作流\r\n\r\n如果你之前是使用 SVN，Forking 工作流可能看起来像是一个激进的范式切换（paradigm shift）。但不要害怕，这个工作流实际上就是在功能分支工作流之上引入另一个抽象层。不是直接通过单个中央仓库来分享分支，而是把贡献代码发布到开发者自己的服务端仓库中。\r\n\r\n示例中解释了，一个贡献如何从一个开发者流到正式的 master 分支中，但同样的方法可以把贡献集成到任一个仓库中。比如，如果团队的几个人协作实现一个功能，可以在开发之间用相同的方法分享变更，完全不涉及正式仓库。\r\n\r\n这使得 Forking 工作流对于松散组织的团队来说是个非常强大的工具。任一开发者可以方便地和另一开发者分享变更，任何分支都能有效地合并到正式代码库中。\r\n\r\n\r\n\r\n\r\n\r\n## 5. Pull Requests\r\n\r\nPull Requests 是 Bitbucket 上方便开发者之间协作的功能。提供了一个用户友好的 Web 界面，在集成提交的变更到正式项目前可以对变更进行讨论。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-bitbucket.png\" width=\"\"/></div>\r\n\r\n开发者向团队成员通知功能开发已经完成，Pull Requests 是最简单的用法。开发者完成功能开发后，通过 Bitbucket 账号发起一个 Pull Request。这样让涉及这个功能的所有人知道，要去做 Code Review 和合并到 master 分支。\r\n\r\n但是，Pull Request 远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。如果变更有任何问题，团队成员反馈在 Pull Request 中，甚至 push 新的提交微调功能。所有的这些活动都直接跟踪在 Pull Request 中。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-overview.png\" width=\"\"/></div>\r\n\r\n相比其它的协作模型，这种分享提交的形式有助于打造一个更流畅的工作流。SVN 和 Git 都能通过一个简单的脚本收到通知邮件；但是，讨论变更时，开发者通常只能去回复邮件。这样做会变得杂乱，尤其还要涉及后面的几个提交时。Pull Requests 把所有相关功能整合到一个和 Bitbucket 仓库界面集成的用户友好 Web 界面中。\r\n\r\n### 解析 Pull Request\r\n\r\n当要发起一个 Pull Request，你所要做的就是请求（Request）另一个开发者（比如项目的维护者），来 pull 你仓库中一个分支到他的仓库中。这意味着你要提供 4 个信息（源仓库、源分支、目的仓库、目的分支），以发起 Pull Request。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-anatomy.png\" width=\"\"/></div>\r\n\r\n### 工作方式-Pull Requests\r\n\r\nPull Request 可以和功能分支工作流、GitFlow 工作流或 Forking 工作流一起使用。但 Pull Request 要求要么分支不同，要么仓库不同，所以不能用于集中式工作流。在不同的工作流中使用 Pull Request 会有一些不同，但基本的过程是这样的：\r\n\r\n- 开发者在本地仓库中新建一个专门的分支开发功能。\r\n- 开发者 push 分支修改到公开的 Bitbucket 仓库中。\r\n- 开发者通过 Bitbucket 发起一个 Pull Request。\r\n- 团队的其它成员 review code，讨论并修改。\r\n- 项目维护者合并功能到官方仓库中并关闭 Pull Request。\r\n\r\n#### 在功能分支工作流中使用 Pull Request\r\n\r\n功能分支工作流用一个共享的 Bitbucket 仓库来管理协作，开发者在专门的分支上开发功能。但不是立即合并到 master 分支上，而是在合并到主代码库之前开发者应该开一个 Pull Request 发起功能的讨论。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-feature-branch.png\" width=\"\"/></div>\r\n\r\n功能分支工作流只有一个公开的仓库，所以 Pull Request 的目的仓库和源仓库总是同一个。通常开发者会指定他的功能分支作为源分支，master 分支作为目的分支。\r\n\r\n收到 Pull Request 后，项目维护者要决定如何做。如果功能没问题，就简单地合并到 master 分支，关闭 Pull Request。但如果提交的变更有问题，他可以在 Pull Request 中反馈。之后新加的提交也会评论之后接着显示出来\r\n\r\n在功能还没有完全开发完的时候，也可能发起一个 Pull Request。比如开发者在实现某个需求时碰到了麻烦，他可以发一个包含正在进行中工作的 Pull Request。其它的开发者可以在 Pull Request 提供建议，或者甚至直接添加提交来解决问题。\r\n\r\n#### 在 GitFlow 工作流中使用 Pull Request\r\n\r\nGitFlow 工作流和功能分支工作流类似，但围绕项目发布定义一个严格的分支模型。在 GitFlow 工作流中使用 Pull Request 让开发者在发布分支或是维护分支上工作时，可以有个方便的地方对关于发布分支或是维护分支的问题进行交流。\r\n\r\n<div align=\"center\"> <img src=\"assets/gitflow-workflow-pull-request.png\" width=\"\"/></div>\r\n\r\nGitFlow 工作流中 Pull Request 的使用过程和上一节中完全一致：当一个功能、发布或是热修复分支需要 Review 时，开发者简单发起一个 Pull Request，团队的其它成员会通过 Bitbucket 收到通知。\r\n\r\n新功能一般合并到 develop 分支，而发布和热修复则要同时合并到 develop 分支和 master 分支上。Pull Request 可能用做所有合并的正式管理。\r\n\r\n#### 在 Forking 工作流中使用 Pull Request\r\n\r\n在 Forking 工作流中，开发者 push 完成的功能到他自己的仓库中，而不是共享仓库。然后，他发起一个 Pull Request，让项目维护者知道他的功能已经可以 Review 了。\r\n\r\n在这个工作流，Pull Request 的通知功能非常有用，因为项目维护者不可能知道其它开发者在他们自己的仓库添加了提交\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-forking-workflow-1.png\" width=\"\"/></div>\r\n\r\n由于各个开发有自己的公开仓库，Pull Request 的源仓库和目标仓库不是同一个。源仓库是开发者的公开仓库，源分支是包含了修改的分支。如果开发者要合并修改到正式代码库中，那么目标仓库是正式仓库，目标分支是 master 分支。\r\n\r\nPull Request 也可以用于正式项目之外的其它开发者之间的协作。比如，如果一个开发者和一个团队成员一起开发一个功能，他们可以发起一个 Pull Request，用团队成员的 Bitbucket 仓库作为目标，而不是正式项目的仓库。然后使用相同的功能分支作为源和目标分支。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-forking-workflow-2.png\" width=\"\"/></div>\r\n\r\n2 个开发者之间可以在 Pull Request 中讨论和开发功能。完成开发后，他们可以发起另一个 Pull Request，请求合并功能到正式的 master 分支。在 Forking 工作流中，这样的灵活性让 Pull Request 成为一个强有力的协作工具。\r\n\r\n### 示例-Pull Requests\r\n\r\n下面的示例演示了 Pull Request 如何在在 Forking 工作流中使用。也同样适用于小团队的开发协作和第三方开发者向开源项目的贡献。\r\n\r\n在示例中，小红是个开发，小明是项目维护者。他们各自有一个公开的 Bitbucket 仓库，而小明的仓库包含了正式工程。\r\n\r\n#### 小红 fork 正式项目\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-1.png\" width=\"\"/></div>\r\n\r\n小红先要 fork 小明的 Bitbucket 仓库，开始项目的开发。她登陆 Bitbucket，浏览到小明的仓库页面，点 Fork 按钮。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-2.png\" width=\"\"/></div>\r\n\r\n然后为 fork 出来的仓库填写名字和描述，这样小红就有了服务端的项目拷贝了。\r\n\r\n#### 小红克隆她的 Bitbucket 仓库\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-3.png\" width=\"\"/></div>\r\n\r\n下一步，小红克隆自己刚才 fork 出来的 Bitbucket 仓库，以在本机上准备出工作拷贝。命令如下：\r\n\r\n```\r\ngit clone https://user@bitbucket.org/user/repo.git\r\n```\r\n\r\n请记住，`git clone` 会自动创建 origin 远程别名，是指向小红 fork 出来的仓库。\r\n\r\n#### 小红开发新功能\r\n\r\n在开始改代码前，小红要为新功能先新建一个新分支。她会用这个分支作为 Pull Request 的源分支。\r\n\r\n```\r\ngit checkout -b some-feature\r\n```\r\n\r\n### 编辑代码\r\n\r\n```\r\ngit commit -a -m \"Add first draft of some feature\"\r\n```\r\n\r\n在新功能分支上，小红按需要添加提交。甚至如果小红觉得功能分支上的提交历史太乱了，她可以用交互式 rebase 来删除或压制提交。对于大型项目，整理功能分支的历史可以让项目维护者更容易看出在 Pull Request 中做了什么内容。\r\n\r\n#### 小红 push 功能到她的 Bitbucket 仓库中\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-5.png\" width=\"\"/></div>\r\n\r\n小红完成了功能后，push 功能到她自己的 Bitbucket 仓库中（不是正式仓库），用下面简单的命令：\r\n\r\n```\r\ngit push origin some-branch\r\n```\r\n\r\n这时她的变更可以让项目维护者看到了（或者任何想要看的协作者）。\r\n\r\n#### 小红发起 Pull Request\r\n\r\n<div align=\"center\"> <img src=\"assets/example-6.png\" width=\"\"/></div>\r\n\r\nBitbucket 上有了她的功能分支后，小红可以用她的 Bitbucket 账号浏览到她的 fork 出来的仓库页面，点右上角的【Pull Request】按钮，发起一个 Pull Request。弹出的表单自动设置小红的仓库为源仓库，询问小红以指定源分支、目标仓库和目标分支。\r\n\r\n小红想要合并功能到正式仓库，所以源分支是她的功能分支，目标仓库是小明的公开仓库，而目标分支是 master 分支。另外，小红需要提供 Pull Request 的标题和描述信息。如果需要小明以外的人审核批准代码，她可以把这些人填在【Reviewers】文本框中。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-7.png\" width=\"\"/></div>\r\n\r\n创建好了 Pull Request，通知会通过Bitbucket系统消息或邮件（可选）发给小明。\r\n\r\n#### 小明 review Pull Request\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-8.png\" width=\"\"/></div>\r\n\r\n在小明的 Bitbucket 仓库页面的 【Pull Request】Tab 可以看到所有人发起的 Pull Request。点击小红的 Pull Request 会显示出 Pull Request 的描述、功能的提交历史和每个变更的差异（diff）。\r\n\r\n如果小明想要合并到项目中，只要点一下【Merge】按钮，就可以同意 Pull Request 并合并到 master 分支。\r\n\r\n但如果像这个示例中一样小明发现了在小红的代码中的一个小 Bug，要小红在合并前修复。小明可以在整个 Pull Request 上加上评注，或是选择历史中的某个提交加上评注。\r\n\r\n<div align=\"center\"> <img src=\"assets/pull-request-9.png\" width=\"\"/></div>\r\n\r\n#### 小红补加提交\r\n\r\n如果小红对反馈有任何疑问，可以在 Pull Request 中响应，把 Pull Request 当作是她功能讨论的论坛。\r\n\r\n小红在她的功能分支新加提交以解决代码问题，并 push 到她的 Bitbucket 仓库中，就像前一轮中的做法一样。这些提交会进入的 Pull Request，小明在原来的评注旁边可以再次 review 变更。\r\n\r\n#### 小明接受 Pull Request\r\n\r\n最终，小明接受变更，合并功能分支到 master 分支，并关闭 Pull Request。至此，功能集成到项目中，其它的项目开发者可以用标准的 git pull 命令 pull 这些变更到自己的本地仓库中。\r\n\r\n### 总结-Pull Requests\r\n\r\n到了这里，你应该有了所有需要的工具来集成 Pull Request 到你自己的工作流。请记住，Pull Request 并不是为了替代任何基于 Git 的协作工作流，而是它们的一个便利的补充，让团队成员间的协作更轻松方便。', 0);
INSERT INTO `blog_course` VALUES (228, 'MyBatis 对原生jdbc程序中的问题总结', 3, '# mybatis学习笔记(1)-对原生jdbc程序中的问题总结\r\n\r\n标签：mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [jdbc编程步骤](#jdbc编程步骤)\r\n  - [问题总结](#问题总结)\r\n  - [参考代码](#参考代码)\r\n\r\n\r\n\r\n---\r\n\r\n本文总结jdbc编程的一般步骤，总结这样编程存在的问题，并附上典型地jdbc示例demo\r\n\r\n\r\n## jdbc编程步骤\r\n\r\n1. 加载数据库驱动\r\n2. 创建并获取数据库链接\r\n3. 创建jdbc statement对象\r\n4. 设置sql语句\r\n5. 设置sql语句中的参数(使用preparedStatement)\r\n6. 通过statement执行sql并获取结果\r\n7. 对sql执行结果进行解析处理\r\n8. 释放资源(resultSet、preparedstatement、connection)\r\n\r\n\r\n## 问题总结\r\n\r\n1.数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。\r\n \r\n设想：使用数据库连接池管理数据库连接。\r\n\r\n2.将sql语句硬编码到java代码中，如果sql语句修改，需要重新编译java代码，不利于系统维护。\r\n\r\n设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。\r\n\r\n\r\n3.向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。\r\n\r\n设想：将sql语句及占位符号和参数全部配置在xml中。\r\n\r\n4.从resultSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。\r\n \r\n设想：将查询的结果集，自动映射成java对象。\r\n\r\n## 参考代码\r\n\r\n```java\r\npackage com.iot.mybatis.jdbc;\r\n\r\n//import java.sql.*;\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\n\r\n/**\r\n * Created by Administrator on 2016/2/21.\r\n */\r\npublic class JdbcTest {\r\n    public static void main(String[] args) {\r\n        //数据库连接\r\n        Connection connection = null;\r\n        //预编译的Statement，使用预编译的Statement提高数据库性能\r\n        PreparedStatement preparedStatement = null;\r\n        //结果集\r\n        ResultSet resultSet = null;\r\n\r\n        try {\r\n            //加载数据库驱动\r\n            Class.forName(\"com.mysql.jdbc.Driver\");\r\n\r\n            //通过驱动管理类获取数据库链接\r\n            connection =  DriverManager.getConnection(\"jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\", \"root\", \"123\");\r\n            //定义sql语句 ?表示占位符\r\n            String sql = \"select * from user where username = ?\";\r\n            //获取预处理statement\r\n            preparedStatement = connection.prepareStatement(sql);\r\n            //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值\r\n            preparedStatement.setString(1, \"王五\");\r\n            //向数据库发出sql执行查询，查询出结果集\r\n            resultSet =  preparedStatement.executeQuery();\r\n            //遍历查询结果集\r\n            while(resultSet.next()){\r\n                System.out.println(resultSet.getString(\"id\")+\"  \"+resultSet.getString(\"username\"));\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }finally{\r\n            //释放资源\r\n            if(resultSet!=null){\r\n                try {\r\n                    resultSet.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(preparedStatement!=null){\r\n                try {\r\n                    preparedStatement.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(connection!=null){\r\n                try {\r\n                    connection.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (229, 'MyBatis 概述', 3, '# mybatis学习笔记(2)-mybatis概述\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [mybatis 介绍](#mybatis 介绍)\r\n  - [框架原理](#框架原理)\r\n  - [mybatis框架执行过程](#mybatis框架执行过程)\r\n  - [mybatis开发dao的方法](#mybatis开发dao的方法)\r\n  - [输入映射和输出映射](#输入映射和输出映射)\r\n  - [动态sql](#动态sql)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文对mybatis做一个简单介绍，包括框架原理，执行过程，开发方法，输入输出映射以及动态sql,我会在后续的系列文章中一一详细说明\r\n\r\n## mybatis 介绍\r\n\r\nmybatis是一个持久层的框架，是apache下的顶级项目。\r\n\r\nmybatis托管到goolecode下，再后来托管到github下(https://github.com/mybatis/mybatis-3/releases)。\r\n\r\nmybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。\r\n\r\nmybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射）\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 框架原理\r\n\r\nmybatis框架\r\n\r\n![mybatis框架图](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E6%A1%86%E6%9E%B6%E5%9B%BE.png)\r\n\r\n\r\n## mybatis框架执行过程\r\n\r\n1、配置mybatis的配置文件，SqlMapConfig.xml（名称不固定）\r\n\r\n2、通过配置文件，加载mybatis运行环境，创建SqlSessionFactory会话工厂(SqlSessionFactory在实际使用时按单例方式)\r\n\r\n3、通过SqlSessionFactory创建SqlSession。SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。\r\n\r\n4、调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。\r\n\r\n5、释放资源，关闭SqlSession\r\n\r\n\r\n## mybatis开发dao的方法\r\n\r\n1.原始dao 的方法\r\n\r\n- 需要程序员编写dao接口和实现类\r\n- 需要在dao实现类中注入一个SqlSessionFactory工厂\r\n\r\n2.mapper代理开发方法（建议使用）\r\n\r\n只需要程序员编写mapper接口（就是dao接口）。\r\n程序员在编写mapper.xml(映射文件)和mapper.java需要遵循一个开发规范：\r\n\r\n- mapper.xml中namespace就是mapper.java的类全路径。\r\n- mapper.xml中statement的id和mapper.java中方法名一致。\r\n- mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入参数类型一致\r\n- mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。\r\n\r\n\r\nSqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载。\r\n\r\n\r\n## 输入映射和输出映射\r\n\r\n- 输入映射：\r\n  - parameterType：指定输入参数类型可以简单类型、pojo、hashmap。\r\n  - 对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展。\r\n\r\n- 输出映射：\r\n	- resultType：查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。\r\n	- reusltMap：可以通过resultMap 完成一些高级映射。如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。\r\n		- 高级映射：\r\n			将关联查询的列映射到一个pojo属性中。（一对一）\r\n			将关联查询的列映射到一个List<pojo>中。（一对多）\r\n\r\n\r\n## 动态sql\r\n\r\n- 动态sql：（重点）\r\n   - if判断（掌握）\r\n   - where\r\n   - foreach\r\n   - sql片段（掌握）\r\n\r\n\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (230, 'MyBatis 入门程序 一', 3, '# mybatis学习笔记(3)-入门程序一\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [工程结构](#工程结构)\r\n- [Global logging configuration](#global-logging-configuration)\r\n- [Console output...](#console-output)\r\n  - [映射文件](#映射文件)\r\n  - [程序代码](#程序代码)\r\n  - [总结](#总结)\r\n\r\n\r\n\r\n---\r\n\r\nmybatis入门程序\r\n\r\n## 工程结构\r\n\r\n\r\n在IDEA中新建了一个普通的java项目，新建文件夹lib,加入jar包,工程结构如图。\r\n\r\n![mybatis_入门程序一-工程结构图](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E4%B8%80-%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E5%9B%BE.png)\r\n\r\n\r\n\r\n- log4j.properties\r\n\r\n```\r\n# Global logging configuration\r\nlog4j.rootLogger=DEBUG, stdout\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n\r\n```\r\n\r\n\r\n\r\n- SqlMapConfig.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <!-- 和spring整合后 environments配置将废除-->\r\n    <environments default=\"development\">\r\n        <environment id=\"development\">\r\n            <!-- 使用jdbc事务管理，事务控制由mybatis-->\r\n            <transactionManager type=\"JDBC\" />\r\n            <!-- 数据库连接池,由mybatis管理-->\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\r\n                <property name=\"url\" value=\"jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\" />\r\n                <property name=\"username\" value=\"root\" />\r\n                <property name=\"password\" value=\"123\" />\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n\r\n</configuration>\r\n```\r\n\r\n## 映射文件\r\n\r\n- sqlmap/User.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离\r\n 注意：使用mapper代理方法开发，namespace有特殊重要的作用\r\n -->\r\n<mapper namespace=\"test\">\r\n    <!-- 在映射文件中配置很多sql语句 -->\r\n    <!--需求:通过id查询用户表的记录 -->\r\n    <!-- 通过select执行数据库查询\r\n     id:标识映射文件中的sql，称为statement的id\r\n     将sql语句封装到mappedStatement对象中，所以将id称为statement的id\r\n     parameterType:指定输入参数的类型\r\n     #{}标示一个占位符,\r\n     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。\r\n\r\n     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象\r\n     -->\r\n    <select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.mybatis.po.User\">\r\n        SELECT * FROM  user  WHERE id=#{value}\r\n    </select>\r\n\r\n    <!-- 根据用户名称模糊查询用户信息，可能返回多条\r\n	resultType：指定就是单条记录所映射的java对象类型\r\n	${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。\r\n	使用${}拼接sql，引起 sql注入\r\n	${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value\r\n	 -->\r\n    <select id=\"findUserByName\" parameterType=\"java.lang.String\" resultType=\"com.iot.mybatis.po.User\">\r\n        SELECT * FROM user WHERE username LIKE \'%${value}%\'\r\n    </select>\r\n\r\n\r\n</mapper>\r\n```\r\n\r\n\r\n\r\n\r\n在sqlMapConfig.xml中加载User.xml\r\n\r\n```xml\r\n<!-- 加载映射文件-->\r\n<mappers>\r\n    <mapper resource=\"sqlmap/User.xml\"/>\r\n</mappers>\r\n```\r\n\r\n## 程序代码\r\n\r\n- po类`User.java`\r\n\r\n```java\r\npackage com.iot.mybatis.po;\r\n\r\nimport java.util.Date;\r\n\r\n/**\r\n * Created by Administrator on 2016/2/21.\r\n */\r\npublic class User {\r\n    //属性名要和数据库表的字段对应\r\n    private int id;\r\n    private String username;// 用户姓名\r\n    private String sex;// 性别\r\n    private Date birthday;// 生日\r\n    private String address;// 地址\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getUsername() {\r\n        return username;\r\n    }\r\n\r\n    public void setUsername(String username) {\r\n        this.username = username;\r\n    }\r\n\r\n    public String getSex() {\r\n        return sex;\r\n    }\r\n\r\n    public void setSex(String sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"User [id=\" + id + \", username=\" + username + \", sex=\" + sex\r\n                + \", birthday=\" + birthday + \", address=\" + address + \"]\";\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n- 测试代码\r\n\r\n```java\r\npackage com.iot.mybatis.first;\r\n\r\nimport com.iot.mybatis.po.User;\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport org.junit.Test;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by Administrator on 2016/2/23.\r\n */\r\npublic class MybatisFirst {\r\n\r\n    //根据id查询用户信息，得到一条记录结果\r\n\r\n    @Test\r\n    public void findUserByIdTest() throws IOException{\r\n        // mybatis配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        // 得到配置文件流\r\n        InputStream inputStream =  Resources.getResourceAsStream(resource);\r\n        //创建会话工厂，传入mybatis配置文件的信息\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        // 通过SqlSession操作数据库\r\n        // 第一个参数：映射文件中statement的id，等于=namespace+\".\"+statement的id\r\n        // 第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n        // sqlSession.selectOne结果 是与映射文件中所匹配的resultType类型的对象\r\n        // selectOne查询出一条记录\r\n        User user = sqlSession.selectOne(\"test.findUserById\", 1);\r\n\r\n        System.out.println(user);\r\n\r\n        // 释放资源\r\n        sqlSession.close();\r\n\r\n    }\r\n\r\n    // 根据用户名称模糊查询用户列表\r\n    @Test\r\n    public void findUserByNameTest() throws IOException {\r\n        // mybatis配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        // 得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n        // 创建会话工厂，传入mybatis的配置文件信息\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()\r\n                .build(inputStream);\r\n\r\n        // 通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        // list中的user和映射文件中resultType所指定的类型一致\r\n        List<User> list = sqlSession.selectList(\"test.findUserByName\", \"小明\");\r\n        System.out.println(list);\r\n        sqlSession.close();\r\n\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n\r\n输出：\r\n\r\n- `findUserByIdTest()`\r\n\r\n```\r\nDEBUG [main] - Logging initialized using \'class org.apache.ibatis.logging.slf4j.Slf4jImpl\' adapter.\r\nDEBUG [main] - PooledDataSource forcefully closed/removed all connections.\r\nDEBUG [main] - PooledDataSource forcefully closed/removed all connections.\r\nDEBUG [main] - PooledDataSource forcefully closed/removed all connections.\r\nDEBUG [main] - PooledDataSource forcefully closed/removed all connections.\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 1857815974.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6ebc05a6]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nUser [id=1, username=王五, sex=2, birthday=null, address=null]\r\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6ebc05a6]\r\nDEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@6ebc05a6]\r\nDEBUG [main] - Returned connection 1857815974 to pool.\r\n```\r\n\r\n- `findUserByNameTest()`\r\n\r\n```\r\nDEBUG [main] - Logging initialized using \'class org.apache.ibatis.logging.slf4j.Slf4jImpl\' adapter.\r\nDEBUG [main] - PooledDataSource forcefully closed/removed all connections.\r\nDEBUG [main] - PooledDataSource forcefully closed/removed all connections.\r\nDEBUG [main] - PooledDataSource forcefully closed/removed all connections.\r\nDEBUG [main] - PooledDataSource forcefully closed/removed all connections.\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 1596467899.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5f282abb]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE username LIKE \'%小明%\' \r\nDEBUG [main] - ==> Parameters: \r\nDEBUG [main] - <==      Total: 3\r\n[User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州]]\r\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5f282abb]\r\nDEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@5f282abb]\r\nDEBUG [main] - Returned connection 1596467899 to pool.\r\n```\r\n\r\n\r\n\r\n\r\n## 总结\r\n\r\n- `parameterType`\r\n\r\n在映射文件中通过parameterType指定输入参数的类型\r\n\r\n\r\n- `resultType`\r\n\r\n在映射文件中通过resultType指定输出结果的类型\r\n\r\n\r\n- `#{}`和`${}`\r\n\r\n`#{}`表示一个占位符号;\r\n\r\n`${}`表示一个拼接符号，会引起sql注入，所以不建议使用\r\n\r\n\r\n- `selectOne`和`selectList`\r\n\r\n`selectOne`表示查询一条记录进行映射，使用`selectList`也可以使用，只不过只有一个对象\r\n\r\n`selectList`表示查询出一个列表(参数记录)进行映射，不能够使用`selectOne`查，不然会报下面的错:\r\n\r\n```\r\norg.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3\r\n```\r\n\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (231, 'MyBatis 入门程序 二', 3, '# mybatis学习笔记(3)-入门程序二\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [映射文件](#映射文件)\r\n  - [程序代码](#程序代码)\r\n    - [Error updating database.  Cause: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement \'test.insertUser!selectKey\'.  It\'s likely that neither a Result Type nor a Result Map was specified.](#error-updating-database--cause-orgapacheibatisexecutorexecutorexception-a-query-was-run-and-no-result-maps-were-found-for-the-mapped-statement-testinsertuserselectkey--its-likely-that-neither-a-result-type-nor-a-result-map-was-specified)\r\n    - [The error may exist in sqlmap/User.xml](#the-error-may-exist-in-sqlmapuserxml)\r\n    - [The error may involve test.insertUser!selectKey-Inline](#the-error-may-involve-testinsertuserselectkey-inline)\r\n    - [The error occurred while setting parameters](#the-error-occurred-while-setting-parameters)\r\n    - [SQL: SELECT LAST_INSERT_ID()](#sql-select-last_insert_id)\r\n    - [Cause: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement \'test.insertUser!selectKey\'.  It\'s likely that neither a Result Type nor a Result Map was specified.](#cause-orgapacheibatisexecutorexecutorexception-a-query-was-run-and-no-result-maps-were-found-for-the-mapped-statement-testinsertuserselectkey--its-likely-that-neither-a-result-type-nor-a-result-map-was-specified)\r\n  - [总结](#总结)\r\n  - [mybatis和hibernate本质区别和应用场景](#mybatis和hibernate本质区别和应用场景)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n添加、删除、更新用户\r\n\r\n\r\n## 映射文件\r\n\r\n - User.xml,在入门程序一基础上增加\r\n\r\n```xml\r\n\r\n    <!-- 添加用户\r\n        parameterType：指定输入 参数类型是pojo（包括 用户信息）\r\n        #{}中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值\r\n        -->\r\n    <insert id=\"insertUser\" parameterType=\"com.iot.mybatis.po.User\">\r\n        <!--\r\n         将插入数据的主键返回，返回到user对象中\r\n\r\n         SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键\r\n\r\n         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性\r\n         order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序\r\n         resultType：指定SELECT LAST_INSERT_ID()的结果类型\r\n          -->\r\n        <selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\">\r\n          SELECT LAST_INSERT_ID()\r\n        </selectKey>\r\n        INSERT INTO user (username,birthday,sex,address)values (#{username},#{birthday},#{sex},#{address})\r\n        <!--\r\n            使用mysql的uuid（）生成主键\r\n            执行过程：\r\n            首先通过uuid()得到主键，将主键设置到user对象的id属性中\r\n            其次在insert执行时，从user对象中取出id属性值\r\n             -->\r\n        <!--  <selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\">\r\n            SELECT uuid()\r\n        </selectKey>\r\n        insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address}) -->\r\n\r\n    </insert>\r\n\r\n    <!-- 删除 用户\r\n        根据id删除用户，需要输入 id值\r\n         -->\r\n    <delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\r\n        delete from user where id=#{id}\r\n    </delete>\r\n\r\n    <!-- 根据id更新用户\r\n    分析：\r\n    需要传入用户的id\r\n    需要传入用户的更新信息\r\n    parameterType指定user对象，包括 id和更新信息，注意：id必须存在\r\n    #{id}：从输入 user对象中获取id属性值\r\n     -->\r\n    <update id=\"updateUser\" parameterType=\"com.iot.mybatis.po.User\">\r\n        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}\r\n        where id=#{id}\r\n    </update>\r\n\r\n```\r\n\r\n\r\n(注：这里的`birthday`字段在mysql表中是DATE类型，在User类中`birthday`属性是java的`java.util.Date`类型，并没有进行转换就插入成功了。\r\n\r\n看到有的文章说，在字段中有Date和DateTime类型，在插入数据时只要将实体的属性设置成Timestamp就会对应mysql的DateTime类型，Date会对应mysql的Date类型:\r\n`#{modified_date,jdbcType=TIMESTAMP}、#{date,jdbcType=DATE}`\r\n\r\n我上面的`birthday`，配置成`#{birthday,jdbcType=TIMESTAMP}`，结果也插入成功了，具体实现待查)\r\n\r\n## 程序代码\r\n\r\n- User.java,在入门程序一基础上增加三个测试方法\r\n\r\n```java\r\n  // 添加用户信息\r\n    @Test\r\n    public void insertUserTest() throws IOException {\r\n        // mybatis配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        // 得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n        // 创建会话工厂，传入mybatis的配置文件信息\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()\r\n                .build(inputStream);\r\n\r\n        // 通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        // 插入用户对象\r\n        User user = new User();\r\n        user.setUsername(\"王小军\");\r\n        user.setBirthday(new Date());\r\n        user.setSex(\"1\");\r\n        user.setAddress(\"河南郑州\");\r\n\r\n        sqlSession.insert(\"test.insertUser\", user);\r\n\r\n        // 提交事务\r\n        sqlSession.commit();\r\n\r\n        // 获取用户信息主键\r\n        System.out.println(user.getId());\r\n        // 关闭会话\r\n        sqlSession.close();\r\n\r\n    }\r\n\r\n    // 根据id删除 用户信息\r\n    @Test\r\n    public void deleteUserTest() throws IOException {\r\n        // mybatis配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        // 得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n        // 创建会话工厂，传入mybatis的配置文件信息\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()\r\n                .build(inputStream);\r\n\r\n        // 通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        // 传入id删除 用户\r\n        sqlSession.delete(\"test.deleteUser\", 29);\r\n\r\n        // 提交事务\r\n        sqlSession.commit();\r\n\r\n        // 关闭会话\r\n        sqlSession.close();\r\n\r\n    }\r\n\r\n    // 更新用户信息\r\n    @Test\r\n    public void updateUserTest() throws IOException {\r\n        // mybatis配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        // 得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n        // 创建会话工厂，传入mybatis的配置文件信息\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()\r\n                .build(inputStream);\r\n\r\n        // 通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        // 更新用户信息\r\n\r\n        User user = new User();\r\n        //必须设置id\r\n        user.setId(27);\r\n        user.setUsername(\"王大军\");\r\n        user.setBirthday(new Date());\r\n        user.setSex(\"2\");\r\n        user.setAddress(\"河南郑州\");\r\n\r\n        sqlSession.update(\"test.updateUser\", user);\r\n\r\n        // 提交事务\r\n        sqlSession.commit();\r\n\r\n        // 关闭会话\r\n        sqlSession.close();\r\n\r\n    }\r\n\r\n```\r\n\r\n\r\n- 自增主键返回\r\n\r\n```xml\r\n<selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\">\r\n          SELECT LAST_INSERT_ID()\r\n</selectKey>\r\n```\r\n\r\n如果没有在上面的配置中配置`resultType`，则会报下面的异常\r\n\r\n\r\n```\r\norg.apache.ibatis.exceptions.PersistenceException: \r\n### Error updating database.  Cause: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement \'test.insertUser!selectKey\'.  It\'s likely that neither a Result Type nor a Result Map was specified.\r\n### The error may exist in sqlmap/User.xml\r\n### The error may involve test.insertUser!selectKey-Inline\r\n### The error occurred while setting parameters\r\n### SQL: SELECT LAST_INSERT_ID()\r\n### Cause: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement \'test.insertUser!selectKey\'.  It\'s likely that neither a Result Type nor a Result Map was specified.\r\n\r\n	...\r\n\r\nCaused by: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement \'test.insertUser!selectKey\'.  It\'s likely that neither a Result Type nor a Result Map was specified.\r\n\r\n\r\n```\r\n\r\n\r\n## 总结\r\n\r\n- `#{}`和`${}`\r\n\r\n`#{}`表示一个占位符号，`#{}`接收输入参数，类型可以是简单类型，pojo、hashmap。\r\n\r\n如果接收简单类型，`#{}`中可以写成value或其它名称。\r\n\r\n`#{}`接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性...的方式获取对象属性值。\r\n\r\n`${}`表示一个拼接符号，会引用sql注入，所以**不建议使用`${}`**。\r\n\r\n`${}`接收输入参数，类型可以是简单类型，pojo、hashmap。\r\n\r\n如果接收简单类型，`${}`中只能写成value。\r\n\r\n`${}`接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性...的方式获取对象属性值。\r\n\r\n\r\n\r\n## mybatis和hibernate本质区别和应用场景\r\n\r\n- hibernate\r\n\r\n是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。对sql语句进行优化、修改比较困难的。\r\n\r\n应用场景：适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa。。\r\n\r\n- mybatis\r\n\r\n专注是sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射、输出映射）。\r\n\r\n应用场景：适用与需求变化较多的项目，比如：互联网项目。\r\n\r\n企业进行技术选型，以低成本高回报作为技术选型的原则，根据项目组的技术力量进行选择。\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (232, 'MyBatis 开发dao方法', 3, '# mybatis学习笔记(4)-开发dao方法\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [SqlSession使用范围](#SqlSession使用范围)\r\n  - [原始dao开发方法](#原始dao开发方法)\r\n    - [dao接口](#dao接口)\r\n    - [dao接口实现类](#dao接口实现类)\r\n    - [测试代码](#测试代码)\r\n    - [总结原始dao开发问题](#总结原始dao开发问题)\r\n  - [mapper代理方法](#mapper代理方法)\r\n    - [开发规范](#开发规范)\r\n    - [代码](#代码)\r\n    - [一些问题总结](#一些问题总结)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文讲解SqlSession，并对两种方法(原始dao开发和mapper代理开发)分别做简单展示\r\n\r\n\r\n## SqlSession使用范围\r\n\r\n- SqlSessionFactoryBuilder\r\n\r\n通过`SqlSessionFactoryBuilder`创建会话工厂`SqlSessionFactory`将`SqlSessionFactoryBuilder`当成一个工具类使用即可，不需要使用单例管理`SqlSessionFactoryBuilder`。在需要创建`SqlSessionFactory`时候，只需要new一次`SqlSessionFactoryBuilder`即可。\r\n\r\n\r\n- `SqlSessionFactory`\r\n\r\n通过`SqlSessionFactory`创建`SqlSession`，使用单例模式管理`sqlSessionFactory`（工厂一旦创建，使用一个实例）。将来mybatis和spring整合后，使用单例模式管理`sqlSessionFactory`。\r\n\r\n\r\n- `SqlSession`\r\n\r\n`SqlSession`是一个面向用户（程序员）的接口。SqlSession中提供了很多操作数据库的方法：如：`selectOne`(返回单个对象)、`selectList`（返回单个或多个对象）。\r\n\r\n`SqlSession`是线程不安全的，在`SqlSesion`实现类中除了有接口中的方法（操作数据库的方法）还有数据域属性。\r\n\r\n`SqlSession`最佳应用场合在方法体内，定义成局部变量使用。\r\n\r\n\r\n## 原始dao开发方法\r\n\r\n程序员需要写dao接口和dao实现类\r\n\r\n### dao接口\r\n\r\n```java\r\npublic interface UserDao {\r\n    //根据id查询用户信息\r\n    public User findUserById(int id) throws Exception;\r\n\r\n    //根据用户名列查询用户列表\r\n    public List<User> findUserByName(String name) throws Exception;\r\n\r\n    //添加用户信息\r\n    public void insertUser(User user) throws Exception;\r\n\r\n    //删除用户信息\r\n    public void deleteUser(int id) throws Exception;\r\n}\r\n```\r\n\r\n### dao接口实现类\r\n\r\n```java\r\npackage com.iot.mybatis.dao;\r\n\r\nimport com.iot.mybatis.po.User;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by Brian on 2016/2/24.\r\n */\r\npublic class UserDaoImpl implements UserDao{\r\n    // 需要向dao实现类中注入SqlSessionFactory\r\n    // 这里通过构造方法注入\r\n    private SqlSessionFactory sqlSessionFactory;\r\n\r\n    public UserDaoImpl(SqlSessionFactory sqlSessionFactory){\r\n        this.sqlSessionFactory = sqlSessionFactory;\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public User findUserById(int id) throws Exception {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        User user = sqlSession.selectOne(\"test.findUserById\",id);\r\n        //释放资源\r\n        sqlSession.close();\r\n        return user;\r\n    }\r\n\r\n    @Override\r\n    public List<User> findUserByName(String name) throws Exception {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        List<User> list = sqlSession.selectList(\"test.findUserByName\", name);\r\n\r\n        // 释放资源\r\n        sqlSession.close();\r\n\r\n        return list;\r\n    }\r\n\r\n    @Override\r\n    public void insertUser(User user) throws Exception {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //执行插入操作\r\n        sqlSession.insert(\"test.insertUser\", user);\r\n\r\n        // 提交事务\r\n        sqlSession.commit();\r\n\r\n        // 释放资源\r\n        sqlSession.close();\r\n    }\r\n\r\n    @Override\r\n    public void deleteUser(int id) throws Exception {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        //执行插入操作\r\n        sqlSession.delete(\"test.deleteUser\", id);\r\n\r\n        // 提交事务\r\n        sqlSession.commit();\r\n\r\n        // 释放资源\r\n        sqlSession.close();\r\n    }\r\n}\r\n```\r\n\r\n### 测试代码\r\n\r\n```java\r\npackage com.iot.mybatis.dao;\r\n\r\nimport java.io.InputStream;\r\n\r\nimport com.iot.mybatis.po.User;\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\n\r\n\r\npublic class UserDaoImplTest {\r\n\r\n	private SqlSessionFactory sqlSessionFactory;\r\n\r\n	// 此方法是在执行testFindUserById之前执行\r\n	@Before\r\n	public void setUp() throws Exception {\r\n		// 创建sqlSessionFactory\r\n\r\n		// mybatis配置文件\r\n		String resource = \"SqlMapConfig.xml\";\r\n		// 得到配置文件流\r\n		InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n		// 创建会话工厂，传入mybatis的配置文件信息\r\n		sqlSessionFactory = new SqlSessionFactoryBuilder()\r\n				.build(inputStream);\r\n	}\r\n\r\n	@Test\r\n	public void testFindUserById() throws Exception {\r\n		// 创建UserDao的对象\r\n		UserDao userDao = new UserDaoImpl(sqlSessionFactory);\r\n\r\n		// 调用UserDao的方法\r\n		User user = userDao.findUserById(1);\r\n		\r\n		System.out.println(user);\r\n	}\r\n\r\n}\r\n\r\n```\r\n\r\n### 总结原始dao开发问题\r\n\r\n1.dao接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。\r\n\r\n2.调用sqlsession方法时将statement的id硬编码了\r\n\r\n3.调用sqlsession方法时传入的变量，由于sqlsession方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。\r\n\r\n\r\n## mapper代理方法\r\n\r\n程序员只需要mapper接口（相当 于dao接口）\r\n\r\n程序员还需要编写mapper.xml映射文件\r\n\r\n程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。\r\n\r\n### 开发规范\r\n\r\n- 在mapper.xml中namespace等于mapper接口地址\r\n\r\n```xml\r\n<!--\r\n namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离\r\n 注意：使用mapper代理方法开发，namespace有特殊重要的作用,namespace等于mapper接口地址\r\n -->\r\n<mapper namespace=\"com.iot.mybatis.mapper.UserMapper\">\r\n```\r\n\r\n- mapper.java接口中的方法名和mapper.xml中statement的id一致\r\n\r\n- mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类型一致。\r\n\r\n- mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致。\r\n\r\n```xml\r\n<select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.mybatis.po.User\">\r\n    SELECT * FROM  user  WHERE id=#{value}\r\n</select>\r\n```\r\n\r\n```java\r\n//根据id查询用户信息\r\npublic User findUserById(int id) throws Exception;\r\n```\r\n\r\n总结：以上开发规范主要是对下边的代码进行统一生成：\r\n\r\n```java\r\nUser user = sqlSession.selectOne(\"test.findUserById\", id);\r\nsqlSession.insert(\"test.insertUser\", user);\r\n```\r\n\r\n\r\n### 代码\r\n\r\n- mapper.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<!--\r\n namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离\r\n 注意：使用mapper代理方法开发，namespace有特殊重要的作用\r\n -->\r\n<mapper namespace=\"com.iot.mybatis.mapper.UserMapper\">\r\n <!-- 在映射文件中配置很多sql语句 -->\r\n    <!--需求:通过id查询用户表的记录 -->\r\n    <!-- 通过select执行数据库查询\r\n     id:标识映射文件中的sql，称为statement的id\r\n     将sql语句封装到mappedStatement对象中，所以将id称为statement的id\r\n     parameterType:指定输入参数的类型\r\n     #{}标示一个占位符,\r\n     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。\r\n\r\n     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象\r\n     -->\r\n    <select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.mybatis.po.User\">\r\n        SELECT * FROM  user  WHERE id=#{value}\r\n    </select>\r\n\r\n    <!-- 根据用户名称模糊查询用户信息，可能返回多条\r\n	resultType：指定就是单条记录所映射的java对象类型\r\n	${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。\r\n	使用${}拼接sql，引起 sql注入\r\n	${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value\r\n	 -->\r\n    <select id=\"findUserByName\" parameterType=\"java.lang.String\" resultType=\"com.iot.mybatis.po.User\">\r\n        SELECT * FROM user WHERE username LIKE \'%${value}%\'\r\n    </select>\r\n\r\n\r\n    <!-- 添加用户\r\n        parameterType：指定输入 参数类型是pojo（包括 用户信息）\r\n        #{}中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值\r\n        -->\r\n    <insert id=\"insertUser\" parameterType=\"com.iot.mybatis.po.User\">\r\n        <!--\r\n         将插入数据的主键返回，返回到user对象中\r\n\r\n         SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键\r\n\r\n         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性\r\n         order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序\r\n         resultType：指定SELECT LAST_INSERT_ID()的结果类型\r\n          -->\r\n        <selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\">\r\n          SELECT LAST_INSERT_ID()\r\n        </selectKey>\r\n        INSERT INTO user (username,birthday,sex,address)values (#{username},#{birthday},#{sex},#{address})\r\n        <!--\r\n            使用mysql的uuid（）生成主键\r\n            执行过程：\r\n            首先通过uuid()得到主键，将主键设置到user对象的id属性中\r\n            其次在insert执行时，从user对象中取出id属性值\r\n             -->\r\n        <!--  <selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\">\r\n            SELECT uuid()\r\n        </selectKey>\r\n        insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address}) -->\r\n\r\n    </insert>\r\n\r\n    <!-- 删除 用户\r\n        根据id删除用户，需要输入 id值\r\n         -->\r\n    <delete id=\"deleteUser\" parameterType=\"java.lang.Integer\">\r\n        delete from user where id=#{id}\r\n    </delete>\r\n\r\n    <!-- 根据id更新用户\r\n    分析：\r\n    需要传入用户的id\r\n    需要传入用户的更新信息\r\n    parameterType指定user对象，包括 id和更新信息，注意：id必须存在\r\n    #{id}：从输入 user对象中获取id属性值\r\n     -->\r\n    <update id=\"updateUser\" parameterType=\"com.iot.mybatis.po.User\">\r\n        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}\r\n        where id=#{id}\r\n    </update>\r\n    \r\n</mapper>\r\n```\r\n\r\n- 在SqlMapConfig.xml中加载映射文件\r\n\r\n```xml\r\n<mappers>  \r\n    <mapper resource=\"mapper/UserMapper.xml\"/>  \r\n</mappers>  \r\n```\r\n\r\n- UserMapper.java\r\n\r\n```java\r\npublic interface UserMapper {\r\n    //根据id查询用户信息\r\n    public User findUserById(int id) throws Exception;\r\n\r\n    //根据用户名列查询用户列表\r\n    public List<User> findUserByName(String name) throws Exception;\r\n\r\n    //添加用户信息\r\n    public void insertUser(User user) throws Exception;\r\n\r\n    //删除用户信息\r\n    public void deleteUser(int id) throws Exception;\r\n\r\n    //更新用户\r\n    public void updateUser(User user)throws Exception;\r\n}\r\n```\r\n\r\n\r\n- UserMapperTest/java\r\n\r\n```java\r\npublic class UserMapperTest {  \r\n  \r\n  \r\n    private SqlSessionFactory sqlSessionFactory;  \r\n      \r\n    //注解Before是在执行本类所有测试方法之前先调用这个方法  \r\n    @Before  \r\n    public void setup() throws Exception{  \r\n        //创建SqlSessionFactory  \r\n        String resource=\"SqlMapConfig.xml\";  \r\n          \r\n        //将配置文件加载成流  \r\n        InputStream inputStream = Resources.getResourceAsStream(resource);  \r\n        //创建会话工厂，传入mybatis配置文件的信息  \r\n        sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream);  \r\n    }  \r\n      \r\n    @Test  \r\n    public void testFindUserById() throws Exception{  \r\n          \r\n        SqlSession sqlSession=sqlSessionFactory.openSession();  \r\n          \r\n        //创建UserMapper代理对象  \r\n        UserMapper userMapper=sqlSession.getMapper(UserMapper.class);  \r\n          \r\n        //调用userMapper的方法  \r\n        User user=userMapper.findUserById(1);  \r\n          \r\n        System.out.println(user.getUsername());  \r\n    }  \r\n}  \r\n```\r\n\r\n\r\n### 一些问题总结\r\n\r\n- 代理对象内部调用`selectOne`或`selectList`\r\n   - 如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。\r\n   - 如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库。\r\n\r\n\r\n- mapper接口方法参数只能有一个是否影响系统开发\r\n\r\nmapper接口方法参数只能有一个，系统是否不利于扩展维护?系统框架中，dao层的代码是被业务层公用的。即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。\r\n\r\n注意：持久层方法的参数可以包装类型、map...等，service方法中建议不要使用包装类型（不利于业务层的可扩展）。\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (233, 'MyBatis 配置文件', 3, '# mybatis学习笔记(5)-配置文件\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [properties(属性)](#properties（属性）)\r\n  - [settings(全局参数配置)](#settings（全局参数配置）)\r\n  - [typeAliases(类型别名)](#typealiases（类型别名）)\r\n  - [typeHandlers(类型处理器)](#typehandlers（类型处理器）)\r\n  - [mappers(映射配置)](#mappers（映射配置）)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要讲解SqlMapConfig配置文件\r\n\r\n> 参考[mybatis – MyBatis 3 `|` Configuration](http://www.mybatis.org/mybatis-3/configuration.html)\r\n\r\nSqlMapConfig.xml中配置的内容和顺序如下\r\n\r\n- properties（属性）\r\n- settings（全局配置参数）\r\n- **typeAliases（类型别名）**\r\n- typeHandlers（类型处理器）\r\n- *objectFactory（对象工厂）*\r\n- *plugins（插件）*\r\n- environments（环境集合属性对象）\r\n  - environment（环境子属性对象）\r\n     - transactionManager（事务管理）\r\n     - dataSource（数据源）\r\n- **mappers（映射器）**\r\n\r\n\r\n(注：粗体是重点，斜体不常用)\r\n\r\n\r\n## properties（属性）\r\n\r\n将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。\r\n\r\n将数据库连接参数只配置在db.properties中。原因：方便对参数进行统一管理，其它xml可以引用该db.properties。\r\n\r\n```\r\njdbc.driver=com.mysql.jdbc.Driver\r\njdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\r\njdbc.username=root\r\njdbc.password=123\r\n```\r\n\r\n在sqlMapConfig.xml加载属性文件：\r\n\r\n```xml\r\n<properties resource=\"db.properties\">\r\n        <!--properties中还可以配置一些属性名和属性值  -->\r\n        <!-- <property name=\"jdbc.driver\" value=\"\"/> -->\r\n</properties>\r\n\r\n<!-- 和spring整合后 environments配置将废除-->\r\n<environments default=\"development\">\r\n    <environment id=\"development\">\r\n        <!-- 使用jdbc事务管理，事务控制由mybatis-->\r\n        <transactionManager type=\"JDBC\" />\r\n        <!-- 数据库连接池,由mybatis管理-->\r\n        <dataSource type=\"POOLED\">\r\n            <property name=\"driver\" value=\"${jdbc.driver}\" />\r\n            <property name=\"url\" value=\"${jdbc.url}\" />\r\n            <property name=\"username\" value=\"${jdbc.username}\" />\r\n            <property name=\"password\" value=\"${jdbc.password}\" />\r\n        </dataSource>\r\n    </environment>\r\n</environments>\r\n```\r\n\r\n注意： MyBatis 将按照下面的顺序(优先级)来加载属性：\r\n\r\n- 在`properties`元素体内定义的属性首先被读取。 \r\n- 然后会读取`properties`元素中resource或url加载的属性，它会覆盖已读取的同名属性。 \r\n- 最后读取`parameterType`传递的属性，它会覆盖已读取的同名属性。\r\n\r\n建议：\r\n\r\n- 不要在`properties`元素体内添加任何属性值，只将属性值定义在properties文件中。\r\n- 在properties文件中定义属性名要有一定的特殊性，如：XXXXX.XXXXX.XXXX\r\n\r\n## settings（全局参数配置）\r\n\r\nmybatis框架在运行时可以调整一些运行参数,比如：开启二级缓存、开启延迟加载...\r\n\r\n全局参数将会影响mybatis的运行行为。具体参考官网：\r\n\r\n> [mybatis-settings](http://www.mybatis.org/mybatis-3/configuration.html#settings)\r\n\r\n\r\n## typeAliases（类型别名）\r\n\r\n在mapper.xml中，定义很多的statement，statement需要`parameterType`指定输入参数的类型、需要`resultType`指定输出结果的映射类型。\r\n\r\n如果在指定类型时输入类型全路径，不方便进行开发，可以针对`parameterType`或`resultType`指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。\r\n\r\n\r\n- mybatis默认支持别名\r\n\r\n> 参考 [typeAliases](http://www.mybatis.org/mybatis-3/configuration.html#typeAliases)\r\n\r\n\r\n|  别名  |  映射的类型  |\r\n|:---    |  :----     |\r\n|_byte   | 	byte | \r\n|_long 	 |  long | \r\n|_short  |	short| \r\n|_int| 	int| \r\n|_integer| 	int| \r\n|_double| 	double|\r\n|_float| 	float |\r\n|_boolean| 	boolean|\r\n|string |	String |\r\n|byte |	Byte |\r\n|long |	Long| \r\n|short |	Short |\r\n|int |	Integer |\r\n|integer |	Integer |\r\n|double |	Double |\r\n|float |	Float |\r\n|boolean| 	Boolean |\r\n|date |	Date |\r\n|decimal |	BigDecimal |\r\n|bigdecimal| BigDecimal| \r\n\r\n\r\n- 自定义别名\r\n  -	单个别名定义 \r\n  -	批量定义别名（常用）\r\n\r\n```xml\r\n<!-- 别名定义 -->\r\n<typeAliases>\r\n\r\n    <!-- 针对单个别名定义\r\n    type：类型的路径\r\n    alias：别名\r\n     -->\r\n    <!-- <typeAlias type=\"cn.itcast.mybatis.po.User\" alias=\"user\"/> -->\r\n    <!-- 批量别名定义\r\n    指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以）\r\n    -->\r\n    <package name=\"com.iot.mybatis.po\"/>\r\n\r\n</typeAliases>\r\n```\r\n\r\n## typeHandlers（类型处理器）\r\n\r\nmybatis中通过typeHandlers完成jdbc类型和java类型的转换。例如：\r\n\r\n```xml\r\n<select id=\"findUserById\" parameterType=\"int\" resultType=\"user\">\r\n		select * from user where id = #{id}\r\n</select>\r\n```\r\n\r\nmybatis自带的类型处理器基本上满足日常需求，不需要单独定义。\r\n\r\nmybatis支持类型处理器\r\n\r\n>  参考 [typeHandlers](http://www.mybatis.org/mybatis-3/configuration.html#typeHandlers)\r\n\r\n|类型处理器	|Java类型|	JDBC类型|\r\n|:---|:---|:----|\r\n|BooleanTypeHandler | Boolean，boolean |任何兼容的布尔值|\r\n|ByteTypeHandler |	Byte，byte |	任何兼容的数字或字节类型|\r\n|ShortTypeHandler |	Short，short |	任何兼容的数字或短整型|\r\n|IntegerTypeHandler| 	Integer，int |	任何兼容的数字和整型|\r\n|LongTypeHandler |	Long，long 	|任何兼容的数字或长整型|\r\n|FloatTypeHandler |	Float，float |	任何兼容的数字或单精度浮点型|\r\n|DoubleTypeHandler |	Double，double |	任何兼容的数字或双精度浮点型|\r\n|BigDecimalTypeHandler |	BigDecimal |	任何兼容的数字或十进制小数类型|\r\n|StringTypeHandler |	String |	CHAR和VARCHAR类型|\r\n|ClobTypeHandler |	String |	CLOB和LONGVARCHAR类型|\r\n|NStringTypeHandler| 	String |	NVARCHAR和NCHAR类型|\r\n|NClobTypeHandler 	|String |	NCLOB类型\r\n|ByteArrayTypeHandler| 	byte[] |	任何兼容的字节流类型|\r\n|BlobTypeHandler |	byte[] |	BLOB和LONGVARBINARY类型|\r\n|DateTypeHandler |	Date（java.util）|	TIMESTAMP类型|\r\n|DateOnlyTypeHandler |	Date（java.util）|	DATE类型|\r\n|TimeOnlyTypeHandler |	Date（java.util）|	TIME类型|\r\n|SqlTimestampTypeHandler |	Timestamp（java.sql）|	TIMESTAMP类型|\r\n|SqlDateTypeHandler |	Date（java.sql）|	DATE类型|\r\n|SqlTimeTypeHandler |	Time（java.sql）|	TIME类型|\r\n|ObjectTypeHandler| 	任意|	其他或未指定类型|\r\n|EnumTypeHandler |	Enumeration类型|	VARCHAR-任何兼容的字符串类型，作为代码存储（而不是索引）|\r\n\r\n\r\n\r\n## mappers（映射配置）\r\n\r\n- 通过resource加载单个映射文件\r\n\r\n```xml\r\n<!--通过resource方法一次加载一个映射文件 -->\r\n<mapper resource=\"mapper/UserMapper.xml\"/>\r\n```\r\n\r\n- 通过mapper接口加载单个mapper\r\n\r\n```xml\r\n <!-- 通过mapper接口加载单个 映射文件\r\n        遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录中\r\n        上边规范的前提是：使用的是mapper代理方法\r\n         -->\r\n<mapper class=\"com.iot.mybatis.mapper.UserMapper\"/> \r\n```\r\n\r\n目录示例\r\n\r\n```\r\ncom.iot.mybatis.mapper------------------package包\r\n           |----UserMapper.java\r\n           |----UserMapper.xml\r\n              \r\n```\r\n\r\n- 批量加载mapper(推荐使用)\r\n\r\n```xml\r\n<!-- 批量加载mapper\r\n		指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载\r\n		遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 中\r\n		上边规范的前提是：使用的是mapper代理方法\r\n		 -->\r\n<package name=\"com.iot.mybatis.mapper\"/>\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (234, 'MyBatis 输入映射', 3, '# mybatis学习笔记(6)-输入映射\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [传递pojo的包装对象](#传递pojo的包装对象)\r\n    - [Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named \'UserCustom\' in \'class com.iot.mybatis.po.UserQueryVo\'](#error-querying-database--cause-orgapacheibatisreflectionreflectionexception-there-is-no-getter-for-property-named-usercustom-in-class-comiotmybatispouserqueryvo)\r\n    - [Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named \'UserCustom\' in \'class com.iot.mybatis.po.UserQueryVo\'](#cause-orgapacheibatisreflectionreflectionexception-there-is-no-getter-for-property-named-usercustom-in-class-comiotmybatispouserqueryvo)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要讲解mybatis的输入映射。\r\n\r\n\r\n通过parameterType指定输入参数的类型，类型可以是\r\n\r\n- 简单类型\r\n- hashmap\r\n- pojo的包装类型\r\n\r\n## 传递pojo的包装对象\r\n\r\n- 定义包装类型pojo\r\n\r\n```java\r\npackage com.iot.mybatis.po;\r\n\r\n/**\r\n * Created by Brian on 2016/2/24.\r\n */\r\npublic class UserQueryVo {\r\n\r\n    //在这里包装所需要的查询条件\r\n\r\n    //用户查询条件\r\n    private UserCustom userCustom;\r\n\r\n    public UserCustom getUserCustom() {\r\n        return userCustom;\r\n    }\r\n\r\n    public void setUserCustom(UserCustom userCustom) {\r\n        this.userCustom = userCustom;\r\n    }\r\n\r\n    //可以包装其它的查询条件，订单、商品\r\n    //....\r\n\r\n}\r\n```\r\n\r\n其中，UserCustom类继承User\r\n\r\n```java\r\npublic class UserCustom extends User{\r\n}\r\n```\r\n\r\n- mapper.xml\r\n\r\n在UserMapper.xml中定义用户信息综合查询（查询条件复杂，通过高级查询进行复杂关联查询）。\r\n\r\n```xml\r\n    <!-- 用户信息综合查询\r\n        #{userCustom.sex}:取出pojo包装对象中性别值\r\n        ${userCustom.username}：取出pojo包装对象中用户名称\r\n     -->\r\n    <select id=\"findUserList\" parameterType=\"com.iot.mybatis.po.UserQueryVo\"\r\n            resultType=\"com.iot.mybatis.po.UserCustom\">\r\n        SELECT * FROM user WHERE user.sex=#{userCustom.sex} AND user.username LIKE \'%${userCustom.username}%\'\r\n    </select>\r\n```\r\n\r\n注意不要将`#{userCustom.sex}`中的`userCustom`写成`UserCustom`,前者指属性名(由于使用IDE提示自动补全，所以只是把类型名首字母小写了)，后者指类型名，这里是`UserQueryVo`类中的`userCustom`属性，是**属性名**。写错会报如下异常：\r\n\r\n```\r\norg.apache.ibatis.exceptions.PersistenceException: \r\n### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named \'UserCustom\' in \'class com.iot.mybatis.po.UserQueryVo\'\r\n### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named \'UserCustom\' in \'class com.iot.mybatis.po.UserQueryVo\'\r\n```\r\n\r\n- mapper.java\r\n\r\n```java\r\n//用户信息综合查询\r\npublic List<UserCustom> findUserList(UserQueryVo userQueryVo) throws Exception;\r\n```\r\n\r\n- 测试代码\r\n\r\n```java\r\n//用户信息的综合 查询\r\n	@Test\r\n	public void testFindUserList() throws Exception {\r\n\r\n		SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n		//创建UserMapper对象，mybatis自动生成mapper代理对象\r\n		UserMapper userMapper  sqlSession.getMapper(UserMapper.class);\r\n\r\n		//创建包装对象，设置查询条件\r\n		UserQueryVo userQueryVo = new UserQueryVo();\r\n		UserCustom userCustom = new UserCustom();\r\n		//由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中\r\n		userCustom.setSex(\"1\");\r\n		userCustom.setUsername(\"张三\");\r\n		userQueryVo.setUserCustom(userCustom);\r\n		//调用userMapper的方法\r\n\r\n		List<UserCustom> list = userMapper.findUserList(userQueryVo);\r\n\r\n		System.out.println(list);\r\n\r\n\r\n	}\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (235, 'MyBats 输出映射', 3, '# mybatis学习笔记(7)-输出映射\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [resultType](#resultType)\r\n    - [输出简单类型](#输出简单类型)\r\n    - [输出pojo对象和pojo列表](#输出pojo对象和pojo列表)\r\n  - [resultMap](#resultMap)\r\n    - [resultMap使用方法](#resultMap使用方法)\r\n    - [小结](#小结)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要讲解mybatis的输出映射。\r\n\r\n\r\n输出映射有两种方式\r\n\r\n- `resultType`\r\n- `resultMap`\r\n\r\n\r\n## resultType\r\n\r\n- 使用`resultType`进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。\r\n- 如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。\r\n- 只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。\r\n\r\n### 输出简单类型\r\n\r\n\r\n- mapper.xml\r\n\r\n```xml\r\n <!-- 用户信息综合查询总数\r\n        parameterType：指定输入类型和findUserList一样\r\n        resultType：输出结果类型\r\n    -->\r\n    <select id=\"findUserCount\" parameterType=\"com.iot.mybatis.po.UserQueryVo\" resultType=\"int\">\r\n        SELECT count(*) FROM user WHERE user.sex=#{userCustom.sex} AND user.username LIKE \'%${userCustom.username}%\'\r\n    </select>\r\n```\r\n\r\n- mapper.java\r\n\r\n```java\r\n    //用户信息综合查询总数\r\n	@Test\r\n	public void testFindUserCount() throws Exception {\r\n\r\n		SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n		//创建UserMapper对象，mybatis自动生成mapper代理对象\r\n		UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n\r\n		//创建包装对象，设置查询条件\r\n		UserQueryVo userQueryVo = new UserQueryVo();\r\n		UserCustom userCustom = new UserCustom();\r\n		//由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中\r\n		userCustom.setSex(\"1\");\r\n		userCustom.setUsername(\"小\");\r\n		userQueryVo.setUserCustom(userCustom);\r\n		//调用userMapper的方法\r\n\r\n		int count = userMapper.findUserCount(userQueryVo);\r\n\r\n		System.out.println(count);\r\n\r\n\r\n	}\r\n```\r\n\r\n\r\n- 小结\r\n\r\n查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。\r\n\r\n\r\n###	输出pojo对象和pojo列表\r\n\r\n**不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中`resultType`指定的类型是一样的。**\r\n\r\n在mapper.java指定的方法返回值类型不一样：\r\n\r\n- 输出单个pojo对象，方法返回值是单个对象类型\r\n\r\n```java\r\n//根据id查询用户信息\r\npublic User findUserById(int id) throws Exception;\r\n```\r\n\r\n- 输出pojo对象list，方法返回值是List<Pojo>\r\n\r\n```java\r\n//根据用户名列查询用户列表\r\npublic List<User> findUserByName(String name) throws Exception;\r\n```\r\n\r\n\r\n**生成的动态代理对象中是根据mapper方法的返回值类型确定是调用`selectOne`(返回单个对象调用)还是`selectList` （返回集合对象调用 ）.**\r\n\r\n\r\n\r\n## resultMap\r\n\r\nmybatis中使用resultMap完成高级输出结果映射。(一对多，多对多)\r\n\r\n\r\n###	resultMap使用方法 \r\n\r\n如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。\r\n\r\n1.定义resultMap\r\n\r\n2.使用resultMap作为statement的输出映射类型\r\n\r\n- 定义reusltMap\r\n\r\n```xml\r\n<!-- 定义resultMap\r\n	将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系\r\n	\r\n	type：resultMap最终映射的java对象类型,可以使用别名\r\n	id：对resultMap的唯一标识\r\n	 -->\r\n	 <resultMap type=\"user\" id=\"userResultMap\">\r\n	 	<!-- id表示查询结果集中唯一标识 \r\n	 	column：查询出来的列名\r\n	 	property：type指定的pojo类型中的属性名\r\n	 	最终resultMap对column和property作一个映射关系 （对应关系）\r\n	 	-->\r\n	 	<id column=\"id_\" property=\"id\"/>\r\n	 	<!-- \r\n	 	result：对普通名映射定义\r\n	 	column：查询出来的列名\r\n	 	property：type指定的pojo类型中的属性名\r\n	 	最终resultMap对column和property作一个映射关系 （对应关系）\r\n	 	 -->\r\n	 	<result column=\"username_\" property=\"username\"/>\r\n	 \r\n	 </resultMap>\r\n```\r\n\r\n- 使用resultMap作为statement的输出映射类型\r\n\r\n```xml\r\n<!-- 使用resultMap进行输出映射\r\n        resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace\r\n        -->\r\n    <select id=\"findUserByIdResultMap\" parameterType=\"int\" resultMap=\"userResultMap\">\r\n        SELECT id id_,username username_ FROM USER WHERE id=#{value}\r\n    </select>\r\n\r\n```\r\n\r\n- mapper.java\r\n\r\n```java\r\n//根据id查询用户信息，使用resultMap输出\r\npublic User findUserByIdResultMap(int id) throws Exception;\r\n```\r\n\r\n- 测试代码\r\n\r\n```java\r\n@Test\r\npublic void testFindUserByIdResultMap() throws Exception {\r\n\r\n	SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n	//创建UserMapper对象，mybatis自动生成mapper代理对象\r\n	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n\r\n	//调用userMapper的方法\r\n\r\n	User user = userMapper.findUserByIdResultMap(1);\r\n\r\n	System.out.println(user);\r\n\r\n\r\n}\r\n```\r\n\r\n\r\n### 小结 \r\n\r\n使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。\r\n\r\n如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。\r\n\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (236, 'MyBatis 动态sql', 3, '# mybatis学习笔记(8)-动态sql\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [if判断](#if判断)\r\n  - [sql片段(重点)](#sql片段（重点）)\r\n  - [foreach标签](#foreach标签)\r\n\r\n\r\n\r\n---\r\n\r\n\r\nmybatis核心,对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。\r\n\r\n## if判断\r\n\r\n- mapper.xml\r\n\r\n```xml\r\n<!-- 用户信息综合查询\r\n    #{userCustom.sex}:取出pojo包装对象中性别值\r\n    ${userCustom.username}：取出pojo包装对象中用户名称\r\n -->\r\n<select id=\"findUserList\" parameterType=\"com.iot.mybatis.po.UserQueryVo\"\r\n        resultType=\"com.iot.mybatis.po.UserCustom\">\r\n    SELECT * FROM user\r\n    <!--  where 可以自动去掉条件中的第一个and -->\r\n    <where>\r\n        <if test=\"userCustom!=null\">\r\n            <if test=\"userCustom.sex!=null and userCustom.sex != \'\' \">\r\n               AND user.sex=#{userCustom.sex}\r\n            </if>\r\n            <if test=\"userCustom.username!=null and userCustom.username != \'\' \">\r\n               AND user.username LIKE \'%${userCustom.username}%\'\r\n            </if>\r\n        </if>\r\n    </where>\r\n\r\n\r\n</select>\r\n\r\n<!-- 用户信息综合查询总数\r\n    parameterType：指定输入类型和findUserList一样\r\n    resultType：输出结果类型\r\n-->\r\n<select id=\"findUserCount\" parameterType=\"com.iot.mybatis.po.UserQueryVo\" resultType=\"int\">\r\n    SELECT count(*) FROM user\r\n    <where>\r\n        <if test=\"userCustom!=null\">\r\n            <if test=\"userCustom.sex!=null and userCustom.sex != \'\' \">\r\n                AND user.sex=#{userCustom.sex}\r\n            </if>\r\n            <if test=\"userCustom.username!=null and userCustom.username != \'\' \">\r\n                AND user.username LIKE \'%${userCustom.username}%\'\r\n            </if>\r\n        </if>\r\n    </where>\r\n</select>\r\n\r\n```\r\n\r\n- 测试结果\r\n\r\n1.注释掉`testFindUserList()`方法中的`userCustom.setUsername(\"张三\");`\r\n\r\n\r\n```java\r\n//由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中\r\nuserCustom.setSex(\"1\");\r\n//userCustom.setUsername(\"张三\");\r\nuserQueryVo.setUserCustom(userCustom);\r\n```\r\n\r\n输出\r\n\r\n```\r\nDEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapper matches criteria [is assignable to Object]\r\nDEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapperTest matches criteria [is assignable to Object]\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 352359770.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1500955a]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE user.sex=? \r\nDEBUG [main] - ==> Parameters: 1(String)\r\nDEBUG [main] - <==      Total: 6\r\n[User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]]\r\n```\r\n\r\n可以看到sql语句为`reparing: SELECT * FROM user WHERE user.sex=? `，没有username的部分\r\n\r\n\r\n2.`userQueryVo`设为null,则`userCustom`为null\r\n\r\n```java\r\n//List<UserCustom> list = userMapper.findUserList(userQueryVo);\r\nList<UserCustom> list = userMapper.findUserList(null);\r\n```\r\n\r\n输出\r\n\r\n```\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user \r\nDEBUG [main] - ==> Parameters: \r\nDEBUG [main] - <==      Total: 9\r\n[User [id=1, username=王五, sex=2, birthday=null, address=null], User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=26, username=王五, sex=null, birthday=null, address=null], User [id=27, username=王大军, sex=2, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]]\r\n\r\n```\r\n\r\n可以看到sql语句变为了`SELECT * FROM user`\r\n\r\n\r\n## sql片段（重点）\r\n\r\n将上边实现的动态sql判断代码块抽取出来，组成一个sql片段。其它的statement中就可以引用sql片段。\r\n\r\n\r\n- 定义sql片段\r\n\r\n```xml\r\n<!-- 定义sql片段\r\nid：sql片段的唯 一标识\r\n\r\n经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高\r\n在sql片段中不要包括 where\r\n -->\r\n<sql id=\"query_user_where\">\r\n    <if test=\"userCustom!=null\">\r\n        <if test=\"userCustom.sex!=null and userCustom.sex!=\'\'\">\r\n            AND user.sex = #{userCustom.sex}\r\n        </if>\r\n        <if test=\"userCustom.username!=null and userCustom.username!=\'\'\">\r\n            AND user.username LIKE \'%${userCustom.username}%\'\r\n        </if>\r\n    </if>\r\n</sql>\r\n```\r\n\r\n- 引用sql片段\r\n\r\n```xml\r\n<!-- 用户信息综合查询\r\n    #{userCustom.sex}:取出pojo包装对象中性别值\r\n    ${userCustom.username}：取出pojo包装对象中用户名称\r\n -->\r\n<select id=\"findUserList\" parameterType=\"com.iot.mybatis.po.UserQueryVo\"\r\n        resultType=\"com.iot.mybatis.po.UserCustom\">\r\n    SELECT * FROM user\r\n    <!--  where 可以自动去掉条件中的第一个and -->\r\n    <where>\r\n        <!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace -->\r\n        <include refid=\"query_user_where\"></include>\r\n        <!-- 在这里还要引用其它的sql片段  -->\r\n    </where>\r\n</select>\r\n```\r\n\r\n## foreach标签\r\n\r\n向sql传递数组或List，mybatis使用foreach解析\r\n\r\n在用户查询列表和查询总数的statement中增加多个id输入查询。两种方法，sql语句如下：\r\n\r\n- `SELECT * FROM USER WHERE id=1 OR id=10 OR id=16`\r\n- `SELECT * FROM USER WHERE id IN(1,10,16)`\r\n\r\n一个使用OR,一个使用IN\r\n\r\n\r\n- 在输入参数类型中添加`List<Integer> ids`传入多个id\r\n\r\n```java\r\npublic class UserQueryVo {\r\n\r\n    //传入多个id\r\n    private List<Integer> ids;\r\n    \r\n    getter、setter方法\r\n    。。。\r\n}\r\n```\r\n\r\n- 修改mapper.xml\r\n\r\n```xml\r\n<if test=\"ids!=null\">\r\n    <!-- 使用 foreach遍历传入ids\r\n    collection：指定输入 对象中集合属性\r\n    item：每个遍历生成对象中\r\n    open：开始遍历时拼接的串\r\n    close：结束遍历时拼接的串\r\n    separator：遍历的两个对象中需要拼接的串\r\n     -->\r\n    <!-- 使用实现下边的sql拼接：\r\n     AND (id=1 OR id=10 OR id=16)\r\n     -->\r\n    <foreach collection=\"ids\" item=\"user_id\" open=\"AND (\" close=\")\" separator=\"or\">\r\n        <!-- 每个遍历需要拼接的串 -->\r\n        id=#{user_id}\r\n    </foreach>\r\n    \r\n    <!-- 实现  “ and id IN(1,10,16)”拼接 -->\r\n    <!-- <foreach collection=\"ids\" item=\"user_id\" open=\"and id IN(\" close=\")\" separator=\",\">\r\n        每个遍历需要拼接的串\r\n        #{user_id}\r\n    </foreach> -->\r\n\r\n</if>\r\n```\r\n\r\n\r\n- 测试代码\r\n\r\n在`testFindUserList`中加入\r\n\r\n```java\r\n//传入多个id\r\nList<Integer> ids = new ArrayList<Integer>();\r\nids.add(1);\r\nids.add(10);\r\nids.add(16);\r\n//将ids通过userQueryVo传入statement中\r\nuserQueryVo.setIds(ids);\r\n```\r\n\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (237, 'MyBatis 订单商品模型数据分析', 3, '# mybatis学习笔记(9)-订单商品数据模型分析\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [数据模型分析思路](#数据模型分析思路)\r\n  - [数据模型分析](#数据模型分析)\r\n  - [订单商品数据模型建表sql](#订单商品数据模型建表sql)\r\n\r\n\r\n\r\n---\r\n\r\n本文对接下来几篇博客中用到的数据模型进行分析，并附上建表sql文件和测试数据文件\r\n\r\n##	数据模型分析思路\r\n\r\n- 每张表记录的数据内容\r\n  \r\n分模块对每张表记录的内容进行熟悉，相当于你学习系统需求（功能）的过程。\r\n\r\n- 每张表重要的字段设置\r\n	\r\n非空字段、外键字段\r\n\r\n- 数据库级别表与表之间的关系\r\n	\r\n外键关系\r\n\r\n- 表与表之间的业务关系\r\n	\r\n在分析表与表之间的业务关系时一定要建立在某个业务意义基础上去分析。\r\n\r\n\r\n##	数据模型分析\r\n\r\n\r\n![数据模型分析](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90.png)\r\n\r\n- 用户表user：记录了购买商品的用户信息\r\n- 订单表orders：记录了用户所创建的订单（购买商品的订单）\r\n- 订单明细表orderdetail：记录了订单的详细信息即购买商品的信息\r\n- 商品表items：记录了商品信息\r\n\r\n\r\n表与表之间的业务关系：\r\n\r\n在分析表与表之间的业务关系时需要建立在某个业务意义基础上去分析。先分析数据级别之间有关系的表之间的业务关系：\r\n	\r\n- usre和orders：\r\n\r\nuser--->orders：一个用户可以创建多个订单，一对多\r\norders--->user：一个订单只由一个用户创建，一对一\r\n\r\n- orders和orderdetail：\r\n\r\norders--->orderdetail：一个订单可以包括多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系\r\n\r\norderdetail---> orders：一个订单明细只能包括在一个订单中，一对一\r\n\r\n\r\n- orderdetail和itesm：\r\n\r\norderdetail--->itesms：一个订单明细只对应一个商品信息，一对一\r\n\r\nitems---> orderdetail:一个商品可以包括在多个订单明细 ，一对多\r\n\r\n再分析数据库级别没有关系的表之间是否有业务关系：\r\n\r\n- orders和items：\r\n\r\norders和items之间可以通过orderdetail表建立关系。\r\n\r\n\r\n\r\n## 订单商品数据模型建表sql\r\n\r\n```sql\r\n/*\r\nSQLyog v10.2 \r\nMySQL - 5.1.72-community : Database - mybatis\r\n*********************************************************************\r\n*/\r\n\r\n\r\n/*!40101 SET NAMES utf8 */;\r\n\r\n/*!40101 SET SQL_MODE=\'\'*/;\r\n\r\n/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;\r\n/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;\r\n/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO\' */;\r\n/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;\r\n/*Table structure for table `items` */\r\n\r\nCREATE TABLE `items` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(32) NOT NULL COMMENT \'商品名称\',\r\n  `price` float(10,1) NOT NULL COMMENT \'商品定价\',\r\n  `detail` text COMMENT \'商品描述\',\r\n  `pic` varchar(64) DEFAULT NULL COMMENT \'商品图片\',\r\n  `createtime` datetime NOT NULL COMMENT \'生产日期\',\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\r\n\r\n/*Table structure for table `orderdetail` */\r\n\r\nCREATE TABLE `orderdetail` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `orders_id` int(11) NOT NULL COMMENT \'订单id\',\r\n  `items_id` int(11) NOT NULL COMMENT \'商品id\',\r\n  `items_num` int(11) DEFAULT NULL COMMENT \'商品购买数量\',\r\n  PRIMARY KEY (`id`),\r\n  KEY `FK_orderdetail_1` (`orders_id`),\r\n  KEY `FK_orderdetail_2` (`items_id`),\r\n  CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,\r\n  CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\r\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\r\n\r\n/*Table structure for table `orders` */\r\n\r\nCREATE TABLE `orders` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `user_id` int(11) NOT NULL COMMENT \'下单用户id\',\r\n  `number` varchar(32) NOT NULL COMMENT \'订单号\',\r\n  `createtime` datetime NOT NULL COMMENT \'创建订单时间\',\r\n  `note` varchar(100) DEFAULT NULL COMMENT \'备注\',\r\n  PRIMARY KEY (`id`),\r\n  KEY `FK_orders_1` (`user_id`),\r\n  CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\r\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;\r\n\r\n/*Table structure for table `user` */\r\n\r\nCREATE TABLE `user` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(32) NOT NULL COMMENT \'用户名称\',\r\n  `birthday` date DEFAULT NULL COMMENT \'生日\',\r\n  `sex` char(1) DEFAULT NULL COMMENT \'性别\',\r\n  `address` varchar(256) DEFAULT NULL COMMENT \'地址\',\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;\r\n\r\n/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;\r\n/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;\r\n/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;\r\n/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;\r\n\r\n```\r\n\r\n测试数据\r\n\r\n```sql\r\n/*\r\nSQLyog v10.2 \r\nMySQL - 5.1.72-community : Database - mybatis\r\n*********************************************************************\r\n*/\r\n\r\n\r\n/*!40101 SET NAMES utf8 */;\r\n\r\n/*!40101 SET SQL_MODE=\'\'*/;\r\n\r\n/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;\r\n/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;\r\n/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO\' */;\r\n/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;\r\n/*Data for the table `items` */\r\n\r\ninsert  into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,\'台式机\',3000.0,\'该电脑质量非常好！！！！\',NULL,\'2015-02-03 13:22:53\'),(2,\'笔记本\',6000.0,\'笔记本性能好，质量好！！！！！\',NULL,\'2015-02-09 13:22:57\'),(3,\'背包\',200.0,\'名牌背包，容量大质量好！！！！\',NULL,\'2015-02-06 13:23:02\');\r\n\r\n/*Data for the table `orderdetail` */\r\n\r\ninsert  into `orderdetail`(`id`,`orders_id`,`items_id`,`items_num`) values (1,3,1,1),(2,3,2,3),(3,4,3,4),(4,4,2,3);\r\n\r\n/*Data for the table `orders` */\r\n\r\ninsert  into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,\'1000010\',\'2015-02-04 13:22:35\',NULL),(4,1,\'1000011\',\'2015-02-03 13:22:41\',NULL),(5,10,\'1000012\',\'2015-02-12 16:13:23\',NULL);\r\n\r\n/*Data for the table `user` */\r\n\r\ninsert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,\'王五\',NULL,\'2\',NULL),(10,\'张三\',\'2014-07-10\',\'1\',\'北京市\'),(16,\'张小明\',NULL,\'1\',\'河南郑州\'),(22,\'陈小明\',NULL,\'1\',\'河南郑州\'),(24,\'张三丰\',NULL,\'1\',\'河南郑州\'),(25,\'陈小明\',NULL,\'1\',\'河南郑州\'),(26,\'王五\',NULL,NULL,NULL);\r\n\r\n/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;\r\n/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;\r\n/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;\r\n/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;\r\n```\r\n\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (238, 'MyBatis 一对一查询', 3, '# mybatis学习笔记(10)-一对一查询\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [resultType实现](#resultType实现)\r\n  - [resultMap实现](#resultMap实现)\r\n  - [resultType和resultMap实现一对一查询小结](#resultType和resultMap实现一对一查询小结)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文使用两种方式(resultType和resultMap)实现一对一查询，查询订单信息，关联查询创建订单的用户信息\r\n\r\n\r\n## resultType实现\r\n\r\n- sql语句\r\n\r\n\r\n确定查询的主表：订单表\r\n\r\n确定查询的关联表：用户表\r\n\r\n关联查询使用内连接？还是外连接？\r\n\r\n由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内连接。\r\n\r\n```sql\r\nSELECT \r\n  orders.*,\r\n  USER.username,\r\n  USER.sex,\r\n  USER.address \r\nFROM\r\n  orders,\r\n  USER \r\nWHERE orders.user_id = user.id\r\n```\r\n\r\n- 创建pojo\r\n\r\n将上边sql查询的结果映射到pojo中，pojo中必须包括所有查询列名。\r\n\r\n原始的Orders.java不能映射全部字段，需要新创建的pojo。\r\n\r\n创建一个pojo继承包括查询字段较多的po类。\r\n\r\n对应数据表的几个pojo类(Items,Orderdetail,Orders)就是把该类的属性名设为和数据表列字段名相同，并为这些属性添加getter和setter，在这里就不贴代码了，只贴出对应于关联查询的自定义pojo类`OrdersCustom`的代码\r\n\r\n```java\r\npackage com.iot.mybatis.po;\r\n\r\n/**\r\n * \r\n * <p>Title: OrdersCustom</p>\r\n * <p>Description: 订单的扩展类</p>\r\n */\r\n//通过此类映射订单和用户查询的结果，让此类继承包括 字段较多的pojo类\r\npublic class OrdersCustom extends Orders{\r\n	\r\n	//添加用户属性\r\n	/*USER.username,\r\n	  USER.sex,\r\n	  USER.address */\r\n	\r\n	private String username;\r\n	private String sex;\r\n	private String address;\r\n\r\n\r\n	public String getUsername() {\r\n		return username;\r\n	}\r\n	public void setUsername(String username) {\r\n		this.username = username;\r\n	}\r\n\r\n	public String getSex() {\r\n		return sex;\r\n	}\r\n	public void setSex(String sex) {\r\n		this.sex = sex;\r\n	}\r\n\r\n	public String getAddress() {\r\n		return address;\r\n	}\r\n	public void setAddress(String address) {\r\n		this.address = address;\r\n	}\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n- mapper.xml\r\n\r\n```xml\r\n <!-- 查询订单关联查询用户信息 -->\r\n<select id=\"findOrdersUser\"  resultType=\"com.iot.mybatis.po.OrdersCustom\">\r\n  SELECT\r\n      orders.*,\r\n      user.username,\r\n      user.sex,\r\n      user.address\r\n    FROM\r\n      orders,\r\n      user\r\n    WHERE orders.user_id = user.id\r\n</select>\r\n```\r\n\r\n\r\n- mapper.java\r\n\r\n```java\r\n//查询订单关联查询用户信息\r\npublic List<OrdersCustom> findOrdersUser()throws Exception;\r\n}\r\n```\r\n\r\n\r\n\r\n## resultMap实现\r\n\r\n使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。\r\n\r\n- 定义resultMap\r\n\r\n\r\n```xml\r\n<!-- 订单查询关联用户的resultMap\r\n将整个查询的结果映射到com.iot.mybatis.po.Orders中\r\n -->\r\n<resultMap type=\"com.iot.mybatis.po.Orders\" id=\"OrdersUserResultMap\">\r\n    <!-- 配置映射的订单信息 -->\r\n    <!-- id：指定查询列中的唯一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id\r\n        column：订单信息的唯一标识列\r\n        property：订单信息的唯一标识列所映射到Orders中哪个属性\r\n      -->\r\n    <id column=\"id\" property=\"id\"/>\r\n    <result column=\"user_id\" property=\"userId\"/>\r\n    <result column=\"number\" property=\"number\"/>\r\n    <result column=\"createtime\" property=\"createtime\"/>\r\n    <result column=\"note\" property=\"note\"/>\r\n\r\n    <!-- 配置映射的关联的用户信息 -->\r\n    <!-- association：用于映射关联查询单个对象的信息\r\n    property：要将关联查询的用户信息映射到Orders中哪个属性\r\n     -->\r\n    <association property=\"user\"  javaType=\"com.iot.mybatis.po.User\">\r\n        <!-- id：关联查询用户的唯 一标识\r\n        column：指定唯 一标识用户信息的列\r\n        javaType：映射到user的哪个属性\r\n         -->\r\n        <id column=\"user_id\" property=\"id\"/>\r\n        <result column=\"username\" property=\"username\"/>\r\n        <result column=\"sex\" property=\"sex\"/>\r\n        <result column=\"address\" property=\"address\"/>\r\n    </association>\r\n</resultMap>\r\n\r\n```\r\n\r\n\r\n- statement定义\r\n\r\n\r\n```xml\r\n<!-- 查询订单关联查询用户信息 -->\r\n<select id=\"findOrdersUserResultMap\" resultMap=\"OrdersUserResultMap\">\r\n    SELECT\r\n    orders.*,\r\n    user.username,\r\n    user.sex,\r\n    user.address\r\n    FROM\r\n    orders,\r\n    user\r\n    WHERE orders.user_id = user.id\r\n</select>\r\n```\r\n\r\n- mapper.java\r\n\r\n```java\r\n//查询订单关联查询用户使用resultMap\r\npublic List<Orders> findOrdersUserResultMap()throws Exception;\r\n```\r\n\r\n- 测试代码\r\n\r\n```java\r\n@Test\r\npublic void testFindOrdersUserResultMap() throws Exception {\r\n\r\n	SqlSession sqlSession = sqlSessionFactory.openSession();\r\n	// 创建代理对象\r\n	OrdersMapperCustom ordersMapperCustom = sqlSession\r\n			.getMapper(OrdersMapperCustom.class);\r\n\r\n	// 调用maper的方法\r\n	List<Orders> list = ordersMapperCustom.findOrdersUserResultMap();\r\n\r\n	System.out.println(list);\r\n\r\n	sqlSession.close();\r\n}\r\n```\r\n\r\n## resultType和resultMap实现一对一查询小结\r\n\r\n实现一对一查询：\r\n\r\n- resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。\r\n- resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。\r\n- resultMap可以实现延迟加载，resultType无法实现延迟加载。\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (239, 'MyBatis 一对多查询', 3, '# mybatis学习笔记(11)-一对多查询\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [示例](#示例)\r\n  - [小结](#小结)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文实现一对多查询，查询订单及订单明细的信息\r\n\r\n## 示例\r\n\r\n- sql\r\n\r\n确定主查询表：订单表\r\n确定关联查询表：订单明细表\r\n在一对一查询基础上添加订单明细表关联即可。\r\n\r\n```sql\r\nSELECT \r\n  orders.*,\r\n  user.username,\r\n  user.sex,\r\n  user.address,\r\n  orderdetail.id orderdetail_id,\r\n  orderdetail.items_id,\r\n  orderdetail.items_num,\r\n  orderdetail.orders_id\r\nFROM\r\n  orders,\r\n  user,\r\n  orderdetail\r\nWHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id\r\n```\r\n\r\n**注意上面的`orderdetail.id (AS) orderdetail_id`,这里需要取别名，否则由于orders表也有id字段，在后面映射时会冲突**\r\n\r\n- 映射思路\r\n\r\n使用resultType将上边的查询结果映射到pojo中，订单信息的就是重复。\r\n\r\n对orders映射不能出现重复记录。\r\n\r\n在orders.java类中添加`List<orderDetail> orderDetails`属性。\r\n最终会将订单信息映射到orders中，订单所对应的订单明细映射到orders中的orderDetails属性中。\r\n\r\n映射成的orders记录数为两条（orders信息不重复）,每个orders中的orderDetails属性存储了该订单所对应的订单明细。\r\n\r\n\r\n- 在orders中添加list订单明细属性\r\n\r\n```java\r\n//订单明细\r\nprivate List<Orderdetail> orderdetails;\r\n```\r\n\r\n- mapper.xml\r\n\r\n```xml\r\n<!-- 查询订单关联查询用户及订单明细，使用resultmap -->\r\n<select id=\"findOrdersAndOrderDetailResultMap\" resultMap=\"OrdersAndOrderDetailResultMap\">\r\n   SELECT\r\n      orders.*,\r\n      user.username,\r\n      user.sex,\r\n      user.address,\r\n      orderdetail.id orderdetail_id,\r\n      orderdetail.items_id,\r\n      orderdetail.items_num,\r\n      orderdetail.orders_id\r\n    FROM\r\n      orders,\r\n      user,\r\n      orderdetail\r\n    WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id\r\n</select>\r\n```\r\n\r\n- resultMap定义\r\n\r\n```xml\r\n<!-- 订单及订单明细的resultMap\r\n使用extends继承，不用在中配置订单信息和用户信息的映射\r\n -->\r\n<resultMap type=\"com.iot.mybatis.po.Orders\" id=\"OrdersAndOrderDetailResultMap\" extends=\"OrdersUserResultMap\">\r\n    <!-- 订单信息 -->\r\n    <!-- 用户信息 -->\r\n    <!-- 使用extends继承，不用在中配置订单信息和用户信息的映射 -->\r\n\r\n\r\n    <!-- 订单明细信息\r\n    一个订单关联查询出了多条明细，要使用collection进行映射\r\n    collection：对关联查询到多条记录映射到集合对象中\r\n    property：将关联查询到多条记录映射到com.iot.mybatis.po.Orders哪个属性\r\n    ofType：指定映射到list集合属性中pojo的类型\r\n     -->\r\n    <collection property=\"orderdetails\" ofType=\"com.iot.mybatis.po.Orderdetail\">\r\n        <!-- id：订单明细唯 一标识\r\n        property:要将订单明细的唯 一标识 映射到com.iot.mybatis.po.Orderdetail的哪个属性\r\n          -->\r\n        <id column=\"orderdetail_id\" property=\"id\"/>\r\n        <result column=\"items_id\" property=\"itemsId\"/>\r\n        <result column=\"items_num\" property=\"itemsNum\"/>\r\n        <result column=\"orders_id\" property=\"ordersId\"/>\r\n    </collection>\r\n\r\n</resultMap>\r\n```\r\n\r\n\r\n- mapper.java\r\n\r\n```java\r\n//查询订单(关联用户)及订单明细\r\npublic List<Orders>  findOrdersAndOrderDetailResultMap()throws Exception;\r\n```\r\n\r\n\r\n## 小结\r\n\r\nmybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。\r\n\r\n使用resultType实现：将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。\r\n\r\n\r\n另外，下面这篇文章对一对多的resultMap机制解释的很清楚：\r\n\r\n> [MyBatis：一对多表关系详解(从案例中解析)](http://blog.csdn.net/xzm_rainbow/article/details/15336933)\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (240, 'MyBatis 多对多查询', 3, '# mybatis学习笔记(12)-多对多查询\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [示例](#示例)\r\n  - [多对多查询总结](#多对多查询总结)\r\n  - [resultMap总结](#resultMap总结)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文实现多对多查询，查询用户及用户购买商品信息。\r\n\r\n## 示例\r\n\r\n查询主表是：用户表\r\n\r\n关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：orders、orderdetail、items\r\n\r\n\r\n- sql\r\n\r\n```sql\r\nSELECT \r\n  orders.*,\r\n  user.username,\r\n  user.sex,\r\n  user.address,\r\n  orderdetail.id orderdetail_id,\r\n  orderdetail.items_id,\r\n  orderdetail.items_num,\r\n  orderdetail.orders_id,\r\n  items.name items_name,\r\n  items.detail items_detail,\r\n  items.price items_price\r\nFROM\r\n  orders,\r\n  user,\r\n  orderdetail,\r\n  items\r\nWHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id\r\n```\r\n\r\n\r\n- 映射思路\r\n\r\n将用户信息映射到user中。\r\n\r\n在user类中添加订单列表属性`List<Orders> orderslist`，将用户创建的订单映射到orderslist\r\n\r\n在Orders中添加订单明细列表属性`List<OrderDetail>orderdetials`，将订单的明细映射到orderdetials\r\n\r\n在OrderDetail中添加`Items`属性，将订单明细所对应的商品映射到Items\r\n\r\n\r\n- mapper.xml\r\n\r\n```xml\r\n<!-- 查询用户及购买的商品信息，使用resultmap -->\r\n<select id=\"findUserAndItemsResultMap\" resultMap=\"UserAndItemsResultMap\">\r\n   SELECT\r\n      orders.*,\r\n      user.username,\r\n      user.sex,\r\n      user.address,\r\n      orderdetail.id orderdetail_id,\r\n      orderdetail.items_id,\r\n      orderdetail.items_num,\r\n      orderdetail.orders_id,\r\n      items.name items_name,\r\n      items.detail items_detail,\r\n      items.price items_price\r\n    FROM\r\n      orders,\r\n      user,\r\n      orderdetail,\r\n      items\r\n    WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id\r\n</select>\r\n```\r\n\r\n- resultMap\r\n\r\n```xml\r\n<!-- 查询用户及购买的商品 -->\r\n<resultMap type=\"com.iot.mybatis.po.User\" id=\"UserAndItemsResultMap\">\r\n    <!-- 用户信息 -->\r\n    <id column=\"user_id\" property=\"id\"/>\r\n    <result column=\"username\" property=\"username\"/>\r\n    <result column=\"sex\" property=\"sex\"/>\r\n    <result column=\"address\" property=\"address\"/>\r\n\r\n    <!-- 订单信息\r\n    一个用户对应多个订单，使用collection映射\r\n     -->\r\n    <collection property=\"ordersList\" ofType=\"com.iot.mybatis.po.Orders\">\r\n        <id column=\"id\" property=\"id\"/>\r\n        <result column=\"user_id\" property=\"userId\"/>\r\n        <result column=\"number\" property=\"number\"/>\r\n        <result column=\"createtime\" property=\"createtime\"/>\r\n        <result column=\"note\" property=\"note\"/>\r\n\r\n        <!-- 订单明细\r\n         一个订单包括 多个明细\r\n         -->\r\n        <collection property=\"orderdetails\" ofType=\"com.iot.mybatis.po.Orderdetail\">\r\n            <id column=\"orderdetail_id\" property=\"id\"/>\r\n            <result column=\"items_id\" property=\"itemsId\"/>\r\n            <result column=\"items_num\" property=\"itemsNum\"/>\r\n            <result column=\"orders_id\" property=\"ordersId\"/>\r\n\r\n            <!-- 商品信息\r\n             一个订单明细对应一个商品\r\n             -->\r\n            <association property=\"items\" javaType=\"com.iot.mybatis.po.Items\">\r\n                <id column=\"items_id\" property=\"id\"/>\r\n                <result column=\"items_name\" property=\"name\"/>\r\n                <result column=\"items_detail\" property=\"detail\"/>\r\n                <result column=\"items_price\" property=\"price\"/>\r\n            </association>\r\n\r\n        </collection>\r\n\r\n    </collection>\r\n</resultMap>\r\n```\r\n\r\n- mapper.java\r\n\r\n```java\r\n//查询用户购买商品信息\r\npublic List<User>  findUserAndItemsResultMap()throws Exception;\r\n```\r\n\r\n## 多对多查询总结\r\n\r\n将查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量）\r\n\r\n针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。\r\n\r\n一对多是多对多的特例，如下需求：\r\n\r\n查询用户购买的商品信息，用户和商品的关系是多对多关系。\r\n\r\n- 需求1：\r\n\r\n查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)\r\n\r\n企业开发中常见明细列表，用户购买商品明细列表，\r\n\r\n使用resultType将上边查询列映射到pojo输出。\r\n\r\n- 需求2：\r\n\r\n查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）\r\n\r\n使用resultMap将用户购买的商品明细列表映射到user对象中。\r\n\r\n总结：\r\n\r\n使用resultMap是针对那些对查询结果映射有特殊要求的功能，比如特殊要求映射成list中包括多个list。\r\n\r\n\r\n\r\n## resultMap总结\r\n\r\n- resultType\r\n   - 作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。\r\n   - 场合：常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。\r\n\r\n- resultMap\r\n	\r\n使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。\r\n\r\nassociation：\r\n\r\n- 作用：将关联查询信息映射到一个pojo对象中。\r\n- 场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。\r\n\r\n使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。\r\n	\r\ncollection：\r\n\r\n- 作用：将关联查询信息映射到一个list集合中。\r\n- 场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (241, 'MyBatis 延迟加载', 3, '# mybatis学习笔记(13)-延迟加载\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [使用association实现延迟加载](#使用association实现延迟加载)\r\n  - [延迟加载思考](#延迟加载思考)\r\n  - [IDEA的debug小现象](#IDEA的debug小现象)\r\n\r\n\r\n\r\n---\r\n\r\n\r\nresultMap可以实现高级映射（使用`association`、`collection`实现一对一及一对多映射），`association`、`collection`具备延迟加载功能。\r\n\r\n延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。\r\n\r\n\r\n需求：\r\n\r\n如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。\r\n\r\n## 使用association实现延迟加载\r\n\r\n- mapper.xml\r\n\r\n需要定义两个mapper的方法对应的statement。\r\n\r\n1.只查询订单信息\r\n\r\n`SELECT * FROM orders`\r\n\r\n在查询订单的statement中使用association去延迟加载（执行）下边的satatement(关联查询用户信息)\r\n\r\n```xml\r\n<!-- 查询订单关联查询用户，用户信息需要延迟加载 -->\r\n<select id=\"findOrdersUserLazyLoading\" resultMap=\"OrdersUserLazyLoadingResultMap\">\r\n    SELECT * FROM orders\r\n</select>\r\n```\r\n\r\n2.关联查询用户信息\r\n\r\n通过上边查询到的订单信息中user_id去关联查询用户信息,使用UserMapper.xml中的findUserById\r\n\r\n```xml\r\n<select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.mybatis.po.User\">\r\n    SELECT * FROM  user  WHERE id=#{value}\r\n</select>\r\n```\r\n\r\n上边先去执行findOrdersUserLazyLoading，当需要去查询用户的时候再去执行findUserById，通过resultMap的定义将延迟加载执行配置起来。\r\n\r\n\r\n- 延迟加载resultMap\r\n\r\n```xml\r\n<!-- 延迟加载的resultMap -->\r\n<resultMap type=\"com.iot.mybatis.po.Orders\" id=\"OrdersUserLazyLoadingResultMap\">\r\n    <!--对订单信息进行映射配置  -->\r\n    <id column=\"id\" property=\"id\"/>\r\n    <result column=\"user_id\" property=\"userId\"/>\r\n    <result column=\"number\" property=\"number\"/>\r\n    <result column=\"createtime\" property=\"createtime\"/>\r\n    <result column=\"note\" property=\"note\"/>\r\n    <!-- 实现对用户信息进行延迟加载\r\n    select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）\r\n    要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace\r\n    column：订单信息中关联用户信息查询的列，是user_id\r\n    关联查询的sql理解为：\r\n    SELECT orders.*,\r\n    (SELECT username FROM USER WHERE orders.user_id = user.id)username,\r\n    (SELECT sex FROM USER WHERE orders.user_id = user.id)sex\r\n     FROM orders\r\n     -->\r\n    <association property=\"user\"  javaType=\"com.iot.mybatis.po.User\"\r\n                 select=\"com.iot.mybatis.mapper.UserMapper.findUserById\"\r\n                 column=\"user_id\">\r\n     <!-- 实现对用户信息进行延迟加载 -->\r\n\r\n    </association>\r\n\r\n</resultMap>\r\n```\r\n\r\n**与非延迟加载的主要区别就在`association`标签属性多了`select`和`column`**\r\n\r\n```xml\r\n<association property=\"user\"  javaType=\"com.iot.mybatis.po.User\"\r\n             select=\"com.iot.mybatis.mapper.UserMapper.findUserById\"\r\n             column=\"user_id\">\r\n```\r\n\r\n- mapper.java\r\n\r\n```java\r\n//查询订单关联查询用户，用户信息是延迟加载\r\npublic List<Orders> findOrdersUserLazyLoading()throws Exception;\r\n```\r\n\r\n\r\n\r\n- 测试思路\r\n  - 执行上边mapper方法(`findOrdersUserLazyLoading`)，内部去调用`com.iot.mybatis.mapper.OrdersMapperCustom`中的`findOrdersUserLazyLoading`只查询orders信息（单表）。\r\n   - 在程序中去遍历上一步骤查询出的List<Orders>，当我们调用Orders中的getUser方法时，开始进行延迟加载。\r\n   - 延迟加载，去调用UserMapper.xml中findUserbyId这个方法获取用户信息。\r\n\r\n- 延迟加载配置\r\n\r\nmybatis默认没有开启延迟加载，需要在SqlMapConfig.xml中setting配置。\r\n\r\n在mybatis核心配置文件中配置：lazyLoadingEnabled、aggressiveLazyLoading\r\n\r\n\r\n| 设置项 | 描述 | 允许值| 默认值 |\r\n| :--- |:----  |:--- |:---- |\r\n|lazyLoadingEnabled|全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载|true/false|false|\r\n|aggressiveLazyLoading|	当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。|true/false|true|\r\n\r\n\r\n在SqlMapConfig.xml中配置：\r\n\r\n```xml\r\n<settings>\r\n    <!-- 打开延迟加载 的开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 将积极加载改为消极加载即按需要加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\r\n    <!-- 开启二级缓存 -->\r\n   <!-- <setting name=\"cacheEnabled\" value=\"true\"/>-->\r\n</settings>\r\n```\r\n\r\n- 测试代码\r\n\r\n```java\r\n// 查询订单关联查询用户，用户信息使用延迟加载\r\n@Test\r\npublic void testFindOrdersUserLazyLoading() throws Exception {\r\n	SqlSession sqlSession = sqlSessionFactory.openSession();// 创建代理对象\r\n	OrdersMapperCustom ordersMapperCustom = sqlSession\r\n			.getMapper(OrdersMapperCustom.class);\r\n	// 查询订单信息（单表）\r\n	List<Orders> list = ordersMapperCustom.findOrdersUserLazyLoading();\r\n\r\n	// 遍历上边的订单列表\r\n	for (Orders orders : list) {\r\n		// 执行getUser()去查询用户信息，这里实现按需加载\r\n		User user = orders.getUser();\r\n		System.out.println(user);\r\n	}\r\n}\r\n```\r\n\r\n\r\n## 延迟加载思考\r\n\r\n不使用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载？？\r\n\r\n实现方法如下：\r\n\r\n定义两个mapper方法：\r\n\r\n- 查询订单列表\r\n- 根据用户id查询用户信息\r\n\r\n实现思路：\r\n\r\n先去查询第一个mapper方法，获取订单信息列表；在程序中（service），按需去调用第二个mapper方法去查询用户信息。\r\n\r\n总之，使用延迟加载方法，先去查询简单的sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。\r\n\r\n\r\n## IDEA的debug小现象\r\n\r\n使用的是intellij IDEA 15.0.2\r\n\r\n先说一下结果吧，IDEA在debug和run条件下，打印结果不同\r\n\r\n我为了验证延迟加载前的user是否为空，在Orders类中加入了\r\n\r\n```java\r\npublic void print(){\r\n    System.out.println(\"----test-print-----\"+user+\"   user==null: \"+(user==null));\r\n}\r\n```\r\n\r\n测试代码如下：\r\n\r\n```java\r\n// 查询订单关联查询用户，用户信息使用延迟加载\r\n@Test\r\npublic void testFindOrdersUserLazyLoading() throws Exception {\r\n	SqlSession sqlSession = sqlSessionFactory.openSession();// 创建代理对象\r\n	OrdersMapperCustom ordersMapperCustom = sqlSession\r\n			.getMapper(OrdersMapperCustom.class);\r\n	// 查询订单信息（单表）\r\n	List<Orders> list = ordersMapperCustom.findOrdersUserLazyLoading();\r\n\r\n	// 遍历上边的订单列表\r\n	for (Orders orders : list) {\r\n		// 执行getUser()去查询用户信息，这里实现按需加载\r\n		//User user = orders.getUser();\r\n		//System.out.println(user);\r\n		orders.print();\r\n	}\r\n\r\n}\r\n```\r\n\r\n然后分别run和debug\r\n\r\n- run输出\r\n\r\n```\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 110771485.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM orders \r\nDEBUG [main] - ==> Parameters: \r\nDEBUG [main] - <==      Total: 3\r\n----test-print-----null   user==null: true\r\n----test-print-----null   user==null: true\r\n----test-print-----null   user==null: true\r\n```\r\n\r\n- debug输出\r\n\r\n在`List<Orders> list = ordersMapperCustom.findOrdersUserLazyLoading();`打断点，运行完这句,日志输出为：\r\n\r\n```\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 1219273867.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@48aca48b]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM orders \r\nDEBUG [main] - ==> Parameters: \r\nDEBUG [main] - <==      Total: 3\r\n```\r\n\r\n但是当你点开`list`属性时，控制台又输出了，而且可以看到list里的user是有内容的\r\n\r\n```\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 10(Integer)\r\nDEBUG [main] - <==      Total: 1\r\n```\r\n\r\n运行完所有程序，控制台输出为：\r\n\r\n```\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 1219273867.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@48aca48b]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM orders \r\nDEBUG [main] - ==> Parameters: \r\nDEBUG [main] - <==      Total: 3\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 10(Integer)\r\nDEBUG [main] - <==      Total: 1\r\n----test-print-----User [id=1, username=王五, sex=2, birthday=null, address=null]   user==null: false\r\n----test-print-----User [id=1, username=王五, sex=2, birthday=null, address=null]   user==null: false\r\n----test-print-----User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市]   user==null: false\r\n```\r\n\r\n\r\n所以，我觉得应该是在debug时，查看属性的话，IDEA会自动调用get相应的方法，从而触发user的查询。延迟加载的源码实现以后我会阅读，把这个问题弄清楚。\r\n\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (242, 'MyBatis 查询缓存之一级缓存', 3, '# mybatis学习笔记(14)-查询缓存之一级缓存\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [查询缓存](#查询缓存)\r\n  - [一级缓存](#一级缓存)\r\n    - [一级缓存工作原理](#一级缓存工作原理)\r\n    - [一级缓存测试](#一级缓存测试)\r\n    - [一级缓存应用](#一级缓存应用)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要讲mybatis的一级缓存，一级缓存是SqlSession级别的缓存。\r\n\r\n\r\n## 查询缓存\r\n\r\nmybatis提供查询缓存，用于减轻数据压力，提高数据库性能。\r\n\r\nmybaits提供一级缓存，和二级缓存。\r\n\r\n![查询缓存](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98.png)\r\n\r\n一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。\r\n\r\n二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\r\n\r\n为什么要用缓存？\r\n\r\n如果缓存中有数据就不用从数据库中获取，大大提高系统性能。\r\n\r\n\r\n## 一级缓存\r\n\r\n### 一级缓存工作原理\r\n\r\n![一级缓存工作原理](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png)\r\n\r\n第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。\r\n\r\n如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。\r\n\r\n第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。\r\n\r\n\r\n### 一级缓存测试\r\n \r\nmybatis默认支持一级缓存，不需要在配置文件去配置。\r\n\r\n按照上边一级缓存原理步骤去测试。\r\n\r\n测试代码\r\n\r\n```java\r\n// 一级缓存测试\r\n@Test\r\npublic void testCache1() throws Exception {\r\n	SqlSession sqlSession = sqlSessionFactory.openSession();// 创建代理对象\r\n	UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n\r\n	// 下边查询使用一个SqlSession\r\n	// 第一次发起请求，查询id为1的用户\r\n	User user1 = userMapper.findUserById(1);\r\n	System.out.println(user1);\r\n\r\n	// 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。\r\n\r\n	// 更新user1的信息\r\n	// user1.setUsername(\"测试用户22\");\r\n	// userMapper.updateUser(user1);\r\n	// //执行commit操作去清空缓存\r\n	// sqlSession.commit();\r\n\r\n	// 第二次发起请求，查询id为1的用户\r\n	User user2 = userMapper.findUserById(1);\r\n	System.out.println(user2);\r\n\r\n	sqlSession.close();\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n1.不执行更新操作，输出:\r\n\r\n```\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 110771485.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nUser [id=1, username=王五, sex=2, birthday=null, address=null]\r\nUser [id=1, username=王五, sex=2, birthday=null, address=null]\r\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]\r\nDEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]\r\nDEBUG [main] - Returned connection 110771485 to pool.\r\n```\r\n\r\n2.取消测试代码中更新的的注释，输出：\r\n\r\n```\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 110771485.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nUser [id=1, username=王五, sex=2, birthday=null, address=null]\r\nDEBUG [main] - ==>  Preparing: update user set username=?,birthday=?,sex=?,address=? where id=? \r\nDEBUG [main] - ==> Parameters: 测试用户22(String), null, 2(String), null, 1(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\nDEBUG [main] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nUser [id=1, username=测试用户22, sex=2, birthday=null, address=null]\r\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]\r\nDEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]\r\nDEBUG [main] - Returned connection 110771485 to pool.\r\n```\r\n\r\n\r\n\r\n### 一级缓存应用\r\n\r\n正式开发，是将mybatis和spring进行整合开发，事务控制在service中。\r\n\r\n一个service方法中包括 很多mapper方法调用。\r\n\r\n```\r\nservice{\r\n	//开始执行时，开启事务，创建SqlSession对象\r\n	//第一次调用mapper的方法findUserById(1)\r\n	\r\n	//第二次调用mapper的方法findUserById(1)，从一级缓存中取数据\r\n	//方法结束，sqlSession关闭\r\n}\r\n```\r\n\r\n如果是执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (243, 'MyBatis 查询缓存之二级缓存', 3, '# mybatis学习笔记(15)-查询缓存之二级缓存\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [二级缓存原理](#二级缓存原理)\r\n  - [开启二级缓存](#开启二级缓存)\r\n  - [调用pojo类实现序列化接口](#调用pojo类实现序列化接口)\r\n  - [测试方法](#测试方法)\r\n  - [useCache配置](#useCache配置)\r\n  - [刷新缓存（就是清空缓存）](#刷新缓存（就是清空缓存）)\r\n  - [应用场景和局限性](#应用场景和局限性)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要讲mybatis的二级缓存，二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\r\n\r\n\r\n## 二级缓存原理\r\n\r\n\r\n![二级缓存原理](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.png)\r\n\r\n首先开启mybatis的二级缓存.\r\n\r\nsqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中。\r\n\r\n如果SqlSession3去执行相同mapper下sql，执行commit提交，清空该mapper下的二级缓存区域的数据。\r\n\r\nsqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据。\r\n\r\n二级缓存与一级缓存区别，**二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域**。\r\n\r\nUserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。\r\n\r\n\r\n## 开启二级缓存\r\n\r\nmybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。\r\n\r\n在核心配置文件SqlMapConfig.xml中加入`<setting name=\"cacheEnabled\" value=\"true\"/>`\r\n\r\n|设置项|描述|允许值|默认值|\r\n|:---|:---|:---|:---|\r\n|cacheEnabled|对在此配置文件下的所有cache 进行全局性开/关设置。|	true/false |	true|\r\n\r\n```xml\r\n<!-- 开启二级缓存 -->\r\n<setting name=\"cacheEnabled\" value=\"true\"/>\r\n```\r\n\r\n在UserMapper.xml中开启二缓存，UserMapper.xml下的sql执行完成会存储到它的缓存区域（HashMap）。\r\n\r\n```xml\r\n<mapper namespace=\"com.iot.mybatis.mapper.UserMapper\">\r\n<!-- 开启本mapper的namespace下的二级缓存-->\r\n<cache />\r\n\r\n...\r\n\r\n</mapper>\r\n```\r\n\r\n\r\n## 调用pojo类实现序列化接口\r\n\r\n```java\r\npublic class User implements Serializable{\r\n    ....\r\n}\r\n```\r\n\r\n为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存。\r\n\r\n## 测试方法\r\n\r\n```java\r\n// 二级缓存测试\r\n@Test\r\npublic void testCache2() throws Exception {\r\n	SqlSession sqlSession1 = sqlSessionFactory.openSession();\r\n	SqlSession sqlSession2 = sqlSessionFactory.openSession();\r\n	SqlSession sqlSession3 = sqlSessionFactory.openSession();\r\n	// 创建代理对象\r\n	UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);\r\n	// 第一次发起请求，查询id为1的用户\r\n	User user1 = userMapper1.findUserById(1);\r\n	System.out.println(user1);\r\n\r\n	//这里执行关闭操作，将sqlsession中的数据写到二级缓存区域\r\n	sqlSession1.close();\r\n\r\n\r\n//		//使用sqlSession3执行commit()操作\r\n//		UserMapper userMapper3 = sqlSession3.getMapper(UserMapper.class);\r\n//		User user  = userMapper3.findUserById(1);\r\n//		user.setUsername(\"张明明\");\r\n//		userMapper3.updateUser(user);\r\n//		//执行提交，清空UserMapper下边的二级缓存\r\n//		sqlSession3.commit();\r\n//		sqlSession3.close();\r\n\r\n\r\n\r\n	UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);\r\n	// 第二次发起请求，查询id为1的用户\r\n	User user2 = userMapper2.findUserById(1);\r\n	System.out.println(user2);\r\n\r\n	sqlSession2.close();\r\n}\r\n```\r\n\r\n\r\n\r\n1.无更新，输出\r\n\r\n```\r\nDEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.0\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 103887628.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nUser [id=1, username=测试用户22, sex=2, birthday=null, address=null]\r\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Returned connection 103887628 to pool.\r\nDEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.5\r\nUser [id=1, username=测试用户22, sex=2, birthday=null, address=null]\r\n```\r\n\r\n2.有更新，输出\r\n\r\n\r\n```\r\nDEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.0\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Created connection 103887628.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nUser [id=1, username=测试用户22, sex=2, birthday=null, address=null]\r\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Returned connection 103887628 to pool.\r\nDEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.5\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Checked out connection 103887628 from pool.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - ==>  Preparing: update user set username=?,birthday=?,sex=?,address=? where id=? \r\nDEBUG [main] - ==> Parameters: 张明明(String), null, 2(String), null, 1(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\nDEBUG [main] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Returned connection 103887628 to pool.\r\nDEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.3333333333333333\r\nDEBUG [main] - Opening JDBC Connection\r\nDEBUG [main] - Checked out connection 103887628 from pool.\r\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM user WHERE id=? \r\nDEBUG [main] - ==> Parameters: 1(Integer)\r\nDEBUG [main] - <==      Total: 1\r\nUser [id=1, username=张明明, sex=2, birthday=null, address=null]\r\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]\r\nDEBUG [main] - Returned connection 103887628 to pool.\r\n```\r\n\r\n\r\n## useCache配置\r\n\r\n在statement中设置`useCache=false`可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。\r\n\r\n`<select id=\"findOrderListResultMap\" resultMap=\"ordersUserMap\" useCache=\"false\">`\r\n\r\n总结：针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。\r\n\r\n\r\n\r\n## 刷新缓存（就是清空缓存）\r\n\r\n刷新缓存就是清空缓存。在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。\r\n\r\n 设置statement配置中的`flushCache=\"true\"`属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。如下：\r\n \r\n`<insert id=\"insertUser\" parameterType=\"cn.itcast.mybatis.po.User\" flushCache=\"true\">`\r\n\r\n总结：一般下执行完commit操作都需要刷新缓存，`flushCache=true`表示刷新缓存，这样可以避免数据库脏读。\r\n\r\n## 应用场景和局限性\r\n\r\n- 应用场景\r\n\r\n对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。\r\n\r\n实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。\r\n\r\n\r\n- 局限性\r\n\r\nmybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。\r\n\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (244, 'MyBatis 整合 ehcache', 3, '# mybatis学习笔记(16)-mybatis整合ehcache\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [分布缓存](#分布缓存)\r\n  - [整合方法(掌握)](#整合方法（掌握）)\r\n    - [整合ehcache](#整合ehcache)\r\n    - [加入ehcache的配置文件](#加入ehcache的配置文件)\r\n\r\n\r\n\r\n---\r\n\r\nehcache是一个分布式缓存框架\r\n\r\n## 分布缓存\r\n\r\n我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）\r\n\r\n![分布缓存](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E5%88%86%E5%B8%83%E7%BC%93%E5%AD%98.png)\r\n\r\n\r\n不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理。\r\n\r\nmybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。\r\n\r\n\r\n## 整合方法（掌握）\r\n\r\nmybatis提供了一个`cache`接口，如果要实现自己的缓存逻辑，实现`cache`接口开发即可。\r\n\r\nmybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。\r\n\r\n\r\n```java\r\npackage org.apache.ibatis.cache;\r\n\r\nimport java.util.concurrent.locks.ReadWriteLock;\r\n\r\n/**\r\n * SPI for cache providers.\r\n * \r\n * One instance of cache will be created for each namespace.\r\n * \r\n * The cache implementation must have a constructor that receives the cache id as an String parameter.\r\n * \r\n * MyBatis will pass the namespace as id to the constructor.\r\n * \r\n * <pre>\r\n * public MyCache(final String id) {\r\n *  if (id == null) {\r\n *    throw new IllegalArgumentException(\"Cache instances require an ID\");\r\n *  }\r\n *  this.id = id;\r\n *  initialize();\r\n * }\r\n * </pre>\r\n *\r\n * @author Clinton Begin\r\n */\r\n\r\npublic interface Cache {\r\n\r\n  /**\r\n   * @return The identifier of this cache\r\n   */\r\n  String getId();\r\n\r\n  /**\r\n   * @param key Can be any object but usually it is a {@link CacheKey}\r\n   * @param value The result of a select.\r\n   */\r\n  void putObject(Object key, Object value);\r\n\r\n  /**\r\n   * @param key The key\r\n   * @return The object stored in the cache.\r\n   */\r\n  Object getObject(Object key);\r\n\r\n  /**\r\n   * Optional. It is not called by the core.\r\n   * \r\n   * @param key The key\r\n   * @return The object that was removed\r\n   */\r\n  Object removeObject(Object key);\r\n\r\n  /**\r\n   * Clears this cache instance\r\n   */  \r\n  void clear();\r\n\r\n  /**\r\n   * Optional. This method is not called by the core.\r\n   * \r\n   * @return The number of elements stored in the cache (not its capacity).\r\n   */\r\n  int getSize();\r\n  \r\n  /** \r\n   * Optional. As of 3.2.6 this method is no longer called by the core.\r\n   *  \r\n   * Any locking needed by the cache must be provided internally by the cache provider.\r\n   * \r\n   * @return A ReadWriteLock \r\n   */\r\n  ReadWriteLock getReadWriteLock();\r\n\r\n}\r\n```\r\n\r\n\r\nmybatis默认实现cache类是：\r\n\r\n```java\r\npackage org.apache.ibatis.cache.impl;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.locks.ReadWriteLock;\r\n\r\nimport org.apache.ibatis.cache.Cache;\r\nimport org.apache.ibatis.cache.CacheException;\r\n\r\n/**\r\n * @author Clinton Begin\r\n */\r\npublic class PerpetualCache implements Cache {\r\n\r\n  private String id;\r\n\r\n  private Map<Object, Object> cache = new HashMap<Object, Object>();\r\n\r\n  public PerpetualCache(String id) {\r\n    this.id = id;\r\n  }\r\n\r\n  public String getId() {\r\n    return id;\r\n  }\r\n\r\n  public int getSize() {\r\n    return cache.size();\r\n  }\r\n\r\n  public void putObject(Object key, Object value) {\r\n    cache.put(key, value);\r\n  }\r\n\r\n  public Object getObject(Object key) {\r\n    return cache.get(key);\r\n  }\r\n\r\n  public Object removeObject(Object key) {\r\n    return cache.remove(key);\r\n  }\r\n\r\n  public void clear() {\r\n    cache.clear();\r\n  }\r\n\r\n  public ReadWriteLock getReadWriteLock() {\r\n    return null;\r\n  }\r\n\r\n  public boolean equals(Object o) {\r\n    if (getId() == null) throw new CacheException(\"Cache instances require an ID.\");\r\n    if (this == o) return true;\r\n    if (!(o instanceof Cache)) return false;\r\n\r\n    Cache otherCache = (Cache) o;\r\n    return getId().equals(otherCache.getId());\r\n  }\r\n\r\n  public int hashCode() {\r\n    if (getId() == null) throw new CacheException(\"Cache instances require an ID.\");\r\n    return getId().hashCode();\r\n  }\r\n\r\n}\r\n```\r\n\r\n### 整合ehcache\r\n\r\n- 加入ehcache包\r\n   - ehcache-core-2.6.5.jar\r\n   - mybatis-ehcache-1.0.2.jar\r\n   \r\n配置mapper中`cache`中的`type`为ehcache对cache接口的实现类型\r\n\r\n```xml\r\n <!-- 开启本mapper的namespace下的二级缓存\r\n    type：指定cache接口的实现类的类型，mybatis默认使用PerpetualCache\r\n    要和ehcache整合，需要配置type为ehcache实现cache接口的类型\r\n    <cache />\r\n    -->\r\n    <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\r\n```\r\n\r\n### 加入ehcache的配置文件\r\n\r\n在classpath下配置ehcache.xml\r\n\r\n\r\n```xml\r\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\">\r\n	<diskStore path=\"F:\\develop\\ehcache\" />\r\n	<defaultCache \r\n		maxElementsInMemory=\"1000\" \r\n		maxElementsOnDisk=\"10000000\"\r\n		eternal=\"false\" \r\n		overflowToDisk=\"false\" \r\n		timeToIdleSeconds=\"120\"\r\n		timeToLiveSeconds=\"120\" \r\n		diskExpiryThreadIntervalSeconds=\"120\"\r\n		memoryStoreEvictionPolicy=\"LRU\">\r\n	</defaultCache>\r\n</ehcache>\r\n```\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (245, 'MyBatis Spring和MyBaits整合', 3, '# mybatis学习笔记(17)-spring和mybatis整合\r\n\r\n标签： mybatis springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [整合思路](#整合思路)\r\n  - [整合环境](#整合环境)\r\n  - [sqlSessionFactory](#sqlSessionFactory)\r\n  - [原始dao开发(和spring整合后)](#原始dao开发（和spring整合后）)\r\n  - [mapper代理开发](#mapper代理开发)\r\n  - [遇到的问题](#遇到的问题)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要将如何将spring和mybatis整合，只是作简单的示例，没有使用Maven构建。并展示mybatis与spring整合后如何进行原始dao开发和mapper代理开发。\r\n\r\n\r\n## 整合思路\r\n\r\n需要spring通过单例方式管理`SqlSessionFactory`。\r\n\r\nspring和mybatis整合生成代理对象，使用`SqlSessionFactory`创建`SqlSession`。（spring和mybatis整合自动完成）\r\n\r\n持久层的mapper都需要由spring进行管理。\r\n\r\n\r\n## 整合环境\r\n\r\n创建一个新的java工程（接近实际开发的工程结构）\r\n\r\njar包：\r\n\r\n- mybatis3.2.7的jar包\r\n- spring3.2.0的jar包\r\n- mybatis和spring的整合包：早期ibatis和spring整合是由spring官方提供，mybatis和spring整合由mybatis提供。\r\n\r\n![mybatis与spring整合工程结构图](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E4%B8%8Espring%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E5%9B%BE.png)\r\n\r\n## sqlSessionFactory\r\n\r\n在applicationContext.xml配置`sqlSessionFactory`和数据源\r\n\r\n`sqlSessionFactory`在mybatis和spring的整合包下。\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\r\n		http://www.springframework.org/schema/mvc\r\n		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\r\n		http://www.springframework.org/schema/context\r\n		http://www.springframework.org/schema/context/spring-context-3.2.xsd\r\n		http://www.springframework.org/schema/aop\r\n		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd\r\n		http://www.springframework.org/schema/tx\r\n		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\r\n\r\n\r\n    <!-- 加载配置文件 -->\r\n    <context:property-placeholder location=\"classpath:db.properties\" />\r\n\r\n    <!-- 数据源，使用dbcp -->\r\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\r\n          destroy-method=\"close\">\r\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\" />\r\n        <property name=\"url\" value=\"${jdbc.url}\" />\r\n        <property name=\"username\" value=\"${jdbc.username}\" />\r\n        <property name=\"password\" value=\"${jdbc.password}\" />\r\n        <property name=\"maxActive\" value=\"10\" />\r\n        <property name=\"maxIdle\" value=\"5\" />\r\n    </bean>\r\n\r\n    <!-- sqlSessinFactory -->\r\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n        <!-- 加载mybatis的配置文件 -->\r\n        <property name=\"configLocation\" value=\"mybatis/SqlMapConfig.xml\" />\r\n        <!-- 数据源 -->\r\n        <property name=\"dataSource\" ref=\"dataSource\" />\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n## 原始dao开发（和spring整合后）\r\n\r\n- User.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离\r\n 注意：使用mapper代理方法开发，namespace有特殊重要的作用\r\n -->\r\n<mapper namespace=\"test\">\r\n    <!-- 在映射文件中配置很多sql语句 -->\r\n    <!--需求:通过id查询用户表的记录 -->\r\n    <!-- 通过select执行数据库查询\r\n     id:标识映射文件中的sql，称为statement的id\r\n     将sql语句封装到mappedStatement对象中，所以将id称为statement的id\r\n     parameterType:指定输入参数的类型\r\n     #{}标示一个占位符,\r\n     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。\r\n\r\n     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象\r\n     -->\r\n    <select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.ssm.po.User\">\r\n        SELECT * FROM  user  WHERE id=#{value}\r\n    </select>\r\n\r\n\r\n</mapper>\r\n```\r\n\r\n在SqlMapconfig.xml中加载User.xml\r\n\r\n```xml\r\n <!-- 加载映射文件-->\r\n<mappers>\r\n    <mapper resource=\"sqlmap/User.xml\"/>\r\n</mappers>  \r\n```\r\n\r\n- dao(实现类继承``SqlSessionDaoSupport``)\r\n\r\n```java\r\npublic interface UserDao {\r\n    //根据id查询用户信息\r\n    public User findUserById(int id) throws Exception;\r\n}\r\n```\r\n\r\ndao接口实现类需要注入`SqlSessoinFactory`，通过spring进行注入。这里spring声明配置方式，配置dao的bean\r\n\r\n**让UserDaoImpl实现类继承SqlSessionDaoSupport**\r\n\r\n```java\r\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserDao{\r\n\r\n\r\n    @Override\r\n    public User findUserById(int id) throws Exception {\r\n        //继承SqlSessionDaoSupport，通过this.getSqlSession()得到sqlSessoin\r\n        SqlSession sqlSession = this.getSqlSession();\r\n        User user = sqlSession.selectOne(\"test.findUserById\",id);\r\n\r\n        return user;\r\n    }\r\n\r\n}\r\n```\r\n\r\n- 配置dao\r\n\r\n在applicationContext.xml中配置dao\r\n\r\n```xml\r\n<!-- 原始dao接口 -->\r\n<bean id=\"userDao\" class=\"com.iot.ssm.dao.UserDaoImpl\">\r\n    <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/>\r\n</bean>\r\n```\r\n\r\n- 测试程序\r\n\r\n```java\r\npublic class UserDaoImplTest {\r\n\r\n	private ApplicationContext applicationContext;\r\n\r\n	//在setUp这个方法得到spring容器\r\n	@Before\r\n	public void setUp() throws Exception {\r\n		applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext.xml\");\r\n	}\r\n\r\n	@Test\r\n	public void testFindUserById() throws Exception {\r\n		// 创建UserDao的对象\r\n		UserDao userDao = (UserDao)applicationContext.getBean(\"userDao\");\r\n\r\n		// 调用UserDao的方法\r\n		User user = userDao.findUserById(1);\r\n		\r\n		System.out.println(user);\r\n	}\r\n\r\n}\r\n```\r\n\r\n\r\n## mapper代理开发\r\n\r\n\r\n- mapper.java\r\n\r\n```java\r\npublic interface UserMapper {\r\n    //根据id查询用户信息\r\n    User findUserById(int id) throws Exception;\r\n\r\n}\r\n```\r\n\r\n- mapper.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<!--\r\n namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离\r\n 注意：使用mapper代理方法开发，namespace有特殊重要的作用\r\n -->\r\n<mapper namespace=\"com.iot.ssm.mapper.UserMapper\">\r\n\r\n    <!-- 在映射文件中配置很多sql语句 -->\r\n\r\n    <select id=\"findUserById\" parameterType=\"int\" resultType=\"user\">\r\n        SELECT * FROM  user  WHERE id=#{value}\r\n    </select>\r\n\r\n\r\n</mapper>\r\n```\r\n\r\n\r\n- 通过`MapperFactoryBean`创建代理对象\r\n\r\n```xml\r\n <!-- mapper配置\r\n    MapperFactoryBean：根据mapper接口生成代理对象\r\n    -->\r\n\r\n<bean id=\"userMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\">\r\n        //mapperInterface指定mapper接口\r\n        <property name=\"mapperInterface\" value=\"com.iot.ssm.mapper.UserMapper\"/>\r\n        <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/>\r\n</bean>\r\n```\r\n\r\n此方法问题：需要针对每个mapper进行配置，麻烦。\r\n\r\n\r\n- 通过`MapperScannerConfigurer`进行mapper扫描（建议使用）\r\n\r\n```xml\r\n<!-- mapper批量扫描，从mapper包中扫描出mapper接口，自动创建代理对象并且在spring容器中注册\r\n    遵循规范：将mapper.java和mapper.xml映射文件名称保持一致，且在一个目录 中\r\n    自动扫描出来的mapper的bean的id为mapper类名（首字母小写）\r\n    -->\r\n<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\r\n    <!-- 指定扫描的包名\r\n    如果扫描多个包，每个包中间使用半角逗号分隔\r\n    -->\r\n    <property name=\"basePackage\" value=\"com.iot.ssm.mapper\"/>\r\n    <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\r\n\r\n</bean>\r\n```\r\n\r\n- 测试代码\r\n\r\n```java\r\npackage com.iot.mybatis.mapper;\r\n\r\nimport com.iot.ssm.mapper.UserMapper;\r\nimport com.iot.ssm.po.User;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class UserMapperTest {\r\n\r\n	private ApplicationContext applicationContext;\r\n\r\n	//在setUp这个方法得到spring容器\r\n	@Before\r\n	public void setUp() throws Exception {\r\n		applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext.xml\");\r\n	}\r\n\r\n\r\n\r\n	@Test\r\n	public void testFindUserById() throws Exception {\r\n\r\n\r\n		UserMapper userMapper = (UserMapper)applicationContext.getBean(\"userMapper\");\r\n\r\n		//调用userMapper的方法\r\n\r\n		User user = userMapper.findUserById(1);\r\n\r\n		System.out.println(user);\r\n\r\n	}\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n## 遇到的问题\r\n\r\n```\r\norg.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [D:\\intellij\\workspace\\spring-mybatis\\out\\production\\spring-mybatis\\com\\iot\\ssm\\mapper\\UserMapper.class]; nested exception is java.lang.IllegalArgumentException\r\n\r\n	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:281)\r\n	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:242)\r\n	at org.mybatis.spring.mapper.ClassPathMapperScanner.doScan(ClassPathMapperScanner.java:155)\r\n	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.scan(ClassPathBeanDefinitionScanner.java:220)\r\n	at org.mybatis.spring.mapper.MapperScannerConfigurer.postProcessBeanDefinitionRegistry(MapperScannerConfigurer.java:315)\r\n	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:630)\r\n	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:461)\r\n	at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:139)\r\n	at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:83)\r\n	at com.iot.mybatis.mapper.UserMapperTest.setUp(UserMapperTest.java:17)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:483)\r\n	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)\r\n	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\r\n	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)\r\n	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:27)\r\n	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\r\n	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:69)\r\n	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:48)\r\n	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\r\n	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\r\n	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\r\n	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\r\n	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\r\n	at org.junit.runners.ParentRunner.run(ParentRunner.java:292)\r\n	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)\r\n	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\r\n	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\r\n	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n	at java.lang.reflect.Method.invoke(Method.java:483)\r\n	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\r\nCaused by: java.lang.IllegalArgumentException\r\n	at org.springframework.asm.ClassReader.<init>(Unknown Source)\r\n	at org.springframework.asm.ClassReader.<init>(Unknown Source)\r\n	at org.springframework.asm.ClassReader.<init>(Unknown Source)\r\n	at org.springframework.core.type.classreading.SimpleMetadataReader.<init>(SimpleMetadataReader.java:52)\r\n	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:80)\r\n	at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:101)\r\n	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:257)\r\n	... 35 more\r\n```\r\n\r\n\r\n- 搜到的答案\r\n\r\n>* [BeanDefinitionStoreException Failed to read candidate component class](http://stackoverflow.com/questions/22771826/beandefinitionstoreexception-failed-to-read-candidate-component-class)\r\n>* [Failed to read candidate component错误](http://www.osblog.net/blog/399.html)\r\n\r\n\r\n总结起来就是java 8 和spring 3 不能一起用，我在IDEA的`project settings`里把`project language level`换成`7`就好了。具体原因还不清楚\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (246, 'MyBatis 逆向方法', 3, '# mybatis学习笔记(18)-mybatis逆向工程\r\n\r\n标签： mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [下载逆向工程](#下载逆向工程)\r\n  - [使用方法](#使用方法)\r\n    - [运行逆向工程](#运行逆向工程)\r\n    - [生成代码配置文件](#生成代码配置文件)\r\n    - [执行生成程序](#执行生成程序)\r\n    - [使用生成的代码](#使用生成的代码)\r\n\r\n\r\n\r\n---\r\n\r\n\r\nmybaits需要程序员自己编写sql语句,mybatis官方提供逆向工程,可以针对单表自动生成mybatis执行所需要的代码（mapper.java,mapper.xml、po..）\r\n\r\n企业实际开发中，常用的逆向工程方式：由数据库的表生成java代码。\r\n\r\n先附上官网链接：\r\n\r\n>* [MyBatis Generator](http://www.mybatis.org/generator/)\r\n>* [A code generator for MyBatis and iBATIS. - GitHub](https://github.com/mybatis/generator)\r\n\r\n\r\n## 下载逆向工程\r\n\r\n这里其实可以添加Maven依赖的，因为跟着视频做的，所以我就建了个普通工程，直接添加了个lib文件夹，把要用的jar包直接copy进来了。\r\n\r\n> maven中央仓库`MyBatis-Generator`下载地址：[【MyBatis Generator Core】](http://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core)\r\n\r\n## 使用方法\r\n\r\n### 运行逆向工程\r\n\r\n根据官网说的[（Running MyBatis Generator）](http://www.mybatis.org/generator/running/running.html)：\r\n\r\n**Running MyBatis Generator**\r\n\r\nMyBatis Generator (MBG) can be run in the following ways:\r\n\r\n- From the command prompt with an XML configuration\r\n- As an Ant task with an XML configuration\r\n- As a Maven Plugin\r\n- From another Java program with an XML configuration\r\n- From another Java program with a Java based configuration\r\n\r\n还可以通过eclipse的插件生成代码\r\n\r\n建议使用java程序方式，不依赖开发工具。\r\n\r\n\r\n### 生成代码配置文件\r\n\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE generatorConfiguration\r\n  PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\r\n\r\n<generatorConfiguration>\r\n	<context id=\"testTables\" targetRuntime=\"MyBatis3\">\r\n		<commentGenerator>\r\n			<!-- 是否去除自动生成的注释 true：是 ： false:否 -->\r\n			<property name=\"suppressAllComments\" value=\"true\" />\r\n		</commentGenerator>\r\n		<!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->\r\n		<jdbcConnection driverClass=\"com.mysql.jdbc.Driver\"\r\n			connectionURL=\"jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\" \r\n			userId=\"root\"\r\n			password=\"123\">\r\n		</jdbcConnection>\r\n		<!-- <jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\"\r\n			connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:yycg\" \r\n			userId=\"yycg\"\r\n			password=\"yycg\">\r\n		</jdbcConnection> -->\r\n\r\n		<!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \r\n			NUMERIC 类型解析为java.math.BigDecimal -->\r\n		<javaTypeResolver>\r\n			<property name=\"forceBigDecimals\" value=\"false\" />\r\n		</javaTypeResolver>\r\n\r\n		<!-- targetProject:生成PO类的位置 -->\r\n		<javaModelGenerator targetPackage=\"com.iot.ssm.po\"\r\n			targetProject=\".\\src\">\r\n			<!-- enableSubPackages:是否让schema作为包的后缀 -->\r\n			<property name=\"enableSubPackages\" value=\"false\" />\r\n			<!-- 从数据库返回的值被清理前后的空格 -->\r\n			<property name=\"trimStrings\" value=\"true\" />\r\n		</javaModelGenerator>\r\n        <!-- targetProject:mapper映射文件生成的位置 -->\r\n		<sqlMapGenerator targetPackage=\"com.iot.ssm.mapper\" \r\n			targetProject=\".\\src\">\r\n			<!-- enableSubPackages:是否让schema作为包的后缀 -->\r\n			<property name=\"enableSubPackages\" value=\"false\" />\r\n		</sqlMapGenerator>\r\n		<!-- targetPackage：mapper接口生成的位置 -->\r\n		<javaClientGenerator type=\"XMLMAPPER\"\r\n			targetPackage=\"com.iot.ssm.mapper\" \r\n			targetProject=\".\\src\">\r\n			<!-- enableSubPackages:是否让schema作为包的后缀 -->\r\n			<property name=\"enableSubPackages\" value=\"false\" />\r\n		</javaClientGenerator>\r\n		<!-- 指定数据库表 -->\r\n		<table tableName=\"items\"></table>\r\n		<table tableName=\"orders\"></table>\r\n		<table tableName=\"orderdetail\"></table>\r\n		<table tableName=\"user\"></table>\r\n		<!-- <table schema=\"\" tableName=\"sys_user\"></table>\r\n		<table schema=\"\" tableName=\"sys_role\"></table>\r\n		<table schema=\"\" tableName=\"sys_permission\"></table>\r\n		<table schema=\"\" tableName=\"sys_user_role\"></table>\r\n		<table schema=\"\" tableName=\"sys_role_permission\"></table> -->\r\n		\r\n		<!-- 有些表的字段需要指定java类型\r\n		 <table schema=\"\" tableName=\"\">\r\n			<columnOverride column=\"\" javaType=\"\" />\r\n		</table> -->\r\n	</context>\r\n</generatorConfiguration>\r\n```\r\n\r\n需要注意的位置：\r\n\r\n- `javaModelGenerator`,生成PO类的位置\r\n- `sqlMapGenerator`,mapper映射文件生成的位置\r\n- `javaClientGenerator`,mapper接口生成的位置 \r\n- `table`,指定数据库表 \r\n\r\n\r\n### 执行生成程序\r\n\r\n```java\r\npublic void generator() throws Exception{\r\n\r\n	List<String> warnings = new ArrayList<String>();\r\n	boolean overwrite = true;\r\n	//指定逆向工程配置文件\r\n	File configFile = new File(\"generatorConfig.xml\"); \r\n	ConfigurationParser cp = new ConfigurationParser(warnings);\r\n	Configuration config = cp.parseConfiguration(configFile);\r\n	DefaultShellCallback callback = new DefaultShellCallback(overwrite);\r\n	MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\r\n			callback, warnings);\r\n	myBatisGenerator.generate(null);\r\n\r\n} \r\n```\r\n\r\n日志输出：\r\n\r\n```\r\n2016-02-27 16:29:46,419 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Retrieving column information for table \"items\"\r\n2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"id\", data type 4, in table \"mybatis001..items\"\r\n2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"name\", data type 12, in table \"mybatis001..items\"\r\n2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"price\", data type 7, in table \"mybatis001..items\"\r\n2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"detail\", data type -1, in table \"mybatis001..items\"\r\n2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"pic\", data type 12, in table \"mybatis001..items\"\r\n2016-02-27 16:29:46,478 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"createtime\", data type 93, in table \"mybatis001..items\"\r\n2016-02-27 16:29:46,503 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Retrieving column information for table \"orders\"\r\n2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"id\", data type 4, in table \"mybatis001..orders\"\r\n2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"user_id\", data type 4, in table \"mybatis001..orders\"\r\n2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"number\", data type 12, in table \"mybatis001..orders\"\r\n2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"createtime\", data type 93, in table \"mybatis001..orders\"\r\n2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"note\", data type 12, in table \"mybatis001..orders\"\r\n2016-02-27 16:29:46,577 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Retrieving column information for table \"orderdetail\"\r\n2016-02-27 16:29:46,630 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"id\", data type 4, in table \"mybatis001..orderdetail\"\r\n2016-02-27 16:29:46,630 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"orders_id\", data type 4, in table \"mybatis001..orderdetail\"\r\n2016-02-27 16:29:46,631 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"items_id\", data type 4, in table \"mybatis001..orderdetail\"\r\n2016-02-27 16:29:46,631 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"items_num\", data type 4, in table \"mybatis001..orderdetail\"\r\n2016-02-27 16:29:46,656 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Retrieving column information for table \"user\"\r\n2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"id\", data type 4, in table \"mybatis001..user\"\r\n2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"username\", data type 12, in table \"mybatis001..user\"\r\n2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"birthday\", data type 91, in table \"mybatis001..user\"\r\n2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"sex\", data type 1, in table \"mybatis001..user\"\r\n2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column \"address\", data type 12, in table \"mybatis001..user\"\r\n```\r\n\r\n生成后的代码：\r\n\r\n![逆向工程](http://7xph6d.com1.z0.glb.clouddn.com/mybatis_%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81.png)\r\n\r\n### 使用生成的代码\r\n\r\n需要将生成工程中所生成的代码拷贝到自己的工程中。\r\n\r\n测试ItemsMapper中的方法\r\n\r\n```java\r\npackage com.iot.ssm.mapper;\r\n\r\nimport static org.junit.Assert.*;\r\n\r\nimport java.util.Date;\r\nimport java.util.List;\r\n\r\nimport com.iot.ssm.po.Items;\r\nimport com.iot.ssm.po.ItemsExample;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\n\r\npublic class ItemsMapperTest {\r\n\r\n	private ApplicationContext applicationContext;\r\n	\r\n	private ItemsMapper itemsMapper;\r\n\r\n	//在setUp这个方法得到spring容器\r\n	@Before\r\n	public void setUp() throws Exception {\r\n		applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext.xml\");\r\n		itemsMapper = (ItemsMapper) applicationContext.getBean(\"itemsMapper\");\r\n	}\r\n\r\n	//根据主键删除 \r\n	@Test\r\n	public void testDeleteByPrimaryKey() {\r\n		\r\n	}\r\n\r\n	//插入\r\n	@Test\r\n	public void testInsert() {\r\n		//构造 items对象\r\n		Items items = new Items();\r\n		items.setName(\"手机\");\r\n		items.setPrice(999f);\r\n		items.setCreatetime(new Date());\r\n		itemsMapper.insert(items);\r\n	}\r\n\r\n	//自定义条件查询\r\n	@Test\r\n	public void testSelectByExample() {\r\n		ItemsExample itemsExample = new ItemsExample();\r\n		//通过criteria构造查询条件\r\n		ItemsExample.Criteria criteria = itemsExample.createCriteria();\r\n		criteria.andNameEqualTo(\"笔记本\");\r\n		//可能返回多条记录\r\n		List<Items> list = itemsMapper.selectByExample(itemsExample);\r\n		\r\n		System.out.println(list);\r\n		\r\n	}\r\n\r\n	//根据主键查询\r\n	@Test\r\n	public void testSelectByPrimaryKey() {\r\n		Items items = itemsMapper.selectByPrimaryKey(1);\r\n		System.out.println(items);\r\n	}\r\n\r\n	//更新数据\r\n	@Test\r\n	public void testUpdateByPrimaryKey() {\r\n		\r\n		//对所有字段进行更新，需要先查询出来再更新\r\n		Items items = itemsMapper.selectByPrimaryKey(1);\r\n		\r\n		items.setName(\"手机\");\r\n		\r\n		itemsMapper.updateByPrimaryKey(items);\r\n		//如果传入字段不空为才更新，在批量更新中使用此方法，不需要先查询再更新\r\n		//itemsMapper.updateByPrimaryKeySelective(record);\r\n		\r\n	}\r\n\r\n}\r\n```\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) | [CSDN](http://blog.csdn.net/h3243212/) | [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (247, 'SpringMVC 框架原理和入门配置', 4, '# springmvc学习笔记(1)-框架原理和入门配置\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [springmvc框架原理](#springmvc框架原理)\r\n  - [springmvc入门程序](#springmvc入门程序)\r\n    - [环境搭建](#环境搭建)\r\n    - [配置文件](#配置文件)\r\n    - [部署调试](#部署调试)\r\n  - [参考链接](#参考链接)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要介绍springmvc的框架原理，并通过一个入门程序展示环境搭建，配置以及部署调试。\r\n\r\n\r\nspringmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。\r\n\r\n\r\n## springmvc框架原理\r\n\r\n给个官网示意图\r\n\r\n![The request processing workflow in Spring Web MVC](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/images/mvc.png)\r\n\r\n组件及其作用\r\n\r\n- 前端控制器(DispatcherServlet)：接收请求，响应结果，相当于转发器，中央处理器。减少了其他组件之间的耦合度\r\n- 处理器映射器(HandlerMapping)：根据请求的url查找Handler\r\n- **Handler处理器**：按照HandlerAdapter的要求编写\r\n- 处理器适配器(HandlerAdapter)：按照特定规则(HandlerAdapter要求的规则)执行Handler。\r\n- 视图解析器(ViewResolver)：进行视图解析，根据逻辑视图解析成真正的视图(View)\r\n- **视图(View)**：View是一个接口实现类试吃不同的View类型（jsp,pdf等等）\r\n\r\n*注：其中加粗的为需要程序员开发的，没加粗的为不需要程序员开发的*\r\n\r\n文末参考链接中《跟开涛学SpringMVC》里面有张图挺好的，感觉很详细.\r\n\r\n![springmvc_核心架构图](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg)\r\n\r\n\r\n步骤：\r\n\r\n- 1.发起请求到前端控制器(`DispatcherServlet`)\r\n- 2.前端控制器请求处理器映射器(`HandlerMapping`)查找`Handler`(可根据xml配置、注解进行查找)\r\n- 3.处理器映射器(`HandlerMapping`)向前端控制器返回`Handler`\r\n- 4.前端控制器调用处理器适配器(`HandlerAdapter`)执行`Handler`\r\n- 5.处理器适配器(HandlerAdapter)去执行Handler\r\n- 6.Handler执行完，给适配器返回ModelAndView(Springmvc框架的一个底层对象)\r\n- 7.处理器适配器(`HandlerAdapter`)向前端控制器返回`ModelAndView`\r\n- 8.前端控制器(`DispatcherServlet`)请求视图解析器(`ViewResolver`)进行视图解析，根据逻辑视图名解析成真正的视图(jsp)\r\n- 9.视图解析器(ViewResolver)向前端控制器(`DispatcherServlet`)返回View\r\n- 10.前端控制器进行视图渲染，即将模型数据(在`ModelAndView`对象中)填充到request域\r\n- 11.前端控制器向用户响应结果\r\n\r\n## springmvc入门程序\r\n\r\n一个展示商品列表的小页面\r\n\r\n### 环境搭建\r\n\r\nintellij IDEA 15.0.2\r\n\r\n- A方法(有待商榷)\r\n\r\n`new->project->maven->勾选create from archetype->选中webapp` \r\n\r\n在`src/main`下新建`java`文件夹，标记为`Sources Root`\r\n\r\n这样建出来的工程感觉有问题，点开一些xml文件一片红，心里不是很踏实，所以放弃这个方法了\r\n\r\n\r\n- B方法\r\n\r\n`new->project->maven`，建一个裸的maven工程，手动建webapp的目录\r\n\r\n在`src/main`下新建文件夹`webapp`\r\n\r\npom.xml文件\r\n\r\n添加依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-webmvc</artifactId>\r\n    <version>4.2.4.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n加上下面的标签会生成Artifacts\r\n\r\n```xml\r\n<packaging>war</packaging>\r\n```\r\n\r\nbuild标签的finalName要和Artifacts的output directory一致\r\n\r\n```xml\r\n<build>\r\n    <finalName>springmvc-2nd-1.0-SNAPSHOT</finalName>\r\n</build>\r\n```\r\n\r\n\r\n### 配置文件\r\n\r\n- 配置前端控制器\r\n\r\nweb.xml\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>springmvc</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)\r\n      若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)\r\n    -->\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:springmvc.xml</param-value>\r\n    </init-param>\r\n</servlet>\r\n```\r\n\r\n```xml\r\n<servlet-mapping>\r\n    <servlet-name>springmvc</servlet-name>\r\n    <!--\r\n    第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析\r\n    第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，\r\n            使用此种方式和实现RESTful风格的url\r\n    第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，\r\n            不能根据jsp页面找到handler，会报错\r\n    -->\r\n    <url-pattern>*.action</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n- 配置Handler\r\n\r\n将编写Handler在spring容器加载\r\n\r\n```xml\r\n<!-- 配置Handler -->\r\n<bean name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/>\r\n\r\n```\r\n\r\n- 配置处理器映射器\r\n\r\n在classpath下的springmvc.xml中配置处理器映射器\r\n\r\n```xml\r\n<!-- 处理器映射器\r\n    将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n-->\r\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\r\n```\r\n\r\n\r\n- 配置处理器适配器\r\n\r\n所有处理器适配器都实现了`HandlerAdapter`接口\r\n\r\n`<bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\">`\r\n\r\n\r\n源码\r\n\r\n```java\r\npublic boolean supports(Object handler) {\r\n        return handler instanceof Controller;\r\n}\r\n```\r\n\r\n此适配器能执行实现`Controller`接口的Handler\r\n\r\n\r\n\r\n- 配置视图解析器\r\n\r\n需要配置解析jsp的视图解析器\r\n\r\n```xml\r\n <!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/>\r\n```\r\n\r\n\r\n在springmvc.xml中视图解析器配置前缀和后缀：\r\n\r\n```xml\r\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- 配置jsp路径的前缀 -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n        <!-- 配置jsp路径的后缀 -->\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n</bean>\r\n```\r\n\r\n程序中不用指定前缀和后缀：\r\n\r\n```java\r\n//指定视图\r\n//下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n//modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\r\n\r\n//下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\nmodelAndView.setViewName(\"items/itemsList\");\r\n```\r\n\r\n\r\n\r\n### 部署调试\r\n\r\n`HTTP Status 404 -`\r\n处理器映射器根据url找不到Handler,说明url错误\r\n\r\n`HTTP Status 404 -/springmvc/WEB-INF/jsp/items/itemsLists.jsp`\r\n处理器映射器根据url找到了Handler，转发的jsp页面找不到\r\n\r\n\r\n\r\n\r\n\r\n## 参考链接\r\n\r\n>* [第二章 Spring MVC入门 —— 跟开涛学SpringMVC](http://sishuok.com/forum/blogPost/list/5160.html)\r\n>* [Spring MVC Framework Tutorial - TutorialsPoint](http://www.tutorialspoint.com/spring/spring_web_mvc_framework.htm)\r\n>* [Web MVC framework](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html)\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (248, 'SpringMVC 非注解的处理器映射器和适配器', 4, '# springmvc学习笔记(2)-非注解的处理器映射器和适配器\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [非注解的处理器映射器](#非注解的处理器映射器)\r\n  - [非注解的处理器适配器](#非注解的处理器适配器)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要介绍非注解的处理器映射器和适配器配置\r\n\r\n\r\n## 非注解的处理器映射器\r\n\r\n```xml\r\n <!-- 配置Handler -->\r\n<bean id=\"itemsController\" name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/>\r\n\r\n<!-- 处理器映射器\r\n将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n -->\r\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\r\n\r\n<!-- 简单url映射-->\r\n<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\r\n    <property name=\"mappings\">\r\n        <props>\r\n            <!-- 对 itemsController进行url映射-->\r\n            <prop key=\"/queryItems1.action\">itemsController</prop>\r\n            <prop key=\"/queryItems2.action\">itemsController</prop>\r\n        </props>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n多个映射器可并存，前端控制器判断url能让哪些映射器处理就让正确的映射器处理\r\n\r\n\r\n## 非注解的处理器适配器\r\n\r\n```\r\n <!-- 处理器适配器\r\n     所有处理器适配器都实现了HandlerAdapter接口\r\n     -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\r\n```\r\n\r\n要求编写的Handler实现`Controller`接口\r\n\r\n`<bean class=\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\"/>`\r\n\r\n要求编写的Handler实现`HttpRequestHandler`接口\r\n\r\n```java\r\npackage com.iot.ssm.controller;\r\n\r\nimport com.iot.ssm.po.Items;\r\nimport org.springframework.web.HttpRequestHandler;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by brian on 2016/2/19.\r\n */\r\npublic class ItemsController2 implements HttpRequestHandler{\r\n    public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {\r\n        //调用service查找数据库，查询商品列表，这里使用静态数据模拟\r\n        List<Items> itemsList = new ArrayList<Items>();\r\n\r\n        //向list中填充静态数据\r\n        Items items_1 = new Items();\r\n        items_1.setName(\"联想笔记本\");\r\n        items_1.setPrice(6000f);\r\n        items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\");\r\n\r\n        Items items_2 = new Items();\r\n        items_2.setName(\"苹果手机\");\r\n        items_2.setPrice(5000f);\r\n        items_2.setDetail(\"iphone6苹果手机！\");\r\n\r\n        itemsList.add(items_1);\r\n        itemsList.add(items_2);\r\n\r\n        //设置模型数据\r\n        httpServletRequest.setAttribute(\"itemsList\",itemsList);\r\n\r\n        //设置转发的视图\r\n        httpServletRequest.getRequestDispatcher(\"/WEB-INF/jsp/items/itemsList.jsp\").forward(httpServletRequest,httpServletResponse);\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n`HttpRequestHandler`适配器的`handleRequest`方法返回为`void`,没有返回`ModelAndView`，可通过response修改响应内容,比如返回json数据：\r\n\r\n```java\r\nresponse.setCharacterEncoding(\"utf-8\");\r\nresponse.setContentType(\"application/json;charset=utf-8\");\r\nresponse.getWriter().write(\"json串\");\r\n```\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (249, 'SpringMVC 注解的处理器映射器和适配器', 4, '# springmvc学习笔记(3)-注解的处理器映射器和适配器\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [默认加载](#默认加载)\r\n  - [注解的处理器映射器和适配器](#注解的处理器映射器和适配器)\r\n  - [开发注解Handler](#开发注解Handler)\r\n  - [在spring容器中加载Handler](#在spring容器中加载Handler)\r\n  - [参考资料](#参考资料)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文主要介绍注解的处理器映射器和适配器相关配置\r\n\r\n\r\n## 默认加载\r\n\r\n前端控制器从`\\org\\springframework\\web\\servlet\\DispatcherServlet.properties`件中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的\r\n\r\n注解的处理器映射器和适配器\r\n\r\n- 在spring3.1之前使用`org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping`注解映射器。\r\n- 在spring3.1之后使用`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping`注解映射器。\r\n- 在spring3.1之前使用`org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter`注解适配器。\r\n- 在spring3.1之后使用`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter`注解适配器\r\n\r\n\r\n## 注解的处理器映射器和适配器\r\n\r\n```xml\r\n<!-- 注解的映射器 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\r\n\r\n<!-- 注解的适配器 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\r\n    \r\n```\r\n\r\n或者\r\n\r\n```xml\r\n    <!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     -->\r\n    <mvc:annotation-driven></mvc:annotation-driven>\r\n\r\n```\r\n\r\n## 开发注解Handler\r\n\r\n使用注解的映射器和注解的适配器。(使用注解的映射器和注解的适配器必须配对使用)\r\n\r\n```java\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\npublic class ItemsController3 {\r\n\r\n    //商品查询列表\r\n    @RequestMapping(\"/queryItems\")\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表，这里使用静态数据模拟\r\n        List<Items> itemsList = new ArrayList<Items>();\r\n\r\n        //向list中填充静态数据\r\n        Items items_1 = new Items();\r\n        items_1.setName(\"联想笔记本\");\r\n        items_1.setPrice(6000f);\r\n        items_1.setDetail(\"ThinkPad T430 c3 联想笔记本电脑！\");\r\n\r\n        Items items_2 = new Items();\r\n        items_2.setName(\"苹果手机\");\r\n        items_2.setPrice(5000f);\r\n        items_2.setDetail(\"iphone6苹果手机！\");\r\n\r\n        itemsList.add(items_1);\r\n        itemsList.add(items_2);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(\"itemsList\",itemsList);\r\n\r\n        //指定视图\r\n        modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\r\n        return modelAndView;\r\n    }\r\n}\r\n```\r\n\r\n## 在spring容器中加载Handler\r\n\r\n```xml\r\n<!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    -->\r\n    <!--  <bean  class=\"com.iot.ssm.controller.ItemsController3\"/> -->\r\n    <!-- 可以扫描controller、service、...\r\n	这里让扫描controller，指定controller的包\r\n	 -->\r\n    <context:component-scan base-package=\"com.iot.ssm.controller\"></context:component-scan>\r\n```\r\n\r\n\r\n\r\n## 参考资料\r\n\r\n>* [SpringMVC框架】注解的处理器映射器和适配器配置](http://blog.csdn.net/acmman/article/details/46980427)\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (250, 'SpringMVC 前端控制器', 4, '# springmvc学习笔记(4)-前端控制器\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文通过前端控制器源码分析springmvc执行过程\r\n\r\n\r\n1.前端控制器接收请求\r\n\r\n调用`doDispatch`方法\r\n\r\n```java\r\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\r\n		HttpServletRequest processedRequest = request;\r\n		HandlerExecutionChain mappedHandler = null;\r\n		boolean multipartRequestParsed = false;\r\n    \r\n         。。。。。\r\n}\r\n```\r\n\r\n\r\n2.前端控制器调用`HandlerMapping`（处理器映射器）根据url查找Handler\r\n\r\n\r\n```java\r\n// Determine handler for the current request.\r\nmappedHandler = getHandler(processedRequest);\r\n```\r\n\r\n```java\r\n/**\r\n	 * Return the HandlerExecutionChain for this request.\r\n	 * <p>Tries all handler mappings in order.\r\n	 * @param request current HTTP request\r\n	 * @return the HandlerExecutionChain, or {@code null} if no handler could be found\r\n	 */\r\n	protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\r\n		for (HandlerMapping hm : this.handlerMappings) {\r\n			if (logger.isTraceEnabled()) {\r\n				logger.trace(\r\n						\"Testing handler map [\" + hm + \"] in DispatcherServlet with name \'\" + getServletName() + \"\'\");\r\n			}\r\n			HandlerExecutionChain handler = hm.getHandler(request);\r\n			if (handler != null) {\r\n				return handler;\r\n			}\r\n		}\r\n		return null;\r\n	}\r\n```\r\n\r\n3.调用处理器适配器执行Handler,得到执行的结果`ModelAndView mv`\r\n\r\n在`doDispatch`方法中\r\n\r\n```java\r\n// Actually invoke the handler.\r\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\r\n```\r\n\r\n4.视图渲染，将model数据填充到request域\r\n\r\n`doDispatch`->`processDispatchResult`->`render`\r\n\r\n在`render`方法中,视图解析得到view\r\n\r\n```java\r\n// We need to resolve the view name.\r\nview = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);\r\n		\r\n```\r\n\r\n调用view的渲染方法，将model数据填充到request域\r\n\r\n在`render`方法中,调用`View`接口的`render`方法\r\n\r\n```java\r\nview.render(mv.getModelInternal(), request, response);\r\n```\r\n\r\n\r\n程序我也没细读，感觉分析比较浅，很多还没弄懂，等我系统阅读源码后会整理一篇好点的。\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (251, 'SpringMVC 入门程序小结', 4, '# springmvc学习笔记(5)-入门程序小结\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [入门程序配置小结](#入门程序配置小结)\r\n  - [非注解的完整的配置文件](#非注解的完整的配置文件)\r\n  - [注解的完整配置文件](#注解的完整配置文件)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n通过入门程序理解springmvc前端控制器、处理器映射器、处理器适配器、视图解析器用法。并附上入门程序的非注解的完整的配置文件，注解的完整配置文件。\r\n\r\n## 入门程序配置小结\r\n\r\n前端控制器配置：\r\n\r\n- 第一种：`*.action`，访问以`.action`结尾 由`DispatcherServlet`进行解析\r\n- 第二种：`/`，所以访问的地址都由`DispatcherServlet`进行解析，对于静态文件的解析需要配置不让`DispatcherServlet`进行解析,使用此种方式可以实现RESTful风格的url\r\n\r\n处理器映射器：\r\n\r\n- 非注解处理器映射器（了解）\r\n- 注解的处理器映射器（掌握）\r\n\r\n对标记`@Controller`类中标识有`@RequestMapping`的方法进行映射。在`@RequestMapping`里边定义映射的url。使用注解的映射器不用在xml中配置url和Handler的映射关系。\r\n\r\n处理器适配器：\r\n\r\n非注解处理器适配器（了解）\r\n注解的处理器适配器（掌握）\r\n注解处理器适配器和注解的处理器映射器是**配对使用**。理解为不能使用非注解映射器进行映射。\r\n\r\n```xml\r\n<mvc:annotation-driven></mvc:annotation-driven> \r\n```\r\n\r\n可以代替下边的配置：\r\n\r\n```xml\r\n<!--注解映射器 -->  \r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>  \r\n    <!--注解适配器 -->  \r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>  \r\n```\r\n\r\n\r\n\r\n## 非注解的完整的配置文件\r\n\r\n`src/main/resources/springmvc.xml`\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\r\n\r\n    <!-- 配置Handler -->\r\n    <bean name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/>\r\n\r\n    <!-- 处理器映射器\r\n    将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n     -->\r\n    <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\r\n\r\n    <!-- 处理器适配器\r\n     所有处理器适配器都实现了HandlerAdapter接口\r\n     -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\r\n\r\n    <!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/>\r\n\r\n</beans>\r\n```\r\n\r\n\r\n## 注解的完整配置文件\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\r\n\r\n   <!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    -->\r\n    <!--  <bean  class=\"com.iot.ssm.controller.ItemsController3\"/> -->\r\n    <!-- 可以扫描controller、service、...\r\n	这里让扫描controller，指定controller的包\r\n	 -->\r\n    <context:component-scan base-package=\"com.iot.ssm.controller\"></context:component-scan>\r\n\r\n\r\n\r\n\r\n    <!-- 注解的映射器 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\r\n\r\n    <!-- 注解的适配器 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\r\n\r\n    <!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     -->\r\n    <mvc:annotation-driven></mvc:annotation-driven>\r\n\r\n    <!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- 配置jsp路径的前缀 -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n        <!-- 配置jsp路径的后缀 -->\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (252, 'SpringMVC 整合mybatis(IDEA中通过maven构建)', 4, '# springmvc学习笔记(6)-springmvc整合mybatis(IDEA中通过maven构建)\r\n\r\n标签： springmvc mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [整合思路](#整合思路)\r\n  - [工程结构](#工程结构)\r\n    - [添加依赖](#添加依赖)\r\n    - [建包](#建包)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文主要展示如何在intellij IDEA中通过maven构建springmvc+mybatis框架的开发环境。\r\n\r\n\r\n\r\n需求：使用springmvc和mybatis完成商品列表查询\r\n\r\n## 整合思路\r\n\r\n![springmvc_整合mybatis思路](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88mybatis%E6%80%9D%E8%B7%AF.png)\r\n\r\n\r\n- 第一步：整合dao层\r\n  - mybatis和spring整合，通过spring管理mapper接口。\r\n  - 使用mapper的扫描器自动扫描mapper接口在spring中进行注册。\r\n\r\n- 第二步：整合service层\r\n  - 通过spring管理service接口。\r\n  - 使用配置方式将service接口配置在spring配置文件中。\r\n  - 实现事务控制。\r\n\r\n- 第三步：整合springmvc\r\n   - 由于springmvc是spring的模块，不需要整合。\r\n\r\n\r\n\r\n## 工程结构\r\n\r\n不同于[《mybatis学习笔记(17)-spring和mybatis整合》](http://blog.csdn.net/h3243212/article/details/50778934)中的示例demo,**本文的整合采用maven构建**。\r\n\r\n如何创建使用maven构建的web应用可以参考前面的一篇[《springmvc学习笔记(1)-框架原理和入门配置》](http://blog.csdn.net/h3243212/article/details/50828141#环境搭建)\r\n\r\n`new->project->maven`，建一个裸的maven工程，手动建webapp的目录\r\n\r\n在`src/main`下新建文件夹`webapp`\r\n\r\n### 添加依赖\r\n\r\npom.xml文件\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.iot.learnssm</groupId>\r\n    <artifactId>learnssm-firstssm</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n    <packaging>war</packaging>\r\n    \r\n    <properties>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <!-- jar 版本设置 -->\r\n        <spring.version>4.2.4.RELEASE</spring.version>\r\n    </properties>\r\n\r\n\r\n    <dependencies>\r\n\r\n        <!-- spring框架-->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-webmvc</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-core</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-orm</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-aspects</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-test</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-jdbc</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <version>5.1.38</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis</artifactId>\r\n            <version>3.3.1</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis-spring</artifactId>\r\n            <version>1.2.4</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>log4j</groupId>\r\n            <artifactId>log4j</artifactId>\r\n            <version>1.2.17</version>\r\n        </dependency>\r\n        \r\n        <dependency>\r\n            <groupId>org.slf4j</groupId>\r\n            <artifactId>slf4j-api</artifactId>\r\n            <version>1.7.18</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>commons-dbcp</groupId>\r\n            <artifactId>commons-dbcp</artifactId>\r\n            <version>1.4</version>\r\n        </dependency>\r\n\r\n        <!-- JSP tag -->\r\n        <dependency>\r\n            <groupId>javax.servlet</groupId>\r\n            <artifactId>jstl</artifactId>\r\n            <version>1.2</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>taglibs</groupId>\r\n            <artifactId>standard</artifactId>\r\n            <version>1.1.2</version>\r\n        </dependency>\r\n    </dependencies>\r\n    \r\n</project>\r\n```\r\n\r\n这里添加的依赖可能有多的,但总比少包好，我开始就是引少了依赖(springframework的依赖只引用了spring-mvc,连spring-core都没引)，导致报错,以后会出一篇博客专门讲这个系列笔记中debug相关问题。\r\n\r\n\r\n### 建包\r\n\r\n在java目录下建各个package,按照maven的命名习惯:\r\n\r\n`com.公司名.项目名.模块名`\r\n\r\n这里我的包为：\r\n\r\n`com.iot.learnssm.firstssm`\r\n\r\n包含几个子包：\r\n\r\n- controller\r\n- mapper\r\n- po\r\n- service\r\n  - impl \r\n\r\n项目结构如图：\r\n  \r\n![springmvc_整合工程-1](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B-1.png)\r\n\r\n\r\n后面几篇笔记会依次记录mapper,service,controller各个部分的整合\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (253, 'SpringMVC 整合mybatis之mapper', 4, '# springmvc学习笔记(7)-springmvc整合mybatis之mapper\r\n\r\n标签： springmvc mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [整合dao](#整合dao)\r\n- [Global logging configuration](#global-logging-configuration)\r\n- [Console output...](#console-output)\r\n    - [sqlMapConfig.xml](#sqlMapConfig.xml)\r\n    - [applicationContext-dao.xml](#applicationContext-dao.xml)\r\n    - [逆向工程生成po类及mapper(单表增删改查)](#逆向工程生成po类及mapper（单表增删改查）)\r\n    - [手动定义商品查询mapper](#手动定义商品查询mapper)\r\n\r\n\r\n\r\n---\r\n\r\n本文记录springmvc整合dao的配置\r\n\r\n## 整合dao\r\n\r\n首先在resource文件夹下添加两个文件：数据库配置文件和日志配置文件\r\n\r\n- 数据库配置文件db.properties\r\n\r\n```\r\njdbc.driver=com.mysql.jdbc.Driver\r\njdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\r\njdbc.username=root\r\njdbc.password=123\r\n```\r\n\r\n- 日志配置文件log4j.properties\r\n\r\n```\r\n# Global logging configuration\r\nlog4j.rootLogger=DEBUG, stdout\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n```\r\n\r\n### sqlMapConfig.xml\r\n\r\nmybatis自己的配置文件\r\n\r\n在resources目录下新建mybatis文件夹，并新建sqlMapConfig.xml文件\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n\r\n    <!-- 全局setting配置，根据需要添加 -->\r\n\r\n    <!-- 配置别名 -->\r\n    <typeAliases>\r\n        <!-- 批量扫描别名 -->\r\n        <package name=\"com.iot.learnssm.firstssm.po\"/>\r\n    </typeAliases>\r\n\r\n    <!-- 配置mapper\r\n    由于使用spring和mybatis的整合包进行mapper扫描，这里不需要配置了。\r\n    必须遵循：mapper.xml和mapper.java文件同名且在一个目录\r\n     -->\r\n\r\n    <!-- <mappers>\r\n\r\n    </mappers> -->\r\n</configuration>\r\n```\r\n\r\n\r\n### applicationContext-dao.xml\r\n\r\n在resources目录下新建spring文件夹，并新建applicationContext-dao.xml文件\r\n\r\n配置：\r\n\r\n- 数据源\r\n- SqlSessionFactory\r\n- mapper扫描器\r\n\r\n\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\r\n\r\n    <!-- 加载db.properties文件中的内容，db.properties文件中key命名要有一定的特殊规则 -->\r\n    <context:property-placeholder location=\"classpath:db.properties\" />\r\n    <!-- 配置数据源 ，dbcp -->\r\n\r\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\r\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\r\n        <property name=\"url\" value=\"${jdbc.url}\"/>\r\n        <property name=\"username\" value=\"${jdbc.username}\" />\r\n        <property name=\"password\" value=\"${jdbc.password}\" />\r\n        <property name=\"maxActive\" value=\"30\" />\r\n        <property name=\"maxIdle\" value=\"5\" />\r\n    </bean>\r\n\r\n    <!-- 从整合包里找，org.mybatis:mybatis-spring:1.2.4 -->\r\n    <!-- sqlSessionFactory -->\r\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n        <!-- 数据库连接池 -->\r\n        <property name=\"dataSource\" ref=\"dataSource\" />\r\n        <!-- 加载mybatis的全局配置文件 -->\r\n        <property name=\"configLocation\" value=\"classpath:mybatis/sqlMapConfig.xml\" />\r\n    </bean>\r\n    <!-- mapper扫描器 -->\r\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\r\n        <!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 -->\r\n        <property name=\"basePackage\" value=\"com.iot.learnssm.firstssm.mapper\"/>\r\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" />\r\n       <!-- <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" />\r\n       会导致数据源配置不管用，数据库连接不上。\r\n       且spring 4弃用\r\n       -->\r\n    </bean>\r\n\r\n</beans>\r\n\r\n```\r\n\r\n\r\n### 逆向工程生成po类及mapper（单表增删改查）\r\n\r\n方法参见[《mybatis学习笔记(18)-mybatis逆向工程》](http://blog.csdn.net/h3243212/article/details/50778937)\r\n\r\n\r\n### 手动定义商品查询mapper\r\n\r\n针对综合查询mapper，一般情况会有关联查询，建议自定义mapper\r\n\r\n- ItemsMapperCustom.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\r\n<mapper namespace=\"com.iot.learnssm.firstssm.mapper.ItemsMapperCustom\" >\r\n\r\n   <!-- 定义商品查询的sql片段，就是商品查询条件 -->\r\n   <sql id=\"query_items_where\">\r\n   	<!-- 使用动态sql，通过if判断，满足条件进行sql拼接 -->\r\n   	<!-- 商品查询条件通过ItemsQueryVo包装对象 中itemsCustom属性传递 -->\r\n   		<if test=\"itemsCustom!=null\">\r\n   			<if test=\"itemsCustom.name!=null and itemsCustom.name!=\'\'\">\r\n   				items.name LIKE \'%${itemsCustom.name}%\'\r\n   			</if>\r\n   		</if>\r\n	\r\n   </sql>\r\n  	\r\n  	<!-- 商品列表查询 -->\r\n  	<!-- parameterType传入包装对象(包装了查询条件)\r\n  		resultType建议使用扩展对象\r\n  	 -->\r\n  	<select id=\"findItemsList\" parameterType=\"com.iot.learnssm.firstssm.po.ItemsQueryVo\"\r\n  		 resultType=\"com.iot.learnssm.firstssm.po.ItemsCustom\">\r\n  		SELECT items.* FROM items  \r\n  		<where>\r\n  			<include refid=\"query_items_where\"></include>\r\n  		</where>\r\n  	</select>\r\n  	\r\n</mapper>\r\n```\r\n\r\n- ItemsMapperCustom.java\r\n\r\n```java\r\npublic interface ItemsMapperCustom {\r\n    //商品查询列表\r\n    List<ItemsCustom> findItemsList(ItemsQueryVo itemsQueryVo)throws Exception;\r\n}\r\n```\r\n\r\n- po类`ItemsCustom`\r\n\r\n```java\r\npackage com.iot.learnssm.firstssm.po;\r\n\r\n/**\r\n * Created by Brian on 2016/3/2.\r\n * 商品信息的扩展类\r\n */\r\npublic class ItemsCustom extends Items{\r\n    //添加商品信息的扩展属性\r\n}\r\n```\r\n\r\n- 输入pojo的包装类\r\n\r\n```java\r\npackage com.iot.learnssm.firstssm.po;\r\n\r\n/**\r\n * Created by Brian on 2016/3/2.\r\n */\r\npublic class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n\r\n    public Items getItems() {\r\n        return items;\r\n    }\r\n\r\n    public void setItems(Items items) {\r\n        this.items = items;\r\n    }\r\n\r\n    public ItemsCustom getItemsCustom() {\r\n        return itemsCustom;\r\n    }\r\n\r\n    public void setItemsCustom(ItemsCustom itemsCustom) {\r\n        this.itemsCustom = itemsCustom;\r\n    }\r\n}\r\n```\r\n\r\n\r\n整合好dao后的工程目录如图\r\n\r\n![springmvc_整合工程-2](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B-2.png)\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (254, 'SpringMVC 整合mybatis之service', 4, '# springmvc学习笔记(8)-springmvc整合mybatis之service\r\n\r\n标签： springmvc mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [定义service接口](#定义service接口)\r\n  - [在spring容器配置service](#在spring容器配置service)\r\n  - [事务控制](#事务控制)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文记录如何整合service,包括定义spring接口，在spring容器配置service以及事务控制。让spring管理service接口。\r\n\r\n\r\n## 定义service接口\r\n\r\n```java\r\npublic interface ItemsService {\r\n    //商品查询列表\r\n    List<ItemsCustom> findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;\r\n\r\n}\r\n```\r\n\r\n```java\r\npublic class ItemsServiceImpl implements ItemsService {\r\n\r\n    @Autowired\r\n    private ItemsMapperCustom itemsMapperCustom;\r\n\r\n    public List<ItemsCustom> findItemsList(ItemsQueryVo itemsQueryVo) throws Exception {\r\n        return itemsMapperCustom.findItemsList(itemsQueryVo);\r\n    }\r\n}\r\n```\r\n\r\n## 在spring容器配置service\r\n\r\n\r\n在`resources/spring`下创建applicationContext-service.xml，文件中配置service。\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\">\r\n\r\n    <!-- 商品管理的service -->\r\n    <bean id=\"itemsService\" class=\"com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n\r\n## 事务控制\r\n\r\n在`resources/spring`下创建applicationContext-transaction.xml，在applicationContext-transaction.xml中使用spring声明式事务控制方法。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\r\n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\">\r\n\r\n\r\n<!-- 事务管理器\r\n        对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\r\n    -->\r\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n        <!-- 数据源\r\n        dataSource在applicationContext-dao.xml中配置了\r\n         -->\r\n        <property name=\"dataSource\" ref=\"dataSource\"/>\r\n    </bean>\r\n\r\n    <!-- 通知 -->\r\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\r\n        <tx:attributes>\r\n            <!-- 传播行为 -->\r\n            <tx:method name=\"save*\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"insert*\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"update*\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\r\n            <tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\r\n            <tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\r\n        </tx:attributes>\r\n    </tx:advice>\r\n    <!-- aop -->\r\n    <aop:config>\r\n        <aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.iot.learnssm.firstssm.service.impl.*.*(..))\"/>\r\n    </aop:config>\r\n</beans>\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (255, 'SpringMVC 整合mybatis之controller', 4, '# springmvc学习笔记(9)-springmvc整合mybatis之controller\r\n\r\n标签： springmvc mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [springmvc.xml](#springmvc.xml)\r\n  - [配置web.xml](#配置web.xml)\r\n  - [编写Controller(就是Handler)](#编写Controller就是Handler)\r\n  - [编写jsp](#编写jsp)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文介绍如何配置springmvc配置文件和web.xml，以及如何编写controller,jsp\r\n\r\n\r\n## springmvc.xml\r\n\r\n在`resources/spring`文件下下创建springmvc.xml文件，配置处理器映射器、适配器、视图解析器。\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\r\n\r\n   <!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    -->\r\n    <!-- 可以扫描controller、service、...\r\n	这里让扫描controller，指定controller的包\r\n	 -->\r\n    <context:component-scan base-package=\"com.iot.learnssm.firstssm.controller\"></context:component-scan>\r\n\r\n\r\n    <!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     -->\r\n    <mvc:annotation-driven></mvc:annotation-driven>\r\n\r\n    <!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- 配置jsp路径的前缀 -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n        <!-- 配置jsp路径的后缀 -->\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n## 配置web.xml\r\n\r\n\r\n参考入门程序，web.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\r\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\r\n         id=\"WebApp_ID\" version=\"3.0\">\r\n    <display-name>firstssm</display-name>\r\n\r\n    <!-- 加载spring容器 -->\r\n    <context-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>WEB-INF/classes/spring/applicationContext-*.xml</param-value>\r\n        <!--  <param-value>classpath:spring/applicationContext-*.xml</param-value>-->\r\n      </context-param>\r\n    <listener>\r\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n\r\n\r\n<!-- springmvc 前端控制器  -->\r\n    <servlet>\r\n        <servlet-name>springmvc</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n        <!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)\r\n          若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)\r\n        -->\r\n        <init-param>\r\n            <param-name>contextConfigLocation</param-name>\r\n            <param-value>classpath:spring/springmvc.xml</param-value>\r\n        </init-param>\r\n    </servlet>\r\n    \r\n    <servlet-mapping>\r\n        <servlet-name>springmvc</servlet-name>\r\n        <!--\r\n        第一种:*.action,访问以.action三结尾，由DispatcherServlet进行解析\r\n        第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，\r\n                使用此种方式和实现RESTful风格的url\r\n        第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，\r\n                不能根据jsp页面找到handler，会报错\r\n        -->\r\n        <url-pattern>*.action</url-pattern>\r\n    </servlet-mapping>\r\n\r\n\r\n    <welcome-file-list>\r\n        <welcome-file>index.html</welcome-file>\r\n        <welcome-file>index.htm</welcome-file>\r\n        <welcome-file>index.jsp</welcome-file>\r\n        <welcome-file>default.html</welcome-file>\r\n        <welcome-file>default.htm</welcome-file>\r\n        <welcome-file>default.jsp</welcome-file>\r\n    </welcome-file-list>\r\n</web-app>\r\n```\r\n\r\n这个文件有两个作用：\r\n\r\n- 配置前端控制器(`DispatcherServlet`)\r\n- 加载spring容器：添加spring容器监听器，加载spring容器，使用通配符加载`spring/`下的配置文件\r\n  - applicationContext-dao.xml\r\n  - applicationContext-service.xml\r\n  - applicationContext-transaction.xml\r\n\r\n\r\n\r\n## 编写Controller(就是Handler)\r\n\r\n\r\n```java\r\npackage com.iot.learnssm.firstssm.controller;\r\n\r\n\r\nimport com.iot.learnssm.firstssm.po.Items;\r\nimport com.iot.learnssm.firstssm.po.ItemsCustom;\r\nimport com.iot.learnssm.firstssm.service.ItemsService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by brian on 2016/3/2.\r\n */\r\n\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\npublic class ItemsController {\r\n\r\n    @Autowired\r\n    private ItemsService itemsService;\r\n\r\n    //商品查询列表\r\n    @RequestMapping(\"/queryItems\")\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表\r\n        List<ItemsCustom> itemsList = itemsService.findItemsList(null);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(\"itemsList\",itemsList);\r\n\r\n        //指定视图\r\n        //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n        //modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\r\n        //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\n        modelAndView.setViewName(\"items/itemsList\");\r\n\r\n        return modelAndView;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n## 编写jsp\r\n\r\n服务器路径为`WEB-INF/jsp/items/itemsList.jsp`\r\n\r\n```jsp\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n    pageEncoding=\"UTF-8\"%>\r\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\r\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\"  prefix=\"fmt\"%>\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\r\n<html>\r\n<head>\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n<title>查询商品列表</title>\r\n</head>\r\n<body> \r\n<form action=\"${pageContext.request.contextPath }/item/queryItem.action\" method=\"post\">\r\n查询条件：\r\n<table width=\"100%\" border=1>\r\n<tr>\r\n<td><input type=\"submit\" value=\"查询\"/></td>\r\n</tr>\r\n</table>\r\n商品列表：\r\n<table width=\"100%\" border=1>\r\n<tr>\r\n	<td>商品名称</td>\r\n	<td>商品价格</td>\r\n	<td>生产日期</td>\r\n	<td>商品描述</td>\r\n	<td>操作</td>\r\n</tr>\r\n<c:forEach items=\"${itemsList }\" var=\"item\">\r\n<tr>\r\n	<td>${item.name }</td>\r\n	<td>${item.price }</td>\r\n	<td><fmt:formatDate value=\"${item.createtime}\" pattern=\"yyyy-MM-dd HH:mm:ss\"/></td>\r\n	<td>${item.detail }</td>\r\n	\r\n	<td><a href=\"${pageContext.request.contextPath }/item/editItem.action?id=${item.id}\">修改</a></td>\r\n\r\n</tr>\r\n</c:forEach>\r\n\r\n</table>\r\n</form>\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (256, 'SpringMVC 注解开发之商品修改功能', 4, '# springmvc学习笔记(10)-springmvc注解开发之商品修改功能\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [需求](#需求)\r\n  - [开发mapper](#开发mapper)\r\n  - [开发service](#开发service)\r\n  - [开发controller](#开发Controller)\r\n  - [@RequestMapping](#@RequestMapping)\r\n  - [controller方法的返回值](#controller方法的返回值)\r\n\r\n\r\n\r\n---\r\n\r\n本文以商品修改为例，记录springmvc的注解开发，包括mapper,service,controller,@RequestMapping,controller方法的返回值等\r\n\r\n## 需求\r\n\r\n操作流程： \r\n\r\n- 1.进入商品查询列表页面\r\n- 2.点击修改，进入商品修改页面，页面中显示了要修改的商品。要修改的商品从数据库查询，根据商品id(主键)查询商品信息\r\n- 3.在商品修改页面，修改商品信息，修改后，点击提交\r\n\r\n## 开发mapper\r\n\r\nmapper：\r\n\r\n- 根据id查询商品信息\r\n- 根据id更新Items表的数据\r\n\r\n不用开发了，使用逆向工程生成的代码。\r\n\r\n## 开发service\r\n\r\n在`com.iot.learnssm.firstssm.service.ItemsService`中添加两个接口\r\n\r\n```java\r\n  //根据id查询商品信息\r\n    /**\r\n     *\r\n     * <p>Title: findItemsById</p>\r\n     * <p>Description: </p>\r\n     * @param id 查询商品的id\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n     ItemsCustom findItemsById(Integer id) throws Exception;\r\n\r\n    //修改商品信息\r\n    /**\r\n     *\r\n     * <p>Title: updateItems</p>\r\n     * <p>Description: </p>\r\n     * @param id 修改商品的id\r\n     * @param itemsCustom 修改的商品信息\r\n     * @throws Exception\r\n     */\r\n     void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception;\r\n\r\n```\r\n\r\n在`com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl`中实现接口，增加`itemsMapper`属性\r\n\r\n\r\n```java\r\n@Autowired\r\nprivate ItemsMapper itemsMapper;\r\n\r\npublic ItemsCustom findItemsById(Integer id) throws Exception {\r\n    Items items = itemsMapper.selectByPrimaryKey(id);\r\n    //中间对商品信息进行业务处理\r\n    //....\r\n    //返回ItemsCustom\r\n    ItemsCustom itemsCustom = new ItemsCustom();\r\n    //将items的属性值拷贝到itemsCustom\r\n    BeanUtils.copyProperties(items, itemsCustom);\r\n\r\n    return itemsCustom;\r\n}\r\n\r\npublic void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception {\r\n    //添加业务校验，通常在service接口对关键参数进行校验\r\n    //校验 id是否为空，如果为空抛出异常\r\n\r\n    //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括 大文本类型字段\r\n    //updateByPrimaryKeyWithBLOBs要求必须转入id\r\n    itemsCustom.setId(id);\r\n    itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);\r\n}\r\n```\r\n\r\n## 开发controller\r\n\r\n方法：\r\n\r\n- 商品信息修改页面显示\r\n- 商品信息修改提交\r\n\r\n```java\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\n//@RequestMapping(\"/items\")\r\npublic class ItemsController {\r\n\r\n    @Autowired\r\n    private ItemsService itemsService;\r\n\r\n    //商品查询列表\r\n    @RequestMapping(\"/queryItems\")\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表\r\n        List<ItemsCustom> itemsList = itemsService.findItemsList(null);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(\"itemsList\",itemsList);\r\n\r\n        //指定视图\r\n        //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n        //modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\r\n        //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\n        modelAndView.setViewName(\"items/itemsList\");\r\n\r\n        return modelAndView;\r\n    }\r\n\r\n\r\n    //商品信息修改页面显示\r\n    @RequestMapping(\"/editItems\")\r\n    //限制http请求方法，可以post和get\r\n	//@RequestMapping(value=\"/editItems\",method={RequestMethod.POST, RequestMethod.GET})\r\n	public ModelAndView editItems()throws Exception {\r\n\r\n		//调用service根据商品id查询商品信息\r\n		ItemsCustom itemsCustom = itemsService.findItemsById(1);\r\n\r\n		// 返回ModelAndView\r\n		ModelAndView modelAndView = new ModelAndView();\r\n\r\n		//将商品信息放到model\r\n		modelAndView.addObject(\"itemsCustom\", itemsCustom);\r\n\r\n		//商品修改页面\r\n		modelAndView.setViewName(\"items/editItems\");\r\n\r\n		return modelAndView;\r\n	}\r\n\r\n    //商品信息修改提交\r\n    @RequestMapping(\"/editItemsSubmit\")\r\n    public ModelAndView editItemsSubmit(HttpServletRequest request, Integer id, ItemsCustom itemsCustom)throws Exception {\r\n\r\n        //调用service更新商品信息，页面需要将商品信息传到此方法\r\n        itemsService.updateItems(id, itemsCustom);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //返回一个成功页面\r\n        modelAndView.setViewName(\"success\");\r\n        return modelAndView;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## @RequestMapping\r\n\r\n- url映射\r\n\r\n定义controller方法对应的url，进行处理器映射使用。\r\n\r\n\r\n- 窄化请求映射\r\n\r\n```java\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\n@RequestMapping(\"/items\")\r\npublic class ItemsController {\r\n```\r\n\r\n\r\n- 限制http请求方法\r\n\r\n出于安全性考虑，对http的链接进行方法限制。\r\n\r\n```java\r\n//商品信息修改页面显示\r\n    //@RequestMapping(\"/editItems\")\r\n    //限制http请求方法，可以post和get\r\n	@RequestMapping(value=\"/editItems\",method={RequestMethod.POST, RequestMethod.GET})\r\n	public ModelAndView editItems()throws Exception {\r\n```\r\n\r\n如果限制请求为post方法，进行get请求，即将上面代码的注解改为`@RequestMapping(value=\"/editItems\",method={RequestMethod.POST})`\r\n\r\n报错，状态码405：\r\n\r\n\r\n![GET拒绝](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E9%99%90%E5%88%B6http%E8%AF%B7%E6%B1%82-GET%E6%8B%92%E7%BB%9D.png)\r\n\r\n\r\n## controller方法的返回值\r\n\r\n- 返回`ModelAndView`\r\n\r\n需要方法结束时，定义ModelAndView，将model和view分别进行设置。\r\n\r\n\r\n- 返回string\r\n\r\n如果controller方法返回string\r\n\r\n1.表示返回逻辑视图名。\r\n\r\n真正视图(jsp路径)=前缀+逻辑视图名+后缀\r\n\r\n```java\r\n@RequestMapping(value=\"/editItems\",method={RequestMethod.POST,RequestMethod.GET})\r\n//@RequestParam里边指定request传入参数名称和形参进行绑定。\r\n//通过required属性指定参数是否必须要传入\r\n//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。\r\n//public String editItems(Model model, @RequestParam(value=\"id\",required=true) Integer items_id)throws Exception {\r\npublic String editItems(Model model)throws Exception {\r\n\r\n    //调用service根据商品id查询商品信息\r\n    ItemsCustom itemsCustom = itemsService.findItemsById(1);\r\n\r\n    //通过形参中的model将model数据传到页面\r\n    //相当于modelAndView.addObject方法\r\n    model.addAttribute(\"itemsCustom\", itemsCustom);\r\n\r\n    return \"items/editItems\";\r\n}\r\n```\r\n\r\n2.redirect重定向\r\n\r\n商品修改提交后，重定向到商品查询列表。\r\n\r\nredirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享）\r\n\r\n```java\r\n//重定向到商品查询列表\r\n//return \"redirect:queryItems.action\";\r\n```\r\n\r\n3.forward页面转发\r\n\r\n通过forward进行页面转发，浏览器地址栏url不变，request可以共享。\r\n\r\n```java\r\n//页面转发\r\nreturn \"forward:queryItems.action\";\r\n```\r\n\r\n\r\n\r\n- 返回void\r\n\r\n在controller方法形参上可以定义request和response，使用request或response指定响应结果：\r\n\r\n1.使用request转向页面，如下：\r\n\r\n`request.getRequestDispatcher(\"页面路径\").forward(request, response);`\r\n\r\n2.也可以通过response页面重定向：\r\n\r\n`response.sendRedirect(\"url\")`\r\n\r\n3.也可以通过response指定响应结果，例如响应json数据如下：\r\n\r\n```java\r\nresponse.setCharacterEncoding(\"utf-8\");\r\nresponse.setContentType(\"application/json;charset=utf-8\");\r\nresponse.getWriter().write(\"json串\");\r\n```\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (257, 'SpringMVC 注解开发之简单参数绑定', 4, '# springmvc学习笔记(11)-springmvc注解开发之简单参数绑定\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [spring参数绑定过程](#spring参数绑定过程)\r\n  - [默认支持的类型](#默认支持的类型)\r\n  - [简单类型](#简单类型)\r\n  - [pojo绑定](#pojo绑定)\r\n  - [自定义参数绑定实现日期类型绑定](#自定义参数绑定实现日期类型绑定)\r\n  - [springmvc和struts2的区别](#springmvc和struts2的区别)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文主要介绍注解开发的简单参数绑定，包括简单类型、简单pojo以及自定义绑定实现类型转换\r\n\r\n## spring参数绑定过程\r\n\r\n从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。\r\n\r\nspringmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变更接收！！！！\r\n\r\n![参数绑定过程](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B.png)\r\n\r\n\r\n## 默认支持的类型\r\n\r\n直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。\r\n\r\n- `HttpServletRequest`：通过request对象获取请求信息\r\n- `HttpServletResponse`：通过response处理响应信息\r\n- `HttpSession`：通过session对象得到session中存放的对象\r\n- `Model/ModelMap`：model是一个接口，modelMap是一个接口实现。作用：将model数据填充到request域。\r\n\r\n\r\n## 简单类型\r\n\r\n通过`@RequestParam`对简单类型的参数进行绑定。如果不使用`@RequestParam`，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。\r\n\r\n如果使用`@RequestParam`，不用限制request传入参数名称和controller方法的形参名称一致。\r\n\r\n通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，报下边错误：\r\n\r\n![指定传入参数未传入报错](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%8C%87%E5%AE%9A%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E6%9C%AA%E4%BC%A0%E5%85%A5%E6%8A%A5%E9%94%99.png)\r\n\r\n\r\n```java\r\n@RequestMapping(value=\"/editItems\",method={RequestMethod.POST,RequestMethod.GET})\r\n//@RequestParam里边指定request传入参数名称和形参进行绑定。\r\n//通过required属性指定参数是否必须要传入\r\n//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。\r\npublic String editItems(Model model,@RequestParam(value=\"id\",required=true) Integer items_id)throws Exception {\r\n\r\n```\r\n\r\n\r\n## pojo绑定\r\n\r\n页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo。\r\n\r\n注意:这里只是要求name和形参的**属性名**一致，而不是要求和形参的**名称**一致，这点不要混淆了，框架会进入形参内部自动匹配pojo类的属性名。(我没看源码，但应该是用反射实现的)\r\n\r\n\r\n\r\n页面定义：\r\n\r\n```jsp\r\n<table width=\"100%\" border=1>\r\n<tr>\r\n	<td>商品名称</td>\r\n	<td><input type=\"text\" name=\"name\" value=\"${itemsCustom.name }\"/></td>\r\n</tr>\r\n<tr>\r\n	<td>商品价格</td>\r\n	<td><input type=\"text\" name=\"price\" value=\"${itemsCustom.price }\"/></td>\r\n</tr>\r\n```\r\n\r\ncontroller的pojo形参的定义：\r\n\r\n```java\r\npublic class Items {\r\n    private Integer id;\r\n\r\n    private String name;\r\n\r\n    private Float price;\r\n\r\n    private String pic;\r\n\r\n    private Date createtime;\r\n\r\n    private String detail;\r\n```\r\n\r\n\r\n## 自定义参数绑定实现日期类型绑定\r\n\r\n对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。\r\n\r\n将请求日期数据串传成日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。本文示例中，自定义参数绑定将日期串转成java.util.Date类型。\r\n\r\n需要向处理器适配器中注入自定义的参数绑定组件。\r\n\r\n\r\n- 自定义日期类型绑定\r\n\r\n```java\r\npublic class CustomDateConverter implements Converter<String,Date>{\r\n    public Date convert(String s) {\r\n        //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss)\r\n\r\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n        try {\r\n            //转成直接返回\r\n            return simpleDateFormat.parse(s);\r\n        } catch (ParseException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        }\r\n        //如果参数绑定失败返回null\r\n        return null;\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n- 配置方式\r\n\r\n```xml\r\n<mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\r\n```\r\n\r\n```xml\r\n<!-- 自定义参数绑定 -->\r\n    <bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\r\n        <!-- 转换器 -->\r\n        <property name=\"converters\">\r\n            <list>\r\n                <!-- 日期类型转换 -->\r\n                <bean class=\"com.iot.learnssm.firstssm.controller.converter.CustomDateConverter\"/>\r\n           </list>\r\n        </property>\r\n    </bean>\r\n```\r\n\r\n\r\n## springmvc和struts2的区别 \r\n\r\n- 1.springmvc基于方法开发的，struts2基于类开发的。\r\n\r\nspringmvc将url和controller方法映射。映射成功后springmvc生成一个Handler对象，对象中只包括了一个method。方法执行结束，形参数据销毁。springmvc的controller开发类似service开发。\r\n\r\n- 2.springmvc可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例。\r\n\r\n- 3.经过实际测试，struts2速度慢，在于使用struts标签，如果使用struts建议使用jstl。\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (258, 'SpringMVC 注解开发之包装类型参数绑定', 4, '# springmvc学习笔记(12)-springmvc注解开发之包装类型参数绑定\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [需求](#需求)\r\n  - [实现方法](#实现方法)\r\n  - [页面参数和controller方法形参定义](#页面参数和controller方法形参定义)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要介绍注解开发的介绍包装类型的参数绑定\r\n\r\n\r\n## 需求\r\n\r\n商品查询controller方法中实现商品查询条件传入。\r\n\r\n## 实现方法\r\n\r\n- 第一种方法：在形参中添加`HttpServletRequest request`参数，通过request接收查询条件参数。\r\n- 第二种方法：在形参中让包装类型的pojo接收查询条件参数。\r\n\r\n分析：\r\n\r\n页面传参数的特点：复杂，多样性。条件包括：用户账号、商品编号、订单信息。。。\r\n\r\n如果将用户账号、商品编号、订单信息等放在简单pojo（属性是简单类型）中，pojo类属性比较多，比较乱。建议使用包装类型的pojo，pojo中属性是pojo。\r\n\r\n## 页面参数和controller方法形参定义\r\n\r\n- 页面参数：\r\n\r\n商品名称：`<input name=\"itemsCustom.name\" />`\r\n\r\n**注意：itemsCustom和包装pojo中的属性名一致即可。**\r\n\r\n\r\n- controller方法形参：\r\n\r\n`public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception`\r\n\r\n- 包装类ItemsQueryVo中部分属性：\r\n\r\n```java\r\npublic class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n```\r\n\r\n可见，`ItemsQueryVo`中属性`itemsCustom`和页面参数中一致\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (259, 'SpringMVC 注解开发之集合类型参数绑定', 4, '# springmvc学习笔记(13)-springmvc注解开发之集合类型参数绑定\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [数组绑定](#数组绑定)\r\n    - [需求](#需求)\r\n    - [表现层实现](#表现层实现)\r\n  - [list绑定](#list绑定)\r\n    - [需求](#需求)\r\n    - [表现层实现](#表现层实现)\r\n  - [map绑定](#map绑定)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文主要介绍注解开发的集合类型参数绑定，包括数组绑定，list绑定以及map绑定\r\n\r\n## 数组绑定\r\n\r\n### 需求\r\n\r\n商品批量删除，用户在页面选择多个商品，批量删除。\r\n\r\n### 表现层实现\r\n\r\n关键：将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。\r\n\r\n- controller方法定义：\r\n\r\n```java\r\n// 批量删除 商品信息\r\n@RequestMapping(\"/deleteItems\")\r\npublic String deleteItems(Integer[] items_id) throws Exception\r\n```\r\n\r\n- 页面定义：\r\n\r\n```jsp\r\n<c:forEach items=\"${itemsList }\" var=\"item\">\r\n<tr>\r\n    <td><input type=\"checkbox\" name=\"items_id\" value=\"${item.id}\"/></td>\r\n	<td>${item.name }</td>\r\n	<td>${item.price }</td>\r\n	<td><fmt:formatDate value=\"${item.createtime}\" pattern=\"yyyy-MM-dd HH:mm:ss\"/></td>\r\n	<td>${item.detail }</td>\r\n	\r\n	<td><a href=\"${pageContext.request.contextPath }/items/editItems.action?id=${item.id}\">修改</a></td>\r\n\r\n</tr>\r\n</c:forEach>\r\n```\r\n\r\n\r\n\r\n## list绑定\r\n\r\n### 需求\r\n\r\n通常在需要批量提交数据时，将提交的数据绑定到`list<pojo>`中，比如：成绩录入（录入多门课成绩，批量提交），\r\n\r\n本例子需求：批量商品修改，在页面输入多个商品信息，将多个商品信息提交到controller方法中。\r\n\r\n### 表现层实现\r\n\r\n- controller方法定义：\r\n   - 1、进入批量商品修改页面(页面样式参考商品列表实现)\r\n   - 2、批量修改商品提交\r\n\r\n使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义`list<pojo>`属性\r\n\r\n```java\r\npublic class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n\r\n    //批量商品信息\r\n    private List<ItemsCustom> itemsList;\r\n```\r\n\r\n\r\n```java\r\n// 批量修改商品提交\r\n// 通过ItemsQueryVo接收批量提交的商品信息，将商品信息存储到itemsQueryVo中itemsList属性中。\r\n@RequestMapping(\"/editItemsAllSubmit\")\r\npublic String editItemsAllSubmit(ItemsQueryVo itemsQueryVo) throws Exception {\r\n\r\n    return \"success\";\r\n}\r\n```\r\n\r\n- 页面定义：\r\n\r\n```jsp\r\n<c:forEach items=\"${itemsList }\" var=\"item\" varStatus=\"status\">\r\n    <tr>\r\n\r\n        <td><input name=\"itemsList[${status.index }].name\" value=\"${item.name }\"/></td>\r\n        <td><input name=\"itemsList[${status.index }].price\" value=\"${item.price }\"/></td>\r\n        <td><input name=\"itemsList[${status.index }].createtime\" value=\"<fmt:formatDate value=\"${item.createtime}\" pattern=\"yyyy-MM-dd HH:mm:ss\"/>\"/></td>\r\n        <td><input name=\"itemsList[${status.index }].detail\" value=\"${item.detail }\"/></td>\r\n\r\n    </tr>\r\n</c:forEach>\r\n```\r\n\r\nname的格式：\r\n\r\n**`对应包装pojo中的list类型属性名`[`下标(从0开始)`].`包装pojo中List类型的属性中pojo的属性名`**\r\n\r\n例子：\r\n\r\n`\"name=\"itemsList[${status.index }].price\"`\r\n\r\n\r\n*可以和包装类型的参数绑定归纳对比一下，其实就是在包装类的pojo基础上多了个下标。只不过包装类参数绑定时，要和包装pojo中的pojo类性的属性名一致，而list参数绑定时，要和包装pojo中的list类型的属性名一致。*\r\n\r\n\r\n## map绑定\r\n\r\n也通过在包装pojo中定义map类型属性。\r\n\r\n在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。\r\n\r\n- 包装类中定义Map对象如下：\r\n\r\n```java\r\nPublic class QueryVo {\r\nprivate Map<String, Object> itemInfo = new HashMap<String, Object>();\r\n  //get/set方法..\r\n}\r\n```\r\n\r\n- 页面定义如下：\r\n\r\n```java\r\n<tr>\r\n<td>学生信息：</td>\r\n<td>\r\n姓名：<inputtype=\"text\"name=\"itemInfo[\'name\']\"/>\r\n年龄：<inputtype=\"text\"name=\"itemInfo[\'price\']\"/>\r\n.. .. ..\r\n</td>\r\n</tr>\r\n```\r\n\r\n\r\n\r\n- Contrller方法定义如下：\r\n\r\n```java\r\npublic String useraddsubmit(Model model,QueryVo queryVo)throws Exception{\r\nSystem.out.println(queryVo.getStudentinfo());\r\n}\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (260, 'SpringMVC 校验', 4, '# springmvc学习笔记(14)-springmvc校验\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [校验理解](#校验理解)\r\n  - [springmvc校验需求](#springmvc校验需求)\r\n  - [环境准备](#环境准备)\r\n  - [配置校验器](#配置校验器)\r\n- [添加校验的错误提示信息](#添加校验的错误提示信息)\r\n  - [在pojo中添加校验规则](#在pojo中添加校验规则)\r\n  - [捕获和显示校验错误信息](#捕获和显示校验错误信息)\r\n  - [分组校验](#分组校验)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文主要介绍springmvc校验，包括环境准备，校验器配置，pojo张添加校验规则，捕获和显示检验错误信息以及分组校验简单示例。\r\n\r\n\r\n## 校验理解\r\n\r\n项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。\r\n\r\n服务端校验：\r\n\r\n- 控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用）\r\n- 业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。\r\n- 持久层dao：一般是不校验的。\r\n\r\n## springmvc校验需求\r\n\r\nspringmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。\r\n\r\n校验思路：\r\n\r\n页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面。\r\n\r\n具体需求：\r\n\r\n商品修改，添加校验（校验商品名称长度，生产日期的非空校验），如果校验出错，在商品修改页面显示错误信息。\r\n\r\n\r\n## 环境准备\r\n\r\n我们需要三个jar包：\r\n\r\n- hibernate-validator.jar\r\n- jboss-logging.jar\r\n- validation-api.jar\r\n\r\n这里我们添加maven依赖\r\n\r\n```xml\r\n<!-- hibernate 校验 -->\r\n<dependency>\r\n    <groupId>org.hibernate</groupId>\r\n    <artifactId>hibernate-validator</artifactId>\r\n    <version>5.2.4.Final</version>\r\n</dependency>\r\n```\r\n\r\n查看maven依赖树\r\n\r\n```\r\n[INFO] \\- org.hibernate:hibernate-validator:jar:5.2.4.Final:compile\r\n[INFO]    +- javax.validation:validation-api:jar:1.1.0.Final:compile\r\n[INFO]    +- org.jboss.logging:jboss-logging:jar:3.2.1.Final:compile\r\n[INFO]    \\- com.fasterxml:classmate:jar:1.1.0:compile\r\n```\r\n\r\n可以看到，另外两个jar包被`hibernate-validator`依赖，所以不用再额外添加了。\r\n\r\n\r\n## 配置校验器\r\n\r\n\r\n- 在springmvc.xml中添加\r\n\r\n```xml\r\n<!-- 校验器 -->\r\n<bean id=\"validator\"\r\n      class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\">\r\n    <!-- hibernate校验器-->\r\n    <property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\" />\r\n    <!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties -->\r\n    <property name=\"validationMessageSource\" ref=\"messageSource\" />\r\n</bean>\r\n<!-- 校验错误信息配置文件 -->\r\n<bean id=\"messageSource\"\r\n      class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\">\r\n    <!-- 资源文件名-->\r\n    <property name=\"basenames\">\r\n        <list>\r\n            <value>classpath:CustomValidationMessages</value>\r\n        </list>\r\n    </property>\r\n    <!-- 资源文件编码格式 -->\r\n    <property name=\"fileEncodings\" value=\"utf-8\" />\r\n    <!-- 对资源文件内容缓存时间，单位秒 -->\r\n    <property name=\"cacheSeconds\" value=\"120\" />\r\n</bean>\r\n```\r\n\r\n- 校验器注入到处理器适配器中\r\n\r\n```xml\r\n<mvc:annotation-driven conversion-service=\"conversionService\"\r\n                       validator=\"validator\">\r\n</mvc:annotation-driven>\r\n```\r\n\r\n- 在CustomValidationMessages.properties配置校验错误信息：\r\n\r\n```\r\n#添加校验的错误提示信息\r\nitems.name.length.error=请输入1到30个字符的商品名称\r\nitems.createtime.isNUll=请输入商品的生产日期\r\n```\r\n\r\n\r\n## 在pojo中添加校验规则\r\n\r\n在ItemsCustom.java中添加校验规则：\r\n\r\n\r\n```java\r\npublic class Items {\r\n    private Integer id;\r\n    //校验名称在1到30字符中间\r\n    //message是提示校验出错显示的信息\r\n    //groups：此校验属于哪个分组，groups可以定义多个分组\r\n    @Size(min=1,max=30,message=\"{items.name.length.error}\")\r\n    private String name;\r\n\r\n    private Float price;\r\n\r\n    private String pic;\r\n\r\n    //非空校验\r\n    @NotNull(message=\"{items.createtime.isNUll}\")\r\n    private Date createtime;\r\n```\r\n\r\n\r\n## 捕获和显示校验错误信息\r\n\r\n```java\r\n@RequestMapping(\"/editItemsSubmit\")\r\npublic String editItemsSubmit(\r\n        Model model,\r\n        HttpServletRequest request,\r\n        Integer id,\r\n        @Validated ItemsCustom itemsCustom,\r\n        BindingResult bindingResult)throws Exception {\r\n```\r\n\r\n- 在controller中将错误信息传到页面即可\r\n\r\n```\r\n//获取校验错误信息\r\nif(bindingResult.hasErrors()){\r\n    // 输出错误信息\r\n    List<ObjectError> allErrors = bindingResult.getAllErrors();\r\n\r\n    for (ObjectError objectError :allErrors){\r\n        // 输出错误信息\r\n        System.out.println(objectError.getDefaultMessage());\r\n    }\r\n    // 将错误信息传到页面\r\n    model.addAttribute(\"allErrors\", allErrors);\r\n\r\n    //可以直接使用model将提交pojo回显到页面\r\n    model.addAttribute(\"items\", itemsCustom);\r\n\r\n    // 出错重新到商品修改页面\r\n    return \"items/editItems\";\r\n}\r\n```\r\n\r\n- 页面显示错误信息：\r\n\r\n```jsp\r\n<!-- 显示错误信息 -->\r\n<c:if test=\"${allErrors!=null }\">\r\n	<c:forEach items=\"${allErrors }\" var=\"error\">\r\n		${ error.defaultMessage}<br/>\r\n	</c:forEach>\r\n</c:if>\r\n```\r\n\r\n## 分组校验\r\n\r\n- 需求：\r\n   - 在pojo中定义校验规则，而pojo是被多个controller所共用，当不同的controller方法对同一个pojo进行校验，但是每个controller方法需要不同的校验\r\n- 解决方法：\r\n   - 定义多个校验分组（其实是一个java接口），分组中定义有哪些规则\r\n   - 每个controller方法使用不同的校验分组\r\n\r\n\r\n   \r\n\r\n1.校验分组\r\n\r\n```java\r\npublic interface ValidGroup1 {\r\n	//接口中不需要定义任何方法，仅是对不同的校验规则进行分组\r\n	//此分组只校验商品名称长度\r\n\r\n}\r\n```\r\n\r\n\r\n2.在校验规则中添加分组\r\n\r\n```java\r\n//校验名称在1到30字符中间\r\n//message是提示校验出错显示的信息\r\n//groups：此校验属于哪个分组，groups可以定义多个分组\r\n@Size(min=1,max=30,message=\"{items.name.length.error}\",groups = {ValidGroup1.class})\r\nprivate String name;\r\n```\r\n\r\n3.在controller方法使用指定分组的校验\r\n\r\n```java\r\n// value={ValidGroup1.class}指定使用ValidGroup1分组的校验\r\n@RequestMapping(\"/editItemsSubmit\")\r\npublic String editItemsSubmit(\r\n        Model model,\r\n        HttpServletRequest request,\r\n        Integer id,\r\n        @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,\r\n        BindingResult bindingResult)throws Exception {\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (261, 'SpringMVC 数据回显', 4, '# springmvc学习笔记(15)-数据回显\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [pojo数据回显方法](#pojo数据回显方法)\r\n  - [简单类型数据回显](#简单类型数据回显)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n本文介绍springmvc中数据回显的几种实现方法\r\n\r\n\r\n数据回显：提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。\r\n\r\n\r\n## pojo数据回显方法\r\n\r\n1.springmvc默认对pojo数据进行回显。\r\n\r\n**pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）**\r\n\r\n使用`@ModelAttribute`指定pojo回显到页面在request中的key\r\n\r\n2.`@ModelAttribute`还可以将方法的返回值传到页面\r\n\r\n在商品查询列表页面，通过商品类型查询商品信息。在controller中定义商品类型查询方法，最终将商品类型传到页面。\r\n\r\n```java\r\n // 商品分类\r\n//itemtypes表示最终将方法返回值放在request中的key\r\n@ModelAttribute(\"itemtypes\")\r\npublic Map<String, String> getItemTypes() {\r\n\r\n    Map<String, String> itemTypes = new HashMap<String, String>();\r\n    itemTypes.put(\"101\", \"数码\");\r\n    itemTypes.put(\"102\", \"母婴\");\r\n\r\n    return itemTypes;\r\n}\r\n```\r\n\r\n页面上可以得到itemTypes数据。\r\n\r\n\r\n```jsp\r\n<td>\r\n    商品名称：<input name=\"itemsCustom.name\" />\r\n    商品类型：\r\n    <select name=\"itemtype\">\r\n        <c:forEach items=\"${itemtypes}\" var=\"itemtype\">\r\n            <option value=\"${itemtype.key }\">${itemtype.value }</option>\r\n        </c:forEach>\r\n    </select>\r\n</td>\r\n```\r\n\r\n3.使用最简单方法使用model，可以不用`@ModelAttribute`\r\n\r\n```java\r\n//可以直接使用model将提交pojo回显到页面\r\n//model.addAttribute(\"items\", itemsCustom);\r\n```\r\n\r\n\r\n## 简单类型数据回显\r\n\r\n使用最简单方法使用model\r\n\r\n`model.addAttribute(\"id\", id);`\r\n\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (262, 'SpringMVC 异常处理器', 4, '# springmvc学习笔记(16)-异常处理器\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [异常处理思路](#异常处理思路)\r\n  - [自定义异常类](#自定义异常类)\r\n  - [全局异常处理器](#全局异常处理器)\r\n  - [错误页面](#错误页面)\r\n  - [在springmvc.xml配置全局异常处理器](#在springmvc.xml配置全局异常处理器)\r\n  - [异常测试](#异常测试)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文主要介绍springmvc中异常处理的思路，并展示如何自定义异常处理类以及全局异常处理器的配置\r\n\r\n\r\n## 异常处理思路\r\n\r\n系统中异常包括两类：\r\n\r\n- 预期异常\r\n- 运行时异常RuntimeException\r\n\r\n前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。\r\n\r\n系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图：\r\n\r\n![springmvc异常处理](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png)\r\n\r\nspringmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。\r\n\r\n\r\n## 自定义异常类\r\n\r\n对不同的异常类型定义异常类，继承Exception。\r\n\r\n```java\r\npackage com.iot.learnssm.firstssm.exception;\r\n\r\n/**\r\n * Created by brian on 2016/3/7.\r\n *\r\n * 系统 自定义异常类，针对预期的异常，需要在程序中抛出此类的异常\r\n */\r\npublic class CustomException  extends  Exception{\r\n    //异常信息\r\n    public String message;\r\n\r\n    public CustomException(String message){\r\n        super(message);\r\n        this.message = message;\r\n    }\r\n\r\n    public String getMessage() {\r\n        return message;\r\n    }\r\n\r\n    public void setMessage(String message) {\r\n        this.message = message;\r\n    }\r\n}\r\n```\r\n\r\n## 全局异常处理器\r\n\r\n思路：\r\n\r\n系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。\r\n\r\n全局异常处理器处理思路：\r\n\r\n解析出异常类型\r\n\r\n- 如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示\r\n- 如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）\r\n\r\nspringmvc提供一个`HandlerExceptionResolver`接口\r\n\r\n\r\n```java\r\n   public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {\r\n        //handler就是处理器适配器要执行Handler对象（只有method）\r\n        //解析出异常类型\r\n        //如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示\r\n        //String message = null;\r\n        //if(ex instanceof CustomException){\r\n			//message = ((CustomException)ex).getMessage();\r\n        //}else{\r\n			////如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）\r\n			//message=\"未知错误\";\r\n        //}\r\n\r\n        //上边代码变为\r\n        CustomException customException;\r\n        if(ex instanceof CustomException){\r\n            customException = (CustomException)ex;\r\n        }else{\r\n            customException = new CustomException(\"未知错误\");\r\n        }\r\n\r\n        //错误信息\r\n        String message = customException.getMessage();\r\n\r\n        ModelAndView modelAndView = new ModelAndView();\r\n\r\n        //将错误信息传到页面\r\n        modelAndView.addObject(\"message\", message);\r\n\r\n        //指向错误页面\r\n        modelAndView.setViewName(\"error\");\r\n\r\n        return modelAndView;\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 错误页面\r\n\r\n```jsp\r\n<%--\r\n  Created by IntelliJ IDEA.\r\n  User: Brian\r\n  Date: 2016/3/4\r\n  Time: 10:51\r\n  To change this template use File | Settings | File Templates.\r\n--%>\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>错误提示</title>\r\n</head>\r\n<body>\r\n${message}\r\n</body>\r\n</html>\r\n```\r\n\r\n## 在springmvc.xml配置全局异常处理器\r\n\r\n```xml\r\n<!-- 全局异常处理器\r\n只要实现HandlerExceptionResolver接口就是全局异常处理器\r\n-->\r\n<bean class=\"com.iot.learnssm.firstssm.exception.CustomExceptionResolver\"></bean>\r\n```\r\n\r\n全局异常处理器只有一个，配置多个也没用。\r\n\r\n\r\n\r\n## 异常测试\r\n\r\n在controller、service、dao中任意一处需要手动抛出异常。如果是程序中手动抛出的异常，在错误页面中显示自定义的异常信息，如果不是手动抛出异常说明是一个运行时异常，在错误页面只显示“未知错误”。\r\n\r\n- 在商品修改的controller方法中抛出异常 .\r\n\r\n```java\r\npublic String editItems(Model model,@RequestParam(value=\"id\",required=true) Integer items_id)throws Exception {\r\n\r\n    //调用service根据商品id查询商品信息\r\n    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);\r\n\r\n    //判断商品是否为空，根据id没有查询到商品，抛出异常，提示用户商品信息不存在\r\n    if(itemsCustom == null){\r\n		throw new CustomException(\"修改的商品信息不存在!\");\r\n    }\r\n\r\n    //通过形参中的model将model数据传到页面\r\n    //相当于modelAndView.addObject方法\r\n    model.addAttribute(\"items\", itemsCustom);\r\n\r\n    return \"items/editItems\";\r\n}\r\n```\r\n\r\n- 在service接口中抛出异常：\r\n\r\n```java\r\npublic ItemsCustom findItemsById(Integer id) throws Exception {\r\n    Items items = itemsMapper.selectByPrimaryKey(id);\r\n    if(items==null){\r\n        throw new CustomException(\"修改的商品信息不存在!\");\r\n    }\r\n    //中间对商品信息进行业务处理\r\n    //....\r\n    //返回ItemsCustom\r\n    ItemsCustom itemsCustom = null;\r\n    //将items的属性值拷贝到itemsCustom\r\n    if(items!=null){\r\n        itemsCustom = new ItemsCustom();\r\n        BeanUtils.copyProperties(items, itemsCustom);\r\n    }\r\n\r\n    return itemsCustom;\r\n}\r\n```\r\n\r\n\r\n- 如果与业务功能相关的异常，建议在service中抛出异常。\r\n- 与业务功能没有关系的异常，建议在controller中抛出。\r\n\r\n上边的功能，建议在service中抛出异常。\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (263, 'SpringMVC 上传图片', 4, '# springmvc学习笔记(17)-上传图片\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [springmvc中对多部件类型解析](#springmvc中对多部件类型解析)\r\n  - [加入上传图片的jar](#加入上传图片的jar)\r\n  - [创建图片虚拟目录存储图片](#创建图片虚拟目录存储图片)\r\n  - [上传图片代码](#上传图片代码)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文展示如何在springmvc中上传图片\r\n\r\n\r\n## springmvc中对多部件类型解析\r\n\r\n在修改商品页面，添加上传商品图片功能。\r\n\r\n在页面form中提交`enctype=\"multipart/form-data\"`的数据时，需要springmvc对multipart类型的数据进行解析。\r\n\r\n在springmvc.xml中配置multipart类型解析器。\r\n\r\n```xml\r\n<!-- 文件上传 -->\r\n<bean id=\"multipartResolver\"\r\n      class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\r\n    <!-- 设置上传文件的最大尺寸为5MB -->\r\n    <property name=\"maxUploadSize\">\r\n        <value>5242880</value>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n## 加入上传图片的jar\r\n\r\n添加依赖\r\n\r\n```xml\r\n<!-- 文件上传 -->\r\n<dependency>\r\n    <groupId>commons-fileupload</groupId>\r\n    <artifactId>commons-fileupload</artifactId>\r\n    <version>1.3.1</version>\r\n</dependency>\r\n```\r\n\r\n依赖树\r\n\r\n```\r\n[INFO] \\- commons-fileupload:commons-fileupload:jar:1.3.1:compile\r\n[INFO]    \\- commons-io:commons-io:jar:2.2:compile\r\n```\r\n\r\n可以看到，其实还间接依赖了`commons-io:commons-io:jar`\r\n\r\n\r\n## 创建图片虚拟目录存储图片\r\n\r\n参考我之前的博文\r\n\r\n> [在intellij IDEA中为web应用创建图片虚拟目录(详细截图)](http://blog.csdn.net/h3243212/article/details/50819218)\r\n\r\n\r\n也可以直接修改tomcat的配置,在conf/server.xml文件，添加虚拟目录.\r\n\r\n注意：在图片虚拟目录中，一定将图片目录分级创建（提高i/o性能），一般我们采用按日期(年、月、日)进行分级创建。\r\n\r\n## 上传图片代码\r\n\r\n- 页面\r\n\r\n```jsp\r\n<tr>\r\n	<td>商品图片</td>\r\n	<td>\r\n		<c:if test=\"${items.pic !=null}\">\r\n			<img src=\"/pic/${items.pic}\" width=100 height=100/>\r\n			<br/>\r\n		</c:if>\r\n		<input type=\"file\"  name=\"items_pic\"/>\r\n	</td>\r\n</tr>\r\n```\r\n\r\n- controller方法\r\n\r\n修改：商品修改controller方法：\r\n\r\n```java\r\n@RequestMapping(\"/editItemsSubmit\")\r\n    public String editItemsSubmit(\r\n            Model model,\r\n            HttpServletRequest request,\r\n            Integer id,\r\n            @ModelAttribute(\"items\")\r\n            @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,\r\n            BindingResult bindingResult,\r\n            MultipartFile items_pic\r\n    )throws Exception {\r\n```\r\n\r\n```java\r\n //原始名称\r\nString originalFilename = items_pic.getOriginalFilename();\r\n//上传图片\r\nif(items_pic!=null && originalFilename!=null && originalFilename.length()>0){\r\n\r\n    //存储图片的物理路径\r\n    String pic_path = \"D:\\\\tmp\\\\\";\r\n\r\n\r\n    //新的图片名称\r\n    String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(\".\"));\r\n    //新图片\r\n    File newFile = new File(pic_path+newFileName);\r\n\r\n    //将内存中的数据写入磁盘\r\n    items_pic.transferTo(newFile);\r\n\r\n    //将新图片名称写到itemsCustom中\r\n    itemsCustom.setPic(newFileName);\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (264, 'SpringMVC json数据交互', 4, '# springmvc学习笔记(18)-json数据交互\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [springmvc进行json交互](#springmvc进行json交互)\r\n  - [环境准备](#环境准备)\r\n    - [添加json转换的依赖](#添加json转换的依赖)\r\n    - [配置json转换器](#配置json转换器)\r\n  - [json交互测试](#json交互测试)\r\n    - [输入json串，输出是json串](#输入json串，输出是json串)\r\n    - [输入key/value，输出是json串](#输入key/value，输出是json串)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n本文主要介绍如何在springmvc中进行json数据的交互，先是环境准备和配置，然后分别展示了“输入json串，输出是json串”和“输入key/value，输出是json串”两种情况下的交互\r\n\r\n\r\n## springmvc进行json交互\r\n\r\njson数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。\r\n\r\n比如：webservice接口，传输json数据.\r\n\r\n![json交互](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json%E4%BA%A4%E4%BA%92.png)\r\n\r\n- 请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。\r\n- 请求key/value、输出json。此方法比较常用。\r\n\r\n## 环境准备\r\n\r\n### 添加json转换的依赖\r\n\r\n最开始我少了`jackson-databind`依赖，程序各种报错。\r\n\r\n```xml\r\n\r\n<!-- json 转换-->\r\n<dependency>\r\n    <groupId>com.fasterxml.jackson.core</groupId>\r\n    <artifactId>jackson-databind</artifactId>\r\n    <version>2.7.2</version>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>org.codehaus.jackson</groupId>\r\n    <artifactId>jackson-mapper-asl</artifactId>\r\n    <version>1.9.13</version>\r\n</dependency>\r\n```\r\n\r\n查看依赖树\r\n\r\n```\r\n[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.7.2:compile\r\n[INFO] |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.7.0:compile\r\n[INFO] |  \\- com.fasterxml.jackson.core:jackson-core:jar:2.7.2:compile\r\n[INFO] \\- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile\r\n[INFO]    \\- org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile\r\n```\r\n\r\n\r\n### 配置json转换器\r\n\r\n在注解适配器中加入`messageConverters`\r\n\r\n```xml\r\n\r\n<!--注解适配器 -->\r\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\r\n	<property name=\"messageConverters\">\r\n	<list>\r\n	<bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"></bean>\r\n	</list>\r\n	</property>\r\n</bean>\r\n```\r\n\r\n**注意：如果使用`<mvc:annotation-driven />`则不用定义上边的内容。**\r\n\r\n## json交互测试\r\n\r\n显示两个按钮分别测试\r\n\r\n- jsp页面\r\n\r\n```jsp\r\n<%--\r\n  Created by IntelliJ IDEA.\r\n  User: brian\r\n  Date: 2016/3/7\r\n  Time: 20:49\r\n  To change this template use File | Settings | File Templates.\r\n--%>\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n    <title>json交互测试</title>\r\n    <script type=\"text/javascript\" src=\"${pageContext.request.contextPath }/js/jquery-1.4.4.min.js\"></script>\r\n    <script type=\"text/javascript\">\r\n        //请求json，输出是json\r\n        function requestJson(){     省略    }\r\n        //请求key/value，输出是json\r\n        function responseJson(){    省略    }\r\n    </script>\r\n</head>\r\n<body>\r\n<input type=\"button\" onclick=\"requestJson()\" value=\"请求json，输出是json\"/>\r\n<input type=\"button\" onclick=\"responseJson()\" value=\"请求key/value，输出是json\"/>\r\n</body>\r\n\r\n```\r\n\r\n- controller\r\n\r\n\r\n```java\r\n@Controller\r\npublic class JsonTest {\r\n    省略\r\n}\r\n```\r\n\r\n- 测试结果\r\n\r\n\r\n### 输入json串，输出是json串\r\n\r\n使用jquery的ajax提交json串，对输出的json结果进行解析。\r\n\r\n- jsp页面\r\n\r\n```jsp\r\n//请求json，输出是json\r\nfunction requestJson(){\r\n\r\n    $.ajax({\r\n        type:\'post\',\r\n        url:\'${pageContext.request.contextPath }/requestJson.action\',\r\n        contentType:\'application/json;charset=utf-8\',\r\n        //数据格式是json串，商品信息\r\n        data:\'{\"name\":\"手机\",\"price\":999}\',\r\n        success:function(data){//返回json结果\r\n            alert(data);\r\n        }\r\n\r\n    });\r\n\r\n}\r\n```\r\n\r\n- controller\r\n\r\n```java\r\n //请求json串(商品信息)，输出json(商品信息)\r\n//@RequestBody将请求的商品信息的json串转成itemsCustom对象\r\n//@ResponseBody将itemsCustom转成json输出\r\n@RequestMapping(\"/requestJson\")\r\npublic @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom){\r\n\r\n    //@ResponseBody将itemsCustom转成json输出\r\n    return itemsCustom;\r\n}\r\n```\r\n\r\n- 测试结果\r\n\r\n![请求json，返回json](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-json-1.png)\r\n\r\n可以看到，request和response的HTTP头的Content-Type都是`application/json;charset=utf-8`\r\n\r\n![请求json，返回json,response的body](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-json-2.png)\r\n\r\n\r\n### 输入key/value，输出是json串\r\n\r\n使用jquery的ajax提交key/value串，对输出的json结果进行解析\r\n\r\n- jsp页面\r\n\r\n```jsp\r\n//请求key/value，输出是json\r\nfunction responseJson(){\r\n\r\n    $.ajax({\r\n        type:\'post\',\r\n        url:\'${pageContext.request.contextPath }/responseJson.action\',\r\n        //请求是key/value这里不需要指定contentType，因为默认就 是key/value类型\r\n        //contentType:\'application/json;charset=utf-8\',\r\n        //数据格式是json串，商品信息\r\n        data:\'name=手机&price=999\',\r\n        success:function(data){//返回json结果\r\n            alert(data.name);\r\n        }\r\n\r\n    });\r\n\r\n}\r\n```\r\n\r\n- controller\r\n\r\n\r\n```java\r\n //请求key/value，输出json\r\n@RequestMapping(\"/responseJson\")\r\npublic @ResponseBody ItemsCustom responseJson(ItemsCustom itemsCustom){\r\n\r\n    //@ResponseBody将itemsCustom转成json输出\r\n    return itemsCustom;\r\n}\r\n```\r\n\r\n- 测试结果\r\n\r\n![请求key/value,返回json](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-keyvalue-1.png)\r\n\r\n\r\n可以看到，key/value键值对的默认Content-Type是`application/x-www-form-urlencoded`,同时，我们收到了响应“手机”\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (265, 'SpringMVC RESTful支持', 4, '# springmvc学习笔记(19)-RESTful支持\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [概念](#概念)\r\n  - [REST的例子](#REST的例子)\r\n    - [controller](#controller)\r\n    - [REST方法的前端控制器配置](#REST方法的前端控制器配置)\r\n  - [对静态资源的解析](#对静态资源的解析)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文介绍RESTful的概念，并通过一个小例子展示如何编写RESTful风格的controller和配置前端控制器，最后展示静态资源的解析\r\n\r\n\r\n## 概念\r\n\r\n首先附上两篇博客链接\r\n\r\n>* [理解RESTful架构 - 阮一峰的网络日志](http://zqpythonic.qiniucdn.com/data/20110912210739/index.html)\r\n>* [RESTful API 设计指南- 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)\r\n\r\n\r\nRESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。\r\n\r\nRESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。\r\n\r\n1.对url进行规范，写RESTful格式的url\r\n\r\n- 非REST的url：`http://...../queryItems.action?id=001&type=T01`\r\n- REST的url风格：`http://..../items/001`\r\n\r\n特点：url简洁，将参数通过url传到服务端\r\n\r\n2.http的方法规范\r\n\r\n不管是删除、添加、更新，等等。使用url是一致的，如果进行删除，需要设置http的方法为delete，其他同理。\r\n\r\n后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。\r\n\r\n3.对http的contentType规范\r\n\r\n请求时指定contentType，要json数据，设置成json格式的type。\r\n\r\n\r\n## REST的例子\r\n\r\n查询商品信息，返回json数据。\r\n\r\n### controller\r\n\r\n定义方法，进行url映射使用REST风格的url，将查询商品信息的id传入controller .\r\n\r\n输出json使用`@ResponseBody`将java对象输出json。\r\n\r\n```java\r\n//查询商品信息，输出json\r\n//itemsView/{id}里边的{id}表示占位符，通过@PathVariable获取占位符中的参数，\r\n//@PathVariable中名称要和占位符一致，形参名无需和其一致\r\n//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称\r\n@RequestMapping(\"/itemsView/{id}\")\r\npublic @ResponseBody ItemsCustom itemsView(@PathVariable(\"id\") Integer items_id)throws Exception{\r\n\r\n    //调用service查询商品信息\r\n    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);\r\n\r\n    return itemsCustom;\r\n\r\n}\r\n```\r\n\r\n`@RequestMapping(value=\"/ itemsView/{id}\")`：`{×××}`占位符，请求的URL可以是`/viewItems/1`或`/viewItems/2`，通过在方法中使用`@PathVariable`获取{×××}中的×××变量。`@PathVariable`用于将请求URL中的模板变量映射到功能处理方法的参数上。\r\n\r\n如果`@RequestMapping`中表示为`/itemsView/{id}`，id和形参名称一致，`@PathVariable`不用指定名称。\r\n\r\n\r\n### REST方法的前端控制器配置\r\n\r\n```xml\r\n<!-- springmvc前端控制器，rest配置 -->\r\n<servlet>\r\n    <servlet-name>springmvc_rest</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） -->\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:spring/springmvc.xml</param-value>\r\n    </init-param>\r\n</servlet>\r\n\r\n<servlet-mapping>\r\n    <servlet-name>springmvc_rest</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n\r\n访问结果如图：\r\n\r\n![RESTful格式访问](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_RESTful%E6%A0%BC%E5%BC%8F%E8%AE%BF%E9%97%AE.png)\r\n\r\n\r\n## 对静态资源的解析\r\n\r\n配置前端控制器的url-parttern中指定`/`，对静态资源的解析会出现问题，报404错误。\r\n\r\n\r\n在springmvc.xml中添加静态资源解析方法。\r\n\r\n```xml\r\n<!-- 静态资源解析\r\n    包括 ：js、css、img、..\r\n     -->\r\n<mvc:resources location=\"/js/\" mapping=\"/js/**\"/>\r\n```\r\n\r\n这时访问`http://localhost:8080/ssm1/js/jquery-1.4.4.min.js`，可以在浏览器中看到js的内容\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (266, 'SpringMVC 拦截器', 4, '# springmvc学习笔记(20)-拦截器\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [拦截定义](#拦截定义)\r\n  - [拦截器配置](#拦截器配置)\r\n    - [针对HandlerMapping配置](#针对HandlerMapping配置)\r\n    - [类似全局的拦截器](#类似全局的拦截器)\r\n  - [拦截测试](#拦截测试)\r\n  - [拦截器应用(实现登陆认证)](#拦截器应用实现登陆认证)\r\n    - [需求](#需求)\r\n    - [登陆controller方法](#登陆controller方法)\r\n    - [登陆认证拦截实现](#登陆认证拦截实现)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n本文主要介绍springmvc中的拦截器，包括拦截器定义和的配置，然后演示了一个链式拦截的测试示例，最后通过一个登录认证的例子展示了拦截器的应用\r\n\r\n\r\n## 拦截定义\r\n\r\n定义拦截器，实现`HandlerInterceptor`接口。接口中提供三个方法。\r\n\r\n\r\n```java\r\npublic class HandlerInterceptor1 implements HandlerInterceptor{\r\n    //进入 Handler方法之前执行\r\n    //用于身份认证、身份授权\r\n    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n\r\n        //return false表示拦截，不向下执行\r\n        //return true表示放行\r\n        return false;\r\n    }\r\n\r\n    //进入Handler方法之后，返回modelAndView之前执行\r\n    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\r\n\r\n    }\r\n\r\n    //执行Handler完成执行此方法\r\n    //应用场景：统一异常处理，统一日志处理\r\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r\n\r\n    }\r\n}\r\n```\r\n\r\n可以从名称和参数看出各个接口的顺序和作用:\r\n\r\n- `public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception`\r\n   - 参数最少，只有三个\r\n   - 进入 Handler方法之前执行\r\n   - 用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n- `public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception`\r\n  - 多了一个modelAndView参数\r\n  - 进入Handler方法之后，返回modelAndView之前执行 \r\n  - 应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n- `public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception`\r\n  - 多了一个Exception的类型的参数\r\n  - 执行Handler完成执行此方法\r\n  - 应用场景：统一异常处理，统一日志处理\r\n\r\n## 拦截器配置\r\n\r\n### 针对HandlerMapping配置\r\n\r\nspringmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器。\r\n\r\n```xml\r\n<bean\r\n	class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\">\r\n	<property name=\"interceptors\">\r\n		<list>\r\n			<ref bean=\"handlerInterceptor1\"/>\r\n			<ref bean=\"handlerInterceptor2\"/>\r\n		</list>\r\n	</property>\r\n</bean>\r\n	<bean id=\"handlerInterceptor1\" class=\"springmvc.intercapter.HandlerInterceptor1\"/>\r\n	<bean id=\"handlerInterceptor2\" class=\"springmvc.intercapter.HandlerInterceptor2\"/>\r\n```\r\n\r\n一般不推荐使用。\r\n\r\n### 类似全局的拦截器\r\n\r\nspringmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。\r\n\r\n```xml\r\n <!--拦截器 -->\r\n<mvc:interceptors>\r\n    <!--多个拦截器,顺序执行 -->\r\n    <mvc:interceptor>\r\n        <!-- /**表示所有url包括子url路径 -->\r\n        <mvc:mapping path=\"/**\"/>\r\n        <bean class=\"com.iot.learnssm.firstssm.interceptor.HandlerInterceptor1\"></bean>\r\n    </mvc:interceptor>\r\n    <mvc:interceptor>\r\n        <mvc:mapping path=\"/**\"/>\r\n        <bean class=\"com.iot.learnssm.firstssm.interceptor.HandlerInterceptor2\"></bean>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n## 拦截测试\r\n\r\n测试多个拦截器各个方法执行时机\r\n\r\n访问`/items/queryItems.action`\r\n\r\n- 1.两个拦截器都放行\r\n\r\n```\r\nDEBUG [http-apr-8080-exec-1] - DispatcherServlet with name \'springmvc\' processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-1] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-1] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-1] - Returning cached instance of singleton bean \'itemsController\'\r\nDEBUG [http-apr-8080-exec-1] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nHandlerInterceptor2...preHandle\r\nDEBUG [http-apr-8080-exec-1] - Fetching JDBC Connection from DataSource\r\nDEBUG [http-apr-8080-exec-1] - Registering transaction synchronization for JDBC Connection\r\nDEBUG [http-apr-8080-exec-1] - Returning JDBC Connection to DataSource\r\nHandlerInterceptor2...postHandle\r\nHandlerInterceptor1...postHandle\r\nDEBUG [http-apr-8080-exec-1] - Rendering view [org.springframework.web.servlet.view.JstlView: name \'items/itemsList\'; URL [/WEB-INF/jsp/items/itemsList.jsp]] in DispatcherServlet with name \'springmvc\'\r\nDEBUG [http-apr-8080-exec-1] - Added model object \'itemtypes\' of type [java.util.HashMap] to request in view with name \'items/itemsList\'\r\nDEBUG [http-apr-8080-exec-1] - Added model object \'itemsQueryVo\' of type [com.iot.learnssm.firstssm.po.ItemsQueryVo] to request in view with name \'items/itemsList\'\r\nDEBUG [http-apr-8080-exec-1] - Added model object \'org.springframework.validation.BindingResult.itemsQueryVo\' of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name \'items/itemsList\'\r\nDEBUG [http-apr-8080-exec-1] - Added model object \'itemsList\' of type [java.util.ArrayList] to request in view with name \'items/itemsList\'\r\nDEBUG [http-apr-8080-exec-1] - Forwarding to resource [/WEB-INF/jsp/items/itemsList.jsp] in InternalResourceView \'items/itemsList\'\r\nHandlerInterceptor2...afterCompletion\r\nHandlerInterceptor1...afterCompletion\r\nDEBUG [http-apr-8080-exec-1] - Successfully completed request\r\n\r\n```\r\n\r\n总结：preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行。\r\n\r\n\r\n2.拦截器1放行，拦截器2不放行\r\n\r\n```\r\nDEBUG [http-apr-8080-exec-8] - DispatcherServlet with name \'springmvc\' processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean \'itemsController\'\r\nDEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nHandlerInterceptor2...preHandle\r\nHandlerInterceptor1...afterCompletion\r\nDEBUG [http-apr-8080-exec-8] - Successfully completed request\r\n```\r\n\r\n总结：\r\n\r\n- 拦截器1放行，拦截器2 preHandle才会执行。\r\n- 拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。\r\n- 只要有一个拦截器不放行，postHandle不会执行。\r\n\r\n\r\n\r\n3.两个拦截器都不放\r\n\r\n```\r\nDEBUG [http-apr-8080-exec-9] - DispatcherServlet with name \'springmvc\' processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-9] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-9] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-9] - Returning cached instance of singleton bean \'itemsController\'\r\nDEBUG [http-apr-8080-exec-9] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nDEBUG [http-apr-8080-exec-9] - Successfully completed request\r\n```\r\n\r\n总结：\r\n\r\n- 拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。\r\n- 拦截器1 preHandle不放行，拦截器2不执行。\r\n\r\n\r\n4.拦截器1不放行，拦截器2放行\r\n\r\n```\r\nDEBUG [http-apr-8080-exec-8] - DispatcherServlet with name \'springmvc\' processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean \'itemsController\'\r\nDEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nDEBUG [http-apr-8080-exec-8] - Successfully completed request\r\n```\r\n\r\n和两个拦截器都不行的结果一致，因为拦截器1先执行，没放行\r\n\r\n\r\n- 小结\r\n\r\n根据测试结果，对拦截器应用。\r\n\r\n比如：统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。\r\n\r\n比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面）\r\n\r\n\r\n## 拦截器应用(实现登陆认证)\r\n\r\n### 需求\r\n\r\n- 1.用户请求url\r\n- 2.拦截器进行拦截校验\r\n	- 如果请求的url是公开地址（无需登陆即可访问的url），让放行\r\n	- 如果用户session 不存在跳转到登陆页面\r\n	- 如果用户session存在放行，继续操作。\r\n\r\n\r\n### 登陆controller方法\r\n\r\n```java\r\n@Controller\r\npublic class LoginController {\r\n    // 登陆\r\n    @RequestMapping(\"/login\")\r\n    public String login(HttpSession session, String username, String password)\r\n            throws Exception {\r\n\r\n        // 调用service进行用户身份验证\r\n        // ...\r\n\r\n        // 在session中保存用户身份信息\r\n        session.setAttribute(\"username\", username);\r\n        // 重定向到商品列表页面\r\n        return \"redirect:/items/queryItems.action\";\r\n    }\r\n\r\n    // 退出\r\n    @RequestMapping(\"/logout\")\r\n    public String logout(HttpSession session) throws Exception {\r\n\r\n        // 清除session\r\n        session.invalidate();\r\n\r\n        // 重定向到商品列表页面\r\n        return \"redirect:/items/queryItems.action\";\r\n    }\r\n}\r\n```\r\n\r\n\r\n###	登陆认证拦截实现\r\n\r\n- 代码实现\r\n\r\n```java\r\n/**\r\n * Created by brian on 2016/3/8.\r\n * 登陆认证拦截器\r\n */\r\n\r\npublic class LoginInterceptor implements HandlerInterceptor {\r\n\r\n\r\n    //进入 Handler方法之前执行\r\n    //用于身份认证、身份授权\r\n    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n    public boolean preHandle(HttpServletRequest request,\r\n                             HttpServletResponse response, Object handler) throws Exception {\r\n\r\n        //获取请求的url\r\n        String url = request.getRequestURI();\r\n        //判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中）\r\n        //这里公开地址是登陆提交的地址\r\n        if(url.indexOf(\"login.action\")>=0){\r\n            //如果进行登陆提交，放行\r\n            return true;\r\n        }\r\n\r\n        //判断session\r\n        HttpSession session  = request.getSession();\r\n        //从session中取出用户身份信息\r\n        String username = (String) session.getAttribute(\"username\");\r\n\r\n        if(username != null){\r\n            //身份存在，放行\r\n            return true;\r\n        }\r\n\r\n        //执行这里表示用户身份需要认证，跳转登陆页面\r\n        request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request, response);\r\n\r\n        //return false表示拦截，不向下执行\r\n        //return true表示放行\r\n        return false;\r\n    }\r\n\r\n    //进入Handler方法之后，返回modelAndView之前执行\r\n    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n    public void postHandle(HttpServletRequest request,\r\n                           HttpServletResponse response, Object handler,\r\n                           ModelAndView modelAndView) throws Exception {\r\n\r\n        System.out.println(\"LoginInterceptor...postHandle\");\r\n\r\n    }\r\n\r\n    //执行Handler完成执行此方法\r\n    //应用场景：统一异常处理，统一日志处理\r\n    public void afterCompletion(HttpServletRequest request,\r\n                                HttpServletResponse response, Object handler, Exception ex)\r\n            throws Exception {\r\n\r\n        System.out.println(\"LoginInterceptor...afterCompletion\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n- 拦截器配置\r\n\r\n```xml\r\n<!--拦截器 -->\r\n<mvc:interceptors>\r\n    <!--多个拦截器,顺序执行 -->\r\n    <!-- 登陆认证拦截器 -->\r\n    <mvc:interceptor>\r\n        <mvc:mapping path=\"/**\"/>\r\n        <bean class=\"com.iot.learnssm.firstssm.interceptor.LoginInterceptor\"></bean>\r\n    </mvc:interceptor>\r\n    \r\n    ...省略\r\n```\r\n\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n', 0);
INSERT INTO `blog_course` VALUES (267, 'SpringMVC 整合mybatis遇到的问题小结', 4, '# springmvc学习笔记(21)-springmvc整合mybatis遇到的问题及解决小结\r\n\r\n标签： springmvc mybatis\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [遇到的问题](#遇到的问题)\r\n    - [在web.xml中`<listener-class>`标签报红](#在web.xml中 listener-class 标签报红)\r\n    - [BeanCreationException](#BeanCreationException)\r\n    - [mybatis绑定错误](#mybatis绑定错误)\r\n    - [请求参数乱码问题](#请求参数乱码问题)\r\n    - [请求参数类型转换问题](#请求参数类型转换问题)\r\n    - [maven平台编码问题](#maven平台编码问题)\r\n    - [json格式数据问题](#json格式数据问题)\r\n  - [还没弄懂但不影响运行的问题](#还没弄懂但不影响运行的问题)\r\n    - [加载spring容器报红](#加载spring容器报红)\r\n    - [参数绑定配置问题](#参数绑定配置问题)\r\n    - [maven依赖分析问题](#maven依赖分析问题)\r\n\r\n\r\n\r\n---\r\n\r\n本文主要记录springmvc整合mybatis整合过程中遇到的各种问题和解决方法\r\n\r\n\r\n## 遇到的问题\r\n\r\n### 在web.xml中 listener-class 标签报红\r\n\r\n\r\n参考：\r\n\r\n> [web.xml listener-class is not allowed here](http://q.cnblogs.com/q/74982/)\r\n\r\n解决：改用2.5的版本\r\n\r\n答案节选：\r\n\r\n> Servlet3.0是J2EE6.0规范的一部分，跟随J2EE6.0一起发布，并且Tomcat7.0已经完全支持Servlet3.0 ；\r\n平时，我们一般使用tomcat6.0，是不能够使用servelt3.0的，tomcat6.0还不能支持那些规范；\r\n至于说，为毛线不能使用lintener-class，是因为在web-app_3_0.xsd结构定义文件中，根本就不提倡这些配置，因为Servlet3.0已经支持注解形式；\r\n\r\n当时解决了报红的问题。但后来我其他部分调试好了后，改回3.0也没报错。\r\n\r\n\r\n### BeanCreationException\r\n\r\n```\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name \'dataSource\' defined in file [D:\\intellij\\workspace\\learnssm-firstssm\\target\\learnssm-firstssm-1.0-SNAPSHOT\\WEB-INF\\classes\\spring\\applicationContext-dao.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name \'org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0\': Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException\r\n	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:478)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)\r\n	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)\r\n    ....省略\r\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name \'org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0\': Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException\r\n	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)\r\n	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)\r\n	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)\r\n	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\r\n	  ....省略\r\n```\r\n\r\n是少依赖的问题，输入`mvn dependency:tree`打依赖树：\r\n\r\n```\r\nD:\\intellij\\workspace\\learnssm-firstssm>mvn dependency:tree\r\n[INFO] Scanning for projects...\r\n[INFO]\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building learnssm-firstssm 1.0-SNAPSHOT\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO]\r\n[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ learnssm-firstssm ---\r\n[INFO] com.iot.learnssm:learnssm-firstssm:war:1.0-SNAPSHOT\r\n[INFO] +- org.springframework:spring-core:jar:4.2.4.RELEASE:compile\r\n[INFO] |  \\- commons-logging:commons-logging:jar:1.2:compile\r\n[INFO] +- org.springframework:spring-webmvc:jar:4.2.4.RELEASE:compile\r\n[INFO] |  +- org.springframework:spring-beans:jar:4.2.4.RELEASE:compile\r\n[INFO] |  +- org.springframework:spring-context:jar:4.2.4.RELEASE:compile\r\n[INFO] |  |  \\- org.springframework:spring-aop:jar:4.2.4.RELEASE:compile\r\n[INFO] |  |     \\- aopalliance:aopalliance:jar:1.0:compile\r\n[INFO] |  +- org.springframework:spring-expression:jar:4.2.4.RELEASE:compile\r\n[INFO] |  \\- org.springframework:spring-web:jar:4.2.4.RELEASE:compile\r\n[INFO] +- org.springframework:spring-jdbc:jar:4.2.4.RELEASE:compile\r\n[INFO] |  \\- org.springframework:spring-tx:jar:4.2.4.RELEASE:compile\r\n[INFO] +- mysql:mysql-connector-java:jar:5.1.38:compile\r\n[INFO] +- org.mybatis:mybatis:jar:3.3.1:compile\r\n[INFO] +- org.mybatis:mybatis-spring:jar:1.2.4:compile\r\n[INFO] +- log4j:log4j:jar:1.2.17:compile\r\n[INFO] +- org.slf4j:slf4j-api:jar:1.7.18:compile\r\n[INFO] +- commons-dbcp:commons-dbcp:jar:1.4:compile\r\n[INFO] |  \\- commons-pool:commons-pool:jar:1.5.4:compile\r\n[INFO] +- javax.servlet:jstl:jar:1.2:compile\r\n[INFO] \\- taglibs:standard:jar:1.1.2:compile\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD SUCCESS\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 7.956 s\r\n[INFO] Finished at: 2016-03-03T20:06:00+08:00\r\n[INFO] Final Memory: 11M/126M\r\n[INFO] ------------------------------------------------------------------------\r\n```\r\n\r\n少了spring-aspects,spring-core等依赖，加上\r\n\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-core</artifactId>\r\n    <version>${spring.version}</version>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-orm</artifactId>\r\n    <version>${spring.version}</version>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-aspects</artifactId>\r\n    <version>${spring.version}</version>\r\n</dependency>\r\n\r\n <dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-test</artifactId>\r\n    <version>${spring.version}</version>\r\n</dependency>\r\n```\r\n\r\nspring版本统一设置\r\n\r\n```xml\r\n<properties>\r\n    <!-- jar 版本设置 -->\r\n    <spring.version>4.2.4.RELEASE</spring.version>\r\n</properties>\r\n```\r\n\r\n\r\n### mybatis绑定错误\r\n\r\n错误：`org.apache.ibatis.binding.BindingException: Invalid bound statement`\r\n\r\n使用了下面的方法检查，都没有解决。排除了包名不同等低级错误。\r\n\r\n>* [mybatis绑定错误- softwarehe的专栏- 博客频道- CSDN.NET](http://blog.csdn.net/softwarehe/article/details/8889206)\r\n>* [Mybatis绑定错误的原因](http://ljhzzyx.blog.163.com/blog/static/38380312201412453629988/)\r\n\r\n又找到了oschina一个人的帖子，有个回答感觉靠谱\r\n\r\n>* [java spring4+mybatis整合报错BindingException Invalid bound statement](http://www.oschina.net/question/113302_228910)\r\n\r\n> 是的，是没有在pom.xml配置build包含 xml，导致target目录下没有userMapper.xml\r\n      -by 唐小明生\r\n\r\n我一看自己的target目录,发现还真是少mapper.xml文件\r\n\r\n![target少mapper的xml文件](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_bug_target%E5%B0%91xml%E6%96%87%E4%BB%B6.png)\r\n  \r\n  \r\n我想到了两种解决方案：\r\n\r\n- 方案一：自定义一个插件，绑定某个生命周期，比如compile，然后插件目标的功能是将源码包下的xml文件copy到相应的输出目录。(现有插件是否有已有这个功能，通过简单的配置就能完成？我还不清楚)\r\n- 方案二：在maven工程的`src/main/resource`目录下建和mapper接口类相应的包，将每个mapper.xml存在这里\r\n\r\n这里我插件玩的不熟，所以没办法，只能手动在resources目录下建包，把每个mapper.xml手动粘贴进去\r\n\r\n解决后如图：\r\n\r\n![mapper.xml存在resources下面](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_solve_mapper%E7%9A%84xml%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8resources.png)\r\n\r\n### 请求参数乱码问题\r\n\r\n![springmcv_post请求参数乱码](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B9%B1%E7%A0%81.png)\r\n\r\n\r\n在web.xml添加post乱码filter\r\n\r\n```xml\r\n<!-- post乱码过虑器 -->\r\n<filter>\r\n    <filter-name>CharacterEncodingFilter</filter-name>\r\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n    <init-param>\r\n        <param-name>encoding</param-name>\r\n        <param-value>utf-8</param-value>\r\n    </init-param>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>CharacterEncodingFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n```\r\n\r\n以上可以解决post请求乱码问题。解决后调试如图\r\n\r\n![springmcv_post请求参数乱码解决](http://7xph6d.com1.z0.glb.clouddn.com/springmcv_post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3.png)\r\n\r\n对于get请求中文参数出现乱码解决方法有两个：\r\n\r\n修改tomcat配置文件添加编码与工程编码一致，如下：\r\n\r\n`<Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>`\r\n\r\n另外一种方法对参数进行重新编码：\r\n\r\n```java\r\nString userName = new \r\nString(request.getParamter(\"userName\").getBytes(\"ISO8859-1\"),\"utf-8\")\r\n```\r\n\r\nISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码\r\n\r\n\r\n\r\n\r\n### 请求参数类型转换问题\r\n\r\n编写对应的转换类才行,具体参考前面参数绑定的博文[《 springmvc学习笔记(11)-springmvc注解开发之简单参数绑定》](http://blog.csdn.net/h3243212/article/details/50854748#自定义参数绑定实现日期类型绑定)\r\n\r\n\r\n### maven平台编码问题\r\n\r\n`[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!`\r\n\r\n参考: \r\n\r\n>* [CSDN博客](http://blog.csdn.net/jinguangliu/article/details/43373203) \r\n>* [Maven官网在FAQ](http://maven.apache.org/general.html#encoding-warning)\r\n\r\n解决:\r\n\r\n在pom.xml文件的设置编码即可\r\n\r\n```\r\n<properties>  \r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>  \r\n</properties>  \r\n```\r\n\r\n\r\n### json格式数据问题\r\n\r\n- 1.请求是json格式\r\n\r\ndebug窗里报下面的错误：\r\n\r\n`org.springframework.web.HttpMediaTypeNotSupportedException: Content type \'application/json;charset=UTF-8\' not supported`\r\n\r\n浏览器报下面的错误：\r\n\r\n`HTTP Status 415 -`and`description The server refused this request because the request entity is in a format not supported by the requested resource for the requested method.`\r\n\r\n\r\n2.请求是key/value格式\r\n\r\ndebug窗里报下面的错误：\r\n\r\n`java.lang.IllegalArgumentException: No converter found for return value of type: class com.iot.learnssm.firstssm.po.ItemsCustom`\r\n\r\n参考stackoverflow的这个链接:\r\n\r\n> [How to return JSON data from spring Controller using @ResponseBody](http://stackoverflow.com/questions/32905917/how-to-return-json-data-from-spring-controller-using-responsebody)\r\n\r\n多加一个依赖`jackson-databind`（之前只加了`jackson-mapper-asl`的依赖， 间接依赖`jackson-core-asl`，但还不够。\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.fasterxml.jackson.core</groupId>\r\n    <artifactId>jackson-databind</artifactId>\r\n    <version>2.7.2</version>\r\n</dependency>\r\n```\r\n\r\n\r\n## 还没弄懂但不影响运行的问题\r\n\r\n### 加载spring容器报红\r\n\r\n- web.xml节选\r\n\r\n```xml\r\n <!-- 加载spring容器 -->\r\n<context-param>\r\n    <param-name>contextConfigLocation</param-name>\r\n    <param-value>WEB-INF/classes/spring/applicationContext-*.xml</param-value>\r\n    <!--  <param-value>classpath:spring/applicationContext-*.xml</param-value>-->\r\n </context-param>\r\n```\r\n\r\n![加载spring容器报红](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_bug_%E5%AE%B9%E5%99%A8%E8%B7%AF%E5%BE%84%E6%8A%A5%E7%BA%A2.png)\r\n\r\n\r\n`/classes/spring/applicationContext-*.xml`这部分字会报红，但运行起来没问题。我使用下面的那句` <param-value>classpath:spring/applicationContext-*.xml</param-value>`不报红.原因不清楚。\r\n\r\n这里两种方式都能跑通，但是引用的路径不同:一个是引用的的输出的target目录的classes下的，一个是引用输出的`target/learnssm-firstssm-1.0-SNAPSHOT`目录(相当于部署的WEBROOT或者叫做webapp)，所以我觉得还是用WEB-INF下面那个更好\r\n\r\n![容器加载文件的选用](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_solve_%E5%AE%B9%E5%99%A8%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%89%E7%94%A8.png)\r\n\r\n\r\n### 参数绑定配置问题\r\n\r\n在自定义参数绑定时，spring.xml的配置如下：\r\n\r\n```xml\r\n<!-- 自定义参数绑定 -->\r\n    <bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\r\n        <!-- 转换器 -->\r\n        <property name=\"converters\">\r\n            <list>\r\n                <!-- 日期类型转换 -->\r\n                <bean class=\"com.iot.learnssm.firstssm.controller.converter.CustomDateConverter\"/>\r\n           </list>\r\n        </property>\r\n    </bean>\r\n```\r\n\r\n其中`<list>`标签会报红，但不影响运行。去掉`<list>`标签，也可以运行成功。原因我还不知道，以后阅读源码会研究下这个问题。\r\n\r\n![转换器list报红](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_bug_%E8%BD%AC%E6%8D%A2%E5%99%A8list%E6%8A%A5%E7%BA%A2.png)\r\n\r\n### maven依赖分析问题\r\n\r\n输入`mvn  dependency:analyze`进行依赖分析\r\n\r\n```\r\n[INFO]\r\n[INFO] --- maven-dependency-plugin:2.8:analyze (default-cli) @ learnssm-firstssm ---\r\n[WARNING] Used undeclared dependencies found:\r\n[WARNING]    org.springframework:spring-context:jar:4.2.4.RELEASE:compile\r\n[WARNING]    org.springframework:spring-web:jar:4.2.4.RELEASE:compile\r\n[WARNING]    org.springframework:spring-beans:jar:4.2.4.RELEASE:compile\r\n[WARNING] Unused declared dependencies found:\r\n[WARNING]    org.springframework:spring-orm:jar:4.2.4.RELEASE:compile\r\n[WARNING]    org.springframework:spring-aspects:jar:4.2.4.RELEASE:compile\r\n[WARNING]    org.springframework:spring-test:jar:4.2.4.RELEASE:compile\r\n[WARNING]    org.springframework:spring-jdbc:jar:4.2.4.RELEASE:compile\r\n[WARNING]    mysql:mysql-connector-java:jar:5.1.38:compile\r\n[WARNING]    org.mybatis:mybatis-spring:jar:1.2.4:compile\r\n[WARNING]    log4j:log4j:jar:1.2.17:compile\r\n[WARNING]    org.slf4j:slf4j-api:jar:1.7.18:compile\r\n[WARNING]    commons-dbcp:commons-dbcp:jar:1.4:compile\r\n[WARNING]    javax.servlet:jstl:jar:1.2:compile\r\n[WARNING]    taglibs:standard:jar:1.1.2:compile\r\n[WARNING]    org.hibernate:hibernate-validator:jar:5.2.4.Final:compile\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] BUILD SUCCESS\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Total time: 3.294 s\r\n[INFO] Finished at: 2016-03-06T16:35:23+08:00\r\n[INFO] Final Memory: 16M/164M\r\n[INFO] ------------------------------------------------------------------------\r\n\r\n```\r\n\r\n可以看到里面有:\r\n\r\n- `Used undeclared dependencies found:`\r\n- `Unused declared dependencies found:`\r\n\r\n当时为了解决缺包的问题，看到相关的spring-xxx包就加进去了，具体相互之间的依赖关系也没搞清楚，等我以后阅读spring源码再慢慢改好了。反正多引比少引好点，起码不会报错，顶多工程冗余点。\r\n\r\n\r\n至于说使用了未声明的包就不知道为啥了，比如\r\n\r\n```\r\n[WARNING]    org.springframework:spring-context:jar:4.2.4.RELEASE:compile\r\n[WARNING]    org.springframework:spring-web:jar:4.2.4.RELEASE:compile\r\n[WARNING]    org.springframework:spring-beans:jar:4.2.4.RELEASE:compile\r\n```\r\n\r\n都被`org.springframework:spring-webmvc:jar:4.2.4.RELEASE:compile`依赖，这点可以从依赖树看到\r\n\r\n```\r\n[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ learnssm-firstssm ---\r\n[INFO] com.iot.learnssm:learnssm-firstssm:war:1.0-SNAPSHOT\r\n[INFO] +- org.springframework:spring-webmvc:jar:4.2.4.RELEASE:compile\r\n[INFO] |  +- org.springframework:spring-beans:jar:4.2.4.RELEASE:compile\r\n[INFO] |  +- org.springframework:spring-context:jar:4.2.4.RELEASE:compile\r\n[INFO] |  |  \\- org.springframework:spring-aop:jar:4.2.4.RELEASE:compile\r\n[INFO] |  |     \\- aopalliance:aopalliance:jar:1.0:compile\r\n[INFO] |  +- org.springframework:spring-expression:jar:4.2.4.RELEASE:compile\r\n[INFO] |  \\- org.springframework:spring-web:jar:4.2.4.RELEASE:compile\r\n```\r\n\r\n总之，上面未解决的问题，我会留意，如果有大神指导原因，请不吝赐教。\r\n\r\n\r\n----\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (268, 'SpringMVC 开发总结', 4, '# springmvc学习笔记(22)-springmvc开发小结\r\n\r\n标签： springmvc\r\n\r\n---\r\n\r\n**Contents**\r\n\r\n  - [springmvc框架](#springmvc框架)\r\n  - [注解开发](#注解开发)\r\n    - [使用注解方式的处理器映射器和适配器](#使用注解方式的处理器映射器和适配器)\r\n    - [注解开发中参数绑定](#注解开发中参数绑定)\r\n    - [springmvc和struts2区别](#springmvc和struts2区别)\r\n  - [校验](#校验)\r\n  - [数据回显](#数据回显)\r\n  - [异常处理](#异常处理)\r\n  - [上传图片](#上传图片)\r\n  - [json数据交互](#json数据交互)\r\n  - [RESTful支持](#RESTful支持)\r\n  - [拦截器](#拦截器)\r\n    - [拦截器定义](#拦截器定义)\r\n    - [拦截器的配置](#拦截器的配置)\r\n    - [拦截器测试及其应用](#拦截器测试及其应用)\r\n\r\n\r\n\r\n---\r\n\r\n本文对springmvc系列博文进行小结\r\n\r\n\r\n## springmvc框架\r\n\r\n![springmvc_核心架构图](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg)\r\n\r\n- `DispatcherServlet`前端控制器：接收request，进行response\r\n- **`HandlerMapping`处理器映射器**：根据url查找Handler。（可以通过xml配置方式，注解方式）\r\n- **`HandlerAdapter`处理器适配器**：根据特定规则去执行Handler，编写Handler时需要按照HandlerAdapter的要求去编写。\r\n- **`Handler`处理器**（后端控制器）：需要程序员去编写，**常用注解开发方式**。\r\n    - Handler处理器执行后结果是`ModelAndView`，具体开发时`Handler`返回方法值类型包括：`ModelAndView`、`String`（逻辑视图名）、`void`（通过在Handler形参中添加request和response，类似原始 servlet开发方式，注意：可以通过指定response响应的结果类型实现json数据输出）\r\n- `View Resolver`视图解析器：根据逻辑视图名生成真正的视图（在springmvc中使用View对象表示）\r\n- `View`视图：jsp页面，仅是数据展示，没有业务逻辑。\r\n\r\n\r\n\r\n## 注解开发\r\n\r\n### 使用注解方式的处理器映射器和适配器\r\n\r\n```xml\r\n<!--注解映射器 -->\r\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\r\n<!--注解适配器 -->\r\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\r\n```\r\n\r\n在实际开发，使用`<mvc:annotation-driven>`代替上边处理器映射器和适配器配置。\r\n\r\n- `@controller`注解必须要加，作用标识类是一个Handler处理器。\r\n- `@requestMapping`注解必须要加，作用：\r\n	- 1、对url和Handler的**方法**进行映射。\r\n	- 2、可以窄化请求映射，设置Handler的根路径，url就是根路径+子路径请求方式\r\n	- 3、可以限制http请求的方法\r\n	\r\n映射成功后，springmvc框架生成一个Handler对象，对象中只包括 一个映射成功的method。\r\n\r\n### 注解开发中参数绑定\r\n\r\n将request请求过来的key/value的数据（理解一个串），通过转换（参数绑定的一部分），将key/value串转成形参，将转换后的结果传给形参（整个参数绑定过程）。\r\n\r\nspringmvc所支持参数绑定：\r\n\r\n- 1、默认支持很多类型：`HttpServletRequest`、`response`、`session`、`model/modelMap`(将模型数据填充到request域)\r\n- 2、支持简单数据类型，整型、字符串、日期..等\r\n    - 只要保证request请求的参数名和形参名称一致，自动绑定成功\r\n	- 如果request请求的参数名和形参名称不一致，可以使用`@RequestParam`（指定request请求的参数名），`@RequestParam`加在形参的前边。\r\n- 3、支持pojo类型\r\n    - 只要保证request请求的参数名称和pojo中的属性名一致，自动将request请求的参数设置到pojo的属性中。\r\n- 4、包装类型pojo参数绑定\r\n  - 第一种方法：在形参中添加`HttpServletRequest request`参数，通过request接收查询条件参数。\r\n  - 第二种方法：在形参中让包装类型的pojo接收查询条件参数。\r\n- 5、集合类型参数绑定\r\n  - 数组绑定：方法形参使用数组接收页面请求的多个参数\r\n  - list绑定：使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义list<pojo>属性\r\n  - map绑定：在包装类中定义Map对象，并添加`get/set`方法，action使用包装对象接收\r\n\r\n*注意：形参中即有pojo类型又有简单类型，参数绑定互不影响。*\r\n\r\n\r\n自定义参数绑定\r\n\r\n- 日期类型绑定自定义：\r\n\r\n定义的`Converter<源类型，目标类型>`接口实现类，比如：`Converter<String,Date>`,表示：将请求的日期数据串转成java中的日期类型。\r\n\r\n*注意：要转换的目标类型一定和接收的pojo中的属性类型一致。*\r\n\r\n将定义的Converter实现类注入到处理器适配器中。\r\n\r\n```xml\r\n<mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\r\n\r\n<!-- conversionService -->\r\n<bean id=\"conversionService\"\r\n	class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\r\n	<!-- 转换器 -->\r\n	<property name=\"converters\">\r\n		<list>\r\n			<bean class=\"cn.itcast.ssm.controller.converter.CustomDateConverter\"/>\r\n		</list>\r\n	</property>\r\n</bean>\r\n```\r\n\r\n\r\n### springmvc和struts2区别\r\n\r\nspringmvc面向方法开发的（更接近service接口的开发方式），struts2面向类开发。\r\n\r\nspringmvc可以单例开发，struts2只能是多例开发。\r\n\r\n\r\n## 校验\r\n\r\n服务端校验：\r\n\r\n- 控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用）\r\n- 业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。\r\n- 持久层dao：一般是不校验的。\r\n\r\n一般使用hibernate的校验框架，依赖`hibernate-validator.jar`,`jboss-logging.jar`,`validation-api.jar`这几个jar包\r\n\r\n开发步骤\r\n\r\n- 在springmvc.xml中添加校验器\r\n- 校验器注入到处理器适配器中\r\n- 在CustomValidationMessages.properties配置校验错误信息\r\n- 在pojo中添加校验规则\r\n- 在控制器中对参数注解`@Validated`来捕获和显示校验错误信息\r\n\r\n分组校验\r\n\r\n- 定义校验分组\r\n- 在校验规则中添加分组\r\n- 在controller方法使用指定分组的校验\r\n\r\n## 数据回显\r\n\r\n数据回显有三种方法\r\n\r\n- 1.springmvc默认对pojo数据进行回显。\r\n  - pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）\r\n  - 使用`@ModelAttribute`指定pojo回显到页面在request中的key\r\n- 2.`@ModelAttribute`还可以将方法的返回值传到页面\r\n- 3.使用最简单方法使用model，可以不用`@ModelAttribute`\r\n\r\n\r\n## 异常处理\r\n\r\n系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。\r\n\r\nspringmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。\r\n\r\n\r\n全局异常处理器处理思路：\r\n\r\n解析出异常类型\r\n\r\n- 如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示\r\n- 如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）\r\n\r\n抛出异常的位置\r\n\r\n- 如果与业务功能相关的异常，建议在service中抛出异常。\r\n- 与业务功能没有关系的异常，建议在controller中抛出。\r\n\r\n## 上传图片\r\n\r\n开发步骤\r\n\r\n- 在页面form中提交enctype=\"multipart/form-data\"的数据时，需要springmvc对multipart类型的数据进行解析。\r\n- 在springmvc.xml中配置multipart类型解析器\r\n- 加入上传图片的jar：`commons-fileupload`\r\n- 创建图片虚拟目录存储图片\r\n\r\n## json数据交互\r\n\r\n两种json数据交互的形式：\r\n\r\n- 请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。\r\n- 请求key/value、输出json。此方法比较常用。\r\n\r\n需要的依赖：\r\n\r\n- `jackson-databind`\r\n- `jackson-mapper-asl`\r\n\r\n\r\n\r\n在注解适配器中加入`messageConverters`\r\n\r\n```xml\r\n\r\n<!--注解适配器 -->\r\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\r\n	<property name=\"messageConverters\">\r\n	<list>\r\n	<bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"></bean>\r\n	</list>\r\n	</property>\r\n</bean>\r\n```\r\n\r\n**注意：如果使用`<mvc:annotation-driven />`则不用定义上边的内容。**\r\n\r\n在controller的返回值上加注解`@ResponseBody`来将java对象输出json，返回json格式数据\r\n\r\n\r\n## RESTful支持\r\n\r\n`@RequestMapping(value=\"/ itemsView/{id}\")`：`{×××}`占位符，请求的URL可以是`/viewItems/1`或`/viewItems/2`，通过在方法中使用`@PathVariable`获取{×××}中的×××变量。`@PathVariable`用于将请求URL中的模板变量映射到功能处理方法的参数上。\r\n\r\n如果`@RequestMapping`中表示为`/itemsView/{id}`，id和形参名称一致，`@PathVariable`不用指定名称。\r\n\r\n同时需要配置前端控制器。若要访问静态资源，还需在springmvc.xml中添加静态资源解析方法,如`<mvc:resources location=\"/js/\" mapping=\"/js/**\"/>`\r\n\r\n## 拦截器\r\n\r\n### 拦截器定义\r\n\r\n定义拦截器，实现`HandlerInterceptor`接口。接口中提供三个方法。可以从名称和参数看出各个接口的顺序和作用\r\n\r\n- `public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception`\r\n   - 参数最少，只有三个\r\n   - 进入 Handler方法之前执行\r\n   - 用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n- `public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception`\r\n  - 多了一个modelAndView参数\r\n  - 进入Handler方法之后，返回modelAndView之前执行 \r\n  - 应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n- `public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception`\r\n  - 多了一个Exception的类型的参数\r\n  - 执行Handler完成执行此方法\r\n  - 应用场景：统一异常处理，统一日志处理\r\n\r\n### 拦截器的配置\r\n\r\n- 针对HandlerMapping配置(一般不推荐)\r\n  - springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器 \r\n- 类似全局的拦截器\r\n  - springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。 \r\n\r\n\r\n### 拦截器测试及其应用\r\n\r\n链式执行测试\r\n\r\n- 两个拦截器都放行\r\n  - preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行\r\n- 拦截器1放行，拦截器2不放行\r\n  - 拦截器1放行，拦截器2 preHandle才会执行。\r\n  - 拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。\r\n  - 只要有一个拦截器不放行，postHandle不会执行。\r\n- 两个拦截器都不放 \r\n  - 拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。\r\n  - 拦截器1 preHandle不放行，拦截器2不执行。\r\n\r\n应用\r\n\r\n- 统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。\r\n- 登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面）\r\n\r\n', 0);
INSERT INTO `blog_course` VALUES (269, 'Redis Spring整合redis', 9, '# Redis与Spring整合\r\n\r\n[TOC]\r\n\r\n练习源码：https://github.com/caojx-git/learn/tree/master/code/spring-redis\r\n\r\n本文主要参考：\r\n\r\n[架构之路之spring+redis的集成](https://blog.csdn.net/tomcat_2014/article/details/55260306)\r\n\r\n[](https://blog.csdn.net/u010690828/article/details/77141083)\r\n\r\n[spring整合redis(集群、主从)](https://blog.csdn.net/sunqingzhong44/article/details/70976038?locationNum=6&fps=1)\r\n\r\n## 一、Redis简介\r\n\r\nRedis是用C语言开发的一个开源的高性能键值对的数据库，他通过提供多种键值的数据类型来适应不同场景下的存储需求，目前为止Redis\r\n支持的数据类型有很多种比如说字符串类型、列表类型、有序集合类型、散列类型、集合类型等。官方还提供了对Redis的测试数据，\r\n由50个并发程序来执行10万次请求，Redis读的速度每秒可以达到11万次，写的速度每秒能达到8万1千次，速度数据是相当惊人的。\r\n\r\n\r\n## 二、Redis与Spring整合\r\n\r\n### 2.1 前言\r\n\r\n在学习Redis的时候，大家应该知道，Java操作redis通常使用的是Jedis，通过java代码来操作redis的数据存储读取等操作，用过的人应该知道，Jedis客户端已经足够简单和轻量级了，但是呢，在此同时，Spring也为Redis提供了支持，就是在Spring-data模块中的Spring-Data-Redis（SDR），它一部分是基于Jedis客户端的API封装，另一部分是对Spring容器的整合。\r\n\r\n大家应该都知道，Spring容器可以作为一个大工厂，为各种对象创建实例，关于SSM与Redis的整合，准确点，其实也就是Spring与Redis的整合。\r\n\r\n又说回来了，Spring要和Redis整合需要用到的，就是Spring-Data模块中的Spring-data-Redis。\r\n\r\n### 2.2 引入依赖\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    \r\n    <groupId>caojx.learn</groupId>\r\n    <artifactId>spring-redis</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n    \r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.12</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    \r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-test</artifactId>\r\n            <version>4.3.12.RELEASE</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    \r\n        <dependency>\r\n            <groupId>org.springframework.data</groupId>\r\n            <artifactId>spring-data-redis</artifactId>\r\n            <version>1.7.2.RELEASE</version>\r\n        </dependency>\r\n        \r\n        <dependency>\r\n            <groupId>redis.clients</groupId>\r\n            <artifactId>jedis</artifactId>\r\n            <version>2.8.1</version>\r\n        </dependency>\r\n    </dependencies>\r\n    \r\n</project>\r\n```\r\n\r\n### 2.3 配置文件\r\n\r\n#### 1. 修改redis.conf\r\n\r\n由于我的redis部署在虚拟机中，我们需要修改redis.config配置文件让redis可以让其他主机访问\r\n\r\n```config\r\n#bind 127.0.0.1 \r\nprotected-mode no\r\n```\r\n\r\n\r\n\r\n#### 2. redis.properties\r\n\r\n```properties\r\n#访问地址,如果redis不是安装在本机，则远程的redis需要允许远程访问\r\nredis.host=127.0.0.1  \r\n#访问端口  \r\nredis.port=6379  \r\n#注意，如果没有password，此处不设置值，但这一项要保留  \r\nredis.password=  \r\n  \r\n#最大空闲数，数据库连接的最大空闲时间。超过空闲时间，数据库连接将被标记为不可用，然后被释放。设为0表示无限制。  \r\nredis.maxIdle=300  \r\n#连接池的最大数据库连接数。设为0表示无限制  \r\nredis.maxActive=600  \r\n#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。  \r\nredis.maxWait=1000  \r\n#在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；  \r\nredis.testOnBorrow=true \r\n```\r\n\r\n#### 3.  redis-context.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\r\n    \r\n    <!-- scanner redis properties  -->\r\n    <context:property-placeholder location=\"classpath:redis.properties\" ignore-unresolvable=\"true\"/>\r\n    \r\n    <!--（1）如果你有多个数据源需要通过<context:property-placeholder管理，且不愿意放在一个配置文件里，那么一定要加上ignore-unresolvable=“true\"-->\r\n    <!--（2）注意新版的（具体从哪个版本开始不清楚，有兴趣可以查一下）JedisPoolConfig的property name，不是maxActive而是maxTotal，而且没有maxWait属性，建议看一下Jedis源码。-->\r\n    \r\n    <!-- redis连接池 -->\r\n    <bean id=\"jedisConfig\" class=\"redis.clients.jedis.JedisPoolConfig\">\r\n        <property name=\"maxTotal\" value=\"${redis.maxActive}\"></property>\r\n        <property name=\"maxIdle\" value=\"${redis.maxIdle}\"></property>\r\n        <property name=\"maxWaitMillis\" value=\"${redis.maxWait}\"></property>\r\n        <property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\"></property>\r\n    </bean>\r\n    \r\n    <!-- redis连接工厂 -->\r\n    <bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\r\n        <property name=\"hostName\" value=\"${redis.host}\"></property>\r\n        <property name=\"port\" value=\"${redis.port}\"></property>\r\n        <property name=\"password\" value=\"${redis.password}\"></property>\r\n        <property name=\"poolConfig\" ref=\"jedisConfig\"></property>\r\n    </bean>\r\n    \r\n    <!-- redis操作模板，这里采用尽量面向对象的模板 -->\r\n    <bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\">\r\n        \r\n        <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\r\n        <!--     如果不配置Serializer，那么存储的时候只能使用String，如果用对象类型存储，那么会提示错误 can\'t cast to String！！！-->\r\n        <property name=\"keySerializer\">\r\n            <bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/>\r\n        </property>\r\n        <property name=\"valueSerializer\">\r\n            <bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/>\r\n        </property>\r\n        <!--开启事务-->\r\n        <property name=\"enableTransactionSupport\" value=\"true\"/>\r\n    </bean>\r\n    \r\n</beans>\r\n```\r\n\r\n注意：\r\n\r\n​	由于我们之前引用了mongo配置文件的properties读取，所以这里的<context:property-placeholder location=\"classpath:redis.properties\"/>在项目加载的时候无法识别里面的占位符错误\"Could not resolve placeholder\"，主要原因是：\r\n\r\n​    	Spring容器采用反射扫描的发现机制，在探测到Spring容器中有一个org.springframework.beans.factory.config.PropertyPlaceholderConfigurer的Bean就会停止对剩余PropertyPlaceholderConfigurer的扫描（Spring 3.1已经使用PropertySourcesPlaceholderConfigurer替代PropertyPlaceholderConfigurer了）。\r\n\r\n而<context:property-placeholder/>这个基于命名空间的配置，其实内部就是创建一个PropertyPlaceholderConfigurer Bean而已。换句话说，即Spring容器仅允许最多定义一个PropertyPlaceholderConfigurer(或<context:property-placeholder/>)，其余的会被Spring忽略掉。\r\n\r\n​	解决方法就是改成<context:property-placeholder location=\"classpath:redis.properties\" \r\n**ignore-unresolvable=\"true\"**/>即可！\r\n\r\n\r\n\r\n### 2.4 测试\r\n\r\n```java\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\n@ContextConfiguration(locations = {\"classpath:redis-context.xml\"})\r\npublic class SpringRedisTest {\r\n    \r\n    @Autowired\r\n    private RedisTemplate redisTemplate;\r\n    \r\n    /**\r\n     * stringRedisTemplate的操作\r\n     */\r\n    @Test\r\n    public void testSpringRedis() {\r\n      \r\n        \r\n        // String读写\r\n        redisTemplate.delete(\"myStr\");\r\n        redisTemplate.opsForValue().set(\"myStr\", \"skyLine\");\r\n        System.out.println(redisTemplate.opsForValue().get(\"myStr\"));\r\n        System.out.println(\"---------------\");\r\n    \r\n        // List读写\r\n        redisTemplate.delete(\"myList\");\r\n        redisTemplate.opsForList().rightPush(\"myList\", \"T\");\r\n        redisTemplate.opsForList().rightPush(\"myList\", \"L\");\r\n        redisTemplate.opsForList().leftPush(\"myList\", \"A\");\r\n        List<String> listCache = redisTemplate.opsForList().range(\"myList\", 0, -1);\r\n        for (String s : listCache) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"---------------\");\r\n    \r\n        // Set读写\r\n        redisTemplate.delete(\"mySet\");\r\n        redisTemplate.opsForSet().add(\"mySet\", \"A\");\r\n        redisTemplate.opsForSet().add(\"mySet\", \"B\");\r\n        redisTemplate.opsForSet().add(\"mySet\", \"C\");\r\n        Set<String> setCache = redisTemplate.opsForSet().members(\"mySet\");\r\n        for (String s : setCache) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"---------------\");\r\n    \r\n        // Hash读写\r\n        redisTemplate.delete(\"myHash\");\r\n        redisTemplate.opsForHash().put(\"myHash\", \"BJ\", \"北京\");\r\n        redisTemplate.opsForHash().put(\"myHash\", \"SH\", \"上海\");\r\n        redisTemplate.opsForHash().put(\"myHash\", \"HN\", \"河南\");\r\n        Map<Object, Object> hashCache = redisTemplate.opsForHash().entries(\"myHash\");\r\n        for (Map.Entry entry : hashCache.entrySet()) {\r\n            System.out.println(entry.getKey() + \" - \" + entry.getValue());\r\n        }\r\n        System.out.println(\"---------------\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n结果：\r\n\r\n```text\r\nskyLine  \r\n---------------  \r\nA  \r\nT  \r\nL  \r\n---------------  \r\nC  \r\nB  \r\nA  \r\n---------------  \r\nHN - 河南  \r\nBJ - 北京  \r\nSH - 上海  \r\n---------------  \r\n```\r\n\r\n\r\n\r\n### 2.5 封装公共操作方法\r\n\r\n上面的代码基本使用的是StringRedisTemplate接口，redisTemplate还提供了list，set，hash类型，同时也可以保存javaBean对象，前提是改对象实现Serializable接口，下面是提出的公共方法\r\n\r\n```java\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.data.redis.core.*;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * redis工具类\r\n */\r\npublic class RedisTemplateUtil {\r\n    \r\n    @Autowired\r\n    private RedisTemplate redisTemplate;\r\n    \r\n    public void set(String key, Object value) {\r\n        ValueOperations valueOperations = redisTemplate.opsForValue();\r\n        valueOperations.set(key, value);\r\n    }\r\n    \r\n    public Object get(String key) {\r\n        return redisTemplate.opsForValue().get(key);\r\n    }\r\n    \r\n    public void setList(String key, List<?> value) {\r\n        ListOperations listOperations = redisTemplate.opsForList();\r\n        listOperations.leftPush(key, value);\r\n    }\r\n    \r\n    public Object getList(String key) {\r\n        return redisTemplate.opsForList().leftPop(key);\r\n    }\r\n    \r\n    public void setSet(String key, Set<?> value) {\r\n        SetOperations setOperations = redisTemplate.opsForSet();\r\n        setOperations.add(key, value);\r\n    }\r\n    \r\n    public Object getSet(String key) {\r\n        return redisTemplate.opsForSet().members(key);\r\n    }\r\n    \r\n    \r\n    public void setHash(String key, Map<String, ?> value) {\r\n        HashOperations hashOperations = redisTemplate.opsForHash();\r\n        hashOperations.putAll(key, value);\r\n    }\r\n    \r\n    public Object getHash(String key) {\r\n        return redisTemplate.opsForHash().entries(key);\r\n    }\r\n    \r\n    \r\n    public void delete(String key) {\r\n        redisTemplate.delete(key);\r\n    }\r\n\r\n    public void clearAll(){\r\n        redisTemplate.multi();\r\n    }\r\n}\r\n```\r\n\r\n## 三、Redis与Spring整合-主从\r\n\r\nredis主从配置下整合到spring \r\n\r\nredis主从配置参考：[redis主从配置.md](https://github.com/caojx-git/learn/blob/master/notes/redis/redis%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE.md)\r\n\r\n### 3.1 配置文件\r\n\r\n#### 1 reids配置\r\n\r\n```shell\r\n[caojx@localhost bin]$ ps -ef | grep redis\r\ncaojx      7248      1  0 07:42 ?        00:00:00 ./redis-server *:6376\r\ncaojx      7258      1  0 07:42 ?        00:00:00 ./redis-server *:6377\r\ncaojx      7268      1  0 07:42 ?        00:00:00 ./redis-server *:6378\r\ncaojx      7279      1  0 07:42 ?        00:00:00 ./redis-server *:6379\r\ncaojx      7294      1  0 07:42 ?        00:00:03 /home/caojx/redis/redis_master/bin/redis-server *:26376 [sentinel]\r\ncaojx      7299      1  1 07:42 ?        00:00:03 /home/caojx/redis/redis_slave1/bin/redis-server *:26377 [sentinel]\r\ncaojx      7304      1  1 07:42 ?        00:00:03 /home/caojx/redis/redis_slave2/bin/redis-server *:26378 [sentinel]\r\ncaojx      7309      1  1 07:42 ?        00:00:03 /home/caojx/redis/redis_slave3/bin/redis-server *:26379 [sentinel]\r\n```\r\n\r\n注意：我的redis在虚拟机中启动，所以需要修改redis.conf和sentinel.conf配置，允许其他主机访问。\r\n\r\n**redis.conf**\r\n\r\n```shell\r\n#bind 127.0.0.1 \r\nprotected-mode no\r\n.....\r\n```\r\n\r\n**sentinel.conf**\r\n\r\n```shell\r\n#bind 127.0.0.1\r\nsentinel monitor mymaster 192.168.46.137 6379 2 #192.168.46.137为虚拟机的ip地址，不能是127.0.0.1\r\nprotected-mode no\r\n....\r\n```\r\n\r\n#### 2. redis-ms.properties \r\n\r\n```properties\r\n#redis主从\r\n\r\n#sentinel1的IP和端口\r\nsentinel1.host=192.168.46.137\r\nsentinel1.port=26376\r\n\r\n#sentinel2的IP和端口\r\nsentinel2.host=192.168.46.137\r\nsentinel2.port=26377\r\n\r\n#sentinel3的IP和端口\r\nsentinel3.host=192.168.46.137\r\nsentinel3.port=26378\r\n\r\n#sentinel4的IP和端口\r\nsentinel4.host=192.168.46.137\r\nsentinel4.port=26379\r\n\r\n#sentinel的鉴权密码\r\nim.hs.server.redis.sentinel.masterName=mymaster\r\nim.hs.server.redis.sentinel.password=123456\r\n\r\n#最大闲置连接数\r\nim.hs.server.redis.maxIdle=500\r\n#最大连接数，超过此连接时操作redis会报错\r\nim.hs.server.redis.maxTotal=5000\r\nim.hs.server.redis.maxWaitTime=1000\r\n#最小闲置连接数，spring启动的时候自动建立该数目的连接供应用程序使用，不够的时候会申请。\r\nim.hs.server.redis.minIdle=300\r\n#在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；\r\nim.hs.server.redis.testOnBorrow=true\r\n```\r\n\r\n#### 3. redis-ms-context.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\r\n    \r\n    <!-- scanner redis properties  -->\r\n    <context:property-placeholder location=\"classpath:redis-ms.properties\" ignore-unresolvable=\"true\"/>\r\n    \r\n    <!-- redis连接池 -->\r\n    <bean id=\"jedisConfig\" class=\"redis.clients.jedis.JedisPoolConfig\">\r\n        <property name=\"maxTotal\" value=\"${im.hs.server.redis.maxTotal}\" />\r\n        <property name=\"minIdle\" value=\"${im.hs.server.redis.minIdle}\" />\r\n        <property name=\"maxWaitMillis\" value=\"${im.hs.server.redis.maxWaitTime}\" />\r\n        <property name=\"maxIdle\" value=\"${im.hs.server.redis.maxIdle}\" />\r\n        <property name=\"testOnBorrow\" value=\"${im.hs.server.redis.testOnBorrow}\" />\r\n    </bean>\r\n    \r\n    <!--哨兵配置-->\r\n    <bean id=\"sentinelConfiguration\" class=\"org.springframework.data.redis.connection.RedisSentinelConfiguration\">\r\n        <property name=\"master\">\r\n            <bean class=\"org.springframework.data.redis.connection.RedisNode\">\r\n                <property name=\"name\" value=\"${im.hs.server.redis.sentinel.masterName}\"></property>\r\n            </bean>\r\n        </property>\r\n        <property name=\"sentinels\">\r\n            <set>\r\n                <bean class=\"org.springframework.data.redis.connection.RedisNode\">\r\n                    <constructor-arg name=\"host\" value=\"${sentinel1.host}\"></constructor-arg>\r\n                    <constructor-arg name=\"port\" value=\"${sentinel1.port}\"></constructor-arg>\r\n                </bean>\r\n                <bean class=\"org.springframework.data.redis.connection.RedisNode\">\r\n                    <constructor-arg name=\"host\" value=\"${sentinel2.host}\"></constructor-arg>\r\n                    <constructor-arg name=\"port\" value=\"${sentinel2.port}\"></constructor-arg>\r\n                </bean>\r\n                <bean class=\"org.springframework.data.redis.connection.RedisNode\">\r\n                    <constructor-arg name=\"host\" value=\"${sentinel3.host}\"></constructor-arg>\r\n                    <constructor-arg name=\"port\" value=\"${sentinel3.port}\"></constructor-arg>\r\n                </bean>\r\n                <bean class=\"org.springframework.data.redis.connection.RedisNode\">\r\n                    <constructor-arg name=\"host\" value=\"${sentinel4.host}\"></constructor-arg>\r\n                    <constructor-arg name=\"port\" value=\"${sentinel4.port}\"></constructor-arg>\r\n                </bean>\r\n            </set>\r\n        </property>\r\n    </bean>\r\n    \r\n    <!--连接工厂-->\r\n    <bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\r\n        <constructor-arg name=\"sentinelConfig\" ref=\"sentinelConfiguration\"></constructor-arg>\r\n        <constructor-arg name=\"poolConfig\" ref=\"jedisConfig\"></constructor-arg>\r\n        <property name=\"password\" value=\"${im.hs.server.redis.sentinel.password}\"></property>\r\n    </bean>\r\n    \r\n    <!-- redis操作模板，这里采用尽量面向对象的模板 -->\r\n    <bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\">\r\n        \r\n        <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\r\n        <!--     如果不配置Serializer，那么存储的时候只能使用String，如果用对象类型存储，那么会提示错误 can\'t cast to String！！！-->\r\n        <property name=\"keySerializer\">\r\n            <bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/>\r\n        </property>\r\n        <property name=\"valueSerializer\">\r\n            <bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/>\r\n        </property>\r\n        <!--开启事务-->\r\n        <property name=\"enableTransactionSupport\" value=\"true\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n### 3.2 测试\r\n\r\n```java\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.test.context.ContextConfiguration;\r\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * spring整合单台多台redis主从\r\n */\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\n@ContextConfiguration(locations = {\"classpath:redis-ms-context.xml\"})\r\npublic class SpringRedisTest2 {\r\n    \r\n    @Autowired\r\n    private RedisTemplate redisTemplate;\r\n    \r\n    /**\r\n     * stringRedisTemplate的操作\r\n     */\r\n    @Test\r\n    public void testSpringRedis() {\r\n      \r\n        \r\n        // String读写\r\n        redisTemplate.delete(\"myStr\");\r\n        redisTemplate.opsForValue().set(\"myStr\", \"skyLine\");\r\n        System.out.println(redisTemplate.opsForValue().get(\"myStr\"));\r\n        System.out.println(\"---------------\");\r\n    \r\n        // List读写\r\n        redisTemplate.delete(\"myList\");\r\n        redisTemplate.opsForList().rightPush(\"myList\", \"T\");\r\n        redisTemplate.opsForList().rightPush(\"myList\", \"L\");\r\n        redisTemplate.opsForList().leftPush(\"myList\", \"A\");\r\n        List<String> listCache = redisTemplate.opsForList().range(\"myList\", 0, -1);\r\n        for (String s : listCache) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"---------------\");\r\n    \r\n        // Set读写\r\n        redisTemplate.delete(\"mySet\");\r\n        redisTemplate.opsForSet().add(\"mySet\", \"A\");\r\n        redisTemplate.opsForSet().add(\"mySet\", \"B\");\r\n        redisTemplate.opsForSet().add(\"mySet\", \"C\");\r\n        Set<String> setCache = redisTemplate.opsForSet().members(\"mySet\");\r\n        for (String s : setCache) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"---------------\");\r\n    \r\n        // Hash读写\r\n        redisTemplate.delete(\"myHash\");\r\n        redisTemplate.opsForHash().put(\"myHash\", \"BJ\", \"北京\");\r\n        redisTemplate.opsForHash().put(\"myHash\", \"SH\", \"上海\");\r\n        redisTemplate.opsForHash().put(\"myHash\", \"HN\", \"河南\");\r\n        Map<Object, Object> hashCache = redisTemplate.opsForHash().entries(\"myHash\");\r\n        for (Map.Entry entry : hashCache.entrySet()) {\r\n            System.out.println(entry.getKey() + \" - \" + entry.getValue());\r\n        }\r\n        System.out.println(\"---------------\");\r\n    }\r\n}\r\n```\r\n\r\n## 四、redis与Spring整合-集群\r\n\r\n注意本节内容来自：[spring整合redis(集群、主从)](https://blog.csdn.net/sunqingzhong44/article/details/70976038?locationNum=6&fps=1) 对应的参考ip端口改成自己的，通过对前面的单台redis与spring整合和redis主从与spring整合，相信很快可以实现redis集群与spring整合\r\n\r\nredis集群参考：[Redis 集群](https://github.com/caojx-git/learn/blob/master/notes/redis/redis%E9%9B%86%E7%BE%A4.md)\r\n\r\n### 4.1 redis-cluster.properties\r\n\r\n```properties\r\nredis.host1=192.168.1.235  \r\nredis.port1=7001  \r\nredis.host2=192.168.1.235  \r\nredis.port2=7002  \r\nredis.host3=192.168.1.235  \r\nredis.port3=7003  \r\nredis.host4=192.168.1.235  \r\nredis.port4=7004  \r\nredis.host5=192.168.1.235  \r\nredis.port5=7005  \r\nredis.host6=192.168.1.235  \r\nredis.port6=7006  \r\n  \r\nredis.maxRedirects=3  \r\nredis.maxIdle=30  \r\nredis.maxTotal=100  \r\nredis.minIdle=5  \r\nredis.maxWaitMillis=30000   \r\nredis.testOnBorrow=true  \r\nredis.testOnReturn=true   \r\nredis.testWhileIdle=true  \r\nredis.timeout=3000  \r\n```\r\n\r\n### 4.2 redis-cluster.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"  \r\n    xmlns:context=\"http://www.springframework.org/schema/context\"  \r\n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"  \r\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"  \r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans    \r\n                            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd    \r\n                            http://www.springframework.org/schema/tx   \r\n                            http://www.springframework.org/schema/tx/spring-tx-4.0.xsd    \r\n                            http://www.springframework.org/schema/context    \r\n                            http://www.springframework.org/schema/context/spring-context-4.0.xsd    \r\n                            http://www.springframework.org/schema/mvc    \r\n                            http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\">  \r\n    \r\n         <bean id=\"redisClusterConfiguration\" class=\"org.springframework.data.redis.connection.RedisClusterConfiguration\">    \r\n                <property name=\"maxRedirects\" value=\"${redis.maxRedirects}\"></property>    \r\n                <property name=\"clusterNodes\">    \r\n                    <set>    \r\n                        <bean class=\"org.springframework.data.redis.connection.RedisNode\">    \r\n                            <constructor-arg name=\"host\" value=\"${redis.host1}\"></constructor-arg>    \r\n                            <constructor-arg name=\"port\" value=\"${redis.port1}\"></constructor-arg>    \r\n                        </bean>    \r\n                        <bean class=\"org.springframework.data.redis.connection.RedisNode\">    \r\n                            <constructor-arg name=\"host\" value=\"${redis.host2}\"></constructor-arg>    \r\n                            <constructor-arg name=\"port\" value=\"${redis.port2}\"></constructor-arg>    \r\n                        </bean>    \r\n                        <bean class=\"org.springframework.data.redis.connection.RedisNode\">    \r\n                            <constructor-arg name=\"host\" value=\"${redis.host3}\"></constructor-arg>    \r\n                            <constructor-arg name=\"port\" value=\"${redis.port3}\"></constructor-arg>    \r\n                        </bean>    \r\n                        <bean class=\"org.springframework.data.redis.connection.RedisNode\">    \r\n                            <constructor-arg name=\"host\" value=\"${redis.host4}\"></constructor-arg>    \r\n                            <constructor-arg name=\"port\" value=\"${redis.port4}\"></constructor-arg>    \r\n                        </bean>    \r\n                        <bean class=\"org.springframework.data.redis.connection.RedisNode\">    \r\n                            <constructor-arg name=\"host\" value=\"${redis.host5}\"></constructor-arg>    \r\n                            <constructor-arg name=\"port\" value=\"${redis.port5}\"></constructor-arg>    \r\n                        </bean>    \r\n                        <bean class=\"org.springframework.data.redis.connection.RedisNode\">    \r\n                            <constructor-arg name=\"host\" value=\"${redis.host6}\"></constructor-arg>    \r\n                            <constructor-arg name=\"port\" value=\"${redis.port6}\"></constructor-arg>    \r\n                        </bean>    \r\n                </set>    \r\n        </property>    \r\n    </bean>    \r\n      \r\n      \r\n    <bean id=\"jedisPoolConfig\"   class=\"redis.clients.jedis.JedisPoolConfig\">    \r\n        <property name=\"maxTotal\" value=\"${redis.maxTotal}\" />  \r\n        <property name=\"maxIdle\" value=\"${redis.maxIdle}\" />  \r\n        <property name=\"maxWaitMillis\" value=\"${redis.maxWaitMillis}\" />  \r\n        <property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\" />  \r\n    </bean>    \r\n         \r\n    <bean id=\"jeidsConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"  >    \r\n          \r\n         <property name=\"poolConfig\" ref=\"jedisPoolConfig\" />  \r\n         <constructor-arg name=\"clusterConfig\" ref=\"redisClusterConfiguration\"/>    \r\n        <constructor-arg name=\"poolConfig\" ref=\"jedisPoolConfig\"/>     \r\n        <!-- <property name=\"timeout\" value=\"${redis.timeout}\" /> -->  \r\n    </bean>    \r\n        \r\n    <bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\">    \r\n        <property name=\"connectionFactory\" ref=\"jeidsConnectionFactory\" />  \r\n         <property name=\"keySerializer\" >    \r\n            <bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" />    \r\n        </property>    \r\n        <property name=\"valueSerializer\" >    \r\n            <bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\" />    \r\n        </property>    \r\n        <property name=\"hashKeySerializer\">    \r\n            <bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/>    \r\n        </property>    \r\n        <property name=\"hashValueSerializer\">    \r\n            <bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/>    \r\n        </property>    \r\n    </bean>     \r\n          \r\n  </beans>  \r\n```\r\n\r\n\r\n\r\n## 五、参考博文\r\n\r\n[架构之路之spring+redis的集成](https://blog.csdn.net/tomcat_2014/article/details/55260306)\r\n\r\n[SSM整合redis](https://blog.csdn.net/u010690828/article/details/77141083)\r\n\r\n[spring整合redis(集群、主从)](https://blog.csdn.net/sunqingzhong44/article/details/70976038?locationNum=6&fps=1)\r\n\r\n[Spring整合redis，通过sentinel进行主从切换](https://blog.csdn.net/albertfly/article/details/61419502)', 0);
INSERT INTO `blog_course` VALUES (270, 'Spring Boot 入门（1）', 5, '# Spring Boot入门\r\n\r\n[TOC]\r\n\r\n参考原文：http://blog.java1234.com/blog/articles/329.html\r\n\r\nSprintBoot学习代码：https://github.com/caojx-git/learn/tree/master/code/springboot-learn/springboot-helloword\r\n\r\nSpring Boot 官网：https://projects.spring.io/spring-boot/\r\n\r\n\r\n\r\n## 一、简介\r\n\r\n> 现如今，互联网的热点已经成为微服务了，如果你到现在还没有听说过微服务，或者还不了解，那表示你已经out了，需要开始作准备了。现在主流的微服务框架包括早期阿里的Dubbo，以及现在热门的SpringCloud，所以我们开始要准备开始学习SpringCloud了，扯远了，因为SpringCloud是基于SpringBoot结构上去进行开发，所以我们也要学习SpringBoot，平时我们使用SSM，SSH等，是不是配置文件一大堆，而且经常不知道哪里配置错了，导致问题很多。SpringBoot就是为了解决这个问题的。使用起来非常简单。\r\n\r\n### 1.1 SpringBoot简介\r\n\r\nSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。\r\n\r\nSpring Boot特点：\r\n\r\n1. 创建独立的Spring应用程序\r\n2. 嵌入的Tomcat，无需部署WAR文件\r\n3. 简化Maven配置\r\n4. 自动配置Spring\r\n5. 提供生产就绪型功能，如指标，健康检查和外部配置\r\n6. 绝对没有代码生成和对XML没有要求配置\r\n\r\n\r\n## 二、 Hello World\r\n\r\n本节内容主要参见：http://blog.java1234.com/blog/articles/330.html\r\n\r\n###2.1 建立Spring Boot工程\r\n\r\nEclipse建立Spring Boot工程，可以参考：http://blog.java1234.com/blog/articles/330.html\r\n\r\n下边演示Intellij IDEA创建SpringBoot项目\r\n\r\n1. 选择Spring Initializr，选择一个jdk版本，这里我们选择1.8，Initializr Service URL地址默认就可以\r\n\r\n![](../images/spring/springboot/springboot_1.png)  \r\n\r\n2. 如图页面，按照需要输入修改即可，Group，Artifact，Package等信息\r\n\r\n![](../images/spring/springboot/springboot_2.png)  \r\n\r\n3. 这个页面选择的是项目依赖，这个是spring-boot集成其它框架的选项，可以勾选多个，spring-boot就会帮我们集成到项目里，非常简单方便,这里我就简单使用web。\r\n\r\n![](../images/spring/springboot/springboot_3.png)  \r\n\r\n4. 输入项目名称，选择项目存放的路径，下面的模块名称一般会随着上方的输入自动变化，如果只有一个模块保持默认即可。\r\n\r\n![](../images/spring/springboot/springboot_4.png)  \r\n\r\n5. 创建完成之后，需要等待一段时间，等待spring-boot为我们创建项目和下载依赖包，构建完成之后，如图所示的目录结构帮我们生成好了。还会生成一个SpringbootHellowordApplication类，这个类里面有个main方法，就是启动项目的入口文件。\r\n\r\n	意：启动前需要修改一下pom.xml文件	去掉\\<scope>provided\\</scope>，不然无法启动\r\n\r\n```xml\r\n<dependency>\r\n	<groupId>org.springframework.boot</groupId>\r\n	<artifactId>spring-boot-starter-tomcat</artifactId>\r\n	<scope>provided</scope>\r\n</dependency>\r\n改为\r\n<dependency>\r\n	<groupId>org.springframework.boot</groupId>\r\n	<artifactId>spring-boot-starter-tomcat</artifactId>\r\n</dependency>\r\n```\r\n假如不去掉\\<scope>provided\\</scope>，会出现如下错误，无法启动\r\n\r\n```text\r\n2018-03-21 13:53:33.484  INFO 5251 --- [       Thread-5] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown\r\n```\r\n\r\n6. 我们右击Run As 选择 Spring Boot app，这里我们不需要Tomcat 因为SpringBoot把Tomcat集成了，默认端口8080\r\n\r\n![](../images/spring/springboot/springboot_5.png)\r\n\r\n我们浏览器输入：<http://localhost:8080/>\r\n\r\n出现这个 说明项目启动成功\r\n\r\n![](../images/spring/springboot/springboot_6.png)  \r\n\r\n### 2.2 编码\r\n\r\n我们现在配置一个HelloWorld请求,在caojx.learn.springboothelloword包下，新建一个HelloWorldController类\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.controller;\r\n\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HelloWorldController {\r\n\r\n	@RequestMapping(\"/hello\")\r\n	public String say(){\r\n		return \"spring boot hello world\";\r\n	}\r\n}\r\n```\r\n\r\n注意，新建的类一定要在caojx.learn.springboothelloword包下，即所有新建的包需要在SpringBoot的启动类（SpringbootHellowordApplication）下，不然无法识别，会出现如下错误\r\n\r\n```html\r\nWhitelabel Error Page\r\n \r\n\r\nThis application has no explicit mapping for /error, so you are seeing this as a fallback.\r\n\r\nWed Dec 14 16:35:25 CST 2016\r\nThere was an unexpected error (type=Not Found, status=404).\r\nNo message available\r\n```\r\n\r\n问题很像是没有访问地址不对，第一感觉以为url写的不对。\r\n\r\n其实不是，真正的原因是【Application启动类放的位置不对】要将Application放在最外层，也就是要包含所有子包。springboot会自动加载启动类所在包下及其子包下的所有组件。\r\n\r\n\r\n\r\n然后我们重新启动SpringbootHellowordApplication类\r\n\r\n请求 <http://localhost:8080/hello>\r\n\r\n![](../images/spring/springboot/springboot_7.png)  \r\n\r\n## 三、SpringBoot项目属性配置\r\n\r\n本节内容主要参见：http://blog.java1234.com/blog/articles/331.html\r\n\r\n其他文章推荐：https://blog.csdn.net/saytime/article/details/74781708\r\n\r\nSpringBoot项目中有个application.properties项目配置文件，打开是空白 里面可以配置项目相关的一些配置，编辑的时候IDEA会自动提示，Eclipse可能需要按alt+/ 提示出来。配置属性有很多，我这里只使用了部分属性\r\n\r\n### 3.1 修改tomcat端口和访问路径\r\n\r\n上一讲tomcat默认端口8080 默认路径是根目录/\r\n\r\n我们现在改成 端口8080 以及上下文路径/HelloWorld\r\n\r\n![](../images/spring/springboot/springboot_8.png)\r\n\r\n\r\n\r\n改完后保存，启动HelloWorldApplication类\r\n\r\n页面输入：http://localhost:8888/HelloWorld/hello\r\n\r\n结果出来了\r\n\r\n![](../images/spring/springboot/springboot_9.png)  \r\n\r\n### 3.2 SpringBoot支持自定义属性\r\n\r\n上边我们使用的是SpringBoot提供的一些属性配置，我们也可以自定义一些属性\r\n\r\n我们在application.properties中加一个helloWorld属性，属性值spring Boot大爷你好\r\n\r\n```properties\r\nserver.port=8888\r\nserver.context-path=/HelloWorld\r\nhelloWorld=Spring Boot hello world\r\n```\r\n\r\n当然对中文字节编码处理了\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.controller;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n/**\r\n * 使用自定义属性\r\n */\r\n@RestController\r\npublic class HelloWorldController2 {\r\n\r\n	//注入 application.properties中定义的属性\r\n	@Value(\"${helloWorld}\")\r\n	private String helloWorld;\r\n\r\n	@RequestMapping(\"/hello2\")\r\n	public String say(){\r\n		return helloWorld;\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n我们重启HelloWorldApplication类，\r\n\r\n页面输入：<http://localhost:8888/HelloWorld/hello2>\r\n\r\n![](../images/spring/springboot/springboot_10.png)  \r\n\r\n\r\n\r\n**假如我们要配置一个类别下的多个属性，**\r\n\r\n比如mysql的jdbc连接配置\r\n\r\nmysql.jdbcName=com.mysql.jdbc.Driver\r\n\r\nmysql.dbUrl=jdbc:mysql://localhost:3306/db_diary\r\n\r\nmysql.userName=root\r\n\r\nmysql.password=123456\r\n\r\n我们贴到application.properties\r\n\r\n然后按照前面的方案，我们在Controller里写四个属性；\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.controller;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n/**\r\n * 使用自定义属性\r\n */\r\n@RestController\r\npublic class HelloWorldController3 {\r\n\r\n	@Value(\"${helloWorld}\")\r\n	private String helloWorld;\r\n\r\n	@Value(\"${mysql.jdbcName}\")\r\n	private String jdbcName;\r\n\r\n	@Value(\"${mysql.dbUrl}\")\r\n	private String dbUrl;\r\n\r\n	@Value(\"${mysql.userName}\")\r\n	private String userName;\r\n\r\n	@Value(\"${mysql.password}\")\r\n	private String password;\r\n	\r\n	@RequestMapping(\"/showJdbc\")\r\n	public String showJdbc(){\r\n		return \"mysql.jdbcName:\"+jdbcName+\"<br/>\"\r\n				+\"mysql.dbUrl:\"+dbUrl+\"<br/>\"\r\n				+\"mysql.userName:\"+userName+\"<br/>\"\r\n				+\"mysql.password:\"+password;\r\n\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n重启启动类，\r\n\r\n页面输入：<http://localhost:8888/HelloWorld/showJdbc>\r\n\r\n![](../images/spring/springboot/springboot_11.png)  \r\n\r\n\r\n\r\n上面那种 假如属性很多 要写一大串 假如多个地方使用 每个地方都得写这么多 不可取 \r\n\r\n下面我们介绍ConfigurationProperties配置方式\r\n\r\n新建一个MysqlProperties类 把所有属性都配置上去\r\n\r\n执行前缀msyql\r\n\r\n以及加上@Component作为组件 方便其他地方注入\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.controller;\r\n\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;\r\nimport org.springframework.stereotype.Component;\r\n\r\n/**\r\n * Mysql属性配置文件,\r\n * 将上面application.properties文件中的mysql配置注入到该实体类，注意这里的prefix指定的是mysql，对应\r\n * 配置文件中的结构\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午5:00\r\n */\r\n@Component\r\n@ConfigurationProperties(prefix=\"mysql\")\r\n class MysqlProperties {\r\n\r\n    private String jdbcName;\r\n\r\n    private String dbUrl;\r\n\r\n    private String userName;\r\n\r\n    private String password;\r\n\r\n    public String getJdbcName() {\r\n        return jdbcName;\r\n    }\r\n\r\n    public void setJdbcName(String jdbcName) {\r\n        this.jdbcName = jdbcName;\r\n    }\r\n\r\n    public String getDbUrl() {\r\n        return dbUrl;\r\n    }\r\n\r\n    public void setDbUrl(String dbUrl) {\r\n        this.dbUrl = dbUrl;\r\n    }\r\n\r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n\r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n\r\n    public String getPassword() {\r\n        return password;\r\n    }\r\n\r\n    public void setPassword(String password) {\r\n        this.password = password;\r\n    }\r\n}\r\n```\r\n\r\n需要引入依赖到pom.xml\r\n\r\n```xml\r\n<dependency>\r\n	<groupId>org.springframework.boot</groupId>\r\n	<artifactId>spring-boot-configuration-processor</artifactId>\r\n	<optional>true</optional>\r\n</dependency>\r\n```\r\n\r\n使用\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.controller;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n/**\r\n * 使用自定义属性\r\n */\r\n@RestController\r\npublic class HelloWorldController4 {\r\n\r\n	@Autowired\r\n	private MysqlProperties mysqlProperties;\r\n\r\n	@RequestMapping(\"/showJdbc2\")\r\n	public String showJdbc(){\r\n		return \"mysql.jdbcName:\"+mysqlProperties.getJdbcName()+\"<br/>\"\r\n				+\"mysql.dbUrl:\"+mysqlProperties.getDbUrl()+\"<br/>\"\r\n				+\"mysql.userName:\"+mysqlProperties.getUserName()+\"<br/>\"\r\n				+\"mysql.password:\"+mysqlProperties.getPassword();\r\n\r\n	}\r\n}\r\n```\r\n\r\n只需要定义MysqlProperties即可 方便很多 运行结果和之前一样\r\n\r\nhttp://localhost:8888/HelloWorld/showJdbc2\r\n\r\n![](../images/spring/springboot/springboot_12.png)  \r\n\r\n\r\n\r\n\r\n\r\n## 四、SpringBoot之Controller使用\r\n\r\n本节内容主要参见：http://blog.java1234.com/blog/articles/332.html\r\n\r\n本节主要了解如下注解\r\n\r\n@Controller	处理http请求\r\n@RestController	Spring4之后新加的注解，原来返回json需要@ResponseBody配合@Controller\r\n@RequestMapping	配置url映射\r\n@PathVariable	获取url中的数据\r\n@RequestParam	获取请求参数中的值\r\n\r\n\r\n\r\n### 4.1 前言\r\n\r\n项目前后台交互的话 无非两种方式\r\n\r\n- 一种普通整体页面提交，比如form提交；\r\n- 还有一种局部刷新，或者叫做异步刷新，ajax提交；\r\n\r\n@Controller就是整体页面刷新提交的处理注解\r\n\r\n@RestController就是ajax提交，一般返回json格式，相当于我们经常使用的@ResponseBody配合@Controller组合\r\n\r\n各有用处的；\r\n\r\n### 4.2 编码\r\n\r\n这里我们分别来演示上面两种交互。请求后台，必须返回一个视图，以前我们一般用Jsp，但是SpringBoot不推荐我们实用jsp，主要是强调前后台分离；官方推荐的是这几种模版视图引擎，我一般推荐Freemarker和Velocity；\r\n\r\n\r\n\r\n添加freemarker支持，在pom.xml文件添加对应的依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-freemarker</artifactId>\r\n</dependency>\r\n```\r\n\r\n然后我们新建一个新的Controller类 HelloWorldFreemakerController\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.controller;\r\n\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\n/**\r\n * 返回到freemaker视图\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午5:29\r\n */\r\n@Controller\r\n@RequestMapping(\"/freemarker\")\r\npublic class HelloWorldFreemakerController {\r\n\r\n    /**\r\n     * 设置数据，返回到freemarker视图\r\n     * @return\r\n     */\r\n    @RequestMapping(\"/say\")\r\n    public ModelAndView say(){\r\n        ModelAndView mav=new ModelAndView();\r\n        mav.addObject(\"message\", \"SpringBoot 大爷你好！\");\r\n        mav.setViewName(\"helloWorld\");\r\n        return mav;\r\n    }\r\n}\r\n```\r\n\r\n对应的，我们在templates下新建一个helloWorld.ftl模版文件\r\n\r\n![](../images/spring/springboot/springboot_13.png)  \r\n\r\n\r\n\r\nhelloWorld.ftl模版文件内容：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>Insert title here</title>\r\n</head>\r\n<body>\r\nshow:${message}\r\n</body>\r\n</html>\r\n```\r\n\r\n我们测试下，启动HelloWorldApplication\r\n\r\n然后浏览器输入：<http://localhost:8888/HelloWorld/freemarker/say>\r\n\r\n页面显示结果：\r\n\r\n![](../images/spring/springboot/springboot_14.png)  \r\n\r\n\r\n\r\n我们在演示下@RestController，ajax方式\r\n\r\n我们新建一个HelloWorldAjaxController类\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.controller;\r\n \r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n \r\n \r\n/**\r\n * 返回ajax json格式\r\n * @author user\r\n *\r\n */\r\n@RestController\r\n@RequestMapping(\"/ajax\")\r\npublic class HelloWorldAjaxController {\r\n \r\n    @RequestMapping(\"/hello\")\r\n    public String say(){\r\n        return \"{\'message1\': \'SpringBoot你大爷\',\'message2\',\'SpringBoot你大爷2\'}\";\r\n    }\r\n}\r\n```\r\n\r\n返回json串\r\n\r\n\r\n\r\n这里我们用的是jquery，随便找个jquery.js\r\n\r\n![](../images/spring/springboot/springboot_15.png)  \r\n\r\n\r\n\r\nindex.html代码，一个ajax请求\r\n\r\n```html\r\n\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>Insert title here</title>\r\n<script src=\"jQuery.js\"></script>\r\n<script type=\"text/javascript\">\r\n    function show(){\r\n        $.post(\"ajax/hello\",{},\r\n                function(result){\r\n                    alert(result);\r\n                }\r\n            );\r\n    }\r\n     \r\n</script>\r\n</head>\r\n<body>\r\n<button onclick=\"show()\">你大爷</button>\r\n</body>\r\n</html>\r\n```\r\n\r\n启动HelloWorldApplication类\r\n\r\n页面先请求index.html\r\n\r\n浏览器输入：<http://localhost:8888/HelloWorld/>\r\n\r\n![](../images/spring/springboot/springboot_16.png)  \r\n\r\n当然这里的json比较简单，所以我直接返回； 实际项目Json格式复杂，要借助于一些json框架，比如Json-lib，gson等；\r\n\r\n\r\n\r\n当然还有一些比如\r\n\r\n@PathVariable 获取url中的数据，获取路径中的值\r\n\r\n@RequestParam 获取请求参数中的值\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.controller;\r\n\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.PathVariable;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestParam;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\n@Controller\r\n@RequestMapping(\"/blog\")\r\npublic class BlogController {\r\n\r\n	/**\r\n	 * @PathVariable 配合 @RequestMapping使用可以获取到路径中的参数\r\n	 * http://localhost:8888/HelloWorld/blog/21  则 id=21\r\n	 * @param id\r\n	 * @return\r\n	 */\r\n	@RequestMapping(\"/{id}\")\r\n	public ModelAndView show(@PathVariable(\"id\") Integer id){\r\n		ModelAndView mav=new ModelAndView();\r\n		mav.addObject(\"id\", id);\r\n		mav.setViewName(\"blog\");\r\n		return mav;\r\n	}\r\n\r\n	/**\r\n	 * RequestParam 获取提交的参数\r\n	 * \r\n	 * http://localhost:8888/HelloWorld/blog/query?q=123456 则q = 123456\r\n	 * @param q\r\n	 * @return\r\n	 */\r\n	@RequestMapping(\"/query\")\r\n	public ModelAndView query(@RequestParam(value=\"q\",required=false)String q){\r\n		ModelAndView mav=new ModelAndView();\r\n		mav.addObject(\"q\", q);\r\n		mav.setViewName(\"query\");\r\n		return mav;\r\n	}\r\n}\r\n```\r\n\r\n## 五、SpringBoot操作之Spring-Data-Jpa\r\n\r\n本节内容主要参见：http://blog.java1234.com/blog/articles/333.html\r\n\r\nSprintBoot整合MyBatis参考：https://blog.csdn.net/saytime/article/details/74783296\r\n\r\n**Spring-Data-Jpa** JPA(Java Persistence API)定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate、TopLink等。\r\n\r\nSpring Data JPA 框架，主要针对的就是 Spring 唯一没有简化到的业务逻辑代码，至此，开发者连仅剩的实现持久层业务逻辑的工作都省了，唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！\r\n\r\n### 5.1 准备\r\n\r\n我这里使用的数据是mariadb与mysql用法一致，引入对应的依赖\r\n\r\n```xml\r\n<!--mariadb-->\r\n<dependency>\r\n    <groupId>org.mariadb.jdbc</groupId>\r\n    <artifactId>mariadb-java-client</artifactId>\r\n</dependency>\r\n\r\n<!--spring jpa支持-->\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\r\n</dependency>\r\n```\r\n\r\n接下来配置application.properties\r\n\r\n```properties\r\nspring.datasource.driver-class-name=org.mariadb.jdbc.Driver\r\nspring.datasource.url=jdbc:mariadb://192.168.46.134:3306/db_book？createDatabaseIfNotExist=true&useUnicode=true&characterEncoding=utf8\r\nspring.datasource.username=root\r\nspring.datasource.password=root\r\n\r\nspring.jpa.hibernate.ddl-auto=update\r\nspring.jpa.show-sql=true\r\n```\r\n\r\n上面是配置数据源\r\n\r\n下面是配置比如ddl-auto 学过hibernate的都知道 我们一般用update 更新操作\r\n\r\nshow-sql 是显示sql语句\r\n\r\n注意：上面我们会发现 这种properties形式的配置有点冗余，后面一一帖我们改成主流的yml形式\r\n\r\n\r\n\r\n### 5.2 编码\r\n\r\n使用Spring-Data-Jpa来实现CRUD操作，视图层采用Freemarker\r\n\r\n1.新建一个Book实体\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.jpa;\r\n\r\nimport javax.persistence.*;\r\n\r\n/**\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午7:58\r\n */\r\n\r\n@Entity\r\n@Table(name=\"t_book\")\r\npublic class Book {\r\n\r\n    @Id\r\n    @GeneratedValue\r\n    private Integer id;\r\n\r\n    @Column(length=100)\r\n    private String bookName;\r\n\r\n    @Column(length = 100)\r\n    private String author;\r\n\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getBookName() {\r\n\r\n        return bookName;\r\n    }\r\n    public void setBookName(String bookName) {\r\n        this.bookName = bookName;\r\n    }\r\n\r\n    public String getAuthor() {\r\n        return author;\r\n    }\r\n\r\n    public void setAuthor(String author) {\r\n        this.author = author;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n2.这里我们先把application.properties修改成application.yml 主流格式\r\n\r\n 在 spring boot 中，有两种配置文件，一种是application.properties,另一种是application.yml,两种都可以配置spring boot 项目中的一些变量的定义，参数的设置等，yml 文件在写的时候层次感强，而且少写了代码。所以现在很多人都使用yml配置文件。\r\n\r\n可以参考：https://www.cnblogs.com/baoyi/p/SpringBoot_YML.html\r\n\r\napplication.yml\r\n\r\n```yml\r\nserver:\r\n  port: 8888\r\n  servlet:\r\n    context-path: /HelloWorld\r\n\r\nhelloWorld: Spring Boot Hello World\r\n\r\nmysql:\r\n     jdbcName: com.mysql.jdbc.Driver\r\n     dbUrl: jdbc:mysql://localhost:3306/db_diary\r\n     userName: root\r\n     password: 123456\r\n\r\nspring:\r\n   datasource:\r\n      driver-class-name: org.mariadb.jdbc.Driver\r\n      url: jdbc:mariadb://192.168.46.134:3306/db_book?createDatabaseIfNotExist=true&useUnicode=true&characterEncoding=utf8\r\n      username: root\r\n      password: root\r\n   jpa:\r\n     hibernate.ddl-auto: update\r\n     show-sql: true\r\n```\r\n\r\n**yml格式有个注意点 冒号后面一定要加个空格,还有我们把context-path改成/方便开发应用**\r\n\r\n3. 图书Dao接口，要求实现JpaRepository,和JpaSpecificationExecutor接口\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.jpa;\r\n\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\r\nimport org.springframework.data.jpa.repository.Query;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * 图书Dao接口，要求实现JpaRepository\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午8:19\r\n */\r\npublic interface BookDao extends JpaRepository<Book,Integer>, JpaSpecificationExecutor<Book> {\r\n\r\n    /**\r\n     * 使用SQL查询\r\n     * @param name\r\n     * @return\r\n     */\r\n    @Query(\"select b from Book b where b.bookName like %?1%\")\r\n    public List<Book> findByName(String name);\r\n\r\n    /**\r\n     * 使用SQL查询\r\n     * @param n\r\n     * @return\r\n     */\r\n    @Query(value=\"select * from t_book order by RAND() limit ?1\",nativeQuery=true)\r\n    public List<Book> randomList(Integer n);\r\n}\r\n```\r\n\r\n4. BookController,我们这里就不编写Service了，直接在这里操作Dao实现CRUD，当然真实企业开发不会这样做。\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.jpa;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\n/**\r\n * Book控制类\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午8:23\r\n */\r\n@Controller\r\n@RequestMapping(\"/book\")\r\npublic class BookController {\r\n\r\n   @Resource\r\n	private BookDao bookDao;\r\n	\r\n	/**\r\n	 * 查询所有图书\r\n	 * @return\r\n	 */\r\n	@RequestMapping(\"/list\")\r\n	public ModelAndView list(){\r\n		ModelAndView mav=new ModelAndView();\r\n		mav.addObject(\"bookList\", bookDao.findAll());\r\n		mav.setViewName(\"bookList\");\r\n		return mav;\r\n	}\r\n	\r\n	/**\r\n	 * 根据条件动态查询\r\n	 * @param book\r\n	 * @return\r\n	 */\r\n	@RequestMapping(\"/list2\")\r\n	public ModelAndView list2(Book book){\r\n		ModelAndView mav=new ModelAndView();\r\n		List<Book> bookList=bookDao.findAll(new Specification<Book>() {\r\n			@Override\r\n			public Predicate toPredicate(Root<Book> root, CriteriaQuery<?> query, CriteriaBuilder cb) {\r\n				Predicate predicate=cb.conjunction();\r\n				if(book!=null){\r\n					if(book.getBookName()!=null && !\"\".equals(book.getBookName())){\r\n						predicate.getExpressions().add(cb.like(root.get(\"bookName\"), \"%\"+book.getBookName()+\"%\"));\r\n					}\r\n					if(book.getAuthor()!=null && !\"\".equals(book.getAuthor())){\r\n						predicate.getExpressions().add(cb.like(root.get(\"author\"), \"%\"+book.getAuthor()+\"%\"));\r\n					}\r\n				}\r\n				return predicate;\r\n			}\r\n		});\r\n		mav.addObject(\"bookList\", bookList);\r\n		mav.setViewName(\"bookList\");\r\n		return mav;\r\n	}\r\n	\r\n	/**\r\n	 * 添加图书\r\n	 * @param book\r\n	 * @return\r\n	 */\r\n	@RequestMapping(value=\"/add\",method=RequestMethod.POST)\r\n	public String add(Book book){\r\n		bookDao.save(book);\r\n		return \"forward:/book/list\";\r\n	}\r\n	\r\n	/**\r\n	 * 根据id查询book实体\r\n	 * @param id\r\n	 * @return\r\n	 */\r\n	@RequestMapping(\"/preUpdate/{id}\")\r\n	public ModelAndView preUpdate(@PathVariable(\"id\")Integer id){\r\n		ModelAndView mav=new ModelAndView();\r\n		mav.addObject(\"book\", bookDao.getOne(id));\r\n		mav.setViewName(\"bookUpdate\");\r\n		return mav;\r\n	}\r\n	\r\n	/**\r\n	 * 修改图书\r\n	 * @param book\r\n	 * @return\r\n	 */\r\n	@PostMapping(value=\"/update\")\r\n	public String update(Book book){\r\n		bookDao.save(book);\r\n		return \"forward:/book/list\";\r\n	}\r\n	\r\n	@GetMapping(\"/delete\")\r\n	public String delete(Integer id){\r\n		bookDao.deleteById(id);\r\n		return \"forward:/book/list\";\r\n	}\r\n	\r\n	@ResponseBody\r\n	@GetMapping(\"/queryByName\")\r\n	public List<Book> queryByName(){\r\n		return bookDao.findByName(\"编程\");\r\n	}\r\n	\r\n	@ResponseBody\r\n	@GetMapping(\"/randomList\")\r\n	public List<Book> randomList(){\r\n		return bookDao.randomList(2);\r\n	}\r\n}\r\n```\r\n\r\n这里的@GetMapping(value=\"xxx\") 类似  @RequestMapping(value=\"xxx\",method=RequestMethod.GET)\r\n\r\n以及@PostMapping(value=\"xxx\") 类似  @RequestMapping(value=\"xxx\",method=RequestMethod.POST)\r\n\r\n5. bookList.ftl 展示数据\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>图书管理</title>\r\n</head>\r\n<body>\r\n<a href=\"/bookAdd.html\">添加</a><br/>\r\n<form method=\"post\" action=\"/book/list2\">\r\n	图书名称：<input type=\"text\" name=\"bookName\" />&nbsp;\r\n	图书作者：<input type=\"text\" name=\"author\" />&nbsp;\r\n	<input type=\"submit\" value=\"搜索\"/>\r\n</form>\r\n<table>\r\n	<tr>\r\n		<th>编号</th>\r\n		<th>图书名称</th>\r\n		<th>图书作者</th>\r\n		<th>操作</th>\r\n	</tr>\r\n	<#list bookList as book>\r\n		<tr>\r\n			<td>${book.id}</td>\r\n			<td>${book.bookName}</td>\r\n            <td>${book.author}</td>\r\n			<td>\r\n				<a href=\"/book/preUpdate/${book.id}\">修改</a>\r\n				<a href=\"/book/delete?id=${book.id}\">删除</a>\r\n			</td>\r\n		</tr>\r\n	</#list>\r\n</table>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n\r\n6. bookAdd.html 图书添加页面\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>图书添加页面</title>\r\n</head>\r\n<body>\r\n<form action=\"book/add\" method=\"post\">\r\n    图书名称：<input type=\"text\" name=\"bookName\"/><br/>\r\n    图书作者：<input type=\"text\" name=\"author\"/><br/>\r\n    <input type=\"submit\" value=\"提交\"/>\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n\r\n7. bookUpdate.ftl图书修改页面\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>图书修改</title>\r\n</head>\r\n<body>\r\n<form action=\"/book/update\" method=\"post\">\r\n	<input type=\"hidden\" name=\"id\" value=\"${book.id}\"/>\r\n	图书名称：<input type=\"text\" name=\"bookName\" value=\"${book.bookName}\"/><br/>\r\n    图书作者：<input type=\"text\" name=\"author\" value=\"${book.author}\"/><br/>\r\n    <input type=\"submit\" value=\"提交\"/>\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n\r\n结果：\r\n\r\n![](../images/spring/springboot/springboot_17.png)  \r\n\r\n\r\n\r\n## 六、SpringBoot之事务管理@Transactional\r\n\r\n本节内容主要参见：http://blog.java1234.com/blog/articles/335.html\r\n\r\n### 6.1 前言\r\n\r\n以前学ssh ssm都有事务管理service层通过applicationContext.xml配置，在service类或所有service方法都加上事务操作；\r\n\r\n用来保证一致性，即service方法里的多个dao操作，要么同时成功，要么同时失败；\r\n\r\nspringboot下的话 搞一个@Transactional即可\r\n\r\n### 6.1 编码\r\n\r\n我们这里搞一个实例，转账实例，A用户转账给B用户xx元\r\n\r\n\r\n\r\n1. Account类\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.transactional;\r\n\r\nimport javax.persistence.*;\r\n\r\n/**\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午10:14\r\n */\r\n@Entity\r\n@Table(name=\"t_account\")\r\npublic class Account {\r\n\r\n    /**\r\n     * id 编号\r\n     */\r\n    @Id\r\n    @GeneratedValue\r\n    private Integer id;\r\n\r\n    /**\r\n     * 用户名\r\n     */\r\n    @Column(length=50)\r\n    private String userName;\r\n\r\n    /**\r\n     * 余额\r\n     */\r\n    private float balance;\r\n\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n\r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n\r\n    public float getBalance() {\r\n        return balance;\r\n    }\r\n\r\n    public void setBalance(float balance) {\r\n        this.balance = balance;\r\n    }\r\n}\r\n```\r\n\r\n2. 启动启动类，会自动创建表t_account，我们插入两条数据（这里我练习还是使用之前 db_book 库，可以自己切换其他库）\r\n\r\n\r\n```mysql\r\ninsert into t_account values(1,700,\'zhangsan\');\r\ninsert into t_account values(2,300,\'lisi\');\r\n```\r\n\r\n![](../images/spring/springboot/springboot_18.png)  \r\n\r\n3. 新建AccountDao接口\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.transactional;\r\n\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\n/**\r\n * 账户Dao接口\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午10:17\r\n */\r\npublic interface AccountDao extends JpaRepository<Account, Integer> {\r\n}\r\n```\r\n\r\n4. AccountService接口\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.transactional;\r\n\r\n/**\r\n * 帐号Service接口\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午10:18\r\n */\r\npublic interface AccountService {\r\n\r\n    /**\r\n     * 转账\r\n     * @param fromUserId\r\n     * @param toUserId\r\n     * @param account\r\n     */\r\n    public void transferAccounts(int fromUserId,int toUserId,float account);\r\n}\r\n```\r\n\r\n5. AccountServiceImpl接口实现类\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.transactional;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport javax.annotation.Resource;\r\nimport javax.transaction.Transactional;\r\n\r\n/**\r\n * 帐号Service实现类\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午10:19\r\n */\r\n//@Transactional\r\n@Service(\"accountService\")\r\npublic class AccountServiceImpl implements AccountService {\r\n\r\n    @Resource\r\n    private AccountDao accountDao;\r\n\r\n    /**\r\n     * 转账\r\n     *\r\n     * @param fromUserId\r\n     * @param toUserId\r\n     * @param account\r\n     */\r\n    @Override\r\n    public void transferAccounts(int fromUserId, int toUserId, float account) {\r\n        Account fromUserAccount=accountDao.getOne(fromUserId);\r\n        fromUserAccount.setBalance(fromUserAccount.getBalance()-account);\r\n        accountDao.save(fromUserAccount); // fromUser扣钱\r\n\r\n        Account toUserAccount=accountDao.getOne(toUserId);\r\n        toUserAccount.setBalance(toUserAccount.getBalance()+account);\r\n\r\n        //假设转账的时候假如出现异常，业务类或业务方法中没有使用@Transactional控制事务，则会出现钱转出了，收钱人没有收到的情况\r\n        //int zero = 1/0;\r\n        accountDao.save(toUserAccount); // toUser加钱\r\n    }\r\n}\r\n```\r\n\r\n6. AccountController类\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.transactional;\r\n\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport javax.annotation.Resource;\r\n\r\n/**\r\n * 账户Controoler类\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午10:21\r\n */\r\n@RestController\r\n@RequestMapping(\"/account\")\r\npublic class AccountController {\r\n\r\n    @Resource\r\n    private AccountService accountService;\r\n\r\n    @RequestMapping(\"/transfer\")\r\n    public String transferAccounts(){\r\n        try{\r\n            accountService.transferAccounts(1, 2, 200);\r\n            return \"ok\";\r\n        }catch(Exception e){\r\n            return \"no\";\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n7. 我们执行启动类\r\n\r\n   浏览器输入：<http://localhost:8888/account/transfer>\r\n\r\n   运行OK,没有事务控制的时候，没有异常的时候，转出的前与入账的钱是一致的，没有出现丢失的情况。\r\n\r\n![](../images/spring/springboot/springboot_19.png)  \r\n\r\n\r\n\r\nOK 我们先把数据恢复到700  300\r\n\r\n现在我们把service层方法改下,抛出一个异常\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.transactional;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport javax.annotation.Resource;\r\nimport javax.transaction.Transactional;\r\n\r\n/**\r\n * 帐号Service实现类\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午10:19\r\n */\r\n@Service(\"accountService\")\r\npublic class AccountServiceImpl implements AccountService {\r\n\r\n    @Resource\r\n    private AccountDao accountDao;\r\n\r\n    /**\r\n     * 转账\r\n     *\r\n     * @param fromUserId\r\n     * @param toUserId\r\n     * @param account\r\n     */\r\n    @Override\r\n\r\n    public void transferAccounts(int fromUserId, int toUserId, float account) {\r\n        Account fromUserAccount=accountDao.getOne(fromUserId);\r\n        fromUserAccount.setBalance(fromUserAccount.getBalance()-account);\r\n        accountDao.save(fromUserAccount); // fromUser扣钱\r\n\r\n        Account toUserAccount=accountDao.getOne(toUserId);\r\n        toUserAccount.setBalance(toUserAccount.getBalance()+account);\r\n\r\n        //假设转账的时候假如出现异常，业务类或业务方法中没有使用@Transactional控制事务，则会出现钱转出了，收钱人没有收到的情况\r\n        int zero = 1/0;\r\n        accountDao.save(toUserAccount); // toUser加钱\r\n    }\r\n}\r\n```\r\n\r\n这时候 扣钱dao能执行成功  加钱操作执行不了了 因为前面会报错。\r\n\r\n我们重启启动类\r\n\r\n浏览器输入：<http://localhost:8888/account/transfer>\r\n\r\n运行NO\r\n\r\n![](../images/spring/springboot/springboot_20.png)  \r\n\r\n这时候 钱扣了 但是 没加钱  导致了数据不一致性\r\n\r\n\r\n\r\n这时候 我们需要用上事务\r\n\r\n在service类或方法上加上@Transactional即可\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.transactional;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport javax.annotation.Resource;\r\nimport javax.transaction.Transactional;\r\n\r\n/**\r\n * 帐号Service实现类\r\n * @author caojx\r\n * Created on 2018/3/22 下午下午10:19\r\n */\r\n//添加事务注解，异常的时候能保证事务的一致性\r\n@Transactional\r\n@Service(\"accountService\")\r\npublic class AccountServiceImpl implements AccountService {\r\n\r\n    @Resource\r\n    private AccountDao accountDao;\r\n\r\n    /**\r\n     * 转账\r\n     *\r\n     * @param fromUserId\r\n     * @param toUserId\r\n     * @param account\r\n     */\r\n    @Override\r\n    public void transferAccounts(int fromUserId, int toUserId, float account) {\r\n        Account fromUserAccount=accountDao.getOne(fromUserId);\r\n        fromUserAccount.setBalance(fromUserAccount.getBalance()-account);\r\n        accountDao.save(fromUserAccount); // fromUser扣钱\r\n\r\n        Account toUserAccount=accountDao.getOne(toUserId);\r\n        toUserAccount.setBalance(toUserAccount.getBalance()+account);\r\n\r\n        //假设转账的时候假如出现异常，业务类或业务方法中没有使用@Transactional控制事务，则会出现钱转出了，收钱人没有收到的情况\r\n        int zero = 1/0;\r\n        accountDao.save(toUserAccount); // toUser加钱\r\n    }\r\n}\r\n```\r\n\r\n我们恢复下数据700  300\r\n\r\n然后再重启启动类，\r\n\r\n浏览器输入：<http://localhost:8888/account/transfer>\r\n\r\n运行NO\r\n\r\n但是数据库数据没变化 说明启动作用了。\r\n\r\n\r\n\r\n## 七、 SpringBoot之表单验证@Valid\r\n\r\n本节内容主要参见：http://blog.java1234.com/blog/articles/336.html\r\n\r\nSpringBoot提供了强大的表单验证功能实现，给我们省去了写验证的麻烦；\r\n\r\n### 7.1 常见表单验证注解\r\n\r\n| 限制                      | 说明                                                         |\r\n| ------------------------- | ------------------------------------------------------------ |\r\n| @Null                     | 限制只能为null                                               |\r\n| @NotNull                  | 限制必须不为null                                             |\r\n| @AssertFalse              | 限制必须为false                                              |\r\n| @AssertTrue               | 限制必须为true                                               |\r\n| @DecimalMax(value)        | 限制必须为一个不大于指定值的数字                             |\r\n| @DecimalMin(value)        | 限制必须为一个不小于指定值的数字                             |\r\n| @Digits(integer,fraction) | 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction |\r\n| @Future                   | 限制必须是一个将来的日期                                     |\r\n| @Max(value)               | 限制必须为一个不大于指定值的数字                             |\r\n| @Min(value)               | 限制必须为一个不小于指定值的数字                             |\r\n| @Past                     | 限制必须是一个过去的日期                                     |\r\n| @Pattern(value)           | 限制必须符合指定的正则表达式                                 |\r\n| @Size(max,min)            | 限制字符长度必须在min到max之间                               |\r\n| @Past                     | 验证注解的元素值（日期类型）比当前时间早                     |\r\n| @NotEmpty                 | 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） |\r\n| @NotBlank                 | 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格 |\r\n| @Email                    | 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 |\r\n\r\n### 7.2 编码\r\n\r\n这里我们给下实例，提交一个有姓名和年龄的表单添加功能，\r\n\r\n要求姓名不能为空，年龄必须是不小于18 ；\r\n\r\n1. 我们先新建一个Student实体，这里只用了两个注解\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.valid;\r\n\r\nimport javax.persistence.*;\r\nimport javax.validation.constraints.Min;\r\nimport javax.validation.constraints.NotEmpty;\r\nimport javax.validation.constraints.NotNull;\r\n\r\n/**\r\n * @author caojx\r\n * Created on 2018/3/23 下午上午11:06\r\n */\r\n@Entity\r\n@Table(name=\"t_student\")\r\npublic class Student {\r\n    @Id\r\n    @GeneratedValue\r\n    private Integer id;\r\n\r\n    @NotEmpty(message=\"姓名不能为空！\")\r\n    @Column(length=50)\r\n    private String name;\r\n\r\n    @NotNull(message=\"年龄不能为空！\")\r\n    @Min(value=18,message=\"年龄必须大于18岁！\")\r\n    @Column(length=50)\r\n    private Integer age;\r\n\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n2. dao接口\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.valid;\r\n\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\n/**\r\n * 学生Dao接口\r\n * @author caojx\r\n * Created on 2018/3/23 下午上午11:10\r\n */\r\npublic interface StudentDao extends JpaRepository<Student, Integer> {\r\n}\r\n```\r\n\r\n3. service接口\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.valid;\r\n\r\n/**\r\n * 学生Service接口\r\n * @author caojx\r\n * Created on 2018/3/23 下午上午11:11\r\n */\r\npublic interface StudentService {\r\n\r\n    /**\r\n     * 添加学生\r\n     */\r\n    public void add(Student student);\r\n}\r\n```\r\n\r\n\r\n\r\n4. service业务实现类\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.valid;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport javax.annotation.Resource;\r\nimport javax.transaction.Transactional;\r\n\r\n/**\r\n * 学生Service实现类\r\n * @author caojx\r\n * Created on 2018/3/23 下午上午11:11\r\n */\r\n@Transactional\r\n@Service\r\npublic class StudentServiceImpl implements StudentService {\r\n\r\n    @Resource\r\n    private StudentDao studentDao;\r\n\r\n    @Override\r\n    public void add(Student student) {\r\n        studentDao.save(student);\r\n    }\r\n}\r\n```\r\n\r\n5. controller\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.valid;\r\n\r\nimport org.springframework.validation.BindingResult;\r\nimport org.springframework.web.bind.annotation.PostMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport javax.annotation.Resource;\r\nimport javax.validation.Valid;\r\n\r\n/**\r\n * 学生控制类\r\n * @author caojx\r\n * Created on 2018/3/23 下午上午11:13\r\n */\r\n@RestController\r\n@RequestMapping(\"/student\")\r\npublic class StudentController {\r\n\r\n    @Resource\r\n    private StudentService studentService;\r\n\r\n    /**\r\n     * 添加学生\r\n     *\r\n     * add方法里 实体前要加@Valid 假如字段验证不通过，信息绑定到后面定义的BindingResult；\r\n     * @param student\r\n     * @param bindingResult\r\n     * @return\r\n     */\r\n    @ResponseBody\r\n    @PostMapping(value=\"/add\")\r\n    public String add(@Valid Student student, BindingResult bindingResult){\r\n        if(bindingResult.hasErrors()){\r\n            return bindingResult.getFieldError().getDefaultMessage();\r\n        }else{\r\n            studentService.add(student);\r\n            return \"添加成功！\";\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n6. student添加页面studentAdd.html\r\n\r\n```java\r\n\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>学生信息添加页面</title>\r\n    <script src=\"jquery.js\"></script>\r\n    <script type=\"text/javascript\">\r\n        function submitData(){\r\n            $.post(\"/student/add\",{name:$(\"#name\").val(),age:$(\"#age\").val()},\r\n                function(result){\r\n                    alert(result);\r\n                }\r\n            );\r\n        }\r\n    </script>\r\n</head>\r\n<body>\r\n姓名：<input type=\"text\" id=\"name\" name=\"name\"/>\r\n年龄：<input type=\"text\" id=\"age\" name=\"age\"/>\r\n<input type=\"button\" value=\"提交\" onclick=\"submitData()\"/>\r\n</body>\r\n</html>\r\n```\r\n\r\n浏览器请求：<http://localhost:8888/studentAdd.html>\r\n\r\n![](../images/spring/springboot/springboot_21.png)  \r\n\r\n直接点击提交\r\n\r\n![](../images/spring/springboot/springboot_22.png)  \r\n\r\n\r\n\r\n输入都符合条件的数据\r\n\r\n![](../images/spring/springboot/springboot_23.png)  \r\n\r\n其他效果几个验证，请自己测试一下。\r\n\r\n\r\n\r\n### 7.3 表单验证总结\r\n\r\n对于这种数据验证，我们一般会先在前端验证，比如js先验证信息，再提交到后台验证。\r\n\r\n\r\n\r\n## 八、 SpringBoot之切面AOP\r\n\r\n本节内容主要参见：http://blog.java1234.com/blog/articles/337.html\r\n\r\n### 8.1 前言\r\n\r\nSpringBoot提供了强大AOP支持，我们前面讲解过AOP面向切面，所以这里具体AOP原理就补具体介绍；\r\n\r\nAOP切面主要是切方法，我们一般搞一些日志分析和事务操作，要用到切面，类似拦截器；\r\n\r\n**下边是AOP中常见的切面注解：**\r\n\r\n- @Aspect注解是切面注解类\r\n- @Pointcut切点定义\r\n- @Before是方法执行前调用\r\n- @After是方法执行后调用\r\n- @AfterReturning方法执行返回值调用\r\n\r\n\r\n### 8.2 编码\r\n\r\n下边简单使用一下切面，在指定的方法中切入动作\r\n\r\n1. 定义一个切面类：RequestAspect\r\n\r\n```java\r\npackage caojx.learn.springboothelloword.aop;\r\n\r\nimport caojx.learn.springboothelloword.valid.Student;\r\nimport org.apache.log4j.Logger;\r\nimport org.aspectj.lang.JoinPoint;\r\nimport org.aspectj.lang.annotation.*;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.context.request.RequestContextHolder;\r\nimport org.springframework.web.context.request.ServletRequestAttributes;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\n\r\n/**\r\n * @author caojx\r\n * Created on 2018/3/23 下午上午11:27\r\n */\r\n@Aspect\r\n@Component\r\npublic class RequestAspect {\r\n\r\n\r\n    private Logger logger = Logger.getLogger(RequestAspect.class);\r\n\r\n    @Pointcut(\"execution(public * caojx.learn.springboothelloword.valid.*.*(..))\")\r\n    public void log() {\r\n    }\r\n\r\n    @Before(\"log()\")\r\n    public void doBefore(JoinPoint joinPoint) {\r\n        logger.info(\"方法执行前...\");\r\n        ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\r\n        HttpServletRequest request = sra.getRequest();\r\n        logger.info(\"url:\" + request.getRequestURI());\r\n        logger.info(\"ip:\" + request.getRemoteHost());\r\n        logger.info(\"method:\" + request.getMethod());\r\n        logger.info(\"class_method:\" + joinPoint.getSignature().getDeclaringTypeName() + \".\" + joinPoint.getSignature().getName());\r\n        logger.info(\"args:\" + joinPoint.getArgs());\r\n        Student student = (Student) joinPoint.getArgs()[0];\r\n        System.out.println(student);\r\n    }\r\n\r\n    @After(\"log()\")\r\n    public void doAfter(JoinPoint joinPoint) {\r\n        logger.info(\"方法执行后...\");\r\n    }\r\n\r\n    @AfterReturning(returning = \"result\", pointcut = \"log()\")\r\n    public void doAfterReturning(Object result) {\r\n        logger.info(\"方法返回值：\" + result);\r\n    }\r\n}\r\n```\r\n\r\nexecution(public * caojx.learn.springboothelloword.valid.\\*.*(..)) 这个定义 意思是 对  caojx.learn.springboothelloword.valid包下的任意类，任意方法，任意参数，任意返回值的方法都进行切入\r\n\r\n2. 引入Log4j依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>log4j</groupId>\r\n    <artifactId>log4j</artifactId>\r\n    <version>1.2.16</version>\r\n</dependency>\r\n```\r\n\r\n3. 在resources文件夹下新建log4j.properties\r\n\r\n```properties\r\nlog4j.rootLogger=info,CONSOLE\r\n\r\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n\r\n```\r\n\r\n4. 测试\r\n\r\n我们测试 StudentController\r\n\r\n请求：<http://localhost:8888/studentAdd.html>\r\n\r\n![](../images/spring/springboot/springboot_24.png)  \r\n\r\n\r\n\r\n输出日志：\r\n\r\n```txt\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法执行前...\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - url:/student/add\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - ip:0:0:0:0:0:0:0:1\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - method:POST\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - class_method:caojx.learn.springboothelloword.valid.StudentController.add\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - args:[Ljava.lang.Object;@267392f5\r\ncaojx.learn.springboothelloword.valid.Student@16167bdf\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法执行前...\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - url:/student/add\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - ip:0:0:0:0:0:0:0:1\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - method:POST\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - class_method:caojx.learn.springboothelloword.valid.StudentServiceImpl.add\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - args:[Ljava.lang.Object;@7b91beb3\r\ncaojx.learn.springboothelloword.valid.Student@16167bdf\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法执行前...\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - url:/student/add\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - ip:0:0:0:0:0:0:0:1\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - method:POST\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - class_method:org.springframework.data.repository.CrudRepository.save\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - args:[Ljava.lang.Object;@31433908\r\ncaojx.learn.springboothelloword.valid.Student@16167bdf\r\nHibernate: select next_val as id_val from hibernate_sequence for update\r\nHibernate: update hibernate_sequence set next_val= ? where next_val=?\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法执行后...\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法返回值：caojx.learn.springboothelloword.valid.Student@16167bdf\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法执行后...\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法返回值：null\r\nHibernate: insert into t_student (age, name, id) values (?, ?, ?)\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法执行后...\r\n2018-03-23-12-55 [http-nio-8888-exec-5] [caojx.learn.springboothelloword.aop.RequestAspect] [INFO] - 方法返回值：添加成功！\r\n```\r\n\r\n\r\n\r\n## 九、其他文章推荐\r\n\r\nsprintboot系列教程1：https://blog.csdn.net/saytime/article/category/6990863\r\n\r\nsprintboot系列教程2：https://blog.csdn.net/winter_chen001/article/details/77249029', 0);
INSERT INTO `blog_course` VALUES (271, 'Spring Boot 入门（2）', 5, '\r\n\r\n\r\n\r\n# 一、Spring Boot 入门\r\n\r\n## 1、Spring Boot 简介\r\n\r\n> 简化Spring应用开发的一个框架；\r\n>\r\n> 整个Spring技术栈的一个大整合；\r\n>\r\n> J2EE开发的一站式解决方案；\r\n\r\n## 2、微服务\r\n\r\n2014，martin fowler\r\n\r\n微服务：架构风格（服务微化）\r\n\r\n一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；\r\n\r\n单体应用：ALL IN ONE\r\n\r\n微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；\r\n\r\n[详细参照微服务文档](https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa)\r\n\r\n\r\n\r\n## 3、环境准备\r\n\r\nhttp://www.gulixueyuan.com/ 谷粒学院\r\n\r\n环境约束\r\n\r\n- jdk1.8：Spring Boot 推荐jdk1.7及以上；java version \"1.8.0_112\"\r\n- maven3.x：maven 3.3以上版本；Apache Maven 3.3.9\r\n- IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS\r\n- SpringBoot 1.5.9.RELEASE：1.5.9；\r\n\r\n统一环境；\r\n\r\n\r\n\r\n### 1、MAVEN设置；\r\n\r\n给maven 的settings.xml配置文件的profiles标签添加\r\n\r\n```xml\r\n<profile>\r\n  <id>jdk-1.8</id>\r\n  <activation>\r\n    <activeByDefault>true</activeByDefault>\r\n    <jdk>1.8</jdk>\r\n  </activation>\r\n  <properties>\r\n    <maven.compiler.source>1.8</maven.compiler.source>\r\n    <maven.compiler.target>1.8</maven.compiler.target>\r\n    <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\r\n  </properties>\r\n</profile>\r\n```\r\n\r\n### 2、IDEA设置\r\n\r\n整合maven进来；\r\n\r\n## 4、Spring Boot HelloWorld\r\n\r\n一个功能：\r\n\r\n浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；\r\n\r\n\r\n\r\n### 1、创建一个maven工程；（jar）\r\n\r\n### 2、导入spring boot相关的依赖\r\n\r\n```xml\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>1.5.9.RELEASE</version>\r\n    </parent>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n```\r\n\r\n### 3、编写一个主程序：启动Spring Boot应用\r\n```java\r\n/**\r\n * @Author: cuzz\r\n * @Date: 2018/9/20 18:06\r\n * @Description: @SpringBootApplication 来标注一个主程序，说明这是一个SpringBoot应用\r\n */\r\n@SpringBootApplication\r\npublic class Application {\r\n\r\n    public static void main(String[] args) {\r\n        \r\n        // Spring应用启动起来\r\n        SpringApplication.run(Application.class, args);\r\n    }\r\n}\r\n```\r\n\r\n### 4、编写相关的Controller、Service\r\n\r\n```java\r\n@Controller\r\npublic class HelloController {\r\n\r\n    @ResponseBody\r\n    @RequestMapping(\"/hello\")\r\n    public String hello(){\r\n        return \"Hello World!\";\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 5、运行主程序测试\r\n\r\n直接右键run`Application`\r\n\r\n### 6、简化部署\r\n\r\n\r\n\r\n![1537439192685](/images/1537439192685.png)\r\n\r\n\r\n\r\n在pom/xml文件引用插件\r\n\r\n```xml\r\n <!-- 这个插件，可以将应用打包成一个可执行的jar包；-->\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n```\r\n\r\n导入这个maven插件，利用idea打包，生成的jar包，可以使用`java -jar xxx.jar`启动\r\n\r\nSpring Boot 使用嵌入式的Tomcat无需再配置Tomcat\r\n\r\n## 5、Hello World探究\r\n\r\n### 1、POM文件\r\n\r\n#### 1、父项目\r\n\r\n```xml\r\n<parent>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-parent</artifactId>\r\n    <version>1.5.9.RELEASE</version>\r\n</parent>\r\n\r\n```\r\n\r\n他的父项目是：\r\n\r\n```xml\r\n<parent>\r\n  <groupId>org.springframework.boot</groupId>\r\n  <artifactId>spring-boot-dependencies</artifactId>\r\n  <version>1.5.9.RELEASE</version>\r\n  <relativePath>../../spring-boot-dependencies</relativePath>\r\n</parent>\r\n```\r\n\r\n这是真正管理Spring Boot应用里面所依赖的版本\r\n\r\nSpring Boot的版本仲裁中心；\r\n\r\n以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）\r\n\r\n#### 2、启动器\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-web</artifactId>\r\n</dependency>\r\n```\r\n\r\n**spring-boot-starter-web**：\r\n\r\nspring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件；\r\n\r\n点击进去可以看到帮我们引入很多web相关的依赖\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n	<modelVersion>4.0.0</modelVersion>\r\n	<parent>\r\n		<groupId>org.springframework.boot</groupId>\r\n		<artifactId>spring-boot-starters</artifactId>\r\n		<version>1.5.4.RELEASE</version>\r\n	</parent>\r\n	<artifactId>spring-boot-starter-web</artifactId>\r\n	<name>Spring Boot Web Starter</name>\r\n	<description>Starter for building web, including RESTful, applications using Spring\r\n		MVC. Uses Tomcat as the default embedded container</description>\r\n	<url>http://projects.spring.io/spring-boot/</url>\r\n	<organization>\r\n		<name>Pivotal Software, Inc.</name>\r\n		<url>http://www.spring.io</url>\r\n	</organization>\r\n	<properties>\r\n		<main.basedir>${basedir}/../..</main.basedir>\r\n	</properties>\r\n	<dependencies>\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-tomcat</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.hibernate</groupId>\r\n			<artifactId>hibernate-validator</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>com.fasterxml.jackson.core</groupId>\r\n			<artifactId>jackson-databind</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework</groupId>\r\n			<artifactId>spring-web</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework</groupId>\r\n			<artifactId>spring-webmvc</artifactId>\r\n		</dependency>\r\n	</dependencies>\r\n</project>\r\n```\r\n\r\n\r\n\r\nSpring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器\r\n\r\n\r\n\r\n### 2、主程序类，主入口类\r\n\r\n```java\r\n/**\r\n * @Author: cuzz\r\n * @Date: 2018/9/20 18:06\r\n * @Description: @SpringBootApplication 来标注一个主程序，说明这是一个SpringBoot应用\r\n */\r\n@SpringBootApplication\r\npublic class Application {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        // Spring应用启动起来\r\n        SpringApplication.run(Application.class, args);\r\n    }\r\n}\r\n```\r\n\r\n@**SpringBootApplication** :  Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\r\n\r\n\r\n\r\n```java\r\n@Target(ElementType.TYPE)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Inherited\r\n@SpringBootConfiguration\r\n@EnableAutoConfiguration\r\n@ComponentScan(excludeFilters = {\r\n      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\r\n      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\r\npublic @interface SpringBootApplication {\r\n```\r\n- @**SpringBootConfiguration** : Spring Boot的配置类，标注在某个类上，表示这是一个Spring Boot的配置类\r\n\r\n- @**Configuration** : 配置类上来标注这个注解，配置类也是容器中的一个组件@Component\r\n\r\n- @**EnableAutoConfiguration**：开启自动配置功能\r\n\r\n以前我们需要配置的东西，Spring Boot帮我们自动配置；@**EnableAutoConfiguration**告诉SpringBoot开启自动配置功能；这样自动配置才能生效；\r\n\r\n```java\r\n@AutoConfigurationPackage\r\n@Import(EnableAutoConfigurationImportSelector.class)\r\npublic @interface EnableAutoConfiguration {\r\n```\r\n\r\n- @**AutoConfigurationPackage**：自动配置包\r\n  - @**Import**(AutoConfigurationPackages.Registrar.class)：\r\n  - Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；\r\n- 将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；\r\n- @**Import**(EnableAutoConfigurationImportSelector.class)，给容器中导入组件\r\n  - EnableAutoConfigurationImportSelector：导入哪些组件的选择器；\r\n  - 将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中；\r\n  	 会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件，并配置好这些组件；		![自动配置类](images/搜狗截图20180129224104.png)\r\n- 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；\r\n- 调用了`SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)`；\r\n- Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；\r\n- 以前我们需要自己配置的东西，自动配置类都帮我们；\r\n- J2EE的整体整合解决方案和自动配置都在`spring-boot-autoconfigure-1.5.9.RELEASE.jar`；\r\n\r\n	​		\r\n\r\n[Spring注解版视频](https://pan.baidu.com/s/1Y3t24jisu3LJvSR8-jiRCw)\r\n\r\n\r\n\r\n## 6、使用Spring Initializer快速创建Spring Boot项目\r\n\r\n### 1、IDEA：使用 Spring Initializer快速创建项目\r\n\r\nIDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；\r\n\r\n选择我们需要的模块；向导会联网创建Spring Boot项目；\r\n\r\n默认生成的Spring Boot项目；\r\n\r\n- 主程序已经生成好了，我们只需要我们自己的逻辑\r\n- resources文件夹中目录结构\r\n  - static：保存所有的静态资源； js css  images；\r\n  - templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；\r\n  - application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；\r\n\r\n### 2、STS使用 Spring Starter Project快速创建项目\r\n\r\n\r\n\r\n-------------\r\n\r\n\r\n\r\n# 二、配置文件\r\n\r\n## 1、配置文件\r\n\r\nSpringBoot使用一个全局的配置文件，配置文件名是固定的；\r\n\r\n- application.properties\r\n- application.yml\r\n\r\n\r\n\r\n配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；\r\n\r\n\r\n\r\nYAML（YAML Ain\'t Markup Language）\r\n\r\n​	YAML  A Markup Language：是一个标记语言\r\n\r\n​	YAML   isn\'t Markup Language：不是一个标记语言；\r\n\r\n标记语言：\r\n\r\n​	以前的配置文件；大多都使用的是  **xxx.xml**文件；\r\n\r\n​	YAML：**以数据为中心**，比json、xml等更适合做配置文件；\r\n\r\n​	YAML：配置例子\r\n\r\n```yaml\r\nserver:\r\n  port: 8081\r\n```\r\n\r\n​	XML：\r\n\r\n```xml\r\n<server>\r\n	<port>8081</port>\r\n</server>\r\n```\r\n\r\n## 2、YAML语法：\r\n\r\n### 1、基本语法\r\n\r\nk:(空格)v：表示一对键值对（空格必须有）；\r\n\r\n以**空格**的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的\r\n\r\n```yaml\r\nserver:\r\n    port: 8081\r\n    path: /hello\r\n```\r\n\r\n属性和值也是大小写敏感；\r\n\r\n\r\n\r\n### 2、值的写法\r\n\r\n#### 字面量：普通的值（数字，字符串，布尔）\r\n\r\n​	k: v：字面直接来写；\r\n\r\n​		字符串默认不用加上单引号或者双引号；\r\n\r\n​		\"\"：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思\r\n\r\n​				name:   \"zhangsan \\n lisi\"：输出；zhangsan 换行  lisi\r\n\r\n​		\'\'：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据\r\n\r\n​				name:   ‘zhangsan \\n lisi’：输出；zhangsan \\n  lisi\r\n\r\n\r\n\r\n#### 对象、Map（属性和值）（键值对）：\r\n\r\n​	k: v：在下一行来写对象的属性和值的关系；注意缩进\r\n\r\n​		对象还是k: v的方式\r\n\r\n```yaml\r\nfriends:\r\n	lastName: zhangsan\r\n	age: 20\r\n```\r\n\r\n行内写法：\r\n\r\n```yaml\r\nfriends: {lastName: zhangsan, age: 18}\r\n```\r\n\r\n\r\n\r\n#### 数组（List、Set）：\r\n\r\n用 - 值表示数组中的一个元素\r\n\r\n```yaml\r\npets:\r\n - cat\r\n - dog\r\n - pig\r\n```\r\n\r\n行内写法\r\n\r\n```yaml\r\npets: [cat, dog, pig]\r\n```\r\n\r\n\r\n\r\n## 3、配置文件值注入\r\n\r\n配置文件\r\n\r\n```yaml\r\nperson:\r\n    lastName: hello\r\n    age: 18\r\n    boss: false\r\n    birth: 2017/12/12\r\n    maps: {k1: v1, k2: 12}\r\n    lists:\r\n      - lisi\r\n      - zhaoliu\r\n    dog:\r\n      name: 小狗\r\n      age: 12\r\n```\r\n\r\njavaBean：\r\n\r\n- 将配置文件中配置的每一个属性的值，映射到这个组件中\r\n- @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；\r\n- prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射\r\n- 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；\r\n- @Data是一个插件，，免去了getter/setter和toString这些繁琐的东西\r\n\r\n```java\r\n/**\r\n * @Author: cuzz\r\n * @Date: 2018/9/20 19:34\r\n * @Description:\r\n */\r\n@Data\r\n@Component\r\n@ConfigurationProperties(prefix = \"person\")\r\npublic class Person {\r\n\r\n    private String lastName;\r\n    private Integer age;\r\n    private Boolean boss;\r\n    private Date birth;\r\n\r\n    private Map<String,Object> maps;\r\n    private List<Object> lists;\r\n    private Dog dog;\r\n\r\n}\r\n\r\n```\r\n\r\n出现以下提示，进入官网，在pom中导入配置\r\n\r\n![1537443412214](images/1537443412214.png)\r\n\r\n我们可以导入配置文件处理器，以后编写配置就有提示了\r\n\r\n```xml\r\n<!--导入配置文件处理器，配置文件进行绑定就会有提示-->\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-configuration-processor</artifactId>\r\n			<optional>true</optional>\r\n		</dependency>\r\n```\r\n\r\n### 1、properties配置文件在idea中默认utf-8可能会乱码\r\n\r\n调整\r\n\r\n![idea配置乱码](images/搜狗截图20180130161620.png)\r\n\r\n### 2、@Value获取值和@ConfigurationProperties获取值比较\r\n\r\n|            | @ConfigurationProperties | @Value |\r\n| ---------- | ------------------------ | ------ |\r\n| 功能         | 批量注入配置文件中的属性             | 一个个指定  |\r\n| 松散绑定（松散语法） | 支持                       | 不支持    |\r\n| SpEL       | 不支持                      | 支持     |\r\n| JSR303数据校验 | 支持                       | 不支持    |\r\n| 复杂类型封装     | 支持                       | 不支持    |\r\n\r\n松散语法绑定：last_name = last-name = lastName 他们取的值都是相同的\r\n\r\n\r\n\r\n配置文件yml还是properties他们都能获取到值；\r\n\r\n如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；\r\n\r\n如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；\r\n\r\n\r\n\r\n### 3、配置文件注入值数据校验\r\n\r\n```java\r\n@Component\r\n@ConfigurationProperties(prefix = \"person\")\r\n@Validated\r\npublic class Person {\r\n\r\n    /**\r\n     * <bean class=\"Person\">\r\n     *      <property name=\"lastName\" value=\"字面量/${key}从环境变量、配置文件中获取值/#{SpEL}\">\r\n     *      </property>\r\n     * <bean/>\r\n     */\r\n\r\n    // lastName必须是邮箱格式\r\n    // @Email\r\n    // @Value(\"${person.last-name}\")\r\n    private String lastName;\r\n    // @Value(\"#{11*2}\")\r\n    private Integer age;\r\n    // @Value(\"true\")\r\n    private Boolean boss;\r\n\r\n    private Date birth;\r\n    // @Value(\"${person.maps}\")\r\n    private Map<String,Object> maps;\r\n    private List<Object> lists;\r\n    private Dog dog;\r\n}\r\n```\r\n\r\n\r\n\r\n### 4、@PropertySource&@ImportResource&@Bean\r\n\r\n@**PropertySource**：加载指定的配置文件；\r\n\r\n```java\r\n/**\r\n * 将配置文件中配置的每一个属性的值，映射到这个组件中\r\n * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；\r\n *      prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射\r\n *\r\n * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；\r\n *  @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值；\r\n *\r\n */\r\n@PropertySource(value = {\"classpath:person.properties\"})\r\n@Component\r\n@ConfigurationProperties(prefix = \"person\")\r\n//@Validated\r\npublic class Person {\r\n\r\n    /**\r\n     * <bean class=\"Person\">\r\n     *      <property name=\"lastName\" value=\"字面量/${key}从环境变量、配置文件中获取值/#{SpEL}\"></property>\r\n     * <bean/>\r\n     */\r\n\r\n   	// lastName必须是邮箱格式\r\n   	// @Email\r\n    // @Value(\"${person.last-name}\")\r\n    private String lastName;\r\n    // @Value(\"#{11*2}\")\r\n    private Integer age;\r\n    // @Value(\"true\")\r\n    private Boolean boss;\r\n\r\n```\r\n\r\n\r\n\r\n@**ImportResource**：导入Spring的配置文件，让配置文件里面的内容生效；\r\n\r\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\r\n\r\n想让Spring的配置文件生效，加载进来；@**ImportResource**标注在一个配置类上\r\n\r\n```java\r\n@ImportResource(locations = {\"classpath:beans.xml\"})\r\n@SpringBootApplication\r\npublic class SpringbootApplication {\r\n\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(SpringbootApplication.class, args);\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n不来编写Spring的配置文件\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <bean id=\"helloService\" class=\"com.cuzz.springboot.service.HelloService\"></bean>\r\n</beans>\r\n```\r\n\r\n测试\r\n\r\n```java\r\n/**\r\n * @Author: cuzz\r\n * @Date: 2018/9/20 20:41\r\n * @Description:\r\n */\r\n@RunWith(SpringRunner.class)\r\n@SpringBootTest\r\npublic class TestHelloService {\r\n\r\n    @Autowired\r\n    ApplicationContext ioc;\r\n\r\n    @Test\r\n    public void testHelloService() {\r\n        boolean b = ioc.containsBean(\"helloService\");\r\n        System.out.println(b); 	// true\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\nSpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式\r\n\r\n1、配置类**@Configuration** --> Spring配置文件\r\n\r\n2、使用**@Bean**给容器中添加组件\r\n\r\n```java\r\n/**\r\n * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件\r\n *\r\n * 在配置文件中用<bean><bean/>标签添加组件\r\n *\r\n */\r\n@Configuration\r\npublic class MyAppConfig {\r\n\r\n    // 将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名\r\n    @Bean\r\n    public HelloService helloService02(){\r\n        System.out.println(\"配置类@Bean给容器中添加组件了...\");\r\n        return new HelloService();\r\n    }\r\n}\r\n```\r\n\r\n测试：\r\n\r\n````java\r\n    @Test\r\n    public void testHelloService() {\r\n        boolean b = ioc.containsBean(\"helloService\");\r\n        System.out.println(b); // true\r\n    }\r\n````\r\n\r\n输出：配置类@Bean给容器中添加组件了... 同时返回true     \r\n\r\n##4、配置文件占位符\r\n\r\n### 1、随机数\r\n\r\n```java\r\n${random.value}、${random.int}、${random.long}\r\n${random.int(10)}、${random.int[1024,65536]}\r\n\r\n```\r\n\r\n\r\n\r\n### 2、占位符获取之前配置的值，如果没有可以是用:指定默认值\r\n\r\n```properties\r\nperson.last-name=张三${random.uuid}\r\nperson.age=${random.int}\r\nperson.birth=2017/12/15\r\nperson.boss=false\r\nperson.maps.k1=v1\r\nperson.maps.k2=14\r\nperson.lists=a,b,c\r\n# 没有取到:后面是默认值\r\nperson.dog.name=${person.hello:hello}_dog\r\nperson.dog.age=15\r\n```\r\n\r\n\r\n\r\n## 5、Profile\r\n\r\n### 1、多Profile文件\r\n\r\n我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml\r\n\r\n默认使用application.properties的配置；\r\n\r\n\r\n\r\n### 2、yml支持多文档块方式\r\n\r\n```yml\r\n\r\nserver:\r\n  port: 8081\r\nspring:\r\n  profiles:\r\n    active: prod\r\n\r\n---\r\nserver:\r\n  port: 8083\r\nspring:\r\n  profiles: dev\r\n\r\n\r\n---\r\n\r\nserver:\r\n  port: 8084\r\nspring:\r\n  profiles: prod  #指定属于哪个环境\r\n```\r\n\r\n\r\n\r\n### 3、激活指定profile\r\n\r\n​	1、在配置文件中指定  spring.profiles.active=dev\r\n\r\n​	2、命令行：\r\n```\r\n​		java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev；\r\n```\r\n\r\n​		可以直接在测试的时候，配置传入命令行参数\r\n\r\n​	3、虚拟机参数；\r\n```\r\n​		-Dspring.profiles.active=dev\r\n```\r\n\r\n\r\n\r\n## 6、配置文件加载位置\r\n\r\nspringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\r\n\r\n–file:./config/   项目目录下的config\r\n\r\n–file:./                项目目录下\r\n\r\n–classpath:/config/      resources目录下的config\r\n\r\n–classpath:/                   resources目录下\r\n\r\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；\r\n\r\nSpringBoot会从这四个位置全部加载主配置文件；**互补配置**；\r\n\r\n我们还可以通过spring.config.location来改变默认的配置文件位置\r\n\r\n**项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；**\r\n\r\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties\r\n\r\n## 7、外部配置加载顺序\r\n\r\n**SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置**\r\n\r\n1.命令行参数\r\n\r\n所有的配置都可以在命令行上进行指定\r\n```\r\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc\r\n```\r\n\r\n多个配置用空格分开； --配置项=值\r\n\r\n2.来自java:comp/env的JNDI属性\r\n\r\n3.Java系统属性（System.getProperties()）\r\n\r\n4.操作系统环境变量\r\n\r\n5.RandomValuePropertySource配置的random.*属性值\r\n\r\n\r\n由jar包外向jar包内进行寻找；\r\n\r\n**优先加载带profile**\r\n\r\n6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件\r\n\r\n7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件\r\n\r\n\r\n\r\n**再来加载不带profile**\r\n\r\n8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件\r\n\r\n9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件\r\n\r\n\r\n\r\n10.@Configuration注解类上的@PropertySource\r\n\r\n11.通过SpringApplication.setDefaultProperties指定的默认属性\r\n\r\n所有支持的配置加载来源；\r\n\r\n[参考官方文档](https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config)\r\n\r\n## 8、自动配置原理\r\n\r\n配置文件到底能写什么？怎么写？自动配置原理；\r\n\r\n[配置文件能配置的属性参照](https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties)\r\n\r\n### 1、自动配置原理：\r\n\r\n1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration\r\n\r\n**2）、@EnableAutoConfiguration 作用：**\r\n\r\n -  利用EnableAutoConfigurationImportSelector给容器中导入一些组件？\r\n\r\n- 可以查看selectImports()方法的内容；\r\n\r\n- `List<String> configurations = getCandidateConfigurations(annotationMetadata,  attributes);`获取候选的配置\r\n\r\n  - ```java\r\n    SpringFactoriesLoader.loadFactoryNames()\r\n    扫描所有jar包类路径下  META-INF/spring.factories\r\n    把扫描到的这些文件的内容包装成properties对象\r\n    从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中\r\n    ```\r\n\r\n\r\n**将类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中**\r\n\r\n```properties\r\n# Auto Configure\r\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\r\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration\r\n```\r\n\r\n每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；\r\n\r\n3）、每一个自动配置类进行自动配置功能；\r\n\r\n4）、以**HttpEncodingAutoConfiguration（Http编码自动配置）**为例解释自动配置原理；\r\n\r\n```java\r\n@Configuration   //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件\r\n@EnableConfigurationProperties(HttpEncodingProperties.class)  //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中\r\n\r\n@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效\r\n\r\n@ConditionalOnClass(CharacterEncodingFilter.class)  //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；\r\n\r\n@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true)  //判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的\r\n//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；\r\npublic class HttpEncodingAutoConfiguration {\r\n  \r\n  	//他已经和SpringBoot的配置文件映射了\r\n  	private final HttpEncodingProperties properties;\r\n  \r\n   //只有一个有参构造器的情况下，参数的值就会从容器中拿\r\n  	public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {\r\n		this.properties = properties;\r\n	}\r\n  \r\n    @Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取\r\n	@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？\r\n	public CharacterEncodingFilter characterEncodingFilter() {\r\n		CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\r\n		filter.setEncoding(this.properties.getCharset().name());\r\n		filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));\r\n		filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));\r\n		return filter;\r\n	}\r\n```\r\n\r\n根据当前不同的条件判断，决定这个配置类是否生效？\r\n\r\n一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；\r\n\r\n\r\n\r\n5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类\r\n\r\n```java\r\n@ConfigurationProperties(prefix = \"spring.http.encoding\")  //从配置文件中获取指定的值和bean的属性进行绑定\r\npublic class HttpEncodingProperties {\r\n\r\n   public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**精髓：**\r\n\r\n​	**1）、SpringBoot启动会加载大量的自动配置类**\r\n\r\n​	**2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；**\r\n\r\n​	**3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）**\r\n\r\n​	**4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；**\r\n\r\n\r\n\r\nxxxxAutoConfigurartion：自动配置类；\r\n\r\n给容器中添加组件\r\n\r\nxxxxProperties:封装配置文件中相关属性；\r\n\r\n\r\n\r\n### 2、细节\r\n\r\n\r\n\r\n#### 1、@Conditional派生注解（Spring注解版原生的@Conditional作用）\r\n\r\n作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\r\n\r\n| @Conditional扩展注解                | 作用（判断是否满足当前指定条件）               |\r\n| ------------------------------- | ------------------------------ |\r\n| @ConditionalOnJava              | 系统的java版本是否符合要求                |\r\n| @ConditionalOnBean              | 容器中存在指定Bean；                   |\r\n| @ConditionalOnMissingBean       | 容器中不存在指定Bean；                  |\r\n| @ConditionalOnExpression        | 满足SpEL表达式指定                    |\r\n| @ConditionalOnClass             | 系统中有指定的类                       |\r\n| @ConditionalOnMissingClass      | 系统中没有指定的类                      |\r\n| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选Bean |\r\n| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                |\r\n| @ConditionalOnResource          | 类路径下是否存在指定资源文件                 |\r\n| @ConditionalOnWebApplication    | 当前是web环境                       |\r\n| @ConditionalOnNotWebApplication | 当前不是web环境                      |\r\n| @ConditionalOnJndi              | JNDI存在指定项                      |\r\n\r\n**自动配置类必须在一定的条件下才能生效；**\r\n\r\n我们怎么知道哪些自动配置类生效；\r\n\r\n**我们可以通过启用  debug=true属性；来让控制台打印自动配置报告**，这样我们就可以很方便的知道哪些自动配置类生效；\r\n\r\n```java\r\n=========================\r\nAUTO-CONFIGURATION REPORT\r\n=========================\r\n\r\n\r\nPositive matches:（自动配置类启用的）\r\n-----------------\r\n\r\n   DispatcherServletAutoConfiguration matched:\r\n      - @ConditionalOnClass found required class \'org.springframework.web.servlet.DispatcherServlet\'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)\r\n      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)\r\n\r\nNegative matches:（没有启动，没有匹配成功的自动配置类）\r\n-----------------\r\n\r\n   ActiveMQAutoConfiguration:\r\n      Did not match:\r\n         - @ConditionalOnClass did not find required classes \'javax.jms.ConnectionFactory\', \'org.apache.activemq.ActiveMQConnectionFactory\' (OnClassCondition)\r\n\r\n   AopAutoConfiguration:\r\n      Did not match:\r\n         - @ConditionalOnClass did not find required classes \'org.aspectj.lang.annotation.Aspect\', \'org.aspectj.lang.reflect.Advice\' (OnClassCondition)\r\n\r\n```\r\n\r\n# 三、日志\r\n\r\n## 1、日志框架\r\n\r\n 小张；开发一个大型系统；\r\n\r\n​		1、System.out.println(\"\")；将关键数据打印在控制台；去掉？写在一个文件？\r\n\r\n​		2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；\r\n\r\n​		3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？\r\n\r\n​		4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；\r\n\r\n​		5、JDBC---数据库驱动；\r\n\r\n​			写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；\r\n\r\n​			给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；\r\n\r\n\r\n\r\n**市面上的日志框架；**\r\n\r\nJUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j....\r\n\r\n| 日志门面  （日志的抽象层）                           | 日志实现                                     |\r\n| ---------------------------------------- | ---------------------------------------- |\r\n| ~~JCL（Jakarta  Commons Logging）~~    SLF4j（Simple  Logging Facade for Java）    **~~jboss-logging~~** | Log4j  JUL（java.util.logging）  Log4j2  **Logback** |\r\n\r\n左边选一个门面（抽象层）、右边来选一个实现；\r\n\r\n日志门面：  SLF4J；\r\n\r\n日志实现：Logback；\r\n\r\n\r\n\r\nSpringBoot：底层是Spring框架，Spring框架默认是用JCL；\r\n\r\n**SpringBoot选用 SLF4j和logback；**\r\n\r\n\r\n\r\n## 2、SLF4j使用\r\n\r\n### 1、如何在系统中使用SLF4j   https://www.slf4j.org\r\n\r\n以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；\r\n\r\n给系统里面导入slf4j的jar和  logback的实现jar\r\n\r\n```java\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\npublic class HelloWorld {\r\n  public static void main(String[] args) {\r\n    Logger logger = LoggerFactory.getLogger(HelloWorld.class);\r\n    logger.info(\"Hello World\");\r\n  }\r\n}\r\n```\r\n\r\n图示；\r\n\r\n![images/concrete-bindings.png](images/concrete-bindings.png)\r\n\r\n每一个日志的实现框架都有自己的配置文件。使用slf4j以后，**配置文件还是做成日志实现框架自己本身的配置文件；**\r\n\r\n### 2、遗留问题\r\n\r\na（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx\r\n\r\n统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？\r\n\r\n![](images/legacy.png)\r\n\r\n**如何让系统中所有的日志都统一到slf4j；**\r\n\r\n1、将系统中其他日志框架先排除出去；\r\n\r\n2、用中间包来替换原有的日志框架；\r\n\r\n3、我们导入slf4j其他的实现\r\n\r\n\r\n\r\n## 3、SpringBoot日志关系\r\n\r\n```xml\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter</artifactId>\r\n		</dependency>\r\n```\r\n\r\n\r\n\r\nSpringBoot使用它来做日志功能；\r\n\r\n```xml\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-logging</artifactId>\r\n		</dependency>\r\n```\r\n\r\n底层依赖关系\r\n\r\n![](images/搜狗截图20180131220946.png)\r\n\r\n总结：\r\n\r\n​	1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录\r\n\r\n​	2）、SpringBoot也把其他的日志都替换成了slf4j；\r\n\r\n​	3）、中间替换包？\r\n\r\n```java\r\n@SuppressWarnings(\"rawtypes\")\r\npublic abstract class LogFactory {\r\n\r\n    static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\";\r\n\r\n    static LogFactory logFactory = new SLF4JLogFactory();\r\n```\r\n\r\n![](images/搜狗截图20180131221411.png)\r\n\r\n\r\n\r\n​	4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？\r\n\r\n​			Spring框架用的是commons-logging；\r\n\r\n```xml\r\n		<dependency>\r\n			<groupId>org.springframework</groupId>\r\n			<artifactId>spring-core</artifactId>\r\n			<exclusions>\r\n				<exclusion>\r\n					<groupId>commons-logging</groupId>\r\n					<artifactId>commons-logging</artifactId>\r\n				</exclusion>\r\n			</exclusions>\r\n		</dependency>\r\n```\r\n\r\n**SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；**\r\n\r\n## 4、日志使用；\r\n\r\n### 1、默认配置\r\n\r\nSpringBoot默认帮我们配置好了日志；\r\n\r\n```java\r\n	//记录器\r\n	Logger logger = LoggerFactory.getLogger(getClass());\r\n	@Test\r\n	public void contextLoads() {\r\n		//System.out.println();\r\n\r\n		//日志的级别；\r\n		//由低到高   trace<debug<info<warn<error\r\n		//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效\r\n		logger.trace(\"这是trace日志...\");\r\n		logger.debug(\"这是debug日志...\");\r\n		//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别\r\n		logger.info(\"这是info日志...\");\r\n		logger.warn(\"这是warn日志...\");\r\n		logger.error(\"这是error日志...\");\r\n\r\n\r\n	}\r\n```\r\n\r\n\r\n\r\n        日志输出格式：\r\n    		%d表示日期时间，\r\n    		%thread表示线程名，\r\n    		%-5level：级别从左显示5个字符宽度\r\n    		%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 \r\n    		%msg：日志消息，\r\n    		%n是换行符\r\n        -->\r\n        %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\r\nSpringBoot修改日志的默认配置\r\n\r\n```properties\r\nlogging.level.com.cuzz=trace\r\n\r\n#logging.path=\r\n# 不指定路径在当前项目下生成springboot.log日志\r\n# 可以指定完整的路径；\r\n#logging.file=G:/springboot.log\r\n\r\n# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件\r\nlogging.path=/spring/log\r\n\r\n#  在控制台输出的日志的格式\r\nlogging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n\r\n# 指定文件中日志输出的格式\r\nlogging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n\r\n```\r\n\r\n| logging.file | logging.path | Example  | Description             |\r\n| ------------ | ------------ | -------- | ----------------------- |\r\n| (none)       | (none)       |          | 只在控制台输出                 |\r\n| 指定文件名        | (none)       | my.log   | 输出日志到my.log文件           |\r\n| (none)       | 指定目录         | /var/log | 输出到指定目录的 spring.log 文件中 |\r\n\r\n### 2、指定配置\r\n\r\n给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了\r\n\r\n| Logging System          | Customization                            |\r\n| ----------------------- | ---------------------------------------- |\r\n| Logback                 | `logback-spring.xml`, `logback-spring.groovy`, `logback.xml` or `logback.groovy` |\r\n| Log4j2                  | `log4j2-spring.xml` or `log4j2.xml`      |\r\n| JDK (Java Util Logging) | `logging.properties`                     |\r\n\r\nlogback.xml：直接就被日志框架识别了；\r\n\r\n**logback-spring.xml**：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能\r\n\r\n```xml\r\n<springProfile name=\"staging\">\r\n    <!-- configuration to be enabled when the \"staging\" profile is active -->\r\n  	可以指定某段配置只在某个环境下生效\r\n</springProfile>\r\n\r\n```\r\n\r\n如：\r\n\r\n```xml\r\n<appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <!--\r\n        日志输出格式：\r\n			%d表示日期时间，\r\n			%thread表示线程名，\r\n			%-5level：级别从左显示5个字符宽度\r\n			%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 \r\n			%msg：日志消息，\r\n			%n是换行符\r\n        -->\r\n        <layout class=\"ch.qos.logback.classic.PatternLayout\">\r\n            <springProfile name=\"dev\">\r\n                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n</pattern>\r\n            </springProfile>\r\n            <springProfile name=\"!dev\">\r\n                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n</pattern>\r\n            </springProfile>\r\n        </layout>\r\n    </appender>\r\n```\r\n\r\n\r\n\r\n如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误\r\n\r\n `no applicable action for [springProfile]`\r\n\r\n推荐使用`spring-logbac.xml` 是由Spring Boot识别，可以使用新功能\r\n\r\n## 5、切换日志框架\r\n\r\n可以按照slf4j的日志适配图，进行相关的切换；\r\n\r\nslf4j+log4j的方式；\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>org.springframework.boot</groupId>\r\n  <artifactId>spring-boot-starter-web</artifactId>\r\n  <exclusions>\r\n    <exclusion>\r\n      <artifactId>logback-classic</artifactId>\r\n      <groupId>ch.qos.logback</groupId>\r\n    </exclusion>\r\n    <exclusion>\r\n      <artifactId>log4j-over-slf4j</artifactId>\r\n      <groupId>org.slf4j</groupId>\r\n    </exclusion>\r\n  </exclusions>\r\n</dependency>\r\n\r\n<dependency>\r\n  <groupId>org.slf4j</groupId>\r\n  <artifactId>slf4j-log4j12</artifactId>\r\n</dependency>\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n切换为log4j2\r\n\r\n```xml\r\n   <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <artifactId>spring-boot-starter-logging</artifactId>\r\n                    <groupId>org.springframework.boot</groupId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n\r\n<dependency>\r\n  <groupId>org.springframework.boot</groupId>\r\n  <artifactId>spring-boot-starter-log4j2</artifactId>\r\n</dependency>\r\n```\r\n\r\n-----------------\r\n\r\n# 四、Web开发\r\n\r\n## 1、简介\r\n\r\n\r\n\r\n使用SpringBoot；\r\n\r\n**1）、创建SpringBoot应用，选中我们需要的模块；**\r\n\r\n**2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来**\r\n\r\n**3）、自己编写业务代码；**\r\n\r\n\r\n\r\n**自动配置原理？**\r\n\r\n这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx\r\n\r\n```\r\nxxxxAutoConfiguration：帮我们给容器中自动配置组件；\r\nxxxxProperties:配置类来封装配置文件的内容；\r\n```\r\n\r\n\r\n\r\n## 2、SpringBoot对静态资源的映射规则；\r\n\r\n```java\r\n@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)\r\npublic class ResourceProperties implements ResourceLoaderAware {\r\n  //可以设置和静态资源有关的参数，缓存时间等\r\n```\r\n\r\n这个类WebMvcAuotConfiguration：\r\n\r\n`org\\springframework\\boot\\autoconfigure\\web\\servlet\\WebMvcAutoConfiguration.java`\r\n\r\n```java\r\n		@Override\r\n		public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n			if (!this.resourceProperties.isAddMappings()) {\r\n				logger.debug(\"Default resource handling disabled\");\r\n				return;\r\n			}\r\n			Integer cachePeriod = this.resourceProperties.getCachePeriod();\r\n			if (!registry.hasMappingForPattern(\"/webjars/**\")) {\r\n				customizeResourceHandlerRegistration(\r\n						registry.addResourceHandler(\"/webjars/**\")\r\n								.addResourceLocations(\r\n										\"classpath:/META-INF/resources/webjars/\")\r\n						.setCachePeriod(cachePeriod));\r\n			}\r\n			String staticPathPattern = this.mvcProperties.getStaticPathPattern();\r\n          	// 静态资源文件夹映射\r\n			if (!registry.hasMappingForPattern(staticPathPattern)) {\r\n				customizeResourceHandlerRegistration(\r\n						registry.addResourceHandler(staticPathPattern)\r\n								.addResourceLocations(\r\n										this.resourceProperties.getStaticLocations())\r\n						.setCachePeriod(cachePeriod));\r\n			}\r\n		}\r\n\r\n         // 配置欢迎页映射\r\n		@Bean\r\n		public WelcomePageHandlerMapping welcomePageHandlerMapping(\r\n				ResourceProperties resourceProperties) {\r\n			return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),\r\n					this.mvcProperties.getStaticPathPattern());\r\n		}\r\n\r\n         // 配置喜欢的图标\r\n		@Configuration\r\n		@ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true)\r\n		public static class FaviconConfiguration {\r\n\r\n			private final ResourceProperties resourceProperties;\r\n\r\n			public FaviconConfiguration(ResourceProperties resourceProperties) {\r\n				this.resourceProperties = resourceProperties;\r\n			}\r\n\r\n			@Bean\r\n			public SimpleUrlHandlerMapping faviconHandlerMapping() {\r\n				SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();\r\n				mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);\r\n              	 // 所有  **/favicon.ico \r\n				mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\",\r\n						faviconRequestHandler()));\r\n				return mapping;\r\n			}\r\n\r\n			@Bean\r\n			public ResourceHttpRequestHandler faviconRequestHandler() {\r\n				ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler();\r\n				requestHandler\r\n						.setLocations(this.resourceProperties.getFaviconLocations());\r\n				return requestHandler;\r\n			}\r\n\r\n		}\r\n\r\n```\r\n\r\n\r\n\r\n1）、所有 `/webjars/**` ，都去` classpath:/META-INF/resources/webjars/` 找资源；\r\n\r\n​	`webjars`：以jar包的方式引入静态资源；\r\n\r\nhttp://www.webjars.org/\r\n\r\n![](images/搜狗截图20180203181751.png)\r\n\r\nlocalhost:8080/webjars/jquery/3.3.1/jquery.js\r\n\r\n```xml\r\n<!--引入jquery-webjar-->在访问的时候只需要写webjars下面资源的名称即可\r\n		<dependency>\r\n			<groupId>org.webjars</groupId>\r\n			<artifactId>jquery</artifactId>\r\n			<version>3.3.1</version>\r\n		</dependency>\r\n```\r\n\r\n\r\n\r\n2）、\"/**\" 访问当前项目的任何资源，都去（静态资源的文件夹）找映射\r\n\r\n```\r\n\"classpath:/META-INF/resources/\", \r\n\"classpath:/resources/\",\r\n\"classpath:/static/\", \r\n\"classpath:/public/\" \r\n\"/\"：当前项目的根路径\r\n```\r\n\r\nlocalhost:8080/abc ===  去静态资源文件夹里面找abc\r\n\r\n3）、欢迎页； 静态资源文件夹下的所有index.html页面；被\"/**\"映射；\r\n\r\n​	localhost:8080/   找index页面\r\n\r\n4）、所有的 **/favicon.ico  都是在静态资源文件下找；\r\n\r\n\r\n\r\n## 3、模板引擎\r\n\r\nJSP、Velocity、Freemarker、Thymeleaf\r\n\r\n![](images/template-engine.png)\r\n\r\n\r\n\r\nSpringBoot推荐的Thymeleaf；\r\n\r\n语法更简单，功能更强大；\r\n\r\n\r\n\r\n### 1、引入thymeleaf；\r\n\r\n[thymeleaf官网](https://www.thymeleaf.org/)\r\n\r\n```xml\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-thymeleaf</artifactId>\r\n          	2.1.6\r\n		</dependency>\r\n切换thymeleaf版本\r\n<properties>\r\n		<thymeleaf.version>3.0.9.RELEASE</thymeleaf.version>\r\n		<!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 -->\r\n		<!-- thymeleaf2   layout1-->\r\n		<thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>\r\n  </properties>\r\n```\r\n\r\n\r\n\r\n### 2、Thymeleaf使用\r\n\r\n```java\r\n@ConfigurationProperties(prefix = \"spring.thymeleaf\")\r\npublic class ThymeleafProperties {\r\n\r\n	private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\");\r\n\r\n	private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\");\r\n\r\n	public static final String DEFAULT_PREFIX = \"classpath:/templates/\";\r\n\r\n	public static final String DEFAULT_SUFFIX = \".html\";\r\n  	//\r\n```\r\n\r\n只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；\r\n\r\n使用：\r\n\r\n1、导入thymeleaf的名称空间\r\n\r\n```xml\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n```\r\n\r\n2、使用thymeleaf语法；\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n    <h1>成功！</h1>\r\n    <!--th:text 将div里面的文本内容设置为 -->\r\n    <div th:text=\"${hello}\">这是显示欢迎信息</div>\r\n</body>\r\n</html>\r\n```\r\n\r\n### 3、语法规则\r\n\r\n1）、th:text；改变当前元素里面的文本内容；\r\n\r\n​	th：任意html属性；来替换原生属性的值\r\n\r\n![](images/2018-02-04_123955.png)\r\n\r\n\r\n\r\n2）、表达式？\r\n\r\n```properties\r\nSimple expressions:（表达式语法）\r\na. Variable Expressions: ${...}：获取变量值；OGNL；\r\n	1）、获取对象的属性、调用方法\r\n	2）、使用内置的基本对象：\r\n    #ctx : the context object.\r\n    #vars: the context variables.\r\n    #locale : the context locale.\r\n    #request : (only in Web Contexts) the HttpServletRequest object.\r\n    #response : (only in Web Contexts) the HttpServletResponse object.\r\n    #session : (only in Web Contexts) the HttpSession object.\r\n    #servletContext : (only in Web Contexts) the ServletContext object.\r\n	${session.foo}\r\n    3）、内置的一些工具对象：\r\n        #execInfo : information about the template being processed.\r\n        #messages : methods for obtaining externalized messages inside variables expressions,\r\n        #          in the same way as they would be obtained using #{…} syntax.\r\n        #uris : methods for escaping parts of URLs/URIs\r\n        #conversions : methods for executing the configured conversion service (if any).\r\n        #dates : methods for java.util.Date objects: formatting, component extraction, etc.\r\n        #calendars : analogous to #dates , but for java.util.Calendar objects.\r\n        #numbers : methods for formatting numeric objects.\r\n        #strings : methods for String objects: contains, startsWith, prepending/appending, etc.\r\n        #objects : methods for objects in general.\r\n        #bools : methods for boolean evaluation.\r\n        #arrays : methods for arrays.\r\n        #lists : methods for lists.\r\n        #sets : methods for sets.\r\n        #maps : methods for maps.\r\n        #aggregates : methods for creating aggregates on arrays or collections.\r\n        #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).\r\n\r\nb. Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；\r\n    	补充：配合 th:object=\"${session.user}：\r\n        <div th:object=\"${session.user}\">\r\n        <p>Name: <span th:text=\"*{firstName}\">Sebastian</span>.</p>\r\n        <p>Surname: <span th:text=\"*{lastName}\">Pepper</span>.</p>\r\n        <p>Nationality: <span th:text=\"*{nationality}\">Saturn</span>.</p>\r\n        </div>\r\n    \r\nc. Message Expressions: #{...}：获取国际化内容\r\nd. Link URL Expressions: @{...}：定义URL；\r\n    		@{/order/process(execId=${execId},execType=\'FAST\')}\r\nf. Fragment Expressions: ~{...}：片段引用表达式\r\n    		<div th:insert=\"~{commons :: main}\">...</div>\r\n    		\r\nLiterals（字面量）\r\n    Text literals: \'one text\' , \'Another one!\' ,…\r\n    Number literals: 0 , 34 , 3.0 , 12.3 ,…\r\n    Boolean literals: true , false\r\n    Null literal: null\r\n    Literal tokens: one , sometext , main ,…\r\nText operations:（文本操作）\r\n    String concatenation: +\r\n    Literal substitutions: |The name is ${name}|\r\nArithmetic operations:（数学运算）\r\n    Binary operators: + , - , * , / , %\r\n    Minus sign (unary operator): -\r\nBoolean operations:（布尔运算）\r\n    Binary operators: and , or\r\n    Boolean negation (unary operator): ! , not\r\nComparisons and equality:（比较运算）\r\n    Comparators: > , < , >= , <= ( gt , lt , ge , le )\r\n    Equality operators: == , != ( eq , ne )\r\nConditional operators:条件运算（三元运算符）\r\n    If-then: (if) ? (then)\r\n    If-then-else: (if) ? (then) : (else)\r\n    Default: (value) ?: (defaultvalue)\r\nSpecial tokens:\r\n    No-Operation: _ \r\n```\r\n\r\n## 4、SpringMVC自动配置\r\n\r\nhttps://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications\r\n\r\n### 1. Spring MVC auto-configuration\r\n\r\nSpring Boot 自动配置好了SpringMVC\r\n\r\n以下是SpringBoot对SpringMVC的默认配置:**（WebMvcAutoConfiguration）**\r\n\r\n- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.\r\n  - 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））\r\n  - ContentNegotiatingViewResolver：组合所有的视图解析器的；\r\n  - 如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；\r\n\r\n- Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars\r\n\r\n- Static `index.html` support. 静态首页访问\r\n\r\n- Custom `Favicon` support (see below).  favicon.ico\r\n\r\n  ​\r\n\r\n- 自动注册了 of `Converter`, `GenericConverter`, `Formatter` beans.\r\n\r\n  - `Converter`：转换器；  public String hello(User user)：类型转换使用Converter\r\n  - `Formatter`  格式化器；  2017.12.17===Date；\r\n\r\n```java\r\n@Bean\r\n@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则\r\npublic Formatter<Date> dateFormatter() {\r\n    return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件\r\n}\r\n```\r\n\r\n​	自己添加的格式化器转换器，我们只需要放在容器中即可\r\n\r\n- Support for `HttpMessageConverters` (see below).\r\n\r\n  - `HttpMessageConverter`：SpringMVC用来转换Http请求和响应的；User---Json；\r\n\r\n  - `HttpMessageConverters` 是从容器中确定；获取所有的HttpMessageConverter；\r\n\r\n    自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）\r\n\r\n    ​\r\n\r\n- Automatic registration of `MessageCodesResolver` (see below).定义错误代码生成规则\r\n\r\n- Automatic use of a `ConfigurableWebBindingInitializer` bean (see below).\r\n\r\n  我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）\r\n\r\n  ```\r\n  初始化WebDataBinder；\r\n  请求数据=====JavaBean；\r\n  ```\r\n\r\n**org.springframework.boot.autoconfigure.web：web的所有自动场景；**\r\n\r\nIf you want to keep Spring Boot MVC features, and you just want to add additional [MVC configuration](https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc) (interceptors, formatters, view controllers etc.) you can add your own `@Configuration` class of type `WebMvcConfigurerAdapter`, but **without** `@EnableWebMvc`. If you wish to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter` or `ExceptionHandlerExceptionResolver` you can declare a `WebMvcRegistrationsAdapter` instance providing such components.\r\n\r\nIf you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`.\r\n\r\n### 2、扩展SpringMVC\r\n\r\n```xml\r\n    <mvc:view-controller path=\"/hello\" view-name=\"success\"/>\r\n    <mvc:interceptors>\r\n        <mvc:interceptor>\r\n            <mvc:mapping path=\"/hello\"/>\r\n            <bean></bean>\r\n        </mvc:interceptor>\r\n    </mvc:interceptors>\r\n```\r\n\r\n**编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc**;\r\n\r\n既保留了所有的自动配置，也能用我们扩展的配置；\r\n\r\n```java\r\n/**\r\n * @Author: cuzz\r\n * @Date: 2018/9/21 14:29\r\n * @Description:\r\n */\r\n@Configuration\r\n// WebMvcConfigurerAdapter过时,使用WebMvcConfigurer接口\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n        // 浏览器发送 /cuzz 请求来到 success\r\n        registry.addViewController(\"/cuzz\").setViewName(\"success\");\r\n    }\r\n}\r\n```\r\n\r\n原理：\r\n\r\n​	1）、WebMvcAutoConfiguration是SpringMVC的自动配置类\r\n\r\n​	2）、在做其他自动配置时会导入；@Import(**EnableWebMvcConfiguration**.class)\r\n\r\n```java\r\n    @Configuration\r\n	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {\r\n      private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();\r\n\r\n	 //从容器中获取所有的WebMvcConfigurer\r\n      @Autowired(required = false)\r\n      public void setConfigurers(List<WebMvcConfigurer> configurers) {\r\n          if (!CollectionUtils.isEmpty(configurers)) {\r\n              this.configurers.addWebMvcConfigurers(configurers);\r\n            	//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  \r\n            	@Override\r\n             	// public void addViewControllers(ViewControllerRegistry registry) {\r\n              	// 	    for (WebMvcConfigurer delegate : this.delegates) {\r\n               	//      delegate.addViewControllers(registry);\r\n               	//   }\r\n              }\r\n          }\r\n	}\r\n```\r\n\r\n​	3）、容器中所有的WebMvcConfigurer都会一起起作用；\r\n\r\n​	4）、我们的配置类也会被调用；\r\n\r\n​	效果：SpringMVC的自动配置和我们的扩展配置都会起作用；\r\n\r\n### 3、全面接管SpringMVC；\r\n\r\nSpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了\r\n\r\n**我们需要在配置类中添加@EnableWebMvc即可；**\r\n\r\n```java\r\n//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能\r\n@EnableWebMvc\r\n@Configuration\r\npublic class MyMvcConfig extends WebMvcConfigurerAdapter {\r\n\r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n       // super.addViewControllers(registry);\r\n        //浏览器发送 /atguigu 请求来到 success\r\n        registry.addViewController(\"/atguigu\").setViewName(\"success\");\r\n    }\r\n}\r\n```\r\n\r\n原理：\r\n\r\n为什么@EnableWebMvc自动配置就失效了；\r\n\r\n1）@EnableWebMvc的核心\r\n\r\n```java\r\n@Import(DelegatingWebMvcConfiguration.class)\r\npublic @interface EnableWebMvc {\r\n```\r\n\r\n2）、\r\n\r\n```java\r\n@Configuration\r\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {\r\n```\r\n\r\n3）、\r\n\r\n```java\r\n@Configuration\r\n@ConditionalOnWebApplication\r\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,\r\n		WebMvcConfigurerAdapter.class })\r\n// 容器中没有这个组件的时候，这个自动配置类才生效\r\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)\r\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)\r\n@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,\r\n		ValidationAutoConfiguration.class })\r\npublic class WebMvcAutoConfiguration {\r\n```\r\n\r\n4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；\r\n\r\n5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；\r\n\r\n\r\n\r\n## 5、如何修改SpringBoot的默认配置\r\n\r\n模式：\r\n\r\n​	1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；\r\n\r\n​	2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置\r\n\r\n​	3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置\r\n\r\n## 6、RestfulCRUD\r\n\r\n### 1）、默认访问首页\r\n\r\n```java\r\n/**\r\n * @Author: cuzz\r\n * @Date: 2018/9/21 14:29\r\n * @Description:\r\n */\r\n@Configuration\r\n// WebMvcConfigurerAdapter过时,使用WebMvcConfigurer接口\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n        registry.addViewController(\"/cuzz\").setViewName(\"success\");\r\n    }\r\n    // 所有的WebMvcConfigurerAdapter组件都会一起起作用\r\n    @Bean\r\n    public WebMvcConfigurer webMvcConfigurer() {\r\n        WebMvcConfigurer webMvcConfigurer = new WebMvcConfigurer() {\r\n            @Override\r\n            public void addViewControllers(ViewControllerRegistry registry) {\r\n                registry.addViewController(\"/\").setViewName(\"login\");\r\n                registry.addViewController(\"/index.html\").setViewName(\"login\");\r\n            }\r\n        };\r\n        return webMvcConfigurer;\r\n    }\r\n}\r\n```\r\n\r\n### 2）、国际化\r\n\r\n**1）、编写国际化配置文件；**\r\n\r\n2）、使用ResourceBundleMessageSource管理国际化资源文件\r\n\r\n3）、在页面使用fmt:message取出国际化内容\r\n\r\ni18n = internationalization（国际化）的缩写，首位的i和末尾的n之间有18个字母，所以就简写为i18n了\r\n\r\n步骤：\r\n\r\nnew -> add properties file to resource bundle 要先新建一个properties文件，xxx_en_US.properties语言和国家\r\n\r\n![1537515512779](images/1537515512779.png)\r\n\r\n1）、编写国际化配置文件，抽取页面需要显示的国际化消息\r\n\r\n![1537515666575](images/1537515666575.png)\r\n\r\n![](images/搜狗截图20180211130721.png)\r\n\r\n\r\n\r\n2）、SpringBoot自动配置好了管理国际化资源文件的组件；\r\n\r\n```java\r\n@ConfigurationProperties(prefix = \"spring.messages\")\r\npublic class MessageSourceAutoConfiguration {\r\n    \r\n    /**\r\n	 * Comma-separated list of basenames (essentially a fully-qualified classpath\r\n	 * location), each following the ResourceBundle convention with relaxed support for\r\n	 * slash based locations. If it doesn\'t contain a package qualifier (such as\r\n	 * \"org.mypackage\"), it will be resolved from the classpath root.\r\n	 */\r\n	private String basename = \"messages\";  \r\n    //我们的配置文件可以直接放在类路径下叫messages.properties；\r\n    \r\n    @Bean\r\n	public MessageSource messageSource() {\r\n		ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\r\n		if (StringUtils.hasText(this.basename)) {\r\n            //设置国际化资源文件的基础名（去掉语言国家代码的）\r\n			messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(\r\n					StringUtils.trimAllWhitespace(this.basename)));\r\n		}\r\n		if (this.encoding != null) {\r\n			messageSource.setDefaultEncoding(this.encoding.name());\r\n		}\r\n		messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);\r\n		messageSource.setCacheSeconds(this.cacheSeconds);\r\n		messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);\r\n		return messageSource;\r\n	}\r\n```\r\n\r\n\r\n\r\n3）、去页面获取国际化的值；\r\n\r\n![](images/搜狗截图20180211134506.png)\r\n\r\n\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\"  xmlns:th=\"http://www.thymeleaf.org\">\r\n	<head>\r\n		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n		<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\r\n		<meta name=\"description\" content=\"\">\r\n		<meta name=\"author\" content=\"\">\r\n		<title>Signin Template for Bootstrap</title>\r\n		<!-- Bootstrap core CSS -->\r\n		<link href=\"asserts/css/bootstrap.min.css\" th:href=\"@{/webjars/bootstrap/4.0.0/css/bootstrap.css}\" rel=\"stylesheet\">\r\n		<!-- Custom styles for this template -->\r\n		<link href=\"asserts/css/signin.css\" th:href=\"@{/asserts/css/signin.css}\" rel=\"stylesheet\">\r\n	</head>\r\n\r\n	<body class=\"text-center\">\r\n		<form class=\"form-signin\" action=\"dashboard.html\">\r\n			<img class=\"mb-4\" th:src=\"@{/asserts/img/bootstrap-solid.svg}\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\">\r\n			<h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\">Please sign in</h1>\r\n			<label class=\"sr-only\" th:text=\"#{login.username}\">Username</label>\r\n			<input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#{login.username}\" required=\"\" autofocus=\"\">\r\n			<label class=\"sr-only\" th:text=\"#{login.password}\">Password</label>\r\n			<input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#{login.password}\" required=\"\">\r\n			<div class=\"checkbox mb-3\">\r\n				<label>\r\n          		<input type=\"checkbox\" value=\"remember-me\"/> [[#{login.remember}]]\r\n        </label>\r\n			</div>\r\n			<button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\">Sign in</button>\r\n			<p class=\"mt-5 mb-3 text-muted\">© 2017-2018</p>\r\n			<a class=\"btn btn-sm\">中文</a>\r\n			<a class=\"btn btn-sm\">English</a>\r\n		</form>\r\n\r\n	</body>\r\n\r\n</html>\r\n```\r\n\r\n效果：根据浏览器语言设置的信息切换了国际化；\r\n原理：\r\n\r\n​	国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；\r\n\r\n```java\r\n		@Bean\r\n		@ConditionalOnMissingBean\r\n		@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\")\r\n		public LocaleResolver localeResolver() {\r\n			if (this.mvcProperties\r\n					.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {\r\n				return new FixedLocaleResolver(this.mvcProperties.getLocale());\r\n			}\r\n			AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();\r\n			localeResolver.setDefaultLocale(this.mvcProperties.getLocale());\r\n			return localeResolver;\r\n		}\r\n默认的就是根据请求头带来的区域信息获取Locale进行国际化\r\n```\r\n\r\n4）、点击链接切换国际化\r\n\r\n```java\r\n/**\r\n * 可以在连接上携带区域信息\r\n */\r\npublic class MyLocaleResolver implements LocaleResolver {\r\n    \r\n    @Override\r\n    public Locale resolveLocale(HttpServletRequest request) {\r\n        String l = request.getParameter(\"l\");\r\n        Locale locale = Locale.getDefault();\r\n        if(!StringUtils.isEmpty(l)){\r\n            String[] split = l.split(\"_\");\r\n            locale = new Locale(split[0],split[1]);\r\n        }\r\n        return locale;\r\n    }\r\n\r\n    @Override\r\n    public void setLocale(HttpServletRequest request, \r\n                          HttpServletResponse response,\r\n                          Locale locale) {\r\n\r\n    }\r\n\r\n\r\n	// 国际化注入\r\n 	@Bean\r\n    public LocaleResolver localeResolver(){\r\n        return new MyLocaleResolver();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n### 3）、登陆\r\n\r\n开发期间模板引擎页面修改以后，要实时生效\r\n\r\n1）、禁用模板引擎的缓存\r\n\r\n```\r\n# 禁用缓存\r\nspring.thymeleaf.cache=false \r\n```\r\n\r\n2）、页面修改完成以后ctrl+f9：重新编译；\r\n\r\n\r\n\r\n登陆错误消息的显示\r\n\r\n```html\r\n<p style=\"color: red\" th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\"></p>\r\n```\r\n\r\n\r\n\r\n### 4）、拦截器进行登陆检查\r\n\r\n拦截器\r\n\r\n```java\r\n\r\n/**\r\n * 登陆检查，\r\n */\r\npublic class LoginHandlerInterceptor implements HandlerInterceptor {\r\n    //目标方法执行之前\r\n    @Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n        Object user = request.getSession().getAttribute(\"loginUser\");\r\n        if(user == null){\r\n            //未登陆，返回登陆页面\r\n            request.setAttribute(\"msg\",\"没有权限请先登陆\");\r\n            request.getRequestDispatcher(\"/index.html\").forward(request,response);\r\n            return false;\r\n        }else{\r\n            //已登陆，放行请求\r\n            return true;\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n注册拦截器\r\n\r\n```java\r\n/**\r\n * @Author: cuzz\r\n * @Date: 2018/9/21 14:29\r\n * @Description:\r\n */\r\n@Configuration\r\n// WebMvcConfigurerAdapter过时,使用WebMvcConfigurer接口\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n        registry.addViewController(\"/cuzz\").setViewName(\"success\");\r\n    }\r\n    //注册拦截器\r\n    @Override\r\n    public void addInterceptors(InterceptorRegistry registry) {\r\n        //super.addInterceptors(registry);\r\n        //静态资源；  *.css , *.js\r\n        //SpringBoot已经做好了静态资源映射\r\n        registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\")\r\n                .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\");\r\n    }\r\n\r\n    // 所有的WebMvcConfigurerAdapter组件都会一起起作用\r\n    @Bean\r\n    public WebMvcConfigurer webMvcConfigurer() {\r\n        WebMvcConfigurer webMvcConfigurer = new WebMvcConfigurer() {\r\n            @Override\r\n            public void addViewControllers(ViewControllerRegistry registry) {\r\n                registry.addViewController(\"/\").setViewName(\"login\");\r\n                registry.addViewController(\"/index.html\").setViewName(\"login\");\r\n                registry.addViewController(\"/main.html\").setViewName(\"dashboard\");\r\n            }\r\n        };\r\n        return webMvcConfigurer;\r\n    }\r\n\r\n    @Bean\r\n    public LocaleResolver localeResolver() {\r\n        return new MyLocaleResolver();\r\n    }\r\n}\r\n```\r\n\r\n### 5）、CRUD-员工列表\r\n\r\n实验要求：\r\n\r\n1）、RestfulCRUD：CRUD满足Rest风格；\r\n\r\nURI：  /资源名称/资源标识       HTTP请求方式区分对资源CRUD操作\r\n\r\n|      | 普通CRUD（uri来区分操作） | RestfulCRUD       |\r\n| ---- | ------------------------- | ----------------- |\r\n| 查询 | getEmp                    | emp---GET         |\r\n| 添加 | addEmp?xxx                | emp---POST        |\r\n| 修改 | updateEmp?id=xxx&xxx=xx   | emp/{id}---PUT    |\r\n| 删除 | deleteEmp?id=1            | emp/{id}---DELETE |\r\n\r\n2）、实验的请求架构;\r\n\r\n| 实验功能                             | 请求URI | 请求方式 |\r\n| ------------------------------------ | ------- | -------- |\r\n| 查询所有员工                         | emps    | GET      |\r\n| 查询某个员工(来到修改页面)           | emp/1   | GET      |\r\n| 来到添加页面                         | emp     | GET      |\r\n| 添加员工                             | emp     | POST     |\r\n| 来到修改页面（查出员工进行信息回显） | emp/1   | GET      |\r\n| 修改员工                             | emp     | PUT      |\r\n| 删除员工                             | emp/1   | DELETE   |\r\n\r\n3）、员工列表：\r\n#### thymeleaf公共页面元素抽取\r\n\r\n```html\r\n1、抽取公共片段\r\n<div th:fragment=\"copy\">\r\n&copy; 2011 The Good Thymes Virtual Grocery\r\n</div>\r\n\r\n2、引入公共片段\r\n<div th:insert=\"~{footer :: copy}\"></div>\r\n~{templatename::selector}：模板名::选择器\r\n~{templatename::fragmentname}:模板名::片段名\r\n\r\n3、默认效果：\r\ninsert的公共片段在div标签中\r\n如果使用th:insert等属性进行引入，可以不用写~{}：\r\n行内写法可以加上：[[~{}]];[(~{})]；\r\n```\r\n\r\n\r\n\r\n三种引入公共片段的th属性：\r\n\r\n**th:insert**：将公共片段整个插入到声明引入的元素中\r\n\r\n**th:replace**：将声明引入的元素替换为公共片段\r\n\r\n**th:include**：将被引入的片段的内容包含进这个标签中\r\n\r\n\r\n\r\n```html\r\n<footer th:fragment=\"copy\">\r\n&copy; 2011 The Good Thymes Virtual Grocery\r\n</footer>\r\n\r\n引入方式\r\n<div th:insert=\"footer :: copy\"></div>\r\n<div th:replace=\"footer :: copy\"></div>\r\n<div th:include=\"footer :: copy\"></div>\r\n\r\n效果\r\n<div>\r\n    <footer>\r\n    &copy; 2011 The Good Thymes Virtual Grocery\r\n    </footer>\r\n</div>\r\n\r\n<footer>\r\n&copy; 2011 The Good Thymes Virtual Grocery\r\n</footer>\r\n\r\n<div>\r\n&copy; 2011 The Good Thymes Virtual Grocery\r\n</div>\r\n```\r\n\r\n\r\n\r\n引入片段的时候传入参数： \r\n\r\n```html\r\n\r\n<nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\">\r\n    <div class=\"sidebar-sticky\">\r\n        <ul class=\"nav flex-column\">\r\n            <li class=\"nav-item\">\r\n                <a class=\"nav-link active\"\r\n                   th:class=\"${activeUri==\'main.html\'?\'nav-link active\':\'nav-link\'}\"\r\n                   href=\"#\" th:href=\"@{/main.html}\">\r\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\">\r\n                        <path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"></path>\r\n                        <polyline points=\"9 22 9 12 15 12 15 22\"></polyline>\r\n                    </svg>\r\n                    Dashboard <span class=\"sr-only\">(current)</span>\r\n                </a>\r\n            </li>\r\n\r\n<!--引入侧边栏;传入参数-->\r\n<div th:replace=\"commons/bar::#sidebar(activeUri=\'emps\')\"></div>\r\n```\r\n\r\n### 6）、CRUD-员工添加\r\n\r\n添加页面\r\n\r\n```html\r\n<form>\r\n    <div class=\"form-group\">\r\n        <label>LastName</label>\r\n        <input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label>Email</label>\r\n        <input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label>Gender</label><br/>\r\n        <div class=\"form-check form-check-inline\">\r\n            <input class=\"form-check-input\" type=\"radio\" name=\"gender\"  value=\"1\">\r\n            <label class=\"form-check-label\">男</label>\r\n        </div>\r\n        <div class=\"form-check form-check-inline\">\r\n            <input class=\"form-check-input\" type=\"radio\" name=\"gender\"  value=\"0\">\r\n            <label class=\"form-check-label\">女</label>\r\n        </div>\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label>department</label>\r\n        <select class=\"form-control\">\r\n            <option>1</option>\r\n            <option>2</option>\r\n            <option>3</option>\r\n            <option>4</option>\r\n            <option>5</option>\r\n        </select>\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label>Birth</label>\r\n        <input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\">\r\n    </div>\r\n    <button type=\"submit\" class=\"btn btn-primary\">添加</button>\r\n</form>\r\n```\r\n\r\n提交的数据格式不对：生日：日期；\r\n\r\n2017-12-12；2017/12/12；2017.12.12；\r\n\r\n日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;\r\n\r\n2017-12-12---Date； 类型转换，格式化;\r\n\r\n默认日期是按照/的方式；\r\n\r\n### 7）、CRUD-员工修改\r\n\r\n修改添加二合一表单\r\n\r\n```html\r\n<!--需要区分是员工修改还是添加；-->\r\n<form th:action=\"@{/emp}\" method=\"post\">\r\n    <!--发送put请求修改员工数据-->\r\n    <!--\r\n1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）\r\n2、页面创建一个post表单\r\n3、创建一个input项，name=\"_method\";值就是我们指定的请求方式\r\n-->\r\n    <input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"${emp!=null}\"/>\r\n    <input type=\"hidden\" name=\"id\" th:if=\"${emp!=null}\" th:value=\"${emp.id}\">\r\n    <div class=\"form-group\">\r\n        <label>LastName</label>\r\n        <input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"${emp!=null}?${emp.lastName}\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label>Email</label>\r\n        <input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"${emp!=null}?${emp.email}\">\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label>Gender</label><br/>\r\n        <div class=\"form-check form-check-inline\">\r\n            <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"${emp!=null}?${emp.gender==1}\">\r\n            <label class=\"form-check-label\">男</label>\r\n        </div>\r\n        <div class=\"form-check form-check-inline\">\r\n            <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"${emp!=null}?${emp.gender==0}\">\r\n            <label class=\"form-check-label\">女</label>\r\n        </div>\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label>department</label>\r\n        <!--提交的是部门的id-->\r\n        <select class=\"form-control\" name=\"department.id\">\r\n            <option th:selected=\"${emp!=null}?${dept.id == emp.department.id}\" th:value=\"${dept.id}\" th:each=\"dept:${depts}\" th:text=\"${dept.departmentName}\">1</option>\r\n        </select>\r\n    </div>\r\n    <div class=\"form-group\">\r\n        <label>Birth</label>\r\n        <input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"${emp!=null}?${#dates.format(emp.birth, \'yyyy-MM-dd HH:mm\')}\">\r\n    </div>\r\n    <button type=\"submit\" class=\"btn btn-primary\" th:text=\"${emp!=null}?\'修改\':\'添加\'\">添加</button>\r\n</form>\r\n```\r\n\r\n### 8）、CRUD-员工删除\r\n\r\n```html\r\n<tr th:each=\"emp:${emps}\">\r\n    <td th:text=\"${emp.id}\"></td>\r\n    <td>[[${emp.lastName}]]</td>\r\n    <td th:text=\"${emp.email}\"></td>\r\n    <td th:text=\"${emp.gender}==0?\'女\':\'男\'\"></td>\r\n    <td th:text=\"${emp.department.departmentName}\"></td>\r\n    <td th:text=\"${#dates.format(emp.birth, \'yyyy-MM-dd HH:mm\')}\"></td>\r\n    <td>\r\n        <a class=\"btn btn-sm btn-primary\" th:href=\"@{/emp/}+${emp.id}\">编辑</a>\r\n        <button th:attr=\"del_uri=@{/emp/}+${emp.id}\" class=\"btn btn-sm btn-danger deleteBtn\">删除</button>\r\n    </td>\r\n</tr>\r\n\r\n\r\n<script>\r\n    $(\".deleteBtn\").click(function(){\r\n        //删除当前员工的\r\n        $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit();\r\n        return false;\r\n    });\r\n</script>\r\n```\r\n## 7、错误处理机制\r\n\r\n### 1）、SpringBoot默认的错误处理机制\r\n\r\n默认效果：\r\n\r\n​		1）、浏览器，返回一个默认的错误页面\r\n\r\n![](images/搜狗截图20180226173408.png)\r\n\r\n  浏览器发送请求的请求头：\r\n\r\n![](images/搜狗截图20180226180347.png)\r\n\r\n​		2）、如果是其他客户端，默认响应一个json数据\r\n\r\n![](images/搜狗截图20180226173527.png)\r\n\r\n​		![](images/搜狗截图20180226180504.png)\r\n\r\n原理：\r\n\r\n​	可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；\r\n\r\n  	给容器中添加了以下组件\r\n\r\n​	1、DefaultErrorAttributes：\r\n\r\n```java\r\n帮我们在页面共享信息；\r\n@Override\r\n	public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes,\r\n			boolean includeStackTrace) {\r\n		Map<String, Object> errorAttributes = new LinkedHashMap<String, Object>();\r\n		errorAttributes.put(\"timestamp\", new Date());\r\n		addStatus(errorAttributes, requestAttributes);\r\n		addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);\r\n		addPath(errorAttributes, requestAttributes);\r\n		return errorAttributes;\r\n	}\r\n```\r\n\r\n\r\n\r\n​	2、BasicErrorController：处理默认/error请求\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"${server.error.path:${error.path:/error}}\")\r\npublic class BasicErrorController extends AbstractErrorController {\r\n    \r\n    @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理\r\n	public ModelAndView errorHtml(HttpServletRequest request,\r\n			HttpServletResponse response) {\r\n		HttpStatus status = getStatus(request);\r\n		Map<String, Object> model = Collections.unmodifiableMap(getErrorAttributes(\r\n				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));\r\n		response.setStatus(status.value());\r\n        \r\n        //去哪个页面作为错误页面；包含页面地址和页面内容\r\n		ModelAndView modelAndView = resolveErrorView(request, response, status, model);\r\n		return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView);\r\n	}\r\n\r\n	@RequestMapping\r\n	@ResponseBody    //产生json数据，其他客户端来到这个方法处理；\r\n	public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {\r\n		Map<String, Object> body = getErrorAttributes(request,\r\n				isIncludeStackTrace(request, MediaType.ALL));\r\n		HttpStatus status = getStatus(request);\r\n		return new ResponseEntity<Map<String, Object>>(body, status);\r\n	}\r\n```\r\n\r\n\r\n\r\n​	3、ErrorPageCustomizer：\r\n\r\n```java\r\n	@Value(\"${error.path:/error}\")\r\n	private String path = \"/error\";  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）\r\n```\r\n\r\n\r\n\r\n​	4、DefaultErrorViewResolver：\r\n\r\n```java\r\n@Override\r\n	public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,\r\n			Map<String, Object> model) {\r\n		ModelAndView modelAndView = resolve(String.valueOf(status), model);\r\n		if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {\r\n			modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);\r\n		}\r\n		return modelAndView;\r\n	}\r\n\r\n	private ModelAndView resolve(String viewName, Map<String, Object> model) {\r\n        //默认SpringBoot可以去找到一个页面？  error/404\r\n		String errorViewName = \"error/\" + viewName;\r\n        \r\n        //模板引擎可以解析这个页面地址就用模板引擎解析\r\n		TemplateAvailabilityProvider provider = this.templateAvailabilityProviders\r\n				.getProvider(errorViewName, this.applicationContext);\r\n		if (provider != null) {\r\n            //模板引擎可用的情况下返回到errorViewName指定的视图地址\r\n			return new ModelAndView(errorViewName, model);\r\n		}\r\n        //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html\r\n		return resolveResource(errorViewName, model);\r\n	}\r\n```\r\n\r\n	步骤：\r\n\r\n​		一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被**BasicErrorController**处理；\r\n\r\n​		1）响应页面；去哪个页面是由**DefaultErrorViewResolver**解析得到的；\r\n\r\n```java\r\nprotected ModelAndView resolveErrorView(HttpServletRequest request,\r\n      HttpServletResponse response, HttpStatus status, Map<String, Object> model) {\r\n    //所有的ErrorViewResolver得到ModelAndView\r\n   for (ErrorViewResolver resolver : this.errorViewResolvers) {\r\n      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);\r\n      if (modelAndView != null) {\r\n         return modelAndView;\r\n      }\r\n   }\r\n   return null;\r\n}\r\n```\r\n\r\n### 2）、如何定制错误响应：\r\n\r\n#### 	1）、如何定制错误的页面；\r\n\r\n​		**1）、有模板引擎的情况下；error/状态码;** 【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到  对应的页面；\r\n\r\n​		我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；\r\n\r\n​		页面能获取的信息；\r\n\r\n​			timestamp：时间戳\r\n\r\n​			status：状态码\r\n\r\n​			error：错误提示\r\n\r\n​			exception：异常对象\r\n\r\n​			message：异常消息\r\n\r\n​			errors：JSR303数据校验的错误都在这里\r\n\r\n​		2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；\r\n\r\n​		3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；\r\n\r\n\r\n\r\n#### 	2）、如何定制错误的json数据；\r\n\r\n​	1）、自定义异常处理&返回定制json数据；\r\n\r\n```java\r\n@ControllerAdvice\r\npublic class MyExceptionHandler {\r\n\r\n    @ResponseBody\r\n    @ExceptionHandler(UserNotExistException.class)\r\n    public Map<String,Object> handleException(Exception e){\r\n        Map<String,Object> map = new HashMap<>();\r\n        map.put(\"code\",\"user.notexist\");\r\n        map.put(\"message\",e.getMessage());\r\n        return map;\r\n    }\r\n}\r\n//没有自适应效果...\r\n```\r\n2）、转发到/error进行自适应响应效果处理\r\n\r\n```java\r\n @ExceptionHandler(UserNotExistException.class)\r\n    public String handleException(Exception e, HttpServletRequest request){\r\n        Map<String,Object> map = new HashMap<>();\r\n        //传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程\r\n        /**\r\n         * Integer statusCode = (Integer) request\r\n         .getAttribute(\"javax.servlet.error.status_code\");\r\n         */\r\n        request.setAttribute(\"javax.servlet.error.status_code\",500);\r\n        map.put(\"code\",\"user.notexist\");\r\n        map.put(\"message\",e.getMessage());\r\n        //转发到/error\r\n        return \"forward:/error\";\r\n    }\r\n```\r\n\r\n#### 	3）、将我们的定制数据携带出去；\r\n\r\n出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；\r\n\r\n​	1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；\r\n\r\n​	2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；\r\n\r\n​			容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；\r\n\r\n自定义ErrorAttributes\r\n\r\n```java\r\n//给容器中加入我们自己定义的ErrorAttributes\r\n@Component\r\npublic class MyErrorAttributes extends DefaultErrorAttributes {\r\n\r\n    @Override\r\n    public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) {\r\n        Map<String, Object> map = super.getErrorAttributes(requestAttributes, includeStackTrace);\r\n        map.put(\"company\",\"atguigu\");\r\n        return map;\r\n    }\r\n}\r\n```\r\n\r\n最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，\r\n\r\n![](images/搜狗截图20180228135513.png)\r\n\r\n\r\n\r\n## 8、配置嵌入式Servlet容器\r\n\r\nSpringBoot默认使用Tomcat作为嵌入式的Servlet容器；\r\n\r\n![](images/搜狗截图20180301142915.png)\r\n\r\n\r\n\r\n问题？\r\n\r\n### 1）、如何定制和修改Servlet容器的相关配置；\r\n\r\n1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；\r\n\r\n```properties\r\nserver.port=8081\r\nserver.context-path=/crud\r\n\r\nserver.tomcat.uri-encoding=UTF-8\r\n\r\n//通用的Servlet容器设置\r\nserver.xxx\r\n//Tomcat的设置\r\nserver.tomcat.xxx\r\n```\r\n\r\n2、编写一个**EmbeddedServletContainerCustomizer**：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置\r\n\r\n```java\r\n@Bean  //一定要将这个定制器加入到容器中\r\npublic EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){\r\n    return new EmbeddedServletContainerCustomizer() {\r\n\r\n        //定制嵌入式的Servlet容器相关的规则\r\n        @Override\r\n        public void customize(ConfigurableEmbeddedServletContainer container) {\r\n            container.setPort(8083);\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n### 2）、注册Servlet三大组件【Servlet、Filter、Listener】\r\n\r\n由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。\r\n\r\n注册三大组件用以下方式\r\n\r\nServletRegistrationBean\r\n\r\n```java\r\n//注册三大组件\r\n@Bean\r\npublic ServletRegistrationBean myServlet(){\r\n    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\");\r\n    return registrationBean;\r\n}\r\n\r\n```\r\n\r\nFilterRegistrationBean\r\n\r\n```java\r\n@Bean\r\npublic FilterRegistrationBean myFilter(){\r\n    FilterRegistrationBean registrationBean = new FilterRegistrationBean();\r\n    registrationBean.setFilter(new MyFilter());\r\n    registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\"));\r\n    return registrationBean;\r\n}\r\n```\r\n\r\nServletListenerRegistrationBean\r\n\r\n```java\r\n@Bean\r\npublic ServletListenerRegistrationBean myListener(){\r\n    ServletListenerRegistrationBean<MyListener> registrationBean = new ServletListenerRegistrationBean<>(new MyListener());\r\n    return registrationBean;\r\n}\r\n```\r\n\r\n\r\n\r\nSpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；\r\n\r\nDispatcherServletAutoConfiguration中：\r\n\r\n```java\r\n@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)\r\n@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\r\npublic ServletRegistrationBean dispatcherServletRegistration(\r\n      DispatcherServlet dispatcherServlet) {\r\n   ServletRegistrationBean registration = new ServletRegistrationBean(\r\n         dispatcherServlet, this.serverProperties.getServletMapping());\r\n    //默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp\r\n    //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径\r\n    \r\n   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);\r\n   registration.setLoadOnStartup(\r\n         this.webMvcProperties.getServlet().getLoadOnStartup());\r\n   if (this.multipartConfig != null) {\r\n      registration.setMultipartConfig(this.multipartConfig);\r\n   }\r\n   return registration;\r\n}\r\n\r\n```\r\n\r\n2）、SpringBoot能不能支持其他的Servlet容器；\r\n### 3）、替换为其他嵌入式Servlet容器\r\n\r\n![](images/搜狗截图20180302114401.png)\r\n\r\n默认支持：\r\n\r\nTomcat（默认使用）\r\n\r\n```xml\r\n<dependency>\r\n   <groupId>org.springframework.boot</groupId>\r\n   <artifactId>spring-boot-starter-web</artifactId>\r\n   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；\r\n</dependency>\r\n```\r\n\r\nJetty\r\n\r\n```xml\r\n<!-- 引入web模块 -->\r\n<dependency>\r\n   <groupId>org.springframework.boot</groupId>\r\n   <artifactId>spring-boot-starter-web</artifactId>\r\n   <exclusions>\r\n      <exclusion>\r\n         <artifactId>spring-boot-starter-tomcat</artifactId>\r\n         <groupId>org.springframework.boot</groupId>\r\n      </exclusion>\r\n   </exclusions>\r\n</dependency>\r\n\r\n<!--引入其他的Servlet容器-->\r\n<dependency>\r\n   <artifactId>spring-boot-starter-jetty</artifactId>\r\n   <groupId>org.springframework.boot</groupId>\r\n</dependency>\r\n```\r\n\r\nUndertow\r\n\r\n```xml\r\n<!-- 引入web模块 -->\r\n<dependency>\r\n   <groupId>org.springframework.boot</groupId>\r\n   <artifactId>spring-boot-starter-web</artifactId>\r\n   <exclusions>\r\n      <exclusion>\r\n         <artifactId>spring-boot-starter-tomcat</artifactId>\r\n         <groupId>org.springframework.boot</groupId>\r\n      </exclusion>\r\n   </exclusions>\r\n</dependency>\r\n\r\n<!--引入其他的Servlet容器-->\r\n<dependency>\r\n   <artifactId>spring-boot-starter-undertow</artifactId>\r\n   <groupId>org.springframework.boot</groupId>\r\n</dependency>\r\n```\r\n\r\n### 4）、嵌入式Servlet容器自动配置原理；\r\n\r\n\r\n\r\nEmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？\r\n\r\n```java\r\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\r\n@Configuration\r\n@ConditionalOnWebApplication\r\n@Import(BeanPostProcessorsRegistrar.class)\r\n//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件\r\n//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：\r\n//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作\r\npublic class EmbeddedServletContainerAutoConfiguration {\r\n    \r\n    @Configuration\r\n	@ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖；\r\n	@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器\r\n	public static class EmbeddedTomcat {\r\n\r\n		@Bean\r\n		public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {\r\n			return new TomcatEmbeddedServletContainerFactory();\r\n		}\r\n\r\n	}\r\n    \r\n    /**\r\n	 * Nested configuration if Jetty is being used.\r\n	 */\r\n	@Configuration\r\n	@ConditionalOnClass({ Servlet.class, Server.class, Loader.class,\r\n			WebAppContext.class })\r\n	@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\r\n	public static class EmbeddedJetty {\r\n\r\n		@Bean\r\n		public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {\r\n			return new JettyEmbeddedServletContainerFactory();\r\n		}\r\n\r\n	}\r\n\r\n	/**\r\n	 * Nested configuration if Undertow is being used.\r\n	 */\r\n	@Configuration\r\n	@ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })\r\n	@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\r\n	public static class EmbeddedUndertow {\r\n\r\n		@Bean\r\n		public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() {\r\n			return new UndertowEmbeddedServletContainerFactory();\r\n		}\r\n\r\n	}\r\n```\r\n\r\n1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）\r\n\r\n```java\r\npublic interface EmbeddedServletContainerFactory {\r\n\r\n   //获取嵌入式的Servlet容器\r\n   EmbeddedServletContainer getEmbeddedServletContainer(\r\n         ServletContextInitializer... initializers);\r\n\r\n}\r\n```\r\n\r\n![](images/搜狗截图20180302144835.png)\r\n\r\n2）、EmbeddedServletContainer：（嵌入式的Servlet容器）\r\n\r\n![](images/搜狗截图20180302144910.png)\r\n\r\n\r\n\r\n3）、以**TomcatEmbeddedServletContainerFactory**为例\r\n\r\n```java\r\n@Override\r\npublic EmbeddedServletContainer getEmbeddedServletContainer(\r\n      ServletContextInitializer... initializers) {\r\n    //创建一个Tomcat\r\n   Tomcat tomcat = new Tomcat();\r\n    \r\n    //配置Tomcat的基本环节\r\n   File baseDir = (this.baseDirectory != null ? this.baseDirectory\r\n         : createTempDir(\"tomcat\"));\r\n   tomcat.setBaseDir(baseDir.getAbsolutePath());\r\n   Connector connector = new Connector(this.protocol);\r\n   tomcat.getService().addConnector(connector);\r\n   customizeConnector(connector);\r\n   tomcat.setConnector(connector);\r\n   tomcat.getHost().setAutoDeploy(false);\r\n   configureEngine(tomcat.getEngine());\r\n   for (Connector additionalConnector : this.additionalTomcatConnectors) {\r\n      tomcat.getService().addConnector(additionalConnector);\r\n   }\r\n   prepareContext(tomcat.getHost(), initializers);\r\n    \r\n    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器\r\n   return getTomcatEmbeddedServletContainer(tomcat);\r\n}\r\n```\r\n\r\n4）、我们对嵌入式容器的配置修改是怎么生效？\r\n\r\n```\r\nServerProperties、EmbeddedServletContainerCustomizer\r\n```\r\n\r\n\r\n\r\n**EmbeddedServletContainerCustomizer**：定制器帮我们修改了Servlet容器的配置？\r\n\r\n怎么修改的原理？\r\n\r\n5）、容器中导入了**EmbeddedServletContainerCustomizerBeanPostProcessor**\r\n\r\n```java\r\n//初始化之前\r\n@Override\r\npublic Object postProcessBeforeInitialization(Object bean, String beanName)\r\n      throws BeansException {\r\n    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件\r\n   if (bean instanceof ConfigurableEmbeddedServletContainer) {\r\n       //\r\n      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);\r\n   }\r\n   return bean;\r\n}\r\n\r\nprivate void postProcessBeforeInitialization(\r\n			ConfigurableEmbeddedServletContainer bean) {\r\n    //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；\r\n    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {\r\n        customizer.customize(bean);\r\n    }\r\n}\r\n\r\nprivate Collection<EmbeddedServletContainerCustomizer> getCustomizers() {\r\n    if (this.customizers == null) {\r\n        // Look up does not include the parent context\r\n        this.customizers = new ArrayList<EmbeddedServletContainerCustomizer>(\r\n            this.beanFactory\r\n            //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer\r\n            //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件\r\n            .getBeansOfType(EmbeddedServletContainerCustomizer.class,\r\n                            false, false)\r\n            .values());\r\n        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);\r\n        this.customizers = Collections.unmodifiableList(this.customizers);\r\n    }\r\n    return this.customizers;\r\n}\r\n\r\nServerProperties也是定制器\r\n```\r\n步骤：\r\n\r\n1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】\r\n\r\n2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；\r\n\r\n只要是嵌入式的Servlet容器工厂，后置处理器就工作；\r\n\r\n3）、后置处理器，从容器中获取所有的**EmbeddedServletContainerCustomizer**，调用定制器的定制方法\r\n\r\n\r\n\r\n###5）、嵌入式Servlet容器启动原理；\r\n\r\n什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；\r\n\r\n获取嵌入式的Servlet容器工厂：\r\n\r\n1）、SpringBoot应用启动运行run方法\r\n\r\n2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建**AnnotationConfigEmbeddedWebApplicationContext**，否则：**AnnotationConfigApplicationContext**\r\n\r\n3）、refresh(context);**刷新刚才创建好的ioc容器；**\r\n\r\n```java\r\npublic void refresh() throws BeansException, IllegalStateException {\r\n   synchronized (this.startupShutdownMonitor) {\r\n      // Prepare this context for refreshing.\r\n      prepareRefresh();\r\n\r\n      // Tell the subclass to refresh the internal bean factory.\r\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\r\n\r\n      // Prepare the bean factory for use in this context.\r\n      prepareBeanFactory(beanFactory);\r\n\r\n      try {\r\n         // Allows post-processing of the bean factory in context subclasses.\r\n         postProcessBeanFactory(beanFactory);\r\n\r\n         // Invoke factory processors registered as beans in the context.\r\n         invokeBeanFactoryPostProcessors(beanFactory);\r\n\r\n         // Register bean processors that intercept bean creation.\r\n         registerBeanPostProcessors(beanFactory);\r\n\r\n         // Initialize message source for this context.\r\n         initMessageSource();\r\n\r\n         // Initialize event multicaster for this context.\r\n         initApplicationEventMulticaster();\r\n\r\n         // Initialize other special beans in specific context subclasses.\r\n         onRefresh();\r\n\r\n         // Check for listener beans and register them.\r\n         registerListeners();\r\n\r\n         // Instantiate all remaining (non-lazy-init) singletons.\r\n         finishBeanFactoryInitialization(beanFactory);\r\n\r\n         // Last step: publish corresponding event.\r\n         finishRefresh();\r\n      }\r\n\r\n      catch (BeansException ex) {\r\n         if (logger.isWarnEnabled()) {\r\n            logger.warn(\"Exception encountered during context initialization - \" +\r\n                  \"cancelling refresh attempt: \" + ex);\r\n         }\r\n\r\n         // Destroy already created singletons to avoid dangling resources.\r\n         destroyBeans();\r\n\r\n         // Reset \'active\' flag.\r\n         cancelRefresh(ex);\r\n\r\n         // Propagate exception to caller.\r\n         throw ex;\r\n      }\r\n\r\n      finally {\r\n         // Reset common introspection caches in Spring\'s core, since we\r\n         // might not ever need metadata for singleton beans anymore...\r\n         resetCommonCaches();\r\n      }\r\n   }\r\n}\r\n```\r\n\r\n4）、  onRefresh(); web的ioc容器重写了onRefresh方法\r\n\r\n5）、webioc容器会创建嵌入式的Servlet容器；**createEmbeddedServletContainer**();\r\n\r\n**6）、获取嵌入式的Servlet容器工厂：**\r\n\r\nEmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();\r\n\r\n​	从ioc容器中获取EmbeddedServletContainerFactory 组件；**TomcatEmbeddedServletContainerFactory**创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；\r\n\r\n7）、**使用容器工厂获取嵌入式的Servlet容器**：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());\r\n\r\n8）、嵌入式的Servlet容器创建对象并启动Servlet容器；\r\n\r\n**先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；**\r\n\r\n**IOC容器启动创建嵌入式的Servlet容器**\r\n\r\n\r\n\r\n## 9、使用外置的Servlet容器\r\n\r\n嵌入式Servlet容器：应用打成可执行的jar\r\n\r\n​		优点：简单、便携；\r\n\r\n​		缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；\r\n\r\n\r\n\r\n外置的Servlet容器：外面安装Tomcat---应用war包的方式打包；\r\n\r\n### 步骤\r\n\r\n1）、必须创建一个war项目；（利用idea创建好目录结构）\r\n\r\n- new project or new module\r\n\r\n![1537583437482](images/1537583437482.png)\r\n\r\n- create\r\n\r\n  ![1537583796091](/images/1537583796091.png)\r\n\r\n- web.xml\r\n\r\n  ![1537584525195](/images/1537584525195.png)\r\n\r\n- 添加外部tomcat启动\r\n\r\n2）、将嵌入式的Tomcat指定为provided；\r\n\r\n```xml\r\n<dependency>\r\n   <groupId>org.springframework.boot</groupId>\r\n   <artifactId>spring-boot-starter-tomcat</artifactId>\r\n   <scope>provided</scope>\r\n</dependency>\r\n```\r\n\r\n3）、必须编写一个**SpringBootServletInitializer**的子类，并调用configure方法\r\n\r\n```java\r\npublic class ServletInitializer extends SpringBootServletInitializer {\r\n\r\n   @Override\r\n   protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\r\n       //传入SpringBoot应用的主程序\r\n      return application.sources(SpringBoot04WebJspApplication.class);\r\n   }\r\n\r\n}\r\n```\r\n\r\n4）、启动服务器就可以使用；\r\n### 原理\r\n\r\njar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；\r\n\r\nwar包：启动服务器，**服务器启动SpringBoot应用**【SpringBootServletInitializer】，启动ioc容器；\r\n\r\n\r\n\r\nservlet3.0（Spring注解版）： \r\n\r\n8.2.4 Shared libraries / runtimes pluggability：\r\n\r\n规则：\r\n\r\n​	1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：\r\n\r\n​	2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名\r\n\r\n​	3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；\r\n\r\n\r\n\r\n流程：\r\n\r\n1）、启动Tomcat\r\n\r\n2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer：\r\n\r\nSpring的web模块里面有这个文件：**org.springframework.web.SpringServletContainerInitializer**\r\n\r\n3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set<Class<?>>；为这些WebApplicationInitializer类型的类创建实例；\r\n\r\n4）、每一个WebApplicationInitializer都调用自己的onStartup；\r\n\r\n![](images/搜狗截图20180302221835.png)\r\n\r\n5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法\r\n\r\n6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器\r\n\r\n```java\r\nprotected WebApplicationContext createRootApplicationContext(\r\n      ServletContext servletContext) {\r\n    //1、创建SpringApplicationBuilder\r\n   SpringApplicationBuilder builder = createSpringApplicationBuilder();\r\n   StandardServletEnvironment environment = new StandardServletEnvironment();\r\n   environment.initPropertySources(servletContext, null);\r\n   builder.environment(environment);\r\n   builder.main(getClass());\r\n   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);\r\n   if (parent != null) {\r\n      this.logger.info(\"Root context already created (using as parent).\");\r\n      servletContext.setAttribute(\r\n            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);\r\n      builder.initializers(new ParentContextApplicationContextInitializer(parent));\r\n   }\r\n   builder.initializers(\r\n         new ServletContextApplicationContextInitializer(servletContext));\r\n   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);\r\n    \r\n    //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来\r\n   builder = configure(builder);\r\n    \r\n    //使用builder创建一个Spring应用\r\n   SpringApplication application = builder.build();\r\n   if (application.getSources().isEmpty() && AnnotationUtils\r\n         .findAnnotation(getClass(), Configuration.class) != null) {\r\n      application.getSources().add(getClass());\r\n   }\r\n   Assert.state(!application.getSources().isEmpty(),\r\n         \"No SpringApplication sources have been defined. Either override the \"\r\n               + \"configure method or add an @Configuration annotation\");\r\n   // Ensure error pages are registered\r\n   if (this.registerErrorPageFilter) {\r\n      application.getSources().add(ErrorPageFilterConfiguration.class);\r\n   }\r\n    //启动Spring应用\r\n   return run(application);\r\n}\r\n```\r\n\r\n7）、Spring的应用就启动并且创建IOC容器\r\n\r\n```java\r\npublic ConfigurableApplicationContext run(String... args) {\r\n   StopWatch stopWatch = new StopWatch();\r\n   stopWatch.start();\r\n   ConfigurableApplicationContext context = null;\r\n   FailureAnalyzers analyzers = null;\r\n   configureHeadlessProperty();\r\n   SpringApplicationRunListeners listeners = getRunListeners(args);\r\n   listeners.starting();\r\n   try {\r\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(\r\n            args);\r\n      ConfigurableEnvironment environment = prepareEnvironment(listeners,\r\n            applicationArguments);\r\n      Banner printedBanner = printBanner(environment);\r\n      context = createApplicationContext();\r\n      analyzers = new FailureAnalyzers(context);\r\n      prepareContext(context, environment, listeners, applicationArguments,\r\n            printedBanner);\r\n       \r\n       //刷新IOC容器\r\n      refreshContext(context);\r\n      afterRefresh(context, applicationArguments);\r\n      listeners.finished(context, null);\r\n      stopWatch.stop();\r\n      if (this.logStartupInfo) {\r\n         new StartupInfoLogger(this.mainApplicationClass)\r\n               .logStarted(getApplicationLog(), stopWatch);\r\n      }\r\n      return context;\r\n   }\r\n   catch (Throwable ex) {\r\n      handleRunFailure(context, listeners, analyzers, ex);\r\n      throw new IllegalStateException(ex);\r\n   }\r\n}\r\n```\r\n\r\n**启动Servlet容器，再启动SpringBoot应用**\r\n\r\n\r\n\r\n# 五、Docker\r\n\r\n## 1、简介\r\n\r\n**Docker**是一个开源的应用容器引擎；是一个轻量级容器技术；\r\n\r\nDocker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；\r\n\r\n运行中的这个镜像称为容器，容器启动是非常快速的。\r\n\r\n![](images/搜狗截图20180303145450.png)\r\n\r\n\r\n\r\n![](images/搜狗截图20180303145531.png)\r\n\r\n## 2、核心概念\r\n\r\ndocker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；\r\n\r\ndocker客户端(Client)：连接docker主机进行操作；\r\n\r\ndocker仓库(Registry)：用来保存各种打包好的软件镜像；\r\n\r\ndocker镜像(Images)：软件打包好的镜像；放在docker仓库中；\r\n\r\ndocker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用\r\n\r\n![](images/搜狗截图20180303165113.png)\r\n\r\n使用Docker的步骤：\r\n\r\n1）、安装Docker\r\n\r\n2）、去Docker仓库找到这个软件对应的镜像；\r\n\r\n3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；\r\n\r\n4）、对容器的启动停止就是对软件的启动停止；\r\n\r\n## 3、安装Docker\r\n\r\n### 1）、安装linux虚拟机\r\n\r\n​	1）、VMWare、VirtualBox（安装）；\r\n\r\n​	2）、导入虚拟机文件centos7-atguigu.ova；\r\n\r\n​	3）、双击启动linux虚拟机;使用  root/ 123456登陆\r\n\r\n​	4）、使用客户端连接linux服务器进行命令操作；\r\n\r\n​	5）、设置虚拟机网络；\r\n\r\n​		桥接网络===选好网卡====接入网线；\r\n\r\n​	6）、设置好网络以后使用命令重启虚拟机的网络\r\n\r\n```shell\r\nservice network restart\r\n```\r\n\r\n​	7）、查看linux的ip地址\r\n\r\n```shell\r\nip addr\r\n```\r\n\r\n​	8）、使用客户端连接linux；\r\n\r\n### 2）、在linux虚拟机上安装docker\r\n\r\n步骤： \r\n\r\n```shell\r\n1、检查内核版本，必须是3.10及以上\r\nuname -r\r\n2、安装docker\r\nyum install docker\r\n3、输入y确认安装\r\n4、启动docker\r\n[root@localhost ~]# systemctl start docker\r\n[root@localhost ~]# docker -v\r\nDocker version 1.12.6, build 3e8e77d/1.12.6\r\n5、开机启动docker\r\n[root@localhost ~]# systemctl enable docker\r\nCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.\r\n6、停止docker\r\nsystemctl stop docker\r\n```\r\n\r\n## 4、Docker常用命令&操作\r\n\r\n### 1）、镜像操作\r\n\r\n| 操作 | 命令                                            | 说明                                                     |\r\n| ---- | ----------------------------------------------- | -------------------------------------------------------- |\r\n| 检索 | docker  search 关键字  eg：docker  search redis | 我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。 |\r\n| 拉取 | docker pull 镜像名:tag                          | :tag是可选的，tag表示标签，多为软件的版本，默认是latest  |\r\n| 列表 | docker images                                   | 查看所有本地镜像                                         |\r\n| 删除 | docker rmi image-id                             | 删除指定的本地镜像                                       |\r\n\r\nhttps://hub.docker.com/\r\n\r\n### 2）、容器操作\r\n\r\n软件镜像（QQ安装程序）----运行镜像----产生一个容器（正在运行的软件，运行的QQ）；\r\n\r\n步骤：\r\n\r\n````shell\r\n1、搜索镜像\r\n[root@localhost ~]# docker search tomcat\r\n2、拉取镜像\r\n[root@localhost ~]# docker pull tomcat\r\n3、根据镜像启动容器\r\ndocker run --name mytomcat -d tomcat:latest\r\n4、docker ps  \r\n查看运行中的容器\r\n5、 停止运行中的容器\r\ndocker stop  容器的id\r\n6、查看所有的容器\r\ndocker ps -a\r\n7、启动容器\r\ndocker start 容器id\r\n8、删除一个容器\r\n docker rm 容器id\r\n9、启动一个做了端口映射的tomcat\r\n[root@localhost ~]# docker run -d -p 8888:8080 tomcat\r\n-d：后台运行\r\n-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口\r\n\r\n10、为了演示简单关闭了linux的防火墙\r\nservice firewalld status ；查看防火墙状态\r\nservice firewalld stop：关闭防火墙\r\n11、查看容器的日志\r\ndocker logs container-name/container-id\r\n\r\n更多命令参看\r\nhttps://docs.docker.com/engine/reference/commandline/docker/\r\n可以参考每一个镜像的文档\r\n\r\n````\r\n\r\n\r\n\r\n### 3）、安装MySQL示例\r\n\r\n```shell\r\ndocker pull mysql\r\n```\r\n\r\n\r\n\r\n错误的启动\r\n\r\n```shell\r\n[root@localhost ~]# docker run --name mysql01 -d mysql\r\n42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846\r\n\r\nmysql退出了\r\n[root@localhost ~]# docker ps -a\r\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES\r\n42f09819908b        mysql               \"docker-entrypoint.sh\"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01\r\n538bde63e500        tomcat              \"catalina.sh run\"        About an hour ago   Exited (143) About an hour ago                       compassionate_\r\ngoldstine\r\nc4f1ac60b3fc        tomcat              \"catalina.sh run\"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi\r\n81ec743a5271        tomcat              \"catalina.sh run\"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan\r\n\r\n\r\n//错误日志\r\n[root@localhost ~]# docker logs 42f09819908b\r\nerror: database is uninitialized and password option is not specified \r\n  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个\r\n```\r\n\r\n正确的启动\r\n\r\n```shell\r\n[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\r\nb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f\r\n[root@localhost ~]# docker ps\r\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\r\nb874c56bec49        mysql               \"docker-entrypoint.sh\"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01\r\n```\r\n\r\n做了端口映射\r\n\r\n```shell\r\n[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\r\nad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434\r\n[root@localhost ~]# docker ps\r\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\r\nad10e4bc5c6a        mysql               \"docker-entrypoint.sh\"   4 seconds ago       Up 2 seconds        0.0.0.0:3306->3306/tcp   mysql02\r\n```\r\n\r\n\r\n\r\n几个其他的高级操作\r\n\r\n```\r\ndocker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\r\n把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面\r\n改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）\r\n\r\ndocker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\r\n指定mysql的一些配置参数\r\n```\r\n\r\n\r\n\r\n# 六、SpringBoot与数据访问\r\n\r\n## 1、JDBC\r\n\r\n```xml\r\n		<dependency>\r\n			<groupId>org.springframework.boot</groupId>\r\n			<artifactId>spring-boot-starter-jdbc</artifactId>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>mysql</groupId>\r\n			<artifactId>mysql-connector-java</artifactId>\r\n			<scope>runtime</scope>\r\n		</dependency>\r\n```\r\n\r\n\r\n\r\n```yaml\r\nspring:\r\n  datasource:\r\n    username: root\r\n    password: 123456\r\n    url: jdbc:mysql://192.168.15.22:3306/jdbc\r\n    driver-class-name: com.mysql.jdbc.Driver\r\n```\r\n\r\n效果：\r\n\r\n​	默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；\r\n\r\n​	数据源的相关配置都在DataSourceProperties里面；\r\n\r\n自动配置原理：\r\n\r\norg.springframework.boot.autoconfigure.jdbc：\r\n\r\n1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；\r\n\r\n2、SpringBoot默认可以支持；\r\n\r\n```\r\norg.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、\r\n```\r\n\r\n3、自定义数据源类型\r\n\r\n```java\r\n/**\r\n * Generic DataSource configuration.\r\n */\r\n@ConditionalOnMissingBean(DataSource.class)\r\n@ConditionalOnProperty(name = \"spring.datasource.type\")\r\nstatic class Generic {\r\n\r\n   @Bean\r\n   public DataSource dataSource(DataSourceProperties properties) {\r\n       //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性\r\n      return properties.initializeDataSourceBuilder().build();\r\n   }\r\n\r\n}\r\n```\r\n\r\n4、**DataSourceInitializer：ApplicationListener**；\r\n\r\n​	作用：\r\n\r\n​		1）、runSchemaScripts();运行建表语句；\r\n\r\n​		2）、runDataScripts();运行插入数据的sql语句；\r\n\r\n默认只需要将文件命名为：\r\n\r\n```properties\r\nschema-*.sql、data-*.sql\r\n默认规则：schema.sql，schema-all.sql；\r\n可以使用   \r\n	schema:\r\n      - classpath:department.sql\r\n      指定位置\r\n```\r\n\r\n5、操作数据库：自动配置了JdbcTemplate操作数据库\r\n\r\n## 2、整合Druid数据源\r\n\r\n```java\r\n导入druid数据源\r\n@Configuration\r\npublic class DruidConfig {\r\n\r\n    @ConfigurationProperties(prefix = \"spring.datasource\")\r\n    @Bean\r\n    public DataSource druid(){\r\n       return  new DruidDataSource();\r\n    }\r\n\r\n    //配置Druid的监控\r\n    //1、配置一个管理后台的Servlet\r\n    @Bean\r\n    public ServletRegistrationBean statViewServlet(){\r\n        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\");\r\n        Map<String,String> initParams = new HashMap<>();\r\n\r\n        initParams.put(\"loginUsername\",\"admin\");\r\n        initParams.put(\"loginPassword\",\"123456\");\r\n        initParams.put(\"allow\",\"\");//默认就是允许所有访问\r\n        initParams.put(\"deny\",\"192.168.15.21\");\r\n\r\n        bean.setInitParameters(initParams);\r\n        return bean;\r\n    }\r\n\r\n\r\n    //2、配置一个web监控的filter\r\n    @Bean\r\n    public FilterRegistrationBean webStatFilter(){\r\n        FilterRegistrationBean bean = new FilterRegistrationBean();\r\n        bean.setFilter(new WebStatFilter());\r\n\r\n        Map<String,String> initParams = new HashMap<>();\r\n        initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\");\r\n\r\n        bean.setInitParameters(initParams);\r\n\r\n        bean.setUrlPatterns(Arrays.asList(\"/*\"));\r\n\r\n        return  bean;\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 3、整合MyBatis\r\n\r\n```xml\r\n		<dependency>\r\n			<groupId>org.mybatis.spring.boot</groupId>\r\n			<artifactId>mybatis-spring-boot-starter</artifactId>\r\n			<version>1.3.1</version>\r\n		</dependency>\r\n```\r\n\r\n![](images/搜狗截图20180305194443.png)\r\n\r\n步骤：\r\n\r\n​	1）、配置数据源相关属性（见上一节Druid）\r\n\r\n​	2）、给数据库建表\r\n\r\n​	3）、创建JavaBean\r\n\r\n### 	4）、注解版\r\n\r\n```java\r\n//指定这是一个操作数据库的mapper\r\n@Mapper\r\npublic interface DepartmentMapper {\r\n\r\n    @Select(\"select * from department where id=#{id}\")\r\n    public Department getDeptById(Integer id);\r\n\r\n    @Delete(\"delete from department where id=#{id}\")\r\n    public int deleteDeptById(Integer id);\r\n\r\n    @Options(useGeneratedKeys = true,keyProperty = \"id\")\r\n    @Insert(\"insert into department(departmentName) values(#{departmentName})\")\r\n    public int insertDept(Department department);\r\n\r\n    @Update(\"update department set departmentName=#{departmentName} where id=#{id}\")\r\n    public int updateDept(Department department);\r\n}\r\n```\r\n\r\n问题：\r\n\r\n自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；\r\n\r\n```java\r\n@org.springframework.context.annotation.Configuration\r\npublic class MyBatisConfig {\r\n\r\n    @Bean\r\n    public ConfigurationCustomizer configurationCustomizer(){\r\n        return new ConfigurationCustomizer(){\r\n\r\n            @Override\r\n            public void customize(Configuration configuration) {\r\n                configuration.setMapUnderscoreToCamelCase(true);\r\n            }\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n```java\r\n使用MapperScan批量扫描所有的Mapper接口；\r\n@MapperScan(value = \"com.atguigu.springboot.mapper\")\r\n@SpringBootApplication\r\npublic class SpringBoot06DataMybatisApplication {\r\n\r\n	public static void main(String[] args) {\r\n		SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);\r\n	}\r\n}\r\n```\r\n\r\n### 5）、配置文件版\r\n\r\n```yaml\r\nmybatis:\r\n  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置\r\n  mapper-locations: classpath:mybatis/mapper/*.xml  指定sql映射文件的位置\r\n```\r\n\r\n更多使用参照\r\n\r\nhttp://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\r\n\r\n\r\n\r\n## 4、整合SpringData JPA\r\n\r\n### 1）、SpringData简介\r\n\r\n![](images/搜狗截图20180306105412.png)\r\n\r\n### 2）、整合SpringData JPA\r\n\r\nJPA:ORM（Object Relational Mapping）；\r\n\r\n1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；\r\n\r\n```java\r\n//使用JPA注解配置映射关系\r\n@Entity //告诉JPA这是一个实体类（和数据表映射的类）\r\n@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；\r\npublic class User {\r\n\r\n    @Id //这是一个主键\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键\r\n    private Integer id;\r\n\r\n    @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列\r\n    private String lastName;\r\n    @Column //省略默认列名就是属性名\r\n    private String email;\r\n```\r\n\r\n2）、编写一个Dao接口来操作实体类对应的数据表（Repository）\r\n\r\n```java\r\n//继承JpaRepository来完成对数据库的操作\r\npublic interface UserRepository extends JpaRepository<User,Integer> {\r\n}\r\n\r\n```\r\n\r\n3）、基本的配置JpaProperties\r\n\r\n```yaml\r\nspring:\r\n  datasource:\r\n    url: jdbc:mysql://127.0.0.1:3306/jpa\r\n    username: root\r\n    password: 123456\r\n    driver-class-name: com.mysql.jdbc.Driver\r\n  jpa:\r\n    hibernate:\r\n      # 更新或者创建数据表结构\r\n      ddl-auto: update\r\n    # 控制台显示SQL\r\n    show-sql: true\r\n```\r\n\r\n4）、controller\r\n\r\n````jAVA\r\n@RestController\r\npublic class UserController {\r\n\r\n    @Autowired\r\n    UserRepository userRepository;\r\n\r\n    @GetMapping(\"/user/{id}\")\r\n    public User getUser(@PathVariable(\"id\") Integer id) {\r\n        // 用2.0这快会报错 换1.5就好了\r\n        User user = userRepository.findOne(id);\r\n        return null;\r\n    }\r\n\r\n    @GetMapping(\"/user\")\r\n    public User insertUser(User user) {\r\n        User save = userRepository.save(user);\r\n        return save;\r\n    }\r\n}\r\n````\r\n\r\n# 七、启动配置原理\r\n\r\n几个重要的事件回调机制\r\n\r\n配置在META-INF/spring.factories\r\n\r\n**ApplicationContextInitializer**\r\n\r\n**SpringApplicationRunListener**\r\n\r\n\r\n\r\n只需要放在ioc容器中\r\n\r\n**ApplicationRunner**\r\n\r\n**CommandLineRunner**\r\n\r\n\r\n\r\n启动流程：\r\n\r\n## 1、创建SpringApplication对象\r\n\r\n```java\r\ninitialize(sources);\r\nprivate void initialize(Object[] sources) {\r\n    //保存主配置类\r\n    if (sources != null && sources.length > 0) {\r\n        this.sources.addAll(Arrays.asList(sources));\r\n    }\r\n    //判断当前是否一个web应用\r\n    this.webEnvironment = deduceWebEnvironment();\r\n    //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来\r\n    setInitializers((Collection) getSpringFactoriesInstances(\r\n        ApplicationContextInitializer.class));\r\n    //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener\r\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\r\n    //从多个配置类中找到有main方法的主配置类\r\n    this.mainApplicationClass = deduceMainApplicationClass();\r\n}\r\n```\r\n\r\n![](images/搜狗截图20180306145727.png)\r\n\r\n![](images/搜狗截图20180306145855.png)\r\n\r\n## 2、运行run方法\r\n\r\n```java\r\npublic ConfigurableApplicationContext run(String... args) {\r\n   StopWatch stopWatch = new StopWatch();\r\n   stopWatch.start();\r\n   ConfigurableApplicationContext context = null;\r\n   FailureAnalyzers analyzers = null;\r\n   configureHeadlessProperty();\r\n    \r\n   //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories\r\n   SpringApplicationRunListeners listeners = getRunListeners(args);\r\n    //回调所有的获取SpringApplicationRunListener.starting()方法\r\n   listeners.starting();\r\n   try {\r\n       //封装命令行参数\r\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(\r\n            args);\r\n      //准备环境\r\n      ConfigurableEnvironment environment = prepareEnvironment(listeners,\r\n            applicationArguments);\r\n       		//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成\r\n       \r\n      Banner printedBanner = printBanner(environment);\r\n       \r\n       //创建ApplicationContext；决定创建web的ioc还是普通的ioc\r\n      context = createApplicationContext();\r\n       \r\n      analyzers = new FailureAnalyzers(context);\r\n       //准备上下文环境;将environment保存到ioc中；而且applyInitializers()；\r\n       //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法\r\n       //回调所有的SpringApplicationRunListener的contextPrepared()；\r\n       //\r\n      prepareContext(context, environment, listeners, applicationArguments,\r\n            printedBanner);\r\n       //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；\r\n       \r\n       //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版\r\n       //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）\r\n      refreshContext(context);\r\n       //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调\r\n       //ApplicationRunner先回调，CommandLineRunner再回调\r\n      afterRefresh(context, applicationArguments);\r\n       //所有的SpringApplicationRunListener回调finished方法\r\n      listeners.finished(context, null);\r\n      stopWatch.stop();\r\n      if (this.logStartupInfo) {\r\n         new StartupInfoLogger(this.mainApplicationClass)\r\n               .logStarted(getApplicationLog(), stopWatch);\r\n      }\r\n       //整个SpringBoot应用启动完成以后返回启动的ioc容器；\r\n      return context;\r\n   }\r\n   catch (Throwable ex) {\r\n      handleRunFailure(context, listeners, analyzers, ex);\r\n      throw new IllegalStateException(ex);\r\n   }\r\n}\r\n```\r\n\r\n## 3、事件监听机制\r\n\r\n配置在META-INF/spring.factories\r\n\r\n`ApplicationContextInitializer`\r\n\r\n```java\r\npublic class HelloApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {\r\n    @Override\r\n    public void initialize(ConfigurableApplicationContext applicationContext) {\r\n        System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext);\r\n    }\r\n}\r\n\r\n```\r\n\r\n`SpringApplicationRunListener`\r\n\r\n```java\r\npublic class HelloSpringApplicationRunListener implements SpringApplicationRunListener {\r\n\r\n    //必须有的构造器\r\n    public HelloSpringApplicationRunListener(SpringApplication application, String[] args){\r\n\r\n    }\r\n\r\n    @Override\r\n    public void starting() {\r\n        System.out.println(\"SpringApplicationRunListener...starting...\");\r\n    }\r\n\r\n    @Override\r\n    public void environmentPrepared(ConfigurableEnvironment environment) {\r\n        Object o = environment.getSystemProperties().get(\"os.name\");\r\n        System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o);\r\n    }\r\n\r\n    @Override\r\n    public void contextPrepared(ConfigurableApplicationContext context) {\r\n        System.out.println(\"SpringApplicationRunListener...contextPrepared...\");\r\n    }\r\n\r\n    @Override\r\n    public void contextLoaded(ConfigurableApplicationContext context) {\r\n        System.out.println(\"SpringApplicationRunListener...contextLoaded...\");\r\n    }\r\n\r\n    @Override\r\n    public void finished(ConfigurableApplicationContext context, Throwable exception) {\r\n        System.out.println(\"SpringApplicationRunListener...finished...\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n配置（META-INF/spring.factories）\r\n\r\n```properties\r\norg.springframework.context.ApplicationContextInitializer=\\\r\ncom.atguigu.springboot.listener.HelloApplicationContextInitializer\r\n\r\norg.springframework.boot.SpringApplicationRunListener=\\\r\ncom.atguigu.springboot.listener.HelloSpringApplicationRunListener\r\n```\r\n\r\n\r\n\r\n\r\n\r\n只需要放在ioc容器中\r\n\r\n`ApplicationRunner`\r\n\r\n```java\r\n@Component\r\npublic class HelloApplicationRunner implements ApplicationRunner {\r\n    @Override\r\n    public void run(ApplicationArguments args) throws Exception {\r\n        System.out.println(\"ApplicationRunner...run....\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n`CommandLineRunner`\r\n\r\n```java\r\n@Component\r\npublic class HelloCommandLineRunner implements CommandLineRunner {\r\n    @Override\r\n    public void run(String... args) throws Exception {\r\n        System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(args));\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 八、自定义starter\r\n\r\nstarter：\r\n\r\n​	1、这个场景需要使用到的依赖是什么？\r\n\r\n​	2、如何编写自动配置\r\n\r\n```java\r\n@Configuration  //指定这个类是一个配置类\r\n@ConditionalOnXXX  //在指定条件成立的情况下自动配置类生效\r\n@AutoConfigureAfter  //指定自动配置类的顺序\r\n@Bean  //给容器中添加组件\r\n\r\n@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置\r\n@EnableConfigurationProperties //让xxxProperties生效加入到容器中\r\n\r\n自动配置类要能加载\r\n将需要启动就加载的自动配置类，配置在META-INF/spring.factories\r\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\r\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\r\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\r\n```\r\n\r\n​	3、模式：\r\n\r\n启动器只用来做依赖导入；\r\n\r\n专门来写一个自动配置模块；\r\n\r\n启动器依赖自动配置；别人只需要引入启动器（starter）\r\n\r\nmybatis-spring-boot-starter；自定义启动器名-spring-boot-starter\r\n\r\n\r\n\r\n步骤：\r\n\r\n1）、启动器模块\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.atguigu.starter</groupId>\r\n    <artifactId>atguigu-spring-boot-starter</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n\r\n    <!--启动器-->\r\n    <dependencies>\r\n\r\n        <!--引入自动配置模块-->\r\n        <dependency>\r\n            <groupId>com.atguigu.starter</groupId>\r\n            <artifactId>atguigu-spring-boot-starter-autoconfigurer</artifactId>\r\n            <version>0.0.1-SNAPSHOT</version>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>\r\n```\r\n\r\n2）、自动配置模块\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n   <modelVersion>4.0.0</modelVersion>\r\n\r\n   <groupId>com.atguigu.starter</groupId>\r\n   <artifactId>atguigu-spring-boot-starter-autoconfigurer</artifactId>\r\n   <version>0.0.1-SNAPSHOT</version>\r\n   <packaging>jar</packaging>\r\n\r\n   <name>atguigu-spring-boot-starter-autoconfigurer</name>\r\n   <description>Demo project for Spring Boot</description>\r\n\r\n   <parent>\r\n      <groupId>org.springframework.boot</groupId>\r\n      <artifactId>spring-boot-starter-parent</artifactId>\r\n      <version>1.5.10.RELEASE</version>\r\n      <relativePath/> <!-- lookup parent from repository -->\r\n   </parent>\r\n\r\n   <properties>\r\n      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n      <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\r\n      <java.version>1.8</java.version>\r\n   </properties>\r\n\r\n   <dependencies>\r\n\r\n      <!--引入spring-boot-starter；所有starter的基本配置-->\r\n      <dependency>\r\n         <groupId>org.springframework.boot</groupId>\r\n         <artifactId>spring-boot-starter</artifactId>\r\n      </dependency>\r\n\r\n   </dependencies>\r\n\r\n\r\n\r\n</project>\r\n\r\n```\r\n\r\n\r\n\r\n```java\r\npackage com.atguigu.starter;\r\n\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;\r\n\r\n@ConfigurationProperties(prefix = \"atguigu.hello\")\r\npublic class HelloProperties {\r\n\r\n    private String prefix;\r\n    private String suffix;\r\n\r\n    public String getPrefix() {\r\n        return prefix;\r\n    }\r\n\r\n    public void setPrefix(String prefix) {\r\n        this.prefix = prefix;\r\n    }\r\n\r\n    public String getSuffix() {\r\n        return suffix;\r\n    }\r\n\r\n    public void setSuffix(String suffix) {\r\n        this.suffix = suffix;\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.atguigu.starter;\r\n\r\npublic class HelloService {\r\n\r\n    HelloProperties helloProperties;\r\n\r\n    public HelloProperties getHelloProperties() {\r\n        return helloProperties;\r\n    }\r\n\r\n    public void setHelloProperties(HelloProperties helloProperties) {\r\n        this.helloProperties = helloProperties;\r\n    }\r\n\r\n    public String sayHellAtguigu(String name){\r\n        return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix();\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.atguigu.starter;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\r\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\n@ConditionalOnWebApplication //web应用才生效\r\n@EnableConfigurationProperties(HelloProperties.class)\r\npublic class HelloServiceAutoConfiguration {\r\n\r\n    @Autowired\r\n    HelloProperties helloProperties;\r\n    @Bean\r\n    public HelloService helloService(){\r\n        HelloService service = new HelloService();\r\n        service.setHelloProperties(helloProperties);\r\n        return service;\r\n    }\r\n}\r\n\r\n```\r\n\r\n# 更多SpringBoot整合示例\r\n\r\nhttps://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 0);

-- ----------------------------
-- Table structure for blog_image
-- ----------------------------
DROP TABLE IF EXISTS `blog_image`;
CREATE TABLE `blog_image`  (
  `image_id` int(10) NOT NULL AUTO_INCREMENT,
  `image_name` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `image_path` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `image_url` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`image_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 236 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_image
-- ----------------------------
INSERT INTO `blog_image` VALUES (208, '20190620120632_timg.jpg', 'F:/ImageFile/20190620120632_timg.jpg', 'https://ailuoli.cn/image/get_image?fileName=20190620120632_timg.jpg');
INSERT INTO `blog_image` VALUES (209, '20190620121727_timg.jpg', 'F:/ImageFile/20190620121727_timg.jpg', 'https://ailuoli.cn/image/get_image?fileName=20190620121727_timg.jpg');
INSERT INTO `blog_image` VALUES (210, '20190625102311_jms_1.png', 'F:/ImageFile/20190625102311_jms_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625102311_jms_1.png');
INSERT INTO `blog_image` VALUES (211, '20190625102342_jms_2.png', 'F:/ImageFile/20190625102342_jms_2.png', 'https://ailuoli.cn/image/get_image?fileName=20190625102342_jms_2.png');
INSERT INTO `blog_image` VALUES (212, '20190625102414_jms_3.png', 'F:/ImageFile/20190625102414_jms_3.png', 'https://ailuoli.cn/image/get_image?fileName=20190625102414_jms_3.png');
INSERT INTO `blog_image` VALUES (213, '20190625102548_jms_4.png', 'F:/ImageFile/20190625102548_jms_4.png', 'https://ailuoli.cn/image/get_image?fileName=20190625102548_jms_4.png');
INSERT INTO `blog_image` VALUES (214, '20190625102615_jms_5.png', 'F:/ImageFile/20190625102615_jms_5.png', 'https://ailuoli.cn/image/get_image?fileName=20190625102615_jms_5.png');
INSERT INTO `blog_image` VALUES (215, '20190625102637_jms_6.png', 'F:/ImageFile/20190625102637_jms_6.png', 'https://ailuoli.cn/image/get_image?fileName=20190625102637_jms_6.png');
INSERT INTO `blog_image` VALUES (216, '20190625102714_activeMQ_1.png', 'F:/ImageFile/20190625102714_activeMQ_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625102714_activeMQ_1.png');
INSERT INTO `blog_image` VALUES (217, '20190625103000_activemq_queue_2.png', 'F:/ImageFile/20190625103000_activemq_queue_2.png', 'https://ailuoli.cn/image/get_image?fileName=20190625103000_activemq_queue_2.png');
INSERT INTO `blog_image` VALUES (218, '20190625103147_activemq_queue_1.png', 'F:/ImageFile/20190625103147_activemq_queue_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625103147_activemq_queue_1.png');
INSERT INTO `blog_image` VALUES (219, '20190625103311_activemq_topic_1.png', 'F:/ImageFile/20190625103311_activemq_topic_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625103311_activemq_topic_1.png');
INSERT INTO `blog_image` VALUES (220, '20190625103345_rabbitmq_1.png', 'F:/ImageFile/20190625103345_rabbitmq_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625103345_rabbitmq_1.png');
INSERT INTO `blog_image` VALUES (221, '20190625103420_activemq_qy_7.png', 'F:/ImageFile/20190625103420_activemq_qy_7.png', 'https://ailuoli.cn/image/get_image?fileName=20190625103420_activemq_qy_7.png');
INSERT INTO `blog_image` VALUES (222, '20190625105612_activemq_qy_6.png', 'F:/ImageFile/20190625105612_activemq_qy_6.png', 'https://ailuoli.cn/image/get_image?fileName=20190625105612_activemq_qy_6.png');
INSERT INTO `blog_image` VALUES (223, '20190625105631_activemq_qy_5.png', 'F:/ImageFile/20190625105631_activemq_qy_5.png', 'https://ailuoli.cn/image/get_image?fileName=20190625105631_activemq_qy_5.png');
INSERT INTO `blog_image` VALUES (224, '20190625105655_activemq_qy_4.png', 'F:/ImageFile/20190625105655_activemq_qy_4.png', 'https://ailuoli.cn/image/get_image?fileName=20190625105655_activemq_qy_4.png');
INSERT INTO `blog_image` VALUES (225, '20190625105714_activemq_qy_3.png', 'F:/ImageFile/20190625105714_activemq_qy_3.png', 'https://ailuoli.cn/image/get_image?fileName=20190625105714_activemq_qy_3.png');
INSERT INTO `blog_image` VALUES (226, '20190625105734_activemq_qy_2.png', 'F:/ImageFile/20190625105734_activemq_qy_2.png', 'https://ailuoli.cn/image/get_image?fileName=20190625105734_activemq_qy_2.png');
INSERT INTO `blog_image` VALUES (227, '20190625105755_activemq_qy_1.png', 'F:/ImageFile/20190625105755_activemq_qy_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625105755_activemq_qy_1.png');
INSERT INTO `blog_image` VALUES (228, '20190625105842_activemq_jq_1.png', 'F:/ImageFile/20190625105842_activemq_jq_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625105842_activemq_jq_1.png');
INSERT INTO `blog_image` VALUES (229, '20190625105932_activemq_leveldb_1.png', 'F:/ImageFile/20190625105932_activemq_leveldb_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625105932_activemq_leveldb_1.png');
INSERT INTO `blog_image` VALUES (230, '20190625110003_activemq_master_slave_3.png', 'F:/ImageFile/20190625110003_activemq_master_slave_3.png', 'https://ailuoli.cn/image/get_image?fileName=20190625110003_activemq_master_slave_3.png');
INSERT INTO `blog_image` VALUES (231, '20190625110032_activemq_master_slave_2.png', 'F:/ImageFile/20190625110032_activemq_master_slave_2.png', 'https://ailuoli.cn/image/get_image?fileName=20190625110032_activemq_master_slave_2.png');
INSERT INTO `blog_image` VALUES (232, '20190625110100_activemq_master_slave_1.png', 'F:/ImageFile/20190625110100_activemq_master_slave_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625110100_activemq_master_slave_1.png');
INSERT INTO `blog_image` VALUES (234, '20190625110134_activemq_broker+cluster_1.png', 'F:/ImageFile/20190625110134_activemq_broker+cluster_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625110134_activemq_broker+cluster_1.png');
INSERT INTO `blog_image` VALUES (235, '20190625110219_activemq_spring_1.png', 'F:/ImageFile/20190625110219_activemq_spring_1.png', 'https://ailuoli.cn/image/get_image?fileName=20190625110219_activemq_spring_1.png');
INSERT INTO `blog_image` VALUES (236, '20190625110303_activemq_topic_2.png', 'F:/ImageFile/20190625110303_activemq_topic_2.png', 'https://ailuoli.cn/image/get_image?fileName=20190625110303_activemq_topic_2.png');

-- ----------------------------
-- Table structure for blog_notice
-- ----------------------------
DROP TABLE IF EXISTS `blog_notice`;
CREATE TABLE `blog_notice`  (
  `notice_id` int(5) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `notice_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '公告标题',
  `notice_content` longtext CHARACTER SET utf8 COLLATE utf8_bin NULL COMMENT '公告信息',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `is_top` int(5) NULL DEFAULT 0 COMMENT '是否置顶',
  `is_delete` int(5) NULL DEFAULT 0 COMMENT '是否删除',
  PRIMARY KEY (`notice_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_notice
-- ----------------------------
INSERT INTO `blog_notice` VALUES (1, '网站进度', '网站正在建设中', '2019-05-20 14:23:10', 0, 0);

-- ----------------------------
-- Table structure for blog_permission
-- ----------------------------
DROP TABLE IF EXISTS `blog_permission`;
CREATE TABLE `blog_permission`  (
  `permission_id` int(11) NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `permission_status` int(5) NULL DEFAULT 0 COMMENT '逻辑删除',
  `is_page` int(5) NULL DEFAULT 0 COMMENT '是否是页面  0是接口  1是页面',
  `is_login` int(5) NULL DEFAULT 0 COMMENT '是否需要登录才能访问0不需要，1需要',
  PRIMARY KEY (`permission_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_permission
-- ----------------------------
INSERT INTO `blog_permission` VALUES (2, '/technology/get_left_menu', '获取技术栈左侧菜单接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (5, '/technology/get_course_value', '获取技术栈内容接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (6, '/technology/get_course_name', '模糊搜索文章名字接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (7, '/technology/show_course_by_name', '通过文章名字加载内容接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (8, '/technology/get_menu_technology', '获取技术栈的主菜单接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (9, '/technology/get_menu_lan_type', '获取技术栈主菜单接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (20, '/technology', '技术栈页面', 0, 1, 1);
INSERT INTO `blog_permission` VALUES (24, '/write', '写博客页', 0, 1, 1);
INSERT INTO `blog_permission` VALUES (25, '/article', '程序人生页', 0, 1, 0);
INSERT INTO `blog_permission` VALUES (26, '/blog/user/registered', '注册接口', 0, 0, 0);
INSERT INTO `blog_permission` VALUES (27, '/blog/user/logout', '登出接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (28, '/write/insert_article', '插入文章接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (29, '/article_details', '文章详情页', 0, 1, 1);
INSERT INTO `blog_permission` VALUES (30, '/write/get_article_details', '获取文章详情接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (31, '/write/add_comment', '评论接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (32, '/write/add_reply_comment', '回复接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (33, '/write/get_article_like_keyword', '获取相关文章', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (34, '/druid/**', '数据源接口', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (35, '/**', '管理员权限（可以访问所有页面）', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (36, '/excels/sql/count', '校验sql，并获取sql返回的数量', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (37, '/excels/download', '根据sql导出excel', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (38, '/excels/show/datas', '根据sql在页面显示结果', 0, 0, 1);
INSERT INTO `blog_permission` VALUES (39, '/swagger-ui.html', 'swagger接口页面', 0, 1, 1);

-- ----------------------------
-- Table structure for blog_role
-- ----------------------------
DROP TABLE IF EXISTS `blog_role`;
CREATE TABLE `blog_role`  (
  `role_id` int(10) NOT NULL AUTO_INCREMENT,
  `role_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `role_status` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '状态\r\n\r\n',
  PRIMARY KEY (`role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_role
-- ----------------------------
INSERT INTO `blog_role` VALUES (1, 'USER', '普通角色');
INSERT INTO `blog_role` VALUES (4, 'ADMIN', '管理员角色');

-- ----------------------------
-- Table structure for blog_user
-- ----------------------------
DROP TABLE IF EXISTS `blog_user`;
CREATE TABLE `blog_user`  (
  `user_id` int(10) NOT NULL AUTO_INCREMENT,
  `qq_open_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'QQ登录openid，第三方登陆时识别用户信息的唯一标识',
  `username` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名  默认为uuid',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码  不可空',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `qq_nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'qq网名',
  `wechat_nickename` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '微信网名',
  `birth_date` date NULL DEFAULT NULL COMMENT '出生日期',
  `sex` int(5) NULL DEFAULT NULL COMMENT '性别（1男，2女）',
  `figure_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像url  默认有',
  `create_date` timestamp(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `phone` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `user_status` int(5) NULL DEFAULT 0 COMMENT '是否激活',
  `last_password_reset_date` datetime(0) NULL DEFAULT NULL COMMENT '上次更改密码的时间',
  `last_user_login_date` datetime(0) NULL DEFAULT NULL COMMENT '上一次登录时间',
  PRIMARY KEY (`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_user
-- ----------------------------
INSERT INTO `blog_user` VALUES (1, NULL, '2665151959@qq.com', '9d97a9342d43e47ceb8b9dff707da9e9c2725da215c285823d8b176c48739f65424dd3d5458fc784', 'Ailuoli', 'Ailuoli', 'Ailuoli', '1996-12-25', 1, 'https://ailuoli.cn/image/get_image?fileName=20190620120632_timg.jpg', '2019-04-16 18:52:39', '2665151959@qq.com', '18609822838', 0, '2019-04-30 21:08:24', '2019-07-11 09:46:33');
INSERT INTO `blog_user` VALUES (22, '75780C7DE4FF99A06E22A465AE96E242', NULL, NULL, 'love|灬爱萝莉', 'love|灬爱萝莉', NULL, NULL, 1, 'https://thirdqq.qlogo.cn/g?b=oidb&k=Us2AicdpkXtXjhiavdFv15OA&s=140&t=1557016300', '2019-07-04 15:11:11', NULL, NULL, 0, NULL, '2019-07-18 20:20:49');

-- ----------------------------
-- Table structure for clientdetails
-- ----------------------------
DROP TABLE IF EXISTS `clientdetails`;
CREATE TABLE `clientdetails`  (
  `appId` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `resourceIds` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `appSecret` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `scope` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `grantTypes` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `redirectUrl` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `authorities` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `access_token_validity` int(11) NULL DEFAULT NULL,
  `refresh_token_validity` int(11) NULL DEFAULT NULL,
  `additionalInformation` varchar(4096) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `autoApproveScopes` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`appId`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for oauth_access_token
-- ----------------------------
DROP TABLE IF EXISTS `oauth_access_token`;
CREATE TABLE `oauth_access_token`  (
  `token_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `token` blob NULL,
  `authentication_id` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `user_name` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `client_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `authentication` blob NULL,
  `refresh_token` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`authentication_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for oauth_approvals
-- ----------------------------
DROP TABLE IF EXISTS `oauth_approvals`;
CREATE TABLE `oauth_approvals`  (
  `userId` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `clientId` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `scope` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `status` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `expiresAt` datetime(0) NULL DEFAULT NULL,
  `lastModifiedAt` datetime(0) NULL DEFAULT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for oauth_client_details
-- ----------------------------
DROP TABLE IF EXISTS `oauth_client_details`;
CREATE TABLE `oauth_client_details`  (
  `client_id` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `resource_ids` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `client_secret` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `scope` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `authorized_grant_types` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `web_server_redirect_uri` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `authorities` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `access_token_validity` int(11) NULL DEFAULT NULL,
  `refresh_token_validity` int(11) NULL DEFAULT NULL,
  `additional_information` varchar(4096) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `autoapprove` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`client_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for oauth_client_token
-- ----------------------------
DROP TABLE IF EXISTS `oauth_client_token`;
CREATE TABLE `oauth_client_token`  (
  `token_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `token` blob NULL,
  `authentication_id` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `user_name` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `client_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`authentication_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for oauth_code
-- ----------------------------
DROP TABLE IF EXISTS `oauth_code`;
CREATE TABLE `oauth_code`  (
  `code` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `authentication` blob NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for oauth_refresh_token
-- ----------------------------
DROP TABLE IF EXISTS `oauth_refresh_token`;
CREATE TABLE `oauth_refresh_token`  (
  `token_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `token` blob NULL,
  `authentication` blob NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for persistent_logins
-- ----------------------------
DROP TABLE IF EXISTS `persistent_logins`;
CREATE TABLE `persistent_logins`  (
  `username` varchar(64) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `series` varchar(64) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `token` varchar(64) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `last_used` timestamp(0) NOT NULL,
  PRIMARY KEY (`series`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for qqinfo
-- ----------------------------
DROP TABLE IF EXISTS `qqinfo`;
CREATE TABLE `qqinfo`  (
  `qq_id` int(100) NOT NULL AUTO_INCREMENT,
  `open_id` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `access_token` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `nikename` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `sex` int(5) NULL DEFAULT NULL,
  `figure_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `note` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`qq_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of qqinfo
-- ----------------------------
INSERT INTO `qqinfo` VALUES (1, '6B66C5EE01E49366231BC703CA36FA4E', '21856D6E5CA21E5CE5358A4087B9B5F1', 'love|灬爱萝莉', 1, 'http://qzapp.qlogo.cn/qzapp/101548252/6B66C5EE01E49366231BC703CA36FA4E/30', NULL);

-- ----------------------------
-- Table structure for reply_comment
-- ----------------------------
DROP TABLE IF EXISTS `reply_comment`;
CREATE TABLE `reply_comment`  (
  `reply_id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `reply_content` longtext CHARACTER SET utf8 COLLATE utf8_bin NULL COMMENT '回复信息',
  `user_id` int(10) NULL DEFAULT NULL COMMENT '回复者id',
  `reply_user_id` int(11) NULL DEFAULT NULL COMMENT '被回复者id',
  `comment_id` int(10) NULL DEFAULT NULL COMMENT '一级评论id',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `is_delete` int(5) NULL DEFAULT 0,
  PRIMARY KEY (`reply_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 77 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for role_permission
-- ----------------------------
DROP TABLE IF EXISTS `role_permission`;
CREATE TABLE `role_permission`  (
  `role_permission_id` int(11) NOT NULL AUTO_INCREMENT,
  `role_id` int(11) NULL DEFAULT NULL,
  `permission_id` int(11) NULL DEFAULT NULL,
  `role_permission_status` int(5) NULL DEFAULT 0,
  PRIMARY KEY (`role_permission_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 50 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of role_permission
-- ----------------------------
INSERT INTO `role_permission` VALUES (2, 1, 2, 0);
INSERT INTO `role_permission` VALUES (3, 1, 5, 0);
INSERT INTO `role_permission` VALUES (4, 1, 6, 0);
INSERT INTO `role_permission` VALUES (5, 1, 7, 0);
INSERT INTO `role_permission` VALUES (6, 1, 8, 0);
INSERT INTO `role_permission` VALUES (7, 1, 9, 0);
INSERT INTO `role_permission` VALUES (35, 1, 20, 0);
INSERT INTO `role_permission` VALUES (39, 1, 24, 0);
INSERT INTO `role_permission` VALUES (40, 1, 25, 0);
INSERT INTO `role_permission` VALUES (41, 1, 26, 0);
INSERT INTO `role_permission` VALUES (42, 1, 27, 0);
INSERT INTO `role_permission` VALUES (43, 1, 29, 0);
INSERT INTO `role_permission` VALUES (44, 1, 28, 0);
INSERT INTO `role_permission` VALUES (45, 1, 30, 0);
INSERT INTO `role_permission` VALUES (46, 1, 31, 0);
INSERT INTO `role_permission` VALUES (47, 1, 32, 0);
INSERT INTO `role_permission` VALUES (48, 1, 33, 0);
INSERT INTO `role_permission` VALUES (50, 4, 35, 0);

-- ----------------------------
-- Table structure for technology_stack
-- ----------------------------
DROP TABLE IF EXISTS `technology_stack`;
CREATE TABLE `technology_stack`  (
  `lan_id` int(10) NOT NULL AUTO_INCREMENT,
  `lan_code` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `lan_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `lan_type_id` int(5) NULL DEFAULT NULL,
  `lan_type_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`lan_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of technology_stack
-- ----------------------------
INSERT INTO `technology_stack` VALUES (1, 'stack_cpp', 'C + +', 1, '服务端');
INSERT INTO `technology_stack` VALUES (2, 'stack_java', 'JAVA', 1, '服务端');
INSERT INTO `technology_stack` VALUES (3, 'stack_mybatis', 'MyBatis', 1, '服务端');
INSERT INTO `technology_stack` VALUES (4, 'statc_springmvc', 'Spring MVC', 1, '服务端');
INSERT INTO `technology_stack` VALUES (5, 'stack_springboot', 'Spring Boot', 1, '服务端');
INSERT INTO `technology_stack` VALUES (6, 'stack_springcloud', 'Spring Cloud', 1, '服务端');
INSERT INTO `technology_stack` VALUES (7, 'stack_mysql', 'MySql', 2, '数据库');
INSERT INTO `technology_stack` VALUES (8, 'stack_oracle', 'ORACLE', 2, '数据库');
INSERT INTO `technology_stack` VALUES (9, 'stack_redis', 'Redis', 3, '中间件');
INSERT INTO `technology_stack` VALUES (10, 'stack_docker', 'Docker', 4, '工具');
INSERT INTO `technology_stack` VALUES (11, 'stack_mongodb', 'MongoDB', 3, '中间件');
INSERT INTO `technology_stack` VALUES (12, 'stack_nginx', 'Nginx', 3, '中间件');
INSERT INTO `technology_stack` VALUES (13, 'stack_rabbit_mq', 'RabbitMQ', 3, '中间件');
INSERT INTO `technology_stack` VALUES (14, 'stack_git', 'Git', 4, '工具');
INSERT INTO `technology_stack` VALUES (15, 'stack_shell', 'Shell', 4, '工具');
INSERT INTO `technology_stack` VALUES (16, 'stack_linux', 'Linux', 4, '工具');
INSERT INTO `technology_stack` VALUES (17, 'stack_nginx', 'Nginx', 3, '中间件');

-- ----------------------------
-- Table structure for user_role
-- ----------------------------
DROP TABLE IF EXISTS `user_role`;
CREATE TABLE `user_role`  (
  `user_role` int(5) NOT NULL AUTO_INCREMENT,
  `user_id` int(65) NOT NULL,
  `role_id` int(10) NOT NULL,
  `user_role_status` int(5) NULL DEFAULT 0,
  PRIMARY KEY (`user_role`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 26 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_role
-- ----------------------------
INSERT INTO `user_role` VALUES (1, 1, 1, 0);
INSERT INTO `user_role` VALUES (18, 5, 1, 0);
INSERT INTO `user_role` VALUES (19, 6, 1, 0);
INSERT INTO `user_role` VALUES (20, 7, 1, 0);
INSERT INTO `user_role` VALUES (21, 8, 1, 0);
INSERT INTO `user_role` VALUES (22, 9, 1, 0);
INSERT INTO `user_role` VALUES (23, 10, 1, 0);
INSERT INTO `user_role` VALUES (24, 11, 1, 0);
INSERT INTO `user_role` VALUES (25, 1, 4, 0);
INSERT INTO `user_role` VALUES (26, 21, 1, 0);

SET FOREIGN_KEY_CHECKS = 1;
